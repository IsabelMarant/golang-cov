
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bfe_balance/backend/bfe_backend.go (19/46=41.3%)</option>
				
				<option value="file1">bfe_balance/backend/health_check.go (0/35=0.0%)</option>
				
				<option value="file2">bfe_balance/bal_gslb/bal_gslb.go (98/164=59.8%)</option>
				
				<option value="file3">bfe_balance/bal_gslb/state.go (0/9=0.0%)</option>
				
				<option value="file4">bfe_balance/bal_gslb/sub_cluster.go (14/17=82.4%)</option>
				
				<option value="file5">bfe_balance/bal_rr/backend_rr.go (12/13=92.3%)</option>
				
				<option value="file6">bfe_balance/bal_rr/bal_rr.go (58/76=76.3%)</option>
				
				<option value="file7">bfe_balance/bal_table.go (82/113=72.6%)</option>
				
				<option value="file8">bfe_basic/condition/build.go (11/59=18.6%)</option>
				
				<option value="file9">bfe_basic/condition/composite.go (0/7=0.0%)</option>
				
				<option value="file10">bfe_basic/condition/parser/ast.go (2/31=6.5%)</option>
				
				<option value="file11">bfe_basic/condition/parser/parser.go (22/30=73.3%)</option>
				
				<option value="file12">bfe_basic/condition/parser/scanner.go (71/223=31.8%)</option>
				
				<option value="file13">bfe_basic/condition/parser/semant.go (24/28=85.7%)</option>
				
				<option value="file14">bfe_basic/condition/parser/token.go (4/6=66.7%)</option>
				
				<option value="file15">bfe_basic/condition/parser/walk.go (11/13=84.6%)</option>
				
				<option value="file16">bfe_basic/condition/parser/y.go (102/162=63.0%)</option>
				
				<option value="file17">bfe_basic/condition/primitive.go (12/165=7.3%)</option>
				
				<option value="file18">bfe_bufio/bufio.go (285/319=89.3%)</option>
				
				<option value="file19">bfe_config/bfe_cluster_conf/cluster_conf/cluster_conf_load.go (53/75=70.7%)</option>
				
				<option value="file20">bfe_config/bfe_cluster_conf/cluster_table_conf/cluster_table_load.go (33/64=51.6%)</option>
				
				<option value="file21">bfe_config/bfe_cluster_conf/gslb_conf/gslb_conf_load.go (27/55=49.1%)</option>
				
				<option value="file22">bfe_config/bfe_conf/bfe_config_load.go (9/14=64.3%)</option>
				
				<option value="file23">bfe_config/bfe_conf/conf_basic.go (57/70=81.4%)</option>
				
				<option value="file24">bfe_config/bfe_conf/conf_https_basic.go (44/82=53.7%)</option>
				
				<option value="file25">bfe_config/bfe_conf/conf_session_cache.go (9/13=69.2%)</option>
				
				<option value="file26">bfe_config/bfe_conf/conf_session_ticket.go (4/6=66.7%)</option>
				
				<option value="file27">bfe_config/bfe_route_conf/host_rule_conf/host_table_load.go (41/49=83.7%)</option>
				
				<option value="file28">bfe_config/bfe_route_conf/route_rule_conf/route_table_load.go (28/37=75.7%)</option>
				
				<option value="file29">bfe_config/bfe_tls_conf/server_cert_conf/server_cert_conf_load.go (37/109=33.9%)</option>
				
				<option value="file30">bfe_config/bfe_tls_conf/session_ticket_key_conf/session_ticket_key_conf.go (18/21=85.7%)</option>
				
				<option value="file31">bfe_config/bfe_tls_conf/tls_rule_conf/tls_rule_conf_load.go (33/45=73.3%)</option>
				
				<option value="file32">bfe_data/cluster_table.go (19/21=90.5%)</option>
				
				<option value="file33">bfe_data/host_table.go (49/54=90.7%)</option>
				
				<option value="file34">bfe_data/server_data_conf.go (22/40=55.0%)</option>
				
				<option value="file35">bfe_data/trie/trie.go (27/28=96.4%)</option>
				
				<option value="file36">bfe_http/chunked.go (49/64=76.6%)</option>
				
				<option value="file37">bfe_http/client.go (2/33=6.1%)</option>
				
				<option value="file38">bfe_http/cookie.go (140/181=77.3%)</option>
				
				<option value="file39">bfe_http/header.go (53/67=79.1%)</option>
				
				<option value="file40">bfe_http/lex.go (3/3=100.0%)</option>
				
				<option value="file41">bfe_http/request.go (210/269=78.1%)</option>
				
				<option value="file42">bfe_http/response.go (48/65=73.8%)</option>
				
				<option value="file43">bfe_http/sniff.go (0/51=0.0%)</option>
				
				<option value="file44">bfe_http/status.go (0/1=0.0%)</option>
				
				<option value="file45">bfe_http/transfer.go (226/287=78.7%)</option>
				
				<option value="file46">bfe_http/transport.go (0/442=0.0%)</option>
				
				<option value="file47">bfe_modules/mod_access/conf_mod_access.go (25/32=78.1%)</option>
				
				<option value="file48">bfe_modules/mod_access/mod_access.go (425/618=68.8%)</option>
				
				<option value="file49">bfe_modules/mod_access_pb/conf_mod_access_pb.go (25/32=78.1%)</option>
				
				<option value="file50">bfe_modules/mod_access_pb/mod_access_pb.go (358/556=64.4%)</option>
				
				<option value="file51">bfe_modules/mod_anti_tlsdos/anti_tlsdos_conf_load.go (25/32=78.1%)</option>
				
				<option value="file52">bfe_modules/mod_anti_tlsdos/conf_mod_anti_tlsdos.go (26/42=61.9%)</option>
				
				<option value="file53">bfe_modules/mod_anti_tlsdos/mod_anti_tlsdos.go (85/102=83.3%)</option>
				
				<option value="file54">bfe_modules/mod_block/action.go (13/17=76.5%)</option>
				
				<option value="file55">bfe_modules/mod_block/conf_mod_block.go (17/19=89.5%)</option>
				
				<option value="file56">bfe_modules/mod_block/global_ip_table_load.go (7/8=87.5%)</option>
				
				<option value="file57">bfe_modules/mod_block/mod_block.go (89/108=82.4%)</option>
				
				<option value="file58">bfe_modules/mod_block/product_rule_load.go (51/65=78.5%)</option>
				
				<option value="file59">bfe_modules/mod_block/product_rule_table.go (13/13=100.0%)</option>
				
				<option value="file60">bfe_modules/mod_cross_region/conf_mod_cross_region.go (42/51=82.4%)</option>
				
				<option value="file61">bfe_modules/mod_cross_region/load_product_rule.go (13/14=92.9%)</option>
				
				<option value="file62">bfe_modules/mod_cross_region/load_region_conf.go (23/33=69.7%)</option>
				
				<option value="file63">bfe_modules/mod_cross_region/mod_cross_region.go (115/137=83.9%)</option>
				
				<option value="file64">bfe_modules/mod_cross_region/product_rule_table.go (11/12=91.7%)</option>
				
				<option value="file65">bfe_modules/mod_cross_region/region_cluster.go (8/10=80.0%)</option>
				
				<option value="file66">bfe_modules/mod_cross_region/region_cluster_table.go (110/131=84.0%)</option>
				
				<option value="file67">bfe_modules/mod_crypto/conf_mod_crypto.go (29/46=63.0%)</option>
				
				<option value="file68">bfe_modules/mod_crypto/crypto_cgo_ecc.go (39/46=84.8%)</option>
				
				<option value="file69">bfe_modules/mod_crypto/crypto_cgo_rsa.go (19/22=86.4%)</option>
				
				<option value="file70">bfe_modules/mod_crypto/crypto_remote.go (40/54=74.1%)</option>
				
				<option value="file71">bfe_modules/mod_crypto/crypto_remote_codec.go (28/36=77.8%)</option>
				
				<option value="file72">bfe_modules/mod_crypto/crypto_remote_msg.go (52/80=65.0%)</option>
				
				<option value="file73">bfe_modules/mod_crypto/mod_crypto.go (90/126=71.4%)</option>
				
				<option value="file74">bfe_modules/mod_decrypt_uri/conf_mod_decrypt_uri.go (0/14=0.0%)</option>
				
				<option value="file75">bfe_modules/mod_decrypt_uri/decrypt_uri_conf_load.go (25/28=89.3%)</option>
				
				<option value="file76">bfe_modules/mod_decrypt_uri/enc/ps_se_enc_linux_amd64.go (13/13=100.0%)</option>
				
				<option value="file77">bfe_modules/mod_decrypt_uri/mod_decrypt_uri.go (47/90=52.2%)</option>
				
				<option value="file78">bfe_modules/mod_dict_client/conf_mod_dict_client.go (20/26=76.9%)</option>
				
				<option value="file79">bfe_modules/mod_dict_client/dict_pb/bfe_dict_gogo.pb.go (578/792=73.0%)</option>
				
				<option value="file80">bfe_modules/mod_dict_client/dict_rule_load.go (46/62=74.2%)</option>
				
				<option value="file81">bfe_modules/mod_dict_client/mod_dict_client.go (68/147=46.3%)</option>
				
				<option value="file82">bfe_modules/mod_dict_client/product_rule_table.go (11/11=100.0%)</option>
				
				<option value="file83">bfe_modules/mod_header/action.go (50/65=76.9%)</option>
				
				<option value="file84">bfe_modules/mod_header/action_header.go (3/3=100.0%)</option>
				
				<option value="file85">bfe_modules/mod_header/action_header_var.go (3/7=42.9%)</option>
				
				<option value="file86">bfe_modules/mod_header/conf_mod_header.go (13/15=86.7%)</option>
				
				<option value="file87">bfe_modules/mod_header/header_conf_load.go (75/94=79.8%)</option>
				
				<option value="file88">bfe_modules/mod_header/header_table.go (12/13=92.3%)</option>
				
				<option value="file89">bfe_modules/mod_header/mod_header.go (41/54=75.9%)</option>
				
				<option value="file90">bfe_modules/mod_header_defence/conf_mod_header_defence.go (9/12=75.0%)</option>
				
				<option value="file91">bfe_modules/mod_header_defence/mod_header_defence.go (72/101=71.3%)</option>
				
				<option value="file92">bfe_modules/mod_host_delegation/base64.go (7/10=70.0%)</option>
				
				<option value="file93">bfe_modules/mod_host_delegation/conf_mod_host_delegation.go (12/17=70.6%)</option>
				
				<option value="file94">bfe_modules/mod_host_delegation/domain_dict.go (64/74=86.5%)</option>
				
				<option value="file95">bfe_modules/mod_host_delegation/innocent_domain_table.go (40/44=90.9%)</option>
				
				<option value="file96">bfe_modules/mod_host_delegation/key_list.go (40/45=88.9%)</option>
				
				<option value="file97">bfe_modules/mod_host_delegation/mod_host_delegation.go (38/146=26.0%)</option>
				
				<option value="file98">bfe_modules/mod_http_retcode/mod_http_retcode.go (52/63=82.5%)</option>
				
				<option value="file99">bfe_modules/mod_http_sign/conf_mod_http_sign.go (17/19=89.5%)</option>
				
				<option value="file100">bfe_modules/mod_http_sign/mod_http_sign.go (70/91=76.9%)</option>
				
				<option value="file101">bfe_modules/mod_http_sign/product_rule_load.go (50/60=83.3%)</option>
				
				<option value="file102">bfe_modules/mod_http_sign/product_rule_table.go (13/13=100.0%)</option>
				
				<option value="file103">bfe_modules/mod_http_sign/sign_conf_load.go (13/18=72.2%)</option>
				
				<option value="file104">bfe_modules/mod_logid/logid_linux.go (9/10=90.0%)</option>
				
				<option value="file105">bfe_modules/mod_logid/mod_logid.go (31/47=66.0%)</option>
				
				<option value="file106">bfe_modules/mod_prison/basic_type.go (13/15=86.7%)</option>
				
				<option value="file107">bfe_modules/mod_prison/conf_mod_prison.go (21/28=75.0%)</option>
				
				<option value="file108">bfe_modules/mod_prison/mod_prison.go (89/107=83.2%)</option>
				
				<option value="file109">bfe_modules/mod_redirect/action.go (33/47=70.2%)</option>
				
				<option value="file110">bfe_modules/mod_redirect/action_url.go (12/13=92.3%)</option>
				
				<option value="file111">bfe_modules/mod_redirect/conf_mod_redirect.go (13/15=86.7%)</option>
				
				<option value="file112">bfe_modules/mod_redirect/mod_redirect.go (38/50=76.0%)</option>
				
				<option value="file113">bfe_modules/mod_redirect/redirect_conf_load.go (59/70=84.3%)</option>
				
				<option value="file114">bfe_modules/mod_redirect/redirect_table.go (13/13=100.0%)</option>
				
				<option value="file115">bfe_modules/mod_rewrite/action.go (36/44=81.8%)</option>
				
				<option value="file116">bfe_modules/mod_rewrite/action_host.go (2/2=100.0%)</option>
				
				<option value="file117">bfe_modules/mod_rewrite/action_path.go (13/13=100.0%)</option>
				
				<option value="file118">bfe_modules/mod_rewrite/action_query.go (37/38=97.4%)</option>
				
				<option value="file119">bfe_modules/mod_rewrite/conf_mod_rewrite.go (13/15=86.7%)</option>
				
				<option value="file120">bfe_modules/mod_rewrite/mod_rewrite.go (0/44=0.0%)</option>
				
				<option value="file121">bfe_modules/mod_rewrite/rewrite_conf_load.go (60/72=83.3%)</option>
				
				<option value="file122">bfe_modules/mod_rewrite/rewrite_table.go (12/13=92.3%)</option>
				
				<option value="file123">bfe_modules/mod_tcp_wise/conf_mod_tcp_wise.go (16/18=88.9%)</option>
				
				<option value="file124">bfe_modules/mod_tcp_wise/cwnd_table.go (63/67=94.0%)</option>
				
				<option value="file125">bfe_modules/mod_tcp_wise/mod_tcp_wise.go (102/194=52.6%)</option>
				
				<option value="file126">bfe_modules/mod_tcp_wise/tcp_wise_rule.go (40/43=93.0%)</option>
				
				<option value="file127">bfe_modules/mod_trust_clientip/conf_mod_trust_clientip.go (13/15=86.7%)</option>
				
				<option value="file128">bfe_modules/mod_trust_clientip/mod_trust_clientip.go (27/53=50.9%)</option>
				
				<option value="file129">bfe_modules/mod_trust_clientip/trustip_conf_load.go (40/51=78.4%)</option>
				
				<option value="file130">bfe_modules/mod_waf_client/conf_mod_waf_client.go (0/29=0.0%)</option>
				
				<option value="file131">bfe_modules/mod_waf_client/mod_waf_client.go (95/167=56.9%)</option>
				
				<option value="file132">bfe_modules/mod_waf_client/waf_client_config_load.go (44/66=66.7%)</option>
				
				<option value="file133">bfe_modules/mod_waf_client/waf_client_status.go (7/7=100.0%)</option>
				
				<option value="file134">bfe_modules/mod_waf_client/waf_pb/bfe_waf_gogo.pb.go (717/1022=70.2%)</option>
				
				<option value="file135">bfe_modules/mod_waf_client/waf_rule_table.go (15/15=100.0%)</option>
				
				<option value="file136">bfe_monitor_proxy/aggre_handler.go (52/67=77.6%)</option>
				
				<option value="file137">bfe_monitor_proxy/monitor_handler.go (38/61=62.3%)</option>
				
				<option value="file138">bfe_monitor_proxy/reload_handler.go (26/37=70.3%)</option>
				
				<option value="file139">bfe_monitor_proxy/web_monitor_proxy.go (69/75=92.0%)</option>
				
				<option value="file140">bfe_net/textproto/header.go (4/10=40.0%)</option>
				
				<option value="file141">bfe_net/textproto/pipeline.go (0/32=0.0%)</option>
				
				<option value="file142">bfe_net/textproto/reader.go (214/249=85.9%)</option>
				
				<option value="file143">bfe_net/textproto/textproto.go (2/28=7.1%)</option>
				
				<option value="file144">bfe_net/textproto/writer.go (34/40=85.0%)</option>
				
				<option value="file145">bfe_server/bfe_confdata_load.go (11/92=12.0%)</option>
				
				<option value="file146">bfe_server/bfe_server.go (38/118=32.2%)</option>
				
				<option value="file147">bfe_server/bfe_server_init.go (0/31=0.0%)</option>
				
				<option value="file148">bfe_server/bufio_cache.go (1/22=4.5%)</option>
				
				<option value="file149">bfe_server/chunk_writer.go (0/176=0.0%)</option>
				
				<option value="file150">bfe_server/expect_continue_reader.go (0/9=0.0%)</option>
				
				<option value="file151">bfe_server/find_location.go (8/9=88.9%)</option>
				
				<option value="file152">bfe_server/http_conn.go (0/207=0.0%)</option>
				
				<option value="file153">bfe_server/http_server.go (0/57=0.0%)</option>
				
				<option value="file154">bfe_server/https_listener.go (0/9=0.0%)</option>
				
				<option value="file155">bfe_server/monitor_stat.go (0/65=0.0%)</option>
				
				<option value="file156">bfe_server/process_info.go (0/14=0.0%)</option>
				
				<option value="file157">bfe_server/protocol_handler.go (0/44=0.0%)</option>
				
				<option value="file158">bfe_server/redirect.go (0/22=0.0%)</option>
				
				<option value="file159">bfe_server/register_modules.go (0/10=0.0%)</option>
				
				<option value="file160">bfe_server/request.go (5/5=100.0%)</option>
				
				<option value="file161">bfe_server/response.go (2/96=2.1%)</option>
				
				<option value="file162">bfe_server/reverseproxy.go (33/320=10.3%)</option>
				
				<option value="file163">bfe_server/server_status.go (0/27=0.0%)</option>
				
				<option value="file164">bfe_server/tls_multi_cert.go (0/92=0.0%)</option>
				
				<option value="file165">bfe_server/tls_next_protos.go (0/26=0.0%)</option>
				
				<option value="file166">bfe_server/tls_session_cache.go (0/96=0.0%)</option>
				
				<option value="file167">bfe_server/web_server.go (0/20=0.0%)</option>
				
				<option value="file168">bfe_spdy/common/compression.go (128/156=82.1%)</option>
				
				<option value="file169">bfe_spdy/common/constants.go (0/7=0.0%)</option>
				
				<option value="file170">bfe_spdy/common/errors.go (0/24=0.0%)</option>
				
				<option value="file171">bfe_spdy/common/limits.go (17/17=100.0%)</option>
				
				<option value="file172">bfe_spdy/common/log.go (0/7=0.0%)</option>
				
				<option value="file173">bfe_spdy/common/response.go (0/115=0.0%)</option>
				
				<option value="file174">bfe_spdy/common/stream_state.go (0/41=0.0%)</option>
				
				<option value="file175">bfe_spdy/common/types.go (0/52=0.0%)</option>
				
				<option value="file176">bfe_spdy/common/utils.go (17/35=48.6%)</option>
				
				<option value="file177">bfe_spdy/spdy2/conn.go (69/74=93.2%)</option>
				
				<option value="file178">bfe_spdy/spdy2/error_handling.go (12/31=38.7%)</option>
				
				<option value="file179">bfe_spdy/spdy2/frames/common.go (7/31=22.6%)</option>
				
				<option value="file180">bfe_spdy/spdy2/frames/data.go (45/58=77.6%)</option>
				
				<option value="file181">bfe_spdy/spdy2/frames/goaway.go (34/40=85.0%)</option>
				
				<option value="file182">bfe_spdy/spdy2/frames/headers.go (61/79=77.2%)</option>
				
				<option value="file183">bfe_spdy/spdy2/frames/noop.go (3/15=20.0%)</option>
				
				<option value="file184">bfe_spdy/spdy2/frames/ping.go (32/36=88.9%)</option>
				
				<option value="file185">bfe_spdy/spdy2/frames/rst_stream.go (41/51=80.4%)</option>
				
				<option value="file186">bfe_spdy/spdy2/frames/settings.go (82/96=85.4%)</option>
				
				<option value="file187">bfe_spdy/spdy2/frames/syn_reply.go (61/77=79.2%)</option>
				
				<option value="file188">bfe_spdy/spdy2/frames/syn_stream.go (74/95=77.9%)</option>
				
				<option value="file189">bfe_spdy/spdy2/frames/window_update.go (8/28=28.6%)</option>
				
				<option value="file190">bfe_spdy/spdy2/interface.go (14/16=87.5%)</option>
				
				<option value="file191">bfe_spdy/spdy2/io.go (52/72=72.2%)</option>
				
				<option value="file192">bfe_spdy/spdy2/processing.go (127/193=65.8%)</option>
				
				<option value="file193">bfe_spdy/spdy2/push_stream.go (56/80=70.0%)</option>
				
				<option value="file194">bfe_spdy/spdy2/request_stream.go (55/105=52.4%)</option>
				
				<option value="file195">bfe_spdy/spdy2/requests.go (69/83=83.1%)</option>
				
				<option value="file196">bfe_spdy/spdy2/response_stream.go (100/146=68.5%)</option>
				
				<option value="file197">bfe_spdy/spdy2/shutdown.go (54/61=88.5%)</option>
				
				<option value="file198">bfe_spdy/spdy2/spdy_api.go (51/65=78.5%)</option>
				
				<option value="file199">bfe_spdy/spdy2/utils.go (2/2=100.0%)</option>
				
				<option value="file200">bfe_spdy/spdy3/conn.go (87/94=92.6%)</option>
				
				<option value="file201">bfe_spdy/spdy3/error_handling.go (16/34=47.1%)</option>
				
				<option value="file202">bfe_spdy/spdy3/flow.go (102/162=63.0%)</option>
				
				<option value="file203">bfe_spdy/spdy3/frames/common.go (7/34=20.6%)</option>
				
				<option value="file204">bfe_spdy/spdy3/frames/credential.go (71/83=85.5%)</option>
				
				<option value="file205">bfe_spdy/spdy3/frames/data.go (44/58=75.9%)</option>
				
				<option value="file206">bfe_spdy/spdy3/frames/goaway.go (40/49=81.6%)</option>
				
				<option value="file207">bfe_spdy/spdy3/frames/headers.go (61/79=77.2%)</option>
				
				<option value="file208">bfe_spdy/spdy3/frames/ping.go (32/36=88.9%)</option>
				
				<option value="file209">bfe_spdy/spdy3/frames/rst_stream.go (41/51=80.4%)</option>
				
				<option value="file210">bfe_spdy/spdy3/frames/settings.go (82/96=85.4%)</option>
				
				<option value="file211">bfe_spdy/spdy3/frames/syn_reply.go (59/75=78.7%)</option>
				
				<option value="file212">bfe_spdy/spdy3/frames/syn_stream.go (150/192=78.1%)</option>
				
				<option value="file213">bfe_spdy/spdy3/frames/window_update.go (41/48=85.4%)</option>
				
				<option value="file214">bfe_spdy/spdy3/interface.go (14/16=87.5%)</option>
				
				<option value="file215">bfe_spdy/spdy3/io.go (65/104=62.5%)</option>
				
				<option value="file216">bfe_spdy/spdy3/processing.go (178/273=65.2%)</option>
				
				<option value="file217">bfe_spdy/spdy3/push_stream.go (58/88=65.9%)</option>
				
				<option value="file218">bfe_spdy/spdy3/request_stream.go (59/116=50.9%)</option>
				
				<option value="file219">bfe_spdy/spdy3/requests.go (70/84=83.3%)</option>
				
				<option value="file220">bfe_spdy/spdy3/response_stream.go (103/165=62.4%)</option>
				
				<option value="file221">bfe_spdy/spdy3/shutdown.go (52/58=89.7%)</option>
				
				<option value="file222">bfe_spdy/spdy3/spdy_api.go (55/69=79.7%)</option>
				
				<option value="file223">bfe_spdy/spdy3/utils.go (2/2=100.0%)</option>
				
				<option value="file224">bfe_tls/alert.go (0/5=0.0%)</option>
				
				<option value="file225">bfe_tls/anti_tlsdos_engine.go (0/3=0.0%)</option>
				
				<option value="file226">bfe_tls/cipher_suites.go (63/78=80.8%)</option>
				
				<option value="file227">bfe_tls/common.go (90/110=81.8%)</option>
				
				<option value="file228">bfe_tls/conn.go (366/536=68.3%)</option>
				
				<option value="file229">bfe_tls/handshake_client.go (212/303=70.0%)</option>
				
				<option value="file230">bfe_tls/handshake_info.go (0/8=0.0%)</option>
				
				<option value="file231">bfe_tls/handshake_messages.go (761/840=90.6%)</option>
				
				<option value="file232">bfe_tls/handshake_server.go (342/486=70.4%)</option>
				
				<option value="file233">bfe_tls/key_agreement.go (163/220=74.1%)</option>
				
				<option value="file234">bfe_tls/prf.go (144/145=99.3%)</option>
				
				<option value="file235">bfe_tls/sslkey_decrypt.go (123/135=91.1%)</option>
				
				<option value="file236">bfe_tls/state.go (5/8=62.5%)</option>
				
				<option value="file237">bfe_tls/ticket.go (101/197=51.3%)</option>
				
				<option value="file238">bfe_tls/tls.go (69/146=47.3%)</option>
				
				<option value="file239">bfe_util/exit.go (0/2=0.0%)</option>
				
				<option value="file240">bfe_util/file.go (0/23=0.0%)</option>
				
				<option value="file241">bfe_util/fixed_pool.go (9/9=100.0%)</option>
				
				<option value="file242">bfe_util/gc_switch.go (0/6=0.0%)</option>
				
				<option value="file243">bfe_util/get_net_info.go (0/61=0.0%)</option>
				
				<option value="file244">bfe_util/getvip_linux.go (0/15=0.0%)</option>
				
				<option value="file245">bfe_util/json_util.go (0/26=0.0%)</option>
				
				<option value="file246">bfe_util/limit_rate.go (24/28=85.7%)</option>
				
				<option value="file247">bfe_util/multi_process_utils.go (0/14=0.0%)</option>
				
				<option value="file248">bfe_util/prob_generator.go (6/6=100.0%)</option>
				
				<option value="file249">bfe_util/register_signal_linux.go (0/7=0.0%)</option>
				
				<option value="file250">bfe_util/rolling_counter.go (37/47=78.7%)</option>
				
				<option value="file251">bfe_util/tcp_wise_util.go (0/27=0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >/* bfe_backend.go - backend framework for bfe   */
/*
modification history
--------------------
2014/5/5, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package backend

import (
    "sync"
)

import (
    "bfe_config/bfe_cluster_conf/cluster_conf"
    "bfe_config/bfe_cluster_conf/cluster_table_conf"
)

// struct for each backend RS
type BfeBackend struct {
    sync.RWMutex
    Name string // backend's name

    Addr string // backend's address
    Port int    // backend's port

    avail   bool // whether the backend is useable
    failNum int  // number of continuous fails

    SubCluster string // name of sub-cluster, set after balance

    closeChan chan bool // tell healthcheck to stop
}

// create new BfeBackend
func NewBfeBackend() *BfeBackend <span class="cov8" title="1">{
    backend := new(BfeBackend)
    backend.avail = true
    backend.closeChan = make(chan bool)

    return backend
}</span>

// initialize BfeBackend with BackendConf
func (back *BfeBackend) Init(conf *cluster_table_conf.BackendConf) <span class="cov8" title="1">{
    back.Name = *conf.Name
    back.Addr = *conf.Addr
    back.Port = *conf.Port
}</span>

// update BfeBackend with BackendConf
func (back *BfeBackend) Update(conf *cluster_table_conf.BackendConf) <span class="cov8" title="1">{
    back.Lock()
    back.Addr = *conf.Addr
    back.Port = *conf.Port
    back.Unlock()
}</span>

func (back *BfeBackend) Avail() bool <span class="cov8" title="1">{
    back.RLock()
    defer back.RUnlock()
    return back.avail
}</span>

func (back *BfeBackend) SetAvail(avail bool) <span class="cov8" title="1">{
    back.Lock()
    back.setAvail(avail)
    back.Unlock()
}</span>

// no lock, caller to call lock
func (back *BfeBackend) setAvail(avail bool) <span class="cov8" title="1">{
    back.avail = avail
    if back.avail </span><span class="cov0" title="0">{
        back.failNum = 0
    }</span>
}

func (back *BfeBackend) GetAddrPort() (string, int) <span class="cov0" title="0">{
    back.RLock()
    defer back.RUnlock()

    return back.Addr, back.Port
}</span>

func (back *BfeBackend) AddFailNum() <span class="cov0" title="0">{
    back.Lock()
    back.failNum++
    back.Unlock()
}</span>

func (back *BfeBackend) ResetFailNum() <span class="cov0" title="0">{
    back.Lock()
    back.failNum = 0
    back.Unlock()
}</span>

func (back *BfeBackend) FailNum() int <span class="cov0" title="0">{
    back.RLock()
    defer back.RUnlock()

    return back.failNum
}</span>

// set status to false when failNum &gt;= threshold
// return true if status flip to false
func (back *BfeBackend) UpdateStatus(failThreshold int) bool <span class="cov0" title="0">{
    back.Lock()
    defer back.Unlock()

    prevStatus := back.avail
    if back.failNum &gt;= failThreshold </span><span class="cov0" title="0">{
        back.setAvail(false)
        if prevStatus </span><span class="cov0" title="0">{
            return true
        }</span>
    }

    <span class="cov0" title="0">return false</span>
}

func (back *BfeBackend) Release() <span class="cov0" title="0">{
    back.Close()
}</span>

func (back *BfeBackend) Close() <span class="cov0" title="0">{
    close(back.closeChan)
}</span>

func (back *BfeBackend) CloseChan() &lt;-chan bool <span class="cov0" title="0">{
    return back.closeChan
}</span>

// call on request success, reset backend failnum
func (back *BfeBackend) OnSuccess() <span class="cov0" title="0">{
    back.ResetFailNum()
}</span>

// called when backend caused request fail
func (back *BfeBackend) OnFail(conf *cluster_conf.BackendCheck) <span class="cov0" title="0">{
    back.AddFailNum()
    UpdateStatus(back, conf)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/* health_check.go - health check for backend    */
/*
modification history
--------------------
2014/6/21, by Weiwei, create
*/
/*
DESCRIPTION
*/

package backend

import (
        "fmt"
        "net/http"
        "time"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
        "bfe_config/bfe_cluster_conf/cluster_conf"
    "bfe_debug"
)

// update backend status
// if backend's status become fail, start healthcheck
func UpdateStatus(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) bool <span class="cov0" title="0">{
    // at most start 1 check goroutine for each backend
    if backend.UpdateStatus(*checkConf.FailNum) </span><span class="cov0" title="0">{
        go check(backend, checkConf)
        return true
    }</span>

    <span class="cov0" title="0">return false</span>
}

func check(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) <span class="cov0" title="0">{
    log.Logger.Info("start healthcheck for %s", backend.Name)

    // backend close chan
    c := backend.CloseChan()
    // ticker to check connectivity
    t := time.NewTicker(time.Duration(*checkConf.CheckInterval) * time.Millisecond)
    defer t.Stop()

loop:
    for </span><span class="cov0" title="0">{
        select </span>{
        <span class="cov0" title="0">case &lt;-c:
            // backend deleted
            break loop</span>
        <span class="cov0" title="0">case &lt;-t.C:
            // time to check
            if ok, err:= checkConnect(backend, checkConf); err == nil &amp;&amp; ok </span><span class="cov0" title="0">{
                log.Logger.Info("backend %s back to Normal", backend.Name)
                backend.SetAvail(true)
                break loop</span>
            }
            <span class="cov0" title="0">if bfe_debug.DEBUG_HEALTH_CHECK </span><span class="cov0" title="0">{
                log.Logger.Debug("backend %s still not avail", backend.Name)
            }</span>
        }
    }
}

// check if backend server become available by generate and send request using given checkConf.
// return (true, nil) if response status code == conf status code
//        (false, err) if get a response of not-200 status code
//        (nil, err) if any err happened
func checkConnect(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) (bool, error) <span class="cov0" title="0">{
        // generate request
    schem := "http" // default to http
    if checkConf.Schem != nil </span><span class="cov0" title="0">{
        schem = *checkConf.Schem
    }</span>
    <span class="cov0" title="0">addr, port := backend.GetAddrPort()
    urlStr := fmt.Sprintf("%s://%s:%d%s", schem, addr, port, *checkConf.Uri)
    request, err := http.NewRequest("GET", urlStr, nil)
        if err != nil </span><span class="cov0" title="0">{
        return false, err
        }</span>

    // modify http host header if needed
    <span class="cov0" title="0">if checkConf.Host != nil </span><span class="cov0" title="0">{
        request.Host = *checkConf.Host
    }</span>

    // do request, send and receive
    <span class="cov0" title="0">response, err := http.DefaultClient.Do(request)
    if err != nil </span><span class="cov0" title="0">{
        return false, err
    }</span>
    <span class="cov0" title="0">defer response.Body.Close()

    if response.StatusCode != *checkConf.StatusCode </span><span class="cov0" title="0">{
        err = fmt.Errorf("health check Url[%s] response statusCode[%d], while expect[%d]",
                          urlStr, response.StatusCode, *checkConf.StatusCode)
    }</span>

    // check StatusCode
    <span class="cov0" title="0">return response.StatusCode == *checkConf.StatusCode, err</span>
}

// check if backend server become available by generate and send request using given checkConf.
// return (true, nil) if response status code == conf status code
//        (false, err) if get a response of not-200 status code
//        (nil, err) if any err happened
func CheckConnect(backend *BfeBackend, checkConf *cluster_conf.BackendCheck) (bool, error) <span class="cov0" title="0">{
    return checkConnect(backend, checkConf)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/* bal_gslb.go - load balance using gslb    */
/*
modification history
--------------------
2014/5/16, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bal_gslb

import (
    "fmt"
    "math/rand"
    "sort"
    "sync"
    "time"
)

import (
    "github.com/murmur3"
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
)

import (
    "bfe_basic"
    backend "bfe_balance/backend"
    "bfe_config/bfe_cluster_conf/cluster_conf"
    "bfe_config/bfe_cluster_conf/cluster_table_conf"
    "bfe_config/bfe_cluster_conf/gslb_conf"
)

type BalanceGslb struct {
    lock sync.Mutex

    name        string         // name of cluster, e.g., "news"
    subClusters SubClusterList // list of sub cluster

    totalWeight int  // sum weight of sub clusters that has a weight &gt;0
    single      bool // only one sub cluster?
    avail       int  // if single is true, avail is index of avail sub cluster

    retryMax    int // inner cluster retry
    crossRetry  int // if all retry within default cluster failed, retry from other cluster
}

// create new BalanceGslb
func NewBalanceGslb(name string) *BalanceGslb <span class="cov1" title="1">{
    bal := new(BalanceGslb)
    bal.name = name

    bal.retryMax = 3
    bal.crossRetry = 1

    return bal
}</span>

func (bal *BalanceGslb) SetGslbRetry(gslbBasic cluster_conf.GslbBasicConf) <span class="cov1" title="1">{
    bal.lock.Lock()
    defer bal.lock.Unlock()

    bal.crossRetry = *gslbBasic.CrossRetry
    bal.retryMax = *gslbBasic.RetryMax
}</span>

// inialize gslb cluster with config
func (bal *BalanceGslb) Init(gslbConf gslb_conf.GslbClusterConf) error <span class="cov1" title="1">{
    totalWeight := 0

    for subClusterName, weight := range gslbConf </span><span class="cov2" title="3">{
        subCluster := newSubCluster(subClusterName)
        subCluster.weight = weight

        if weight &gt; 0 </span><span class="cov1" title="1">{
            totalWeight += weight
        }</span>

        // add sub-cluster to cluster
        <span class="cov2" title="3">bal.subClusters = append(bal.subClusters, subCluster)</span>
    }

    <span class="cov1" title="1">if totalWeight == 0 </span><span class="cov0" title="0">{
        // should never be here, as ClusterCheck return true
        log.Logger.Critical("gslb total weight = 0 [%s]", bal.name)
        return fmt.Errorf("gslb total weight = 0 [%s]", bal.name)
    }</span>

    <span class="cov1" title="1">bal.totalWeight = totalWeight

    // sort list to guarantee same order, since map iteration is not in order
    sort.Sort(SubClusterListSorter{bal.subClusters})
    availNum := 0
    for index, sub := range bal.subClusters </span><span class="cov2" title="3">{
        if sub.weight &gt; 0 </span><span class="cov1" title="1">{
            bal.avail = index
            availNum += 1
        }</span>
    }
    <span class="cov1" title="1">bal.single = (availNum == 1)

    return nil</span>
}

func (bal *BalanceGslb) BackendInit(clusterBackend cluster_table_conf.ClusterBackend) error <span class="cov0" title="0">{
    bal.lock.Lock()
    defer bal.lock.Unlock()
    for _, subCluster := range bal.subClusters </span><span class="cov0" title="0">{
        if backend, ok := clusterBackend[subCluster.Name]; ok </span><span class="cov0" title="0">{
            subCluster.init(backend)
        }</span>
    }

    <span class="cov0" title="0">return nil</span>
}

// reload gslb config
func (bal *BalanceGslb) Reload(gslbConf gslb_conf.GslbClusterConf) error <span class="cov1" title="1">{
    bal.lock.Lock()
    defer bal.lock.Unlock()

    // create new SubClusterList
    var subListNew SubClusterList

    // create a map to record exist subCluster in gslbConf
    subExist := make(map[string]bool)

    // go through existing sub cluster, and doing update
    for i := 0; i &lt; len(bal.subClusters); i++ </span><span class="cov2" title="3">{
        sub := bal.subClusters[i]

        // find new conf of sub in gslbConf
        weight, ok := gslbConf[sub.Name]

        if ok </span><span class="cov1" title="2">{
            // exist in new conf
            sub.weight = weight

            // add sub cluster to subListNew
            subListNew = append(subListNew, sub)
        }</span> <span class="cov1" title="1">else {
            // release sub_cluster
            sub.release()
            log.Logger.Info("release subcluster %s", sub.Name)
        }</span>

        // record in the map of subExist
        <span class="cov2" title="3">subExist[sub.Name] = true</span>
    }

    // go through gslbConf, and doing init for those not in subExist
    <span class="cov1" title="1">for subName, weight := range gslbConf </span><span class="cov2" title="3">{
        _, ok := subExist[subName]

        if !ok </span><span class="cov1" title="1">{
            // create new sub cluster
            sub := newSubCluster(subName)
            sub.weight = weight

            // add sub cluster to subListNew
            subListNew = append(subListNew, sub)
        }</span>
    }

    // sort list
    <span class="cov1" title="1">sort.Sort(SubClusterListSorter{subListNew})

    // calc total_weight
    totalWeight := 0
    availableNum := 0
    lastAvailIndex := 0

    for index, sub := range subListNew </span><span class="cov2" title="3">{
        if sub.weight &gt; 0 </span><span class="cov1" title="2">{
            totalWeight += sub.weight
            availableNum += 1
            lastAvailIndex = index
        }</span>
    }

    <span class="cov1" title="1">if totalWeight == 0 </span><span class="cov0" title="0">{
        // should never be here, as ClusterCheck return true
        log.Logger.Critical("gslb total weight = 0 [%s]", bal.name)
        return fmt.Errorf("gslb total weight = 0 [%s]", bal.name)
    }</span>

    <span class="cov1" title="1">bal.totalWeight = totalWeight

    if availableNum == 1 </span><span class="cov0" title="0">{
        bal.single = true
        bal.avail = lastAvailIndex
    }</span> <span class="cov1" title="1">else {
        bal.single = false
    }</span>

    // update gslb.subClusters
    <span class="cov1" title="1">bal.subClusters = subListNew

    return nil</span>
}

func (bal *BalanceGslb) BackendReload(clusterBackend cluster_table_conf.ClusterBackend) error <span class="cov1" title="1">{
    bal.lock.Lock()
    defer bal.lock.Unlock()

    for _, subCluster := range bal.subClusters </span><span class="cov2" title="3">{
        if backend, ok := clusterBackend[subCluster.Name]; ok </span><span class="cov1" title="2">{
            subCluster.update(backend)
        }</span>
    }

    <span class="cov1" title="1">return nil</span>
}

// reload gslb config
func (bal *BalanceGslb) Release() <span class="cov0" title="0">{
    bal.lock.Lock()
    defer bal.lock.Unlock()
    // go through all sub clusters
    for i := 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
        // release sub_cluster
        bal.subClusters[i].release()
    }</span>
}

// balance function of gslb , ip + cookie hash
func (bal *BalanceGslb) Balance(req *bfe_basic.Request,
    proxyState *module_state2.State) (*backend.BfeBackend, error) <span class="cov9" title="1000">{
    var backend *backend.BfeBackend
    var current *SubCluster
    var err error

    bal.lock.Lock()
    defer bal.lock.Unlock()

    if req.RetryTime &gt; (bal.retryMax + bal.crossRetry) </span><span class="cov0" title="0">{
        // both in-cluster and cross-cluster retry failed.
        proxyState.Inc("ERR_BK_RETRY_TOOMANY", 1)
        req.ErrCode = bfe_basic.ERR_BK_RETRY_TOOMANY
        return backend, bfe_basic.ERR_BK_RETRY_TOOMANY
    }</span>

    <span class="cov9" title="1000">current, err = bal.subClusterBalance(req.BaiduidHex)
    if err != nil </span><span class="cov0" title="0">{
        // no sub cluster available
        proxyState.Inc("ERR_BK_NO_SUB_CLUSTER", 1)
        req.ErrCode = bfe_basic.ERR_BK_NO_SUB_CLUSTER
        return backend, bfe_basic.ERR_BK_NO_SUB_CLUSTER
    }</span>
    <span class="cov9" title="1000">log.Logger.Debug("baiduid[%s], sub cluster=[%s],total_weight=[%d]",
        req.Baiduid, current.Name, bal.totalWeight)

    // after get the distribution subcluster

    // blackhole
    if current.sType == TYPE_GSLB_BLACKHOLE </span><span class="cov0" title="0">{
        proxyState.Inc("ERR_GSLB_BLACKHOLE", 1)
        req.ErrCode = bfe_basic.ERR_GSLB_BLACKHOLE
        return backend, bfe_basic.ERR_GSLB_BLACKHOLE
    }</span>

    // still in-cluster selection
    <span class="cov9" title="1000">if req.RetryTime &lt;= bal.retryMax </span><span class="cov9" title="1000">{
        backend, err = current.balance()
        if err == nil </span><span class="cov9" title="1000">{
            // piggyback name of sub-cluster in backend
            backend.SubCluster = current.Name
            return backend, nil
        }</span> <span class="cov0" title="0">else {
            // fail to get backend from current sub-cluster
            proxyState.Inc("ERR_BK_NO_BACKEND", 1)
            log.Logger.Warn("gslb.Balance():no backend(in cluster):cluster[%s], sub[%s], err[%s]",
                bal.name, current.Name, err.Error())
        }</span>
    }

    // in-cluster selection failed, select from cross-cluster
    <span class="cov0" title="0">log.Logger.Debug("start cross-cluster selection , retry = %d", req.RetryTime)
    if req.Stat != nil </span><span class="cov0" title="0">{
        req.Stat.IsCrossCluster = true
    }</span>

    <span class="cov0" title="0">current, err = bal.randomSelectExclude(current)
    if err != nil </span><span class="cov0" title="0">{
        proxyState.Inc("ERR_BK_NO_SUB_CLUSTER_CROSS", 1)
        req.ErrCode = bfe_basic.ERR_BK_NO_SUB_CLUSTER_CROSS
        return backend, bfe_basic.ERR_BK_NO_SUB_CLUSTER_CROSS
    }</span>

    <span class="cov0" title="0">backend, err = current.balance()
    if err == nil </span><span class="cov0" title="0">{
        // piggyback name of sub-cluster in backend
        backend.SubCluster = current.Name
    }</span> <span class="cov0" title="0">else {
        // fail to get backend from current sub-cluster
        proxyState.Inc("ERR_BK_NO_BACKEND", 1)
        req.ErrCode = bfe_basic.ERR_BK_NO_BACKEND
        req.ErrMsg = fmt.Sprintf("cluster[%s], sub[%s], err[%s]",
            bal.name, current.Name, err.Error())
        log.Logger.Warn("gslb.Balance():no backend(cross cluster):cluster[%s], sub[%s], err[%s]",
            bal.name, current.Name, err.Error())
    }</span>

    <span class="cov0" title="0">return backend, err</span>
}

func getHash(baiduid []byte, base uint) int <span class="cov9" title="1000">{
    var hash uint64

    if baiduid == nil </span><span class="cov0" title="0">{
        hash = uint64(rand.Uint32())
    }</span> <span class="cov9" title="1000">else {
        hash = murmur3.Sum64(baiduid)
    }</span>

    <span class="cov9" title="1000">return int(hash % uint64(base))</span>
}

// select one sub cluster, based on baiduid
func (bal *BalanceGslb) subClusterBalance(baiduid []byte) (*SubCluster, error) <span class="cov9" title="1000">{
    var subCluster *SubCluster

    if bal == nil </span><span class="cov0" title="0">{
        return subCluster, fmt.Errorf("gslb is nil")
    }</span>

    <span class="cov9" title="1000">if bal.totalWeight == 0 </span><span class="cov0" title="0">{
        return subCluster, fmt.Errorf("totalWeight is 0")
    }</span>

    <span class="cov9" title="1000">if bal.single </span><span class="cov0" title="0">{
        return bal.subClusters[bal.avail], nil
    }</span>

    <span class="cov9" title="1000">w := getHash(baiduid, uint(bal.totalWeight))

    for i := 0; i &lt; len(bal.subClusters); i++ </span><span class="cov10" title="2150">{
        subCluster = bal.subClusters[i]
        if subCluster.weight &lt;= 0 </span><span class="cov9" title="1000">{
            continue</span>
        }
        <span class="cov9" title="1150">w -= subCluster.weight
        // got it
        if w &lt; 0 </span><span class="cov9" title="1000">{
            break</span>
        }
    }

    <span class="cov9" title="1000">return subCluster, nil</span>
}

// randomly select a sub cluster, exclude exclude_sub_cluster, gslb blackhole
func (bal *BalanceGslb) randomSelectExclude(excludeCluster *SubCluster) (*SubCluster, error) <span class="cov0" title="0">{
    var i int
    var subCluster *SubCluster

    available := 0

    for i = 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
        subCluster = bal.subClusters[i]
        if subCluster != excludeCluster &amp;&amp; subCluster.weight &gt;= 0 &amp;&amp;
            subCluster.sType != TYPE_GSLB_BLACKHOLE </span><span class="cov0" title="0">{
            available++
        }</span>
    }

    <span class="cov0" title="0">if available == 0 </span><span class="cov0" title="0">{
        return subCluster, fmt.Errorf("no sub cluster available")
    }</span>

    <span class="cov0" title="0">r := rand.New(rand.NewSource(time.Now().UnixNano()))
    n := int(r.Int31()) % available

    for i = 0; i &lt; len(bal.subClusters); i++ </span><span class="cov0" title="0">{
        subCluster = bal.subClusters[i]
        if subCluster != excludeCluster &amp;&amp; subCluster.weight &gt;= 0 &amp;&amp;
            subCluster.sType != TYPE_GSLB_BLACKHOLE </span><span class="cov0" title="0">{
            if n == 0 </span><span class="cov0" title="0">{
                return subCluster, nil
            }</span> <span class="cov0" title="0">else {
                n--
            }</span>
        }
    }

    // never reach here
    <span class="cov0" title="0">return subCluster, fmt.Errorf("randomSelectExclude():should not reach here")</span>
}

func (bal *BalanceGslb) SubClusterNum() int <span class="cov0" title="0">{
    return len(bal.subClusters)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/* state.go - gslb load balance state  */
/*
modification history
--------------------
2014/7/15, by Weiwei, create
*/

/*
DESCRIPTION
*/
package bal_gslb

// state of sub-cluster
type SubClusterState struct {
    BackendNum int     // number of backends
}

// state of cluster
type GslbState struct {
        SubClusters map[string]*SubClusterState  // state of sub-cluster
        BackendNum int                           // number of cluster backend
}

func State(bal *BalanceGslb) *GslbState <span class="cov0" title="0">{
        bal.lock.Lock()
        defer bal.lock.Unlock()

        gslbState := new(GslbState)
        gslbState.SubClusters = make(map[string]*SubClusterState)

        for _, sub := range bal.subClusters </span><span class="cov0" title="0">{
                subState := &amp;SubClusterState{
                        BackendNum : sub.Len(),
                }
                
                gslbState.SubClusters[sub.Name] = subState
                gslbState.BackendNum += subState.BackendNum
        }</span>
        
        <span class="cov0" title="0">return gslbState</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/* sub_cluster.go - sub cluster in gslb */
/*
modification history
--------------------
2014/5/20, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bal_gslb

import (
        "fmt"
)

import (
    "bfe_balance/backend"
    "bfe_balance/bal_rr"
    "bfe_config/bfe_cluster_conf/cluster_table_conf"
)

// type of sub cluster
const (
    TYPE_GSLB_NORM      = 0     // normal sub cluster
    TYPE_GSLB_BLACKHOLE = 1     // gslb blackhole
)

// sub cluster
type SubCluster struct {
    Name        string          // name of sub cluster
    sType       int             // TYPE_GSLB_NORM, or TYPE_GSLB_BLACKHOLE    
    backends    *bal_rr.BalanceRR  // backend with round robin    
    weight      int             // weight between subclusters
}

// create new SubCluster
func newSubCluster(name string) *SubCluster <span class="cov2" title="4">{
    sub := new(SubCluster)
    
    // set name
    sub.Name = name
    
    // set type
    if name == "GSLB_BLACKHOLE" </span><span class="cov1" title="1">{
        sub.sType = TYPE_GSLB_BLACKHOLE
    }</span> <span class="cov2" title="3">else {
        sub.sType = TYPE_GSLB_NORM
    }</span>

    // create backends
    <span class="cov2" title="4">sub.backends = bal_rr.NewBalanceRR(name)
        
    return sub</span>
}

// initialize sub-cluster with backend list
func (sub *SubCluster) init(backends cluster_table_conf.SubClusterBackend) <span class="cov0" title="0">{
    sub.backends.Init(backends)
}</span>

// update sub-cluster with backend list
func (sub *SubCluster) update(backends cluster_table_conf.SubClusterBackend) <span class="cov1" title="2">{
    sub.backends.Update(backends)
}</span>

// release sub-cluster
func (sub *SubCluster) release() <span class="cov1" title="1">{
    sub.backends.Release()   
}</span>

// get length of sub-cluster
func (sub *SubCluster) Len() int <span class="cov0" title="0">{
    return sub.backends.Len()
}</span>

func (sub *SubCluster) balance() (*backend.BfeBackend, error) <span class="cov10" title="1000">{
    if sub.backends.Len() == 0 </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("no backend in sub cluster [%s]", sub.Name)
    }</span>

    // wrr is the only choice;
    <span class="cov10" title="1000">return sub.backends.Balance()</span>
}

// subcluster list
type SubClusterList []*SubCluster

// subcluster list sorter
type SubClusterListSorter struct {
        l SubClusterList
}

func (s SubClusterListSorter) Len() int <span class="cov1" title="2">{
    return len(s.l)
}</span>

// Swap is part of sort.Interface.
func (s SubClusterListSorter) Swap(i, j int) <span class="cov1" title="1">{
    s.l[i], s.l[j] = s.l[j], s.l[i]
}</span>

// Less is part of sort.Interface.
func (s SubClusterListSorter) Less(i, j int) bool <span class="cov3" title="5">{
    return s.l[i].Name &lt; s.l[j].Name
}</span>

</pre>
		
		<pre class="file" id="file5" style="display: none">/* backend_rr.go - backend with round robin     */
/*
modification history
--------------------
2014/5/20, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bal_rr

import (
        "bfe_balance/backend"
        "bfe_config/bfe_cluster_conf/cluster_table_conf"
)

// backend for round robin
type BackendRR struct {
        weight  int                 // weight of this backend
        left    int                 // weight left
        backend *backend.BfeBackend // point to BfeBackend
}

// create new BackendRR
func NewBackendRR() *BackendRR <span class="cov10" title="2">{
        backendRR := new(BackendRR)
        backendRR.backend = backend.NewBfeBackend()

        return backendRR
}</span>

// initialize BackendRR with BackendConf
func (backRR *BackendRR) Init(conf *cluster_table_conf.BackendConf) <span class="cov10" title="2">{
        backRR.weight = *conf.Weight
        backRR.left = *conf.Weight

        back := backRR.backend
        back.Init(conf)
}</span>

// update BackendRR with BackendConf
func (backRR *BackendRR) Update(conf *cluster_table_conf.BackendConf) <span class="cov1" title="1">{
        backRR.weight = *conf.Weight

        // if weight &gt; 0, don't touch backRR.left
        if *conf.Weight &lt;= 0 </span><span class="cov0" title="0">{
                backRR.left = 0
        }</span>

        <span class="cov1" title="1">back := backRR.backend
        back.Update(conf)</span>
}

func (backRR *BackendRR) Release() <span class="cov10" title="2">{
        backRR.backend.Release()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/* bal_rr.go - roundrobin balance    */
/*
modification history
--------------------
2014/7/11, by Weiwei, create
*/
/*
DESCRIPTION
*/


package bal_rr

import (
        "fmt"
    "sync"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
        backend "bfe_balance/backend"
        "bfe_config/bfe_cluster_conf/cluster_table_conf"
        "bfe_debug"
)

type BackendList []*BackendRR

func (bl *BackendList) ResetWeight() <span class="cov3" title="3">{
        for _, backendRR := range *bl </span><span class="cov6" title="9">{
                backendRR.left = backendRR.weight
        }</span>
}

type BalanceRR struct {
        sync.Mutex
        Name          string
        backends BackendList // list of BackendRR
        next     int         // next backend to schedule
}

func NewBalanceRR(name string) *BalanceRR <span class="cov0" title="0">{
        brr := new(BalanceRR)
        brr.Name = name
        return brr
}</span>

// initialize RRList with config
func (brr *BalanceRR) Init(conf cluster_table_conf.SubClusterBackend) <span class="cov0" title="0">{
        for _, backendConf := range conf </span><span class="cov0" title="0">{
                backendRR := NewBackendRR()
                backendRR.Init(backendConf)
                backendRR.backend.SubCluster = brr.Name
                // add to backends
                brr.backends = append(brr.backends, backendRR)
        }</span>

        <span class="cov0" title="0">brr.next = 0</span>
}

// release backend list
func (brr *BalanceRR) Release() <span class="cov0" title="0">{
        for _, back := range(brr.backends) </span><span class="cov0" title="0">{
                back.Release()
        }</span>
}

// create map for conf
func confMapMake(conf cluster_table_conf.SubClusterBackend) map[string]*cluster_table_conf.BackendConf <span class="cov1" title="1">{
        retVal := make(map[string]*cluster_table_conf.BackendConf)

        for _, backend := range conf </span><span class="cov2" title="2">{
                retVal[*backend.Name] = backend
        }</span>

        <span class="cov1" title="1">return retVal</span>
}

// update BalanceRR with new config
func (brr *BalanceRR) Update(conf cluster_table_conf.SubClusterBackend) <span class="cov1" title="1">{
        // create new BackendList
        var backendsNew BackendList

        // create map for config
        confMap := confMapMake(conf)

        brr.Lock()
        defer brr.Unlock()
        
        // go through backendsOld, make update and delete
        for index := 0; index &lt; len(brr.backends); index++ </span><span class="cov3" title="3">{
                backendRR := brr.backends[index]

                bkConf, ok := confMap[backendRR.backend.Name]

                if ok </span><span class="cov1" title="1">{
                        // update backend with new conf
                        backendRR.Update(bkConf)
                        backendsNew = append(backendsNew, backendRR)

                        // remove from confMap
                        delete(confMap, backendRR.backend.Name)
                }</span> <span class="cov2" title="2">else {
                        // tell healthcheck to stop
                        backendRR.Release()
                }</span>
        }

        // add new backend to backendsNew
        <span class="cov1" title="1">for _, bkConf := range confMap </span><span class="cov1" title="1">{
                backendRR := NewBackendRR()
                backendRR.Init(bkConf)
                backendRR.backend.SubCluster = brr.Name
                // add to backendsNew
                backendsNew = append(backendsNew, backendRR)
        }</span>

        // point brr.backends to backendsNew
        <span class="cov1" title="1">brr.backends = backendsNew
        brr.next = 0</span>
}

// initialize all backendRR.left to backendRR.weight
func (brr *BalanceRR) initWeight() <span class="cov3" title="3">{
        brr.backends.ResetWeight()
}</span>

// move to next. if at end of list, move back to 0
func moveToNext(next int, backends BackendList) int <span class="cov10" title="34">{
        next += 1
        if next &gt;= len(backends) </span><span class="cov6" title="9">{
                next = 0
        }</span>
        <span class="cov10" title="34">return next</span>
}

// get one backend from sub cluster with round robin
func (brr *BalanceRR) Balance() (*backend.BfeBackend, error) <span class="cov8" title="18">{
        var backend *backend.BfeBackend
        var backendRR *BackendRR

        brr.Lock()
        defer brr.Unlock()
        
        backends := brr.backends
        all_backend_down := true

        next := brr.next
        for </span><span class="cov10" title="34">{
                backendRR = backends[next]
                backend = backendRR.backend
                
                avail := backend.Avail()
                if avail &amp;&amp; backendRR.left &gt; 0 </span><span class="cov8" title="18">{
                        // find one available backend
                        break</span>
                }

                <span class="cov8" title="16">if bfe_debug.DEBUG_BAL </span><span class="cov0" title="0">{
                        log.Logger.Debug("backend[%s],avail[%d],weight[%d]",
                                backend.Name, avail, backendRR.weight)
                }</span>

                <span class="cov8" title="16">if avail &amp;&amp; backendRR.weight != 0 </span><span class="cov6" title="8">{
                        all_backend_down = false
                }</span>

                // move to next
                <span class="cov8" title="16">next = moveToNext(next, backends)

                if next == brr.next </span><span class="cov3" title="3">{
                        // all backends have been check
                        if all_backend_down </span><span class="cov0" title="0">{
                                if bfe_debug.DEBUG_BAL </span><span class="cov0" title="0">{
                                        log.Logger.Debug("rr_bal:all backend is down")
                                }</span>
                                <span class="cov0" title="0">return backend, fmt.Errorf("rr_bal:all backend is down")</span>
                        } <span class="cov3" title="3">else {
                                if bfe_debug.DEBUG_BAL </span><span class="cov0" title="0">{
                                        log.Logger.Debug("rr_bal:reset backend weight")
                                }</span>
                                <span class="cov3" title="3">brr.initWeight()
                                brr.next = 0
                                next = 0</span>
                        }
                }
        }

        // modify left
        <span class="cov8" title="18">backendRR.left--

        // modify brr.next, for next use
        next = moveToNext(next, backends)
        brr.next = next

        if bfe_debug.DEBUG_BAL </span><span class="cov0" title="0">{
                log.Logger.Debug("rr.Balance: backend[%s] weight[%d]left[%d]",
                        backend.Name, backendRR.weight, backendRR.left)
        }</span>
        <span class="cov8" title="18">return backend, nil</span>
}

// get length
func (brr *BalanceRR) Len() int <span class="cov0" title="0">{
        return len(brr.backends)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/* bal_table.go - table for maintain backend cluster    */
/*
modification history
--------------------
2015/4/9, by caodong, create
*/
/*
DESCRIPTION
    bal_table mainly keep BalMap struct which split from BfeCluster struct
    BalMap map[string] *bal_gslb.BalanceGslb, the key is cluster name.
    
    previously, we get backend instance via method as follows:
    1, host -&gt; cluster name. (hostTable.FindLocation(req))
    2, cluster name -&gt; cluster instance (clusterTable.Lookup(clusterName))
    3, cluster.Balance -&gt; backend instance (cluster.Balance.Balance(req))

    In order to support multi files reload, move Balacne from cluster struct to BalMap
    Now, we get one backend instance as follows:
    1, host -&gt; cluster name. (hostTable.FindLocation(req))
    2, cluster name -&gt; cluster instance (clusterTable.Lookup(clusterName))
    3, cluster name -&gt; gslb instance (balTable.Lookup(clusterName))
    4, gslb -&gt; backend instance (gslb.Balance())
*/
package bfe_balance

import (
        "fmt"
        "strings"
        "sync"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
    "bfe_balance/bal_gslb"
    "bfe_data"
        cluster_table_conf "bfe_config/bfe_cluster_conf/cluster_table_conf"
        gslb_conf "bfe_config/bfe_cluster_conf/gslb_conf"
)

// map from clusterName to BalanceGsl
type BalMap map[string] *bal_gslb.BalanceGslb

// how to select backend
type BalTable struct {
        lock        sync.RWMutex
        balTable    BalMap          // from cluster to balancer
    versions    BalVersion
}

type BalVersion struct {
    ClusterTableConfVer string // cluster table conf version
        GslbConfTimeStamp   string // timestamp of gslb-conf
        GslbConfSrc         string // which gslb-scheduler come from?
}

type BalTableState struct {
    Balancers  map[string] *bal_gslb.GslbState // state of cluster
    BackendNum int                             // size of backendTable
}

// create new BalTable
func NewBalTable() *BalTable <span class="cov5" title="4">{
    t := new(BalTable)
    t.balTable = make(BalMap)
    return t
}</span>

func (t *BalTable) BalTableConfLoad(gslbConfFilename, clusterTableFilename string) (
    gslb_conf.GslbConf, cluster_table_conf.ClusterTableConf, error) <span class="cov7" title="8">{

    var gslbConf gslb_conf.GslbConf
    var backendConf cluster_table_conf.ClusterTableConf
    var err error

        gslbConf, err = gslb_conf.GslbConfLoad(gslbConfFilename)
        if err != nil </span><span class="cov3" title="2">{
                log.Logger.Error("gslb_conf.GslbConfLoad err [%s]", err)
                return gslbConf, backendConf, err
        }</span>

        <span class="cov6" title="6">backendConf, err = cluster_table_conf.ClusterTableLoad(clusterTableFilename)
        if err != nil </span><span class="cov3" title="2">{
                log.Logger.Error("clusterBackendConfLoad err [%s]", err)
        }</span>

    <span class="cov6" title="6">return gslbConf, backendConf, err</span>
}

func (t *BalTable) Init(gslbConfFilename, clusterTableFilename string) error <span class="cov5" title="4">{
    gslbConf, backendConf, err := t.BalTableConfLoad(gslbConfFilename, clusterTableFilename)

    if err != nil </span><span class="cov3" title="2">{
        log.Logger.Error("BalTable conf load err %s", err)
        return err
    }</span>

        // init gslb
        <span class="cov3" title="2">if err := t.gslbInit(gslbConf); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("clusterTable gslb init err [%s]", err)
                return err
        }</span>

        // init backend
        <span class="cov3" title="2">if err := t.backendInit(backendConf); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("clusterTable backend init err [%s]", err)
                return err
        }</span>

        <span class="cov3" title="2">log.Logger.Info("init bal table success")
        return nil</span>
}

// initialize gslb
func (t *BalTable) gslbInit(gslbConfs gslb_conf.GslbConf) error <span class="cov5" title="4">{
        fails := make([]string, 0)

        for clusterName, gslbConf := range (*gslbConfs.Clusters) </span><span class="cov9" title="13">{
        bal := bal_gslb.NewBalanceGslb(clusterName)
                err := bal.Init(gslbConf)
                if err != nil </span><span class="cov1" title="1">{
                        log.Logger.Error("BalTable.gslbInit():err[%s] in bal_gslb.GslbInit() for %s",
                                err.Error(), clusterName)
                        fails = append(fails, clusterName)
                        continue</span>
                }
        <span class="cov9" title="12">t.balTable[clusterName] = bal</span>
        }

        // update versions
        <span class="cov5" title="4">t.versions.GslbConfTimeStamp = *gslbConfs.Ts
        t.versions.GslbConfSrc = *gslbConfs.Hostname

        if len(fails) == 0 </span><span class="cov4" title="3">{
                return nil
        }</span> <span class="cov1" title="1">else {
                return fmt.Errorf("error in ClusterTable.gslbInit() for [%s]",
                        strings.Join(fails, ","))
        }</span>
}

func (t *BalTable) backendInit(backendConfs cluster_table_conf.ClusterTableConf) error <span class="cov5" title="4">{
        fails := make([]string, 0)

    for clusterName, bal := range t.balTable </span><span class="cov10" title="16">{
        // get gslbConf
        backendConf, ok := (*backendConfs.Config)[clusterName]
        if !ok </span><span class="cov4" title="3">{
            // external checking guarantee. should not come here in theory
            log.Logger.Error("BalTable.backendInit():no backend conf for %s", clusterName)
            fails = append(fails, clusterName)
            continue</span>
        }

        // initalize
                <span class="cov9" title="13">err := bal.BackendInit(backendConf)
                if err != nil </span><span class="cov0" title="0">{
                        log.Logger.Error("ClusterTable.backendInit():err[%s] in cluster.BackendInit() for %s",
                                err.Error(), clusterName)
                        fails = append(fails, clusterName)
                        continue</span>
                }
        }

        // update versions
        <span class="cov5" title="4">t.versions.ClusterTableConfVer = *backendConfs.Version

        if len(fails) == 0 </span><span class="cov4" title="3">{
                return nil
        }</span> <span class="cov1" title="1">else {
                return fmt.Errorf("error in ClusterTable.backendInit() for [%s]",
                        strings.Join(fails, ","))
        }</span>
}

func (t *BalTable) SetGslbRetry(clusterTable *bfe_data.ClusterTable) <span class="cov0" title="0">{
    if clusterTable == nil </span><span class="cov0" title="0">{
        return
    }</span>

    <span class="cov0" title="0">for clusterName, bal := range t.balTable </span><span class="cov0" title="0">{
        cluster, err := clusterTable.Lookup(clusterName)
        if err != nil </span><span class="cov0" title="0">{
            continue</span>
        }

        <span class="cov0" title="0">bal.SetGslbRetry(*cluster.GslbBasic)</span>
    }
}

func (t *BalTable) BalTableReload(gslbConfs gslb_conf.GslbConf, 
                                  backendConfs cluster_table_conf.ClusterTableConf) error <span class="cov1" title="1">{
    t.lock.Lock()
    defer t.lock.Unlock()

    var fails []string
    bmNew := make(BalMap)
    for clusterName, gslbConf := range *gslbConfs.Clusters </span><span class="cov6" title="5">{
        bal, ok := t.balTable[clusterName]
        if !ok </span><span class="cov1" title="1">{
            // new one balance
            bal = bal_gslb.NewBalanceGslb(clusterName)
        }</span> <span class="cov5" title="4">else {
            delete(t.balTable, clusterName)
        }</span>

        // update balance
        <span class="cov6" title="5">if err := bal.Reload(gslbConf); err != nil </span><span class="cov0" title="0">{
            log.Logger.Error("BalTableReload():err[%s] in bal.Reload() for %s",
                              err.Error(), clusterName)
            fails = append(fails, clusterName)
        }</span>

        <span class="cov6" title="5">bmNew[clusterName] = bal</span>
    }

    // remove bal not in configure file
    <span class="cov1" title="1">for _, remainder := range t.balTable </span><span class="cov0" title="0">{
        remainder.Release()
    }</span>

    <span class="cov1" title="1">t.balTable = bmNew
    for clusterName, bal := range t.balTable </span><span class="cov6" title="5">{
        backendConf, ok1 := (*backendConfs.Config)[clusterName]
        if !ok1 </span><span class="cov0" title="0">{
            // nerver comes here
            log.Logger.Error("BalTableReload():no backend conf for %s", clusterName)
            fails = append(fails, clusterName)
            continue</span>
        }

        <span class="cov6" title="5">if err := bal.BackendReload(backendConf); err != nil </span><span class="cov0" title="0">{
            log.Logger.Error("BalTableReload():err[%s] in bal.BackendReload() for %s",
                              err.Error(), clusterName)
            fails = append(fails, clusterName)
        }</span>
    }

        // update versions
        <span class="cov1" title="1">t.versions.ClusterTableConfVer = *backendConfs.Version
    t.versions.GslbConfTimeStamp = *gslbConfs.Ts
        t.versions.GslbConfSrc = *gslbConfs.Hostname

        if len(fails) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span> <span class="cov0" title="0">else {
                return fmt.Errorf("error in BalTableReload() for [%s]", strings.Join(fails, ","))
        }</span>
}

// lookup bal without lock
func (t *BalTable) lookup(clusterName string) (*bal_gslb.BalanceGslb, error) <span class="cov0" title="0">{
    bal, ok := t.balTable[clusterName]
    if !ok </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("no bal found for %s", clusterName)
    }</span>
    <span class="cov0" title="0">return bal, nil</span>
}

func (t *BalTable) Lookup(clusterName string) (*bal_gslb.BalanceGslb, error) <span class="cov0" title="0">{
    t.lock.Lock()
    defer t.lock.Unlock()

    return t.lookup(clusterName)
}</span>

// create new BalTableState
func NewBalTableState() *BalTableState <span class="cov1" title="1">{
    state := new(BalTableState)
    state.Balancers = make(map[string] *bal_gslb.GslbState)

        return state
}</span>

// get state
func (t *BalTable) GetState() *BalTableState <span class="cov1" title="1">{
    state := NewBalTableState()

    t.lock.Lock()
    defer t.lock.Unlock()

    // go through clusters
        for name, bal := range t.balTable </span><span class="cov6" title="5">{
                gs := bal_gslb.State(bal)
                state.Balancers[name] = gs
                state.BackendNum += gs.BackendNum
        }</span>

        <span class="cov1" title="1">return state</span>
}

// get versions
func (t *BalTable) GetVersions() BalVersion <span class="cov0" title="0">{
    return t.versions
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/* build.go - build condition by config ast */
/*
modification history
------------------
2015/3/5, weiwei
*/
/*
DESCRIPTION
*/

package condition

import (
        "fmt"
        "regexp"
        "strings"
)

import (
        "bfe_basic/condition/parser"
)

func Build(condStr string) (Condition, error) <span class="cov10" title="7">{
        node, identList, err := parser.Parse(condStr)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="6">if len(identList) != 0 </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("found unresolved variable %s %d", identList[0].Name, identList[0].Pos())
        }</span>

        <span class="cov7" title="4">return build(node)</span>
}

func build(node parser.Node) (Condition, error) <span class="cov7" title="4">{
        switch n := node.(type) </span>{
        <span class="cov7" title="4">case *parser.CallExpr:
                return buildPrimitive(n)</span>
        <span class="cov0" title="0">case *parser.UnaryExpr:
                return buildUnary(n)</span>
        <span class="cov0" title="0">case *parser.BinaryExpr:
                return buildBinary(n)</span>
        <span class="cov0" title="0">case *parser.ParenExpr:
                return build(n.X)</span>
        <span class="cov0" title="0">default:
                return nil, fmt.Errorf("unsupported node %s", node)</span>
        }
}

func buildUnary(node *parser.UnaryExpr) (Condition, error) <span class="cov0" title="0">{
        c, err := build(node.X)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;UnaryCond{op: node.Op, cond: c}, nil</span>

}

func buildBinary(node *parser.BinaryExpr) (Condition, error) <span class="cov0" title="0">{
        l, err := build(node.X)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">r, err := build(node.Y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;BinaryCond{op: node.Op, lc: l, rc: r}, nil</span>
}

// build primitive from PrimitiveCondExpr
// if failed, b.err is set to err, return Condition is nil
// if success, b.err is nil
func buildPrimitive(node *parser.CallExpr) (Condition, error) <span class="cov7" title="4">{
        switch node.Fun.Name </span>{
        <span class="cov1" title="1">case "default_t":
                return &amp;DefaultTrueCond{}, nil</span>
        <span class="cov0" title="0">case "req_cip_trusted":
                return &amp;TrustedCIpMatcher{}, nil</span>
        <span class="cov0" title="0">case "req_proto_match":
                return &amp;PrimitiveCond{
                        name:     node.Fun.Name,
                        fetcher: &amp;ProtoFetcher{},
                        matcher: NewExactMatcher(node.Args[0].Value, true),
                }, nil</span>
        <span class="cov0" title="0">case "req_host_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HostFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        <span class="cov6" title="3">case "req_path_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_path_prefix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewPrefixInMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_path_suffix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewSuffixInMatcher(node.Args[0].Value, node.Args[1].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_path_regmatch":
                reg, err := regexp.Compile(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>
                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PathFetcher{},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        <span class="cov0" title="0">case "req_query_key_in":
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;QueryKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        <span class="cov0" title="0">case "req_query_key_prefix_in":
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;QueryKeyPrefixInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        <span class="cov0" title="0">case "req_query_value_in":
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;QueryValueFetcher{
                                key: node.Args[0].Value,
                        },
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_query_value_prefix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: NewPrefixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_query_value_suffix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;QueryValueFetcher{node.Args[0].Value},
                        matcher: NewSuffixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>

        <span class="cov0" title="0">case "req_cookie_key_in":
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;CookieKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        <span class="cov0" title="0">case "req_cookie_value_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_cookie_value_prefix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewPrefixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_cookie_value_suffix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;CookieValueFetcher{node.Args[0].Value},
                        matcher: NewSuffixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_port_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;PortFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        <span class="cov0" title="0">case "req_tag_match":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;TagFetcher{key: node.Args[0].Value},
                        matcher: &amp;HasTagMatcher{value: node.Args[1].Value},
                }, nil</span>
        <span class="cov0" title="0">case "req_ua_regmatch":
                reg, err := regexp.Compile(node.Args[0].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("compile regexp err %s", err)
                }</span>

                <span class="cov0" title="0">return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;UAFetcher{},
                        matcher: NewRegMatcher(reg),
                }, nil</span>
        <span class="cov0" title="0">case "req_header_key_in":
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;HeaderKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        <span class="cov0" title="0">case "req_header_value_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_header_value_prefix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewPrefixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_header_value_suffix_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;HeaderValueFetcher{node.Args[0].Value},
                        matcher: NewSuffixInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>
        <span class="cov0" title="0">case "req_method_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;MethodFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        <span class="cov0" title="0">case "res_code_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;ResCodeFetcher{},
                        matcher: NewInMatcher(node.Args[0].Value, false),
                }, nil</span>
        <span class="cov0" title="0">case "res_header_key_in":
                return &amp;PrimitiveCond{
                        name: node.Fun.Name,
                        node: node,
                        fetcher: &amp;ResHeaderKeyInFetcher{
                                keys: strings.Split(node.Args[0].Value, "|"),
                        },
                        matcher: &amp;BypassMatcher{},
                }, nil</span>
        <span class="cov0" title="0">case "res_header_value_in":
                return &amp;PrimitiveCond{
                        name:    node.Fun.Name,
                        node:    node,
                        fetcher: &amp;ResHeaderValueFetcher{node.Args[0].Value},
                        matcher: NewInMatcher(node.Args[1].Value, node.Args[2].ToBool()),
                }, nil</span>

        <span class="cov0" title="0">default:
                return nil, fmt.Errorf("unsupported primitive %s", node.Fun.Name)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/* composite.go - composite condition implementation */
/*
modification history
------------------
2015/3/5, weiwei
*/
/*
DESCRIPTION
*/

package condition

import (
        "bfe_basic"
        "bfe_basic/condition/parser"
)

// unary condition for !cond
type UnaryCond struct {
        op   parser.Token
        cond Condition
}

func (uc *UnaryCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        switch uc.op </span>{
        <span class="cov0" title="0">case parser.NOT:
                return !uc.cond.Match(req)</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}

// binary condition for lc&amp;&amp;rc , lc||rc
type BinaryCond struct {
        op parser.Token
        lc Condition
        rc Condition
}

func (bc *BinaryCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        switch bc.op </span>{
        <span class="cov0" title="0">case parser.LAND:
                return bc.lc.Match(req) &amp;&amp; bc.rc.Match(req)</span>
        <span class="cov0" title="0">case parser.LOR:
                return bc.lc.Match(req) || bc.rc.Match(req)</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/* ast.go - ast node for condition expression */
/*
modification history
------------------
2015/4/9, weiwei
*/
/*
DESCRIPTION
*/

package parser

import (
        "bytes"
        "go/token"
        "strconv"
        "strings"
)

type Node interface {
        Pos() token.Pos
        End() token.Pos
}

type Expr interface {
        Node
        //    exprNode()
}

type BinaryExpr struct {
        X  Expr
        Op Token
        Y  Expr
}

type UnaryExpr struct {
        X     Expr
        Op    Token
        OpPos token.Pos
}

type Ident struct {
        Name    string
        NamePos token.Pos
}

type BasicLit struct {
        Kind     Token
        Value    string
        ValuePos token.Pos
}

type CallExpr struct {
        Fun    *Ident
        Args   BasicLitList
        Rparen token.Pos
}

type ParenExpr struct {
        X Expr
}

func (c CallExpr) String() string <span class="cov0" title="0">{
        var b bytes.Buffer

        b.WriteString(c.Fun.Name)
        b.WriteString("(")

        var strArgs []string
        for _, arg := range c.Args </span><span class="cov0" title="0">{
                if arg.Kind == STRING </span><span class="cov0" title="0">{
                        strArgs = append(strArgs, strconv.Quote(arg.Value))
                }</span> <span class="cov0" title="0">else {
                        strArgs = append(strArgs, arg.Value)
                }</span>
        }

        <span class="cov0" title="0">b.WriteString(strings.Join(strArgs, ","))
        b.WriteString(")")

        return b.String()</span>

}

type BasicLitList []*BasicLit

func (b *BinaryExpr) Pos() token.Pos <span class="cov0" title="0">{
        return b.X.Pos()
}</span>

func (b *BinaryExpr) End() token.Pos <span class="cov0" title="0">{
        return b.Y.End()
}</span>

func (u *UnaryExpr) Pos() token.Pos <span class="cov0" title="0">{
        return u.OpPos
}</span>

func (u *UnaryExpr) End() token.Pos <span class="cov0" title="0">{
        return u.X.End()
}</span>

func (id *Ident) Pos() token.Pos <span class="cov10" title="3">{
        return id.NamePos
}</span>

func (id *Ident) End() token.Pos <span class="cov0" title="0">{
        return token.Pos(int(id.NamePos) + len(id.Name))
}</span>

func (b *BasicLit) Pos() token.Pos <span class="cov0" title="0">{
        return b.ValuePos
}</span>

func (b *BasicLit) End() token.Pos <span class="cov0" title="0">{
        return token.Pos(int(b.ValuePos) + len(b.Value))
}</span>

func (c *CallExpr) Pos() token.Pos <span class="cov10" title="3">{
        return c.Fun.Pos()
}</span>

func (c *CallExpr) End() token.Pos <span class="cov0" title="0">{
        return c.Rparen
}</span>

func (b BasicLitList) Pos() token.Pos <span class="cov0" title="0">{
        return b[0].Pos()
}</span>

func (b BasicLitList) End() token.Pos <span class="cov0" title="0">{
        return b[len(b)].End()
}</span>

//TODO: not accurate
func (p ParenExpr) Pos() token.Pos <span class="cov0" title="0">{
        return p.X.Pos()
}</span>

func (p ParenExpr) End() token.Pos <span class="cov0" title="0">{
        return p.X.End()
}</span>

// calller should check its Kind
func (b *BasicLit) ToBool() bool <span class="cov0" title="0">{
        if b.Kind != BOOL </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(b.Value) </span>{
        <span class="cov0" title="0">case "TRUE":
                return true</span>
        <span class="cov0" title="0">case "FALSE":
                return false</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/* parse.go - parser for condition expression */
/*
modification history
------------------
2015/4/5, weiwei
*/
/*
DESCRIPTION
*/

package parser

import (
    "fmt"
    "go/token"
    "strings"
)

// callback for scanner and lexer if any error occurred
type ErrorHandler func(pos token.Pos, msg string)

type Parser struct {
    fset    *token.FileSet
    scanner Scanner
    lexer   *condLex

    identList []*Ident
    errors    []Error
    ast       Node
}

type Error struct {
    pos token.Position
    msg string
}

func (e Error) Error() string <span class="cov4" title="2">{
    return fmt.Sprintf("%s %s", e.pos, e.msg)
}</span>

func (p *Parser) Init(src []byte) <span class="cov10" title="6">{
    p.fset = token.NewFileSet()
    p.errors = p.errors[0:0]
    p.identList = p.identList[0:0]

    file := p.fset.AddFile("", p.fset.Base(), len(src))
    p.scanner.Init(file, src, p.addError)
    p.lexer = &amp;condLex{
        s:   &amp;p.scanner,
        err: p.addError,
    }
}</span>

func (p *Parser) addError(pos token.Pos, msg string) <span class="cov6" title="3">{
    p.errors = append(p.errors, Error{pos: p.fset.Position(pos), msg: msg})
}</span>

// return first error
func (p *Parser) Error() error <span class="cov10" title="6">{
    if len(p.errors) == 0 </span><span class="cov7" title="4">{
        return nil
    }</span>

    <span class="cov4" title="2">return p.errors[0]</span>
}

func (p *Parser) Parse() <span class="cov10" title="6">{
    condParse(p.lexer)
    p.ast = parseNode

    if len(p.errors) &gt; 0 </span><span class="cov0" title="0">{
        return
    }</span>

    // colllect all variables
    <span class="cov10" title="6">Inspect(p.ast, p.collectVariable)

    // static check for all call expr
    Inspect(p.ast, p.primitiveCheck)</span>
}

// string representation of parsed variables and errors
func (p Parser) String() string <span class="cov0" title="0">{
    var variables []string

    for _, ident := range p.identList </span><span class="cov0" title="0">{
        variables = append(variables, ident.Name)
    }</span>

    <span class="cov0" title="0">var errors []string

    for _, err := range p.errors </span><span class="cov0" title="0">{
        errors = append(errors, err.Error())
    }</span>

    <span class="cov0" title="0">return "names: " + strings.Join(variables, ",") + "\terrors: " + strings.Join(errors, ",")</span>
}

// provided interface
// condStr: input condition expression
// err : err is not nil if parse error(including scan, lexer, prototype check)
// idents: if err is nil, all conditionVariable is list in idents ([]*Ident)
// node: if err is nil, parsed ast is returned by node
func Parse(condStr string) (Node, []*Ident, error) <span class="cov10" title="6">{
    var p Parser

    p.Init([]byte(condStr))
    p.Parse()

    if err := p.Error(); err != nil </span><span class="cov4" title="2">{
        return nil, nil, err
    }</span>

    <span class="cov7" title="4">return p.ast, p.identList, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/* scanner.go - scanner for condition expression */
/*
modification history
------------------
2015/4/9, weiwei
*/
/*
DESCRIPTION
*/
package parser

import (
        "fmt"
        "go/token"
        "path/filepath"
        "unicode"
        "unicode/utf8"
)

type Scanner struct {
        file *token.File
        dir  string
        src  []byte
        err  ErrorHandler // error reporting; or nil

        ch         rune
        offset     int
        rdOffset   int
        lineOffset int

        ErrorCount int
}

const bom = 0xFEFF // byte order mark, only permitted as very first character

// Init prepares the scanner s to tokenize the text src by setting the
// scanner at the beginning of src. The scanner uses the file set file
// for position information and it adds line information for each line.
// It is ok to re-use the same file when re-scanning the same file as
// line information which is already present is ignored. Init causes a
// panic if the file size does not match the src size.
//
// Calls to Scan will invoke the error handler err if they encounter a
// syntax error and err is not nil. Also, for each error encountered,
// the Scanner field ErrorCount is incremented by one. The mode parameter
// determines how comments are handled.
//
// Note that Init may call err if there is an error in the first character
// of the file.
//
func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler) <span class="cov3" title="6">{
        // Explicitly initialize all fields since a scanner may be reused.
        if file.Size() != len(src) </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("file size (%d) does not match src len (%d)", file.Size(), len(src)))
        }</span>
        <span class="cov3" title="6">s.file = file
        s.dir, _ = filepath.Split(file.Name())
        s.src = src
        s.err = err

        s.ch = ' '
        s.offset = 0
        s.rdOffset = 0
        s.lineOffset = 0
        s.ErrorCount = 0

        s.next()
        if s.ch == bom </span><span class="cov0" title="0">{
                s.next() // ignore BOM at file beginning
        }</span>
}

func (s *Scanner) error(offs int, msg string) <span class="cov0" title="0">{
        if s.err != nil </span><span class="cov0" title="0">{
                s.err(s.file.Pos(offs), msg)
        }</span>
        <span class="cov0" title="0">s.ErrorCount++</span>
}

func (s *Scanner) next() <span class="cov10" title="691">{
        if s.rdOffset &lt; len(s.src) </span><span class="cov9" title="679">{
                s.offset = s.rdOffset
                if s.ch == '\n' </span><span class="cov0" title="0">{
                        s.lineOffset = s.offset
                        s.file.AddLine(s.offset)
                }</span>
                <span class="cov9" title="679">r, w := rune(s.src[s.rdOffset]), 1
                switch </span>{
                <span class="cov0" title="0">case r == 0:
                        s.error(s.offset, "illegal character NUL")</span>
                <span class="cov0" title="0">case r &gt;= 0x80:
                        r, w = utf8.DecodeRune(s.src[s.rdOffset:])
                        if r == utf8.RuneError &amp;&amp; w == 1 </span><span class="cov0" title="0">{
                                s.error(s.offset, "illegal UTF-8 encoding")
                        }</span> <span class="cov0" title="0">else if r == bom &amp;&amp; s.offset &gt; 0 </span><span class="cov0" title="0">{
                                s.error(s.offset, "illegal byte order mark")
                        }</span>
                }
                <span class="cov9" title="679">s.rdOffset += w
                s.ch = r</span>
        } <span class="cov4" title="12">else {
                s.offset = len(s.src)
                if s.ch == '\n' </span><span class="cov0" title="0">{
                        s.lineOffset = s.offset
                        s.file.AddLine(s.offset)
                }</span>
                <span class="cov4" title="12">s.ch = -1</span>
        }
}

func (s *Scanner) skipWhitespace() <span class="cov7" title="130">{
        for s.ch == ' ' || s.ch == '\t' || s.ch == '\r' || s.ch == '\n' </span><span class="cov5" title="36">{
                s.next()
        }</span>
}

func isLetter(ch rune) bool <span class="cov9" title="460">{
        return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' || ch == '_' || ch == '-' || ch &gt;= 0x80 &amp;&amp; unicode.IsLetter(ch)
}</span>

func isDigit(ch rune) bool <span class="cov5" title="36">{
        return '0' &lt;= ch &amp;&amp; ch &lt;= '9' || ch &gt;= 0x80 &amp;&amp; unicode.IsDigit(ch)
}</span>

func (s *Scanner) scanIdentifier() string <span class="cov5" title="36">{
        offs := s.offset
        for isLetter(s.ch) || isDigit(s.ch) </span><span class="cov8" title="294">{
                s.next()
        }</span>
        <span class="cov5" title="36">return string(s.src[offs:s.offset])</span>
}

func stripCR(b []byte) []byte <span class="cov0" title="0">{
        c := make([]byte, len(b))
        i := 0
        for _, ch := range b </span><span class="cov0" title="0">{
                if ch != '\r' </span><span class="cov0" title="0">{
                        c[i] = ch
                        i++
                }</span>
        }
        <span class="cov0" title="0">return c[:i]</span>
}

func (s *Scanner) scanString() string <span class="cov4" title="18">{
        // '"' opening already consumed
        offs := s.offset - 1

        for </span><span class="cov8" title="242">{
                ch := s.ch
                if ch == '\n' || ch &lt; 0 </span><span class="cov0" title="0">{
                        s.error(offs, "string literal not terminated")
                        break</span>
                }
                <span class="cov8" title="242">s.next()
                if ch == '"' </span><span class="cov4" title="18">{
                        break</span>
                }
                <span class="cov8" title="224">if ch == '\\' </span><span class="cov0" title="0">{
                        s.scanEscape('"')
                }</span>
        }

        <span class="cov4" title="18">return string(s.src[offs+1 : s.offset-1])</span>
}

// scanEscape parses an escape sequence where rune is the accepted
// escaped quote. In case of a syntax error, it stops at the offending
// character (without consuming it) and returns false. Otherwise
// it returns true.
func (s *Scanner) scanEscape(quote rune) bool <span class="cov0" title="0">{
        offs := s.offset

        var n int
        var base, max uint32
        switch s.ch </span>{
        <span class="cov0" title="0">case 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', quote:
                s.next()
                return true</span>
        <span class="cov0" title="0">case '0', '1', '2', '3', '4', '5', '6', '7':
                n, base, max = 3, 8, 255</span>
        <span class="cov0" title="0">case 'x':
                s.next()
                n, base, max = 2, 16, 255</span>
        <span class="cov0" title="0">case 'u':
                s.next()
                n, base, max = 4, 16, unicode.MaxRune</span>
        <span class="cov0" title="0">case 'U':
                s.next()
                n, base, max = 8, 16, unicode.MaxRune</span>
        <span class="cov0" title="0">default:
                msg := "unknown escape sequence"
                if s.ch &lt; 0 </span><span class="cov0" title="0">{
                        msg = "escape sequence not terminated"
                }</span>
                <span class="cov0" title="0">s.error(offs, msg)
                return false</span>
        }

        <span class="cov0" title="0">var x uint32
        for n &gt; 0 </span><span class="cov0" title="0">{
                d := uint32(digitVal(s.ch))
                if d &gt;= base </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("illegal character %#U in escape sequence", s.ch)
                        if s.ch &lt; 0 </span><span class="cov0" title="0">{
                                msg = "escape sequence not terminated"
                        }</span>
                        <span class="cov0" title="0">s.error(s.offset, msg)
                        return false</span>
                }
                <span class="cov0" title="0">x = x*base + d
                s.next()
                n--</span>
        }

        <span class="cov0" title="0">if x &gt; max || 0xD800 &lt;= x &amp;&amp; x &lt; 0xE000 </span><span class="cov0" title="0">{
                s.error(offs, "escape sequence is invalid Unicode code point")
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func digitVal(ch rune) int <span class="cov0" title="0">{
        switch </span>{
        <span class="cov0" title="0">case '0' &lt;= ch &amp;&amp; ch &lt;= '9':
                return int(ch - '0')</span>
        <span class="cov0" title="0">case 'a' &lt;= ch &amp;&amp; ch &lt;= 'f':
                return int(ch - 'a' + 10)</span>
        <span class="cov0" title="0">case 'A' &lt;= ch &amp;&amp; ch &lt;= 'F':
                return int(ch - 'A' + 10)</span>
        }
        <span class="cov0" title="0">return 16</span> // larger than any legal digit val
}

func (s *Scanner) scanRawString() string <span class="cov0" title="0">{
        // '`' opening already consumed
        offs := s.offset - 1

        hasCR := false
        for </span><span class="cov0" title="0">{
                ch := s.ch
                if ch &lt; 0 </span><span class="cov0" title="0">{
                        s.error(offs, "raw string literal not terminated")
                        break</span>
                }
                <span class="cov0" title="0">s.next()
                if ch == '`' </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if ch == '\r' </span><span class="cov0" title="0">{
                        hasCR = true
                }</span>
        }

        <span class="cov0" title="0">lit := s.src[offs:s.offset]
        if hasCR </span><span class="cov0" title="0">{
                lit = stripCR(lit)
        }</span>

        <span class="cov0" title="0">return string(lit)</span>
}

func (s *Scanner) scanComment() string <span class="cov0" title="0">{
        offs := s.offset - 1
        hasCR := false

        s.next()
        for s.ch != '\n' &amp;&amp; s.ch &gt;= 0 </span><span class="cov0" title="0">{
                if s.ch == '\r' </span><span class="cov0" title="0">{
                        hasCR = true
                }</span>
                <span class="cov0" title="0">s.next()</span>
        }

        <span class="cov0" title="0">lit := s.src[offs:s.offset]
        if hasCR </span><span class="cov0" title="0">{
                lit = stripCR(lit)
        }</span>

        <span class="cov0" title="0">return string(lit)</span>
}

func (s *Scanner) scanMantissa(base int) <span class="cov0" title="0">{
        for digitVal(s.ch) &lt; base </span><span class="cov0" title="0">{
                s.next()
        }</span>
}

func (s *Scanner) scanNumber(seenDecimalPoint bool) (Token, string) <span class="cov0" title="0">{
        // digitVal(s.ch) &lt; 10
        offs := s.offset
        tok := INT

        if seenDecimalPoint </span><span class="cov0" title="0">{
                offs--
                tok = FLOAT
                s.scanMantissa(10)
                goto exponent</span>
        }

        <span class="cov0" title="0">if s.ch == '0' </span><span class="cov0" title="0">{
                // int or float
                offs := s.offset
                s.next()
                if s.ch == 'x' || s.ch == 'X' </span><span class="cov0" title="0">{
                        // hexadecimal int
                        s.next()
                        s.scanMantissa(16)
                        if s.offset-offs &lt;= 2 </span><span class="cov0" title="0">{
                                // only scanned "0x" or "0X"
                                s.error(offs, "illegal hexadecimal number")
                        }</span>
                } <span class="cov0" title="0">else {
                        // octal int or float
                        seenDecimalDigit := false
                        s.scanMantissa(8)
                        if s.ch == '8' || s.ch == '9' </span><span class="cov0" title="0">{
                                // illegal octal int or float
                                seenDecimalDigit = true
                                s.scanMantissa(10)
                        }</span>
                        <span class="cov0" title="0">if s.ch == '.' || s.ch == 'e' || s.ch == 'E' || s.ch == 'i' </span><span class="cov0" title="0">{
                                goto fraction</span>
                        }
                        // octal int
                        <span class="cov0" title="0">if seenDecimalDigit </span><span class="cov0" title="0">{
                                s.error(offs, "illegal octal number")
                        }</span>
                }
                <span class="cov0" title="0">goto exit</span>
        }

        // decimal int or float
        <span class="cov0" title="0">s.scanMantissa(10)

fraction:
        if s.ch == '.' </span><span class="cov0" title="0">{
                tok = FLOAT
                s.next()
                s.scanMantissa(10)
        }</span>

<span class="cov0" title="0">exponent:
        if s.ch == 'e' || s.ch == 'E' </span><span class="cov0" title="0">{
                tok = FLOAT
                s.next()
                if s.ch == '-' || s.ch == '+' </span><span class="cov0" title="0">{
                        s.next()
                }</span>
                <span class="cov0" title="0">s.scanMantissa(10)</span>
        }

        <span class="cov0" title="0">if s.ch == 'i' </span><span class="cov0" title="0">{
                tok = IMAG
                s.next()
        }</span>

<span class="cov0" title="0">exit:
        return Token(tok), string(s.src[offs:s.offset])</span>
}

func (s *Scanner) Scan() (pos token.Pos, tok Token, lit string) <span class="cov7" title="130">{
scanAgain:
        s.skipWhitespace()

        // current token start
        pos = s.file.Pos(s.offset)

        // determine token value
        switch ch := s.ch; </span>{
        <span class="cov5" title="36">case isLetter(ch):
                lit = s.scanIdentifier()
                if len(lit) &gt; 1 </span><span class="cov5" title="26">{
                        // keywords are longer than one letter - avoid lookup otherwise
                        tok = Lookup(lit)
                        if tok != IDENT </span><span class="cov0" title="0">{
                                // go keyword can't be used
                                tok = ILLEGAL
                                s.error(s.offset, "keyword can't be used")
                        }</span>
                        <span class="cov5" title="26">if lit == "true" || lit == "false" </span><span class="cov4" title="11">{
                                tok = BOOL
                        }</span>

                } <span class="cov4" title="10">else {
                        tok = IDENT
                }</span>
        <span class="cov0" title="0">case '0' &lt;= ch &amp;&amp; ch &lt;= '9':
                tok, lit = s.scanNumber(false)</span>
        <span class="cov7" title="94">default:
                s.next() // always make progress
                switch ch </span>{
                <span class="cov3" title="6">case -1:
                        tok = EOF</span>
                <span class="cov0" title="0">case ';':
                        tok = SEMICOLON
                        lit = ";"</span>
                <span class="cov4" title="18">case '"':
                        tok = STRING
                        lit = s.scanString()</span>
                <span class="cov0" title="0">case '`':
                        tok = STRING
                        lit = s.scanRawString()</span>
                <span class="cov4" title="16">case '(':
                        tok = LPAREN
                        lit = "("</span>
                <span class="cov4" title="16">case ')':
                        tok = RPAREN
                        lit = ")"</span>
                <span class="cov3" title="5">case '!':
                        tok = NOT
                        lit = "!"</span>
                <span class="cov4" title="14">case ',':
                        tok = COMMA
                        lit = ","</span>
                <span class="cov4" title="18">case '&amp;':
                        if s.ch == '&amp;' </span><span class="cov4" title="18">{
                                s.next()
                                tok = LAND
                                lit = "&amp;&amp;"
                        }</span> <span class="cov0" title="0">else {
                                tok = ILLEGAL
                                lit = string(ch)
                        }</span>
                <span class="cov1" title="1">case '|':
                        if s.ch == '|' </span><span class="cov1" title="1">{
                                s.next()
                                tok = LOR
                                lit = "||"
                        }</span> <span class="cov0" title="0">else {
                                tok = ILLEGAL
                                lit = string(ch)
                        }</span>
                <span class="cov0" title="0">case '/':
                        if s.ch == '/' </span><span class="cov0" title="0">{
                                tok = COMMENT
                                lit = s.scanComment()
                                goto scanAgain</span>
                        } <span class="cov0" title="0">else {
                                tok = ILLEGAL
                                lit = string(ch)
                        }</span>
                <span class="cov0" title="0">default:
                        tok = ILLEGAL
                        lit = string(ch)</span>
                }
        }

        <span class="cov7" title="130">return</span>
}

/*
func main() {
    var s Scanner
    src := "test = abc(\"xxx\", true ) &amp;&amp; got // xxxxxxxx\n //xxxxxx"
    fset := token.NewFileSet()
    f := fset.AddFile("", fset.Base(), len(src))
    s.Init(f, []byte(src), func(pos token.Position, msg string) { fmt.Printf("%s %s", pos, msg) })

    pos, tok, lit := s.Scan()
    for tok != EOF {
        fmt.Println(pos, lit)
        fmt.Printf("pos: %s\n", fset.Position(pos))
        pos, tok, lit = s.Scan()

    }
}*/
</pre>
		
		<pre class="file" id="file13" style="display: none">/* scanner.go - semant check for condition expression */
/*
modification history
------------------
2015/4/9, weiwei
*/
/*
DESCRIPTION
*/

package parser

import (
        "fmt"
        "log"
)

// func name -&gt; args types
var funcProtos = map[string][]Token{
        "default_t":                  nil,
        "req_cip_trusted":            nil,
        "req_proto_match":            []Token{STRING},
        "req_host_in":                []Token{STRING},
        "req_path_in":                []Token{STRING, BOOL},
        "req_path_prefix_in":         []Token{STRING, BOOL},
        "req_path_suffix_in":         []Token{STRING, BOOL},
        "req_path_regmatch":          []Token{STRING},
        "req_query_key_prefix_in":    []Token{STRING},
        "req_query_key_in":           []Token{STRING},
        "req_query_value_in":         []Token{STRING, STRING, BOOL},
        "req_query_value_prefix_in":  []Token{STRING, STRING, BOOL},
        "req_query_value_suffix_in":  []Token{STRING, STRING, BOOL},
        "req_cookie_key_in":          []Token{STRING},
        "req_cookie_value_in":        []Token{STRING, STRING, BOOL},
        "req_cookie_value_prefix_in": []Token{STRING, STRING, BOOL},
        "req_cookie_value_suffix_in": []Token{STRING, STRING, BOOL},
        "req_port_in":                []Token{STRING},
        "req_tag_match":              []Token{STRING, STRING},
        "req_ua_regmatch":            []Token{STRING},
        "req_header_key_in":          []Token{STRING},
        "req_header_value_in":        []Token{STRING, STRING, BOOL},
        "req_header_value_prefix_in": []Token{STRING, STRING, BOOL},
        "req_header_value_suffix_in": []Token{STRING, STRING, BOOL},
        "req_method_in":              []Token{STRING},
        "res_code_in":                []Token{STRING},
        "res_header_key_in":          []Token{STRING},
        "res_header_value_in":        []Token{STRING, STRING, BOOL},
}

func prototypeCheck(expr *CallExpr) error <span class="cov7" title="15">{
        // log.Printf("start prototype Check")
        argsType, ok := funcProtos[expr.Fun.Name]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("primitive %s not found", expr.Fun.Name)
        }</span>

        <span class="cov7" title="15">if len(argsType) != len(expr.Args) </span><span class="cov1" title="1">{
                return fmt.Errorf("primitive args len error, expect %v, got %v", len(argsType), len(expr.Args))
        }</span>

        <span class="cov7" title="14">for i, argType := range argsType </span><span class="cov8" title="27">{
                if argType != expr.Args[i].Kind </span><span class="cov2" title="2">{
                        return fmt.Errorf("primitive %s arg %d expect %s, got %s",
                                expr.Fun.Name, i, argType, expr.Args[i].Kind)
                }</span>
        }

        <span class="cov6" title="12">return nil</span>
}

// traverse function to check all func call prototype
// check: 1. func name 2. func args len and type
func (p *Parser) primitiveCheck(n Node) bool <span class="cov10" title="50">{
        switch x := n.(type) </span>{
        <span class="cov8" title="25">case *BinaryExpr, *UnaryExpr, *ParenExpr:
                return true</span>
        <span class="cov6" title="10">case *Ident:
                return false</span>
        <span class="cov7" title="15">case *CallExpr:
                if err := prototypeCheck(x); err != nil </span><span class="cov3" title="3">{
                        p.addError(x.Pos(), err.Error())
                }</span>
                <span class="cov7" title="15">return false</span>
        <span class="cov0" title="0">default:
                log.Printf("get a node %s", n)</span>
        }

        <span class="cov0" title="0">return false</span>
}

// traverse function to collect all variables(Ident) from nodeTree
func (p *Parser) collectVariable(n Node) bool <span class="cov10" title="50">{
        switch x := n.(type) </span>{
        <span class="cov8" title="25">case *BinaryExpr, *UnaryExpr, *ParenExpr:
                return true</span>
        <span class="cov6" title="10">case *Ident:
                exist := false
                for _, i := range p.identList </span><span class="cov4" title="5">{
                        if i.Name == x.Name </span><span class="cov2" title="2">{
                                exist = true
                        }</span>
                }

                <span class="cov6" title="10">if !exist </span><span class="cov5" title="8">{
                        p.identList = append(p.identList, x)
                }</span>
        <span class="cov7" title="15">case *CallExpr:
                return false</span>
        <span class="cov0" title="0">default:
                return false</span>
        }

        <span class="cov6" title="10">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/* token.go - token utility for condition expression */
/*
modification history
------------------
2015/4/9, weiwei
*/
/*
DESCRIPTION
*/

package parser

type Token int

var keywords = []string{
        "break",
        "case",
        "chan",
        "const",
        "continue",

        "default",
        "defer",
        "else",
        "fallthrough",
        "for",

        "func",
        "go",
        "goto",
        "if",
        "import",

        "interface",
        "map",
        "package",
        "range",
        "return",

        "select",
        "struct",
        "switch",
        "type",
        "var",
}

var tokens = map[Token]string{
        IDENT:     "IDENT",
        LAND:      "LAND",
        LOR:       "LOR",
        LPAREN:    "LPAREN",
        RPAREN:    "RPAREN",
        NOT:       "NOT",
        SEMICOLON: "SEMICOLON",
        BASICLIT:  "BASICLIT",
        COMMA:     "COMMA",
        BOOL:      "BOOL",
        STRING:    "STRING",
        INT:       "INT",
        FLOAT:     "FLOAT",
        IMAG:      "IMAG",
        COMMENT:   "COMMENT",
        ILLEGAL:   "ILLEGAL",
        EOF:       "EOF",
}

var symbols = map[Token]string{
        IDENT:     "",
        LAND:      "&amp;&amp;",
        LOR:       "||",
        LPAREN:    "(",
        RPAREN:    ")",
        NOT:       "!",
        SEMICOLON: ";",
        BASICLIT:  "BASICLIT",
        COMMA:     ",",
        BOOL:      "BOOL",
        STRING:    "STRING",
        INT:       "INT",
        FLOAT:     "FLOAT",
        IMAG:      "IMAG",
        COMMENT:   "//",
        ILLEGAL:   "ILLEGAL",
        EOF:       "EOF",
}

func (t Token) Symbol() string <span class="cov0" title="0">{
        return symbols[t]
}</span>

func (t Token) String() string <span class="cov2" title="4">{
        return tokens[t]
}</span>

func Lookup(ident string) Token <span class="cov5" title="26">{
        for _, keyword := range keywords </span><span class="cov10" title="650">{
                if ident == keyword </span><span class="cov0" title="0">{
                        // reserved
                        return ILLEGAL
                }</span>
        }
        <span class="cov5" title="26">return IDENT</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/* walk.go - visitor over ast nodes */
/*
modification history
------------------
2015/4/9, weiwei
*/
/*
DESCRIPTION
*/
package parser

// A Visitor's Visit method is invoked for each node encountered by Walk.
// If the result visitor w is not nil, Walk visits each of the children
// of node with the visitor w, followed by a call of w.Visit(nil).
type Visitor interface {
        Visit(node Node) (w Visitor)
}

func Walk(v Visitor, node Node) <span class="cov10" title="100">{
        if v = v.Visit(node); v == nil </span><span class="cov8" title="50">{
                return
        }</span>

        <span class="cov8" title="50">switch n := node.(type) </span>{
        <span class="cov8" title="38">case *BinaryExpr:
                // semant check for X,Y
                Walk(v, n.X)
                Walk(v, n.Y)</span>
        <span class="cov5" title="10">case *UnaryExpr:
                // semant check for X
                Walk(v, n.X)</span>
        <span class="cov0" title="0">case *Ident:</span>
                // do nothing
        <span class="cov0" title="0">case *CallExpr:
                Walk(v, n.Fun)
                Walk(v, n.Args)</span>
        <span class="cov2" title="2">case *ParenExpr:
                Walk(v, n.X)</span>
        }
}

type inspector func(Node) bool

func (f inspector) Visit(node Node) Visitor <span class="cov10" title="100">{
        if f(node) </span><span class="cov8" title="50">{
                return f
        }</span>
        <span class="cov8" title="50">return nil</span>
}

// Inspect traverses an AST in depth-first order: It starts by calling
// f(node); node must not be nil. If f returns true, Inspect invokes f
// for all the non-nil children of node, recursively.
//
func Inspect(node Node, f func(Node) bool) <span class="cov5" title="12">{
        Walk(inspector(f), node)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">//line cond.y:7
package parser

import __yyfmt__ "fmt"

//line cond.y:8
import (
        "fmt"
        "go/token"
)

//line cond.y:17
type condSymType struct {
        yys  int
        Node Node
        str  string
}

const IDENT = 57346
const LAND = 57347
const LOR = 57348
const LPAREN = 57349
const RPAREN = 57350
const NOT = 57351
const SEMICOLON = 57352
const BASICLIT = 57353
const COMMA = 57354
const BOOL = 57355
const STRING = 57356
const INT = 57357
const FLOAT = 57358
const IMAG = 57359
const COMMENT = 57360
const ILLEGAL = 57361

var condToknames = []string{
        "IDENT",
        "LAND",
        "LOR",
        "LPAREN",
        "RPAREN",
        "NOT",
        "SEMICOLON",
        "BASICLIT",
        "COMMA",
        "BOOL",
        "STRING",
        "INT",
        "FLOAT",
        "IMAG",
        "COMMENT",
        "ILLEGAL",
}
var condStatenames = []string{}

const condEofCode = 1
const condErrCode = 2
const condMaxDepth = 200

//line cond.y:82

// The parser expects the lexer to return 0 on EOF.  Give it a name
// for clarity.
const EOF = 0

var (
        parseNode    Node // save parse node
        lastPos      token.Pos
        lastTokenPos token.Pos
)

// The parser uses the type &lt;prefix&gt;Lex as a lexer.  It must provide
// the methods Lex(*&lt;prefix&gt;SymType) int and Error(string).
type condLex struct {
        s   *Scanner
        err ErrorHandler
}

// The parser calls this method to get each new token.
func (x *condLex) Lex(yylval *condSymType) int {
        for {
                pos, tok, lit := x.s.Scan()

                lastPos = pos

                // fmt.Printf("got token %s %s\n", tok, lit)
                switch tok {
                case EOF:
                        return EOF
                case IDENT:
                        yylval.Node = &amp;Ident{Name: lit, NamePos: pos}
                        return IDENT
                case BOOL, STRING, INT:
                        yylval.Node = &amp;BasicLit{Kind: tok, Value: lit, ValuePos: pos}
                        return BASICLIT
                case LPAREN, RPAREN, LAND, LOR, SEMICOLON, COMMA, NOT:
                        lastTokenPos = pos
                        return int(tok)
                default:
                        x.Error(fmt.Sprintf("unrecognized token %d", tok))
                        return EOF
                }
        }
}

// The parser calls this method on a parse error.
func (x *condLex) Error(s string) {
        if x.err != nil {
                x.err(lastPos, s)
        }
}

//line yacctab:1
var condExca = []int{
        -1, 1,
        1, -1,
        -2, 0,
}

const condNprod = 12
const condPrivate = 57344

var condTokenNames []string
var condStates []string

const condLast = 23

var condAct = []int{

        18, 20, 16, 2, 19, 17, 11, 9, 10, 8,
        6, 12, 13, 3, 15, 4, 7, 8, 5, 14,
        7, 8, 1,
}
var condPact = []int{

        6, -1000, 15, 6, 6, -1000, -1, 6, 6, 11,
        -1000, -6, 3, -1000, -1000, -8, -1000, -1000, -1000, -10,
        -1000,
}
var condPgo = []int{

        0, 22, 3, 18, 14,
}
var condR1 = []int{

        0, 1, 2, 2, 2, 2, 2, 2, 3, 3,
        4, 4,
}
var condR2 = []int{

        0, 1, 3, 3, 3, 2, 1, 1, 4, 3,
        1, 3,
}
var condChk = []int{

        -1000, -1, -2, 7, 9, -3, 4, 5, 6, -2,
        -2, 7, -2, -2, 8, -4, 8, 11, 8, 12,
        11,
}
var condDef = []int{

        0, -2, 1, 0, 0, 6, 7, 0, 0, 0,
        5, 0, 3, 4, 2, 0, 9, 10, 8, 0,
        11,
}
var condTok1 = []int{

        1,
}
var condTok2 = []int{

        2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        12, 13, 14, 15, 16, 17, 18, 19,
}
var condTok3 = []int{
        0,
}

//line yaccpar:1

/*        parser for yacc output        */

var condDebug = 0

type condLexer interface {
        Lex(lval *condSymType) int
        Error(s string)
}

const condFlag = -1000

func condTokname(c int) string {
        // 4 is TOKSTART above
        if c &gt;= 4 &amp;&amp; c-4 &lt; len(condToknames) {
                if condToknames[c-4] != "" {
                        return condToknames[c-4]
                }
        }
        return __yyfmt__.Sprintf("tok-%v", c)
}

func condStatname(s int) string {
        if s &gt;= 0 &amp;&amp; s &lt; len(condStatenames) {
                if condStatenames[s] != "" {
                        return condStatenames[s]
                }
        }
        return __yyfmt__.Sprintf("state-%v", s)
}

func condlex1(lex condLexer, lval *condSymType) int {
        c := 0
        char := lex.Lex(lval)
        if char &lt;= 0 {
                c = condTok1[0]
                goto out
        }
        if char &lt; len(condTok1) {
                c = condTok1[char]
                goto out
        }
        if char &gt;= condPrivate {
                if char &lt; condPrivate+len(condTok2) {
                        c = condTok2[char-condPrivate]
                        goto out
                }
        }
        for i := 0; i &lt; len(condTok3); i += 2 {
                c = condTok3[i+0]
                if c == char {
                        c = condTok3[i+1]
                        goto out
                }
        }

out:
        if c == 0 {
                c = condTok2[1] /* unknown char */
        }
        if condDebug &gt;= 3 {
                __yyfmt__.Printf("lex %s(%d)\n", condTokname(c), uint(char))
        }
        return c
}

func condParse(condlex condLexer) int {
        var condn int
        var condlval condSymType
        var condVAL condSymType
        condS := make([]condSymType, condMaxDepth)

        Nerrs := 0   /* number of errors */
        Errflag := 0 /* error recovery flag */
        condstate := 0
        condchar := -1
        condp := -1
        goto condstack

ret0:
        return 0

ret1:
        return 1

condstack:
        /* put a state and value onto the stack */
        if condDebug &gt;= 4 {
                __yyfmt__.Printf("char %v in %v\n", condTokname(condchar), condStatname(condstate))
        }

        condp++
        if condp &gt;= len(condS) {
                nyys := make([]condSymType, len(condS)*2)
                copy(nyys, condS)
                condS = nyys
        }
        condS[condp] = condVAL
        condS[condp].yys = condstate

condnewstate:
        condn = condPact[condstate]
        if condn &lt;= condFlag {
                goto conddefault /* simple state */
        }
        if condchar &lt; 0 {
                condchar = condlex1(condlex, &amp;condlval)
        }
        condn += condchar
        if condn &lt; 0 || condn &gt;= condLast {
                goto conddefault
        }
        condn = condAct[condn]
        if condChk[condn] == condchar { /* valid shift */
                condchar = -1
                condVAL = condlval
                condstate = condn
                if Errflag &gt; 0 {
                        Errflag--
                }
                goto condstack
        }

conddefault:
        /* default state action */
        condn = condDef[condstate]
        if condn == -2 {
                if condchar &lt; 0 {
                        condchar = condlex1(condlex, &amp;condlval)
                }

                /* look through exception table */
                xi := 0
                for {
                        if condExca[xi+0] == -1 &amp;&amp; condExca[xi+1] == condstate {
                                break
                        }
                        xi += 2
                }
                for xi += 2; ; xi += 2 {
                        condn = condExca[xi+0]
                        if condn &lt; 0 || condn == condchar {
                                break
                        }
                }
                condn = condExca[xi+1]
                if condn &lt; 0 {
                        goto ret0
                }
        }
        if condn == 0 {
                /* error ... attempt to resume parsing */
                switch Errflag {
                case 0: /* brand new error */
                        condlex.Error(fmt.Sprintf("syntax error: %s saw %s", condStatname(condstate), condTokname(condchar)))
                        Nerrs++
                        if condDebug &gt;= 1 {
                                __yyfmt__.Printf("%s", condStatname(condstate))
                                __yyfmt__.Printf(" saw %s\n", condTokname(condchar))
                        }
                        fallthrough

                case 1, 2: /* incompletely recovered error ... try again */
                        Errflag = 3

                        /* find a state where "error" is a legal shift action */
                        for condp &gt;= 0 {
                                condn = condPact[condS[condp].yys] + condErrCode
                                if condn &gt;= 0 &amp;&amp; condn &lt; condLast {
                                        condstate = condAct[condn] /* simulate a shift of "error" */
                                        if condChk[condstate] == condErrCode {
                                                goto condstack
                                        }
                                }

                                /* the current p has no shift on "error", pop stack */
                                if condDebug &gt;= 2 {
                                        __yyfmt__.Printf("error recovery pops state %d\n", condS[condp].yys)
                                }
                                condp--
                        }
                        /* there is no state on the stack with an error shift ... abort */
                        goto ret1

                case 3: /* no shift yet; clobber input char */
                        if condDebug &gt;= 2 {
                                __yyfmt__.Printf("error recovery discards %s\n", condTokname(condchar))
                        }
                        if condchar == condEofCode {
                                goto ret1
                        }
                        condchar = -1
                        goto condnewstate /* try again in the same state */
                }
        }

        /* reduction by production condn */
        if condDebug &gt;= 2 {
                __yyfmt__.Printf("reduce %v in:\n\t%v\n", condn, condStatname(condstate))
        }

        condnt := condn
        condpt := condp
        _ = condpt // guard against "declared and not used"

        condp -= condR2[condn]
        condVAL = condS[condp+1]

        /* consult goto table to find next state */
        condn = condR1[condn]
        condg := condPgo[condn]
        condj := condg + condS[condp].yys + 1

        if condj &gt;= condLast {
                condstate = condAct[condg]
        } else {
                condstate = condAct[condj]
                if condChk[condstate] != -condn {
                        condstate = condAct[condg]
                }
        }
        // dummy call; replaced with literal code
        switch condnt {

        case 1:
                //line cond.y:31
                {
                        parseNode = condS[condpt-0].Node
                }
        case 2:
                //line cond.y:36
                {
                        condVAL.Node = &amp;ParenExpr{condS[condpt-1].Node.(Expr)}

                }
        case 3:
                //line cond.y:41
                {
                        condVAL.Node = &amp;BinaryExpr{condS[condpt-2].Node.(Expr), LAND, condS[condpt-0].Node.(Expr)}
                }
        case 4:
                //line cond.y:45
                {
                        condVAL.Node = &amp;BinaryExpr{condS[condpt-2].Node.(Expr), LOR, condS[condpt-0].Node.(Expr)}
                }
        case 5:
                //line cond.y:49
                {
                        condVAL.Node = &amp;UnaryExpr{condS[condpt-0].Node.(Expr), NOT, lastTokenPos}
                }
        case 6:
                //line cond.y:53
                {
                        condVAL.Node = condS[condpt-0].Node
                }
        case 7:
                //line cond.y:57
                {
                        condVAL.Node = condS[condpt-0].Node
                }
        case 8:
                //line cond.y:63
                {
                        condVAL.Node = &amp;CallExpr{condS[condpt-3].Node.(*Ident), condS[condpt-1].Node.(BasicLitList), lastPos}
                }
        case 9:
                //line cond.y:67
                {
                        condVAL.Node = &amp;CallExpr{condS[condpt-2].Node.(*Ident), nil, lastPos}
                }
        case 10:
                //line cond.y:73
                {
                        condVAL.Node = BasicLitList{condS[condpt-0].Node.(*BasicLit)}
                }
        case 11:
                //line cond.y:77
                {
                        condVAL.Node = append(condS[condpt-2].Node.(BasicLitList), condS[condpt-0].Node.(*BasicLit))
                }
        }
        goto condstack /* stack new state and value */
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/* primitive.go - primitive condition implementation */
/*
modification history
------------------
2015/3/5, weiwei
2015/4/29, Xiong Zongtao, modify
    -add ProtoFetcher(get http|https from request) and ExactMatcher for exact match
*/
/*
DESCRIPTION
*/

package condition

import (
        "fmt"
        "regexp"
        "sort"
        "strings"
)

import (
        "bfe_basic"
        "bfe_basic/condition/parser"
)

type Fetcher interface {
        Fetch(req *bfe_basic.Request) (interface{}, error)
}

type Matcher interface {
        Match(interface{}) bool
}

// always return true
type DefaultTrueCond struct{}

func (dt DefaultTrueCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        return true
}</span>

type PrimitiveCond struct {
        name    string
        node    *parser.CallExpr
        fetcher Fetcher
        matcher Matcher
}

func (p *PrimitiveCond) String() string <span class="cov1" title="1">{
        return p.node.String()
}</span>

func (p *PrimitiveCond) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">fetched, err := p.fetcher.Fetch(req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">r := p.matcher.Match(fetched)
        return r</span>
}

type HostFetcher struct{}

func (hf *HostFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.Host, nil</span>
}

type ProtoFetcher struct{}

func (pf *ProtoFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
    if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("fetcher: nil pointer")
    }</span>

    <span class="cov0" title="0">proto := "http"
    if req.Session.IsHttps </span><span class="cov0" title="0">{
        proto = "https"
    }</span>

    <span class="cov0" title="0">return proto, nil</span>
}

type MethodFetcher struct{}

func (mf *MethodFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.Method, nil</span>
}

type PortFetcher struct{}

func (pf *PortFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">port := "80"
        i := strings.Index(req.HttpRequest.Host, ":")
        if i &gt; 0 </span><span class="cov0" title="0">{
                port = req.HttpRequest.Host[i+1:]
        }</span>

        <span class="cov0" title="0">return port, nil</span>
}

type TagFetcher struct {
        key string
}

func (tf *TagFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">switch tf.key </span>{
        <span class="cov0" title="0">case "IPTags":
                return req.Tags.IPTags, nil</span>
        <span class="cov0" title="0">case "BaiduIDTags":
                return req.Tags.BaiduIDTags, nil</span>
        <span class="cov0" title="0">case "UserAgentTags":
                return req.Tags.UserAgentTags, nil</span>
        <span class="cov0" title="0">case "IPCookieTags":
                return req.Tags.IPCookieTags, nil</span>
        <span class="cov0" title="0">case "CookieVerifyTags":
                return req.Tags.CookieVerifyTags, nil</span>
        <span class="cov0" title="0">default:
                return nil, fmt.Errorf("unknown tag key %s", tf.key)</span>
        }
}

type HasTagMatcher struct {
        value string
}

func (tm *HasTagMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        tags, ok := v.([]string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, t := range tags </span><span class="cov0" title="0">{
                if t == tm.value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

type PathFetcher struct{}

func (pf *PathFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.URL.Path, nil</span>
}

type QueryKeyInFetcher struct {
        keys []string
}

func (qf *QueryKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range qf.keys </span><span class="cov0" title="0">{
                if _, ok := req.CachedQuery()[key]; ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

type QueryKeyPrefixInFetcher struct {
        keys []string
}

func (qf *QueryKeyPrefixInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">ok := false
        for k := range req.CachedQuery() </span><span class="cov0" title="0">{
                if prefix_in(k, qf.keys) </span><span class="cov0" title="0">{
                        ok = true
                        break</span>
                }
        }
        <span class="cov0" title="0">return ok, nil</span>
}

type QueryValueFetcher struct {
        key string
}

// get first query value for the given name
func (q *QueryValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.CachedQuery().Get(q.key), nil</span>
}

type CookieKeyInFetcher struct {
        keys []string
}

func (c *CookieKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range c.keys </span><span class="cov0" title="0">{
                if _, err := req.Cookie(key); err == nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

type CookieValueFetcher struct {
        key string
}

func (c *CookieValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">cookie, err := req.Cookie(c.key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cookie.Value, nil</span>
}

type HeaderKeyInFetcher struct {
        keys []string
}

func (r *HeaderKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range r.keys </span><span class="cov0" title="0">{
                if _, ok := req.HttpRequest.Header[key]; ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>

}

type HeaderValueFetcher struct {
        key string
}

func (r *HeaderValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.Header.Get(r.key), nil</span>
}

type BypassMatcher struct{}

func (b *BypassMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        if b, ok := v.(bool); ok </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov0" title="0">return false</span>
}

type InMatcher struct {
        patterns []string
        foldCase bool
}

func (im *InMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if im.foldCase </span><span class="cov0" title="0">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov0" title="0">return in(vs, im.patterns)</span>
}

type ExactMatcher struct {
    pattern  string
    foldCase bool
}

func (em *ExactMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
    vs, ok := v.(string)
    if !ok </span><span class="cov0" title="0">{
        return false
    }</span>
    <span class="cov0" title="0">if em.foldCase </span><span class="cov0" title="0">{
        vs = strings.ToUpper(vs)
    }</span>
    <span class="cov0" title="0">return vs == em.pattern</span>
}

func NewExactMatcher(pattern string, foldCase bool) *ExactMatcher <span class="cov0" title="0">{
    p := pattern

    if foldCase </span><span class="cov0" title="0">{
        p = strings.ToUpper(p)
    }</span>

    <span class="cov0" title="0">return &amp;ExactMatcher{
        pattern: p,
        foldCase: foldCase,
    }</span>
}

func toUpper(patterns []string) []string <span class="cov1" title="1">{
        upper := make([]string, len(patterns))

        for i, v := range patterns </span><span class="cov1" title="1">{
                upper[i] = strings.ToUpper(v)
        }</span>

        <span class="cov1" title="1">return upper</span>
}

func NewInMatcher(patterns string, foldCase bool) *InMatcher <span class="cov10" title="3">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov1" title="1">{
                p = toUpper(p)
        }</span>

        <span class="cov10" title="3">sort.Strings(p)

        return &amp;InMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

type PrefixInMatcher struct {
        patterns []string
        foldCase bool
}

func (p *PrefixInMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.foldCase </span><span class="cov0" title="0">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov0" title="0">return prefix_in(vs, p.patterns)</span>
}

func NewPrefixInMatcher(patterns string, foldCase bool) *PrefixInMatcher <span class="cov0" title="0">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov0" title="0">{
                p = toUpper(p)
        }</span>

        <span class="cov0" title="0">return &amp;PrefixInMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

type SuffixInMatcher struct {
        patterns []string
        foldCase bool
}

func (p *SuffixInMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if p.foldCase </span><span class="cov0" title="0">{
                vs = strings.ToUpper(vs)
        }</span>

        <span class="cov0" title="0">return suffix_in(vs, p.patterns)</span>
}

func NewSuffixInMatcher(patterns string, foldCase bool) *SuffixInMatcher <span class="cov0" title="0">{
        p := strings.Split(patterns, "|")

        if foldCase </span><span class="cov0" title="0">{
                p = toUpper(p)
        }</span>

        <span class="cov0" title="0">return &amp;SuffixInMatcher{
                patterns: p,
                foldCase: foldCase,
        }</span>
}

type RegMatcher struct {
        regex *regexp.Regexp
}

func (p *RegMatcher) Match(v interface{}) bool <span class="cov0" title="0">{
        vs, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return p.regex.MatchString(vs)</span>
}

func NewRegMatcher(regex *regexp.Regexp) *RegMatcher <span class="cov0" title="0">{
        return &amp;RegMatcher{
                regex: regex,
        }
}</span>

func in(v string, patterns []string) bool <span class="cov6" title="2">{
        i := sort.SearchStrings(patterns, v)
        return i &lt; len(patterns) &amp;&amp; patterns[i] == v
}</span>

func prefix_in(v string, patterns []string) bool <span class="cov0" title="0">{
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if strings.HasPrefix(v, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func suffix_in(v string, patterns []string) bool <span class="cov0" title="0">{
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if strings.HasSuffix(v, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func contains(v, pattern string) bool <span class="cov0" title="0">{
        return strings.Contains(v, pattern)
}</span>

type UAFetcher struct{}

func (uaf *UAFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpRequest == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpRequest.Header.Get("User-Agent"), nil</span>
}

type ResHeaderKeyInFetcher struct {
        keys []string
}

func (r *ResHeaderKeyInFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpResponse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">for _, key := range r.keys </span><span class="cov0" title="0">{
                if _, ok := req.HttpResponse.Header[key]; ok </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>

}

type ResHeaderValueFetcher struct {
        key string
}

func (r *ResHeaderValueFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpResponse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return req.HttpResponse.Header.Get(r.key), nil</span>
}

type ResCodeFetcher struct{}

func (rf *ResCodeFetcher) Fetch(req *bfe_basic.Request) (interface{}, error) <span class="cov0" title="0">{
        if req == nil || req.HttpResponse == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetcher: nil pointer")
        }</span>

        <span class="cov0" title="0">return string(req.HttpResponse.StatusCode), nil</span>
}

type TrustedCIpMatcher struct{}

func (m *TrustedCIpMatcher) Match(req *bfe_basic.Request) bool <span class="cov0" title="0">{
        return req.Session.IsTrustIP
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/* bufio.go - ported from /src/pkg/bufio    */
/*
modification history
--------------------
2014/6/16, by Zhang Miao, add TotalRead to Reader
                          add TotalWrite to Writer
*/
/*
DESCRIPTION
*/

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package bfe_bufio implements buffered I/O.  It wraps an io.Reader or io.Writer
// object, creating another object (Reader or Writer) that also implements
// the interface but provides buffering and some help for textual I/O.
package bfe_bufio

import (
        "bytes"
        "errors"
        "io"
        "unicode/utf8"
)

import (
    "www.baidu.com/golang-lib/log"
)

const (
        defaultBufSize = 4096
)

var (
        ErrInvalidUnreadByte = errors.New("bfe_bufio: invalid use of UnreadByte")
        ErrInvalidUnreadRune = errors.New("bfe_bufio: invalid use of UnreadRune")
        ErrBufferFull        = errors.New("bfe_bufio: buffer full")
        ErrNegativeCount     = errors.New("bfe_bufio: negative count")
)

// Buffered input.

// Reader implements buffering for an io.Reader object.
type Reader struct {
        buf          []byte
        rd           io.Reader
        r, w         int
        err          error
        lastByte     int
        lastRuneSize int

        TotalRead    int        // number of bytes total read
}

const minReadBufferSize = 16

// NewReaderSize returns a new Reader whose buffer has at least the specified
// size. If the argument io.Reader is already a Reader with large enough
// size, it returns the underlying Reader.
func NewReaderSize(rd io.Reader, size int) *Reader <span class="cov8" title="11198">{
        // Is it already a Reader?
        b, ok := rd.(*Reader)
        if ok &amp;&amp; len(b.buf) &gt;= size </span><span class="cov1" title="1">{
                return b
        }</span>
        <span class="cov8" title="11197">if size &lt; minReadBufferSize </span><span class="cov0" title="0">{
                size = minReadBufferSize
        }</span>
        <span class="cov8" title="11197">r := new(Reader)
        r.reset(make([]byte, size), rd)
        return r</span>
}

// NewReader returns a new Reader whose buffer has the default size.
func NewReader(rd io.Reader) *Reader <span class="cov3" title="24">{
        return NewReaderSize(rd, defaultBufSize)
}</span>

// Reset discards any buffered data, resets all state, and switches
// the buffered reader to read from r.
func (b *Reader) Reset(r io.Reader) <span class="cov1" title="1">{
        b.reset(b.buf, r)
}</span>

func (b *Reader) reset(buf []byte, r io.Reader) <span class="cov8" title="11198">{
        *b = Reader{
                buf:          buf,
                rd:           r,
                lastByte:     -1,
                lastRuneSize: -1,
                TotalRead:    0,
        }
}</span>

var errNegativeRead = errors.New("bfe_bufio: reader returned negative count from Read")

// fill reads a new chunk into the buffer.
func (b *Reader) fill() <span class="cov9" title="92197">{
        // Slide existing data to beginning.
        if b.r &gt; 0 </span><span class="cov9" title="70614">{
                copy(b.buf, b.buf[b.r:b.w])
                b.w -= b.r
                b.r = 0
        }</span>

        // Read new data.
        <span class="cov9" title="92197">n, err := b.rd.Read(b.buf[b.w:])
        if n &lt; 0 </span><span class="cov1" title="1">{
                panic(errNegativeRead)
        }</span>

        <span class="cov9" title="92196">if (b.w + n) &gt; len(b.buf) </span><span class="cov0" title="0">{
                log.Logger.Warn("bfe_bufio:reader.fill(),len(buf)=%d,b.r=%d,b.w=%d,n=%d\n",
                                len(b.buf), b.r, b.w, n)
        }</span>

        <span class="cov9" title="92196">b.w += n
        if err != nil </span><span class="cov8" title="13425">{
                b.err = err
        }</span>
}

func (b *Reader) readErr() error <span class="cov8" title="13429">{
        err := b.err
        b.err = nil
        return err
}</span>

// Peek returns the next n bytes without advancing the reader. The bytes stop
// being valid at the next read call. If Peek returns fewer than n bytes, it
// also returns an error explaining why the read is short. The error is
// ErrBufferFull if n is larger than b's buffer size.
func (b *Reader) Peek(n int) ([]byte, error) <span class="cov2" title="11">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                return nil, ErrNegativeCount
        }</span>
        <span class="cov2" title="11">if n &gt; len(b.buf) </span><span class="cov1" title="1">{
                return nil, ErrBufferFull
        }</span>
        <span class="cov2" title="10">for b.w-b.r &lt; n &amp;&amp; b.err == nil </span><span class="cov2" title="4">{
                b.fill()
        }</span>
        <span class="cov2" title="10">m := b.w - b.r
        if m &gt; n </span><span class="cov2" title="6">{
                m = n
        }</span>
        <span class="cov2" title="10">var err error
        if m &lt; n </span><span class="cov1" title="2">{
                err = b.readErr()
                if err == nil </span><span class="cov0" title="0">{
                        err = ErrBufferFull
                }</span>
        }
        <span class="cov2" title="10">return b.buf[b.r : b.r+m], err</span>
}

// Read reads data into p.
// It returns the number of bytes read into p.
// It calls Read at most once on the underlying Reader,
// hence n may be less than len(p).
// At EOF, the count will be zero and err will be io.EOF.
func (b *Reader) Read(p []byte) (n int, err error) <span class="cov10" title="144673">{
        n = len(p)
        if n == 0 </span><span class="cov1" title="2">{
                return 0, b.readErr()
        }</span>
        <span class="cov9" title="144671">if b.w == b.r </span><span class="cov9" title="70485">{
                if b.err != nil </span><span class="cov6" title="1675">{
                        return 0, b.readErr()
                }</span>
                <span class="cov9" title="68810">if len(p) &gt;= len(b.buf) </span><span class="cov1" title="2">{
                        // Large read, empty buffer.
                        // Read directly into p to avoid copy.
                        n, b.err = b.rd.Read(p)
                        if n &gt; 0 </span><span class="cov1" title="1">{
                                b.lastByte = int(p[n-1])
                                b.lastRuneSize = -1

                            b.TotalRead += n
                        }</span>
                                                
                        <span class="cov1" title="2">return n, b.readErr()</span>
                }
                <span class="cov9" title="68808">b.fill()
                if b.w == b.r </span><span class="cov7" title="8372">{
                        return 0, b.readErr()
                }</span>
        }

        <span class="cov9" title="134621">if n &gt; b.w-b.r </span><span class="cov9" title="47891">{
                n = b.w - b.r
        }</span>
        
        <span class="cov9" title="134621">if b.r &gt; len(b.buf) || (b.r + n) &gt; len(b.buf) </span><span class="cov0" title="0">{
                log.Logger.Warn("bfe_bufio:reader.Read(),len(buf)=%d,b.r=%d,b.w=%d,n=%d\n",
                                len(b.buf), b.r, b.w, n)
        }</span>
        
        <span class="cov9" title="134621">copy(p[0:n], b.buf[b.r:])
        b.r += n
        b.lastByte = int(b.buf[b.r-1])
        b.lastRuneSize = -1
        
    b.TotalRead += n
        
        return n, nil</span>
}

// ReadByte reads and returns a single byte.
// If no byte is available, returns an error.
func (b *Reader) ReadByte() (c byte, err error) <span class="cov9" title="43552">{
        b.lastRuneSize = -1
        for b.w == b.r </span><span class="cov8" title="13147">{
                if b.err != nil </span><span class="cov6" title="1676">{
                        return 0, b.readErr()
                }</span>
                <span class="cov8" title="11471">b.fill()</span>
        }
        <span class="cov9" title="41876">c = b.buf[b.r]
        b.r++
        b.lastByte = int(c)
        
        b.TotalRead += 1
        
        return c, nil</span>
}

// UnreadByte unreads the last byte.  Only the most recently read byte can be unread.
func (b *Reader) UnreadByte() error <span class="cov1" title="1">{
        b.lastRuneSize = -1
        if b.r == b.w &amp;&amp; b.lastByte &gt;= 0 </span><span class="cov0" title="0">{
                b.w = 1
                b.r = 0
                b.buf[0] = byte(b.lastByte)
                b.lastByte = -1
                
                if b.TotalRead &gt; 0 </span><span class="cov0" title="0">{
                    b.TotalRead -= 1
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov1" title="1">if b.r &lt;= 0 </span><span class="cov0" title="0">{
                return ErrInvalidUnreadByte
        }</span>
        <span class="cov1" title="1">b.r--
        b.lastByte = -1

        if b.TotalRead &gt; 0 </span><span class="cov1" title="1">{
            b.TotalRead -= 1
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ReadRune reads a single UTF-8 encoded Unicode character and returns the
// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte
// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.
func (b *Reader) ReadRune() (r rune, size int, err error) <span class="cov6" title="1088">{
        for b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == nil </span><span class="cov3" title="39">{
                b.fill()
        }</span>
        <span class="cov6" title="1088">b.lastRuneSize = -1
        if b.r == b.w </span><span class="cov2" title="12">{
                return 0, 0, b.readErr()
        }</span>
        <span class="cov6" title="1076">r, size = rune(b.buf[b.r]), 1
        if r &gt;= 0x80 </span><span class="cov6" title="894">{
                r, size = utf8.DecodeRune(b.buf[b.r:b.w])
        }</span>
        <span class="cov6" title="1076">b.r += size
        b.lastByte = int(b.buf[b.r-1])
        b.lastRuneSize = size
        
        b.TotalRead += size
        
        return r, size, nil</span>
}

// UnreadRune unreads the last rune.  If the most recent read operation on
// the buffer was not a ReadRune, UnreadRune returns an error.  (In this
// regard it is stricter than UnreadByte, which will unread the last byte
// from any read operation.)
func (b *Reader) UnreadRune() error <span class="cov3" title="24">{
        if b.lastRuneSize &lt; 0 || b.r == 0 </span><span class="cov2" title="7">{
                return ErrInvalidUnreadRune
        }</span>
        <span class="cov3" title="17">b.r -= b.lastRuneSize
        
        if b.TotalRead &gt;= b.lastRuneSize </span><span class="cov3" title="17">{
            b.TotalRead -= b.lastRuneSize
        }</span>        
        
        <span class="cov3" title="17">b.lastByte = -1
        b.lastRuneSize = -1        
        
        return nil</span>
}

// Buffered returns the number of bytes that can be read from the current buffer.
func (b *Reader) Buffered() int <span class="cov8" title="21650">{ return b.w - b.r }</span>

// ReadSlice reads until the first occurrence of delim in the input,
// returning a slice pointing at the bytes in the buffer.
// The bytes stop being valid at the next read.
// If ReadSlice encounters an error before finding a delimiter,
// it returns all the data in the buffer and the error itself (often io.EOF).
// ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.
// Because the data returned from ReadSlice will be overwritten
// by the next I/O operation, most clients should use
// ReadBytes or ReadString instead.
// ReadSlice returns err != nil if and only if line does not end in delim.
func (b *Reader) ReadSlice(delim byte) (line []byte, err error) <span class="cov7" title="4632">{
        // Look in buffer.
        if i := bytes.IndexByte(b.buf[b.r:b.w], delim); i &gt;= 0 </span><span class="cov5" title="640">{
                line1 := b.buf[b.r : b.r+i+1]
                b.r += i + 1
                
                b.TotalRead += i + 1
                
                return line1, nil
        }</span>

        // Read more into buffer, until buffer fills or we find delim.
        <span class="cov7" title="3992">for </span><span class="cov8" title="13555">{
                if b.err != nil </span><span class="cov6" title="1685">{
                        line := b.buf[b.r:b.w]
                        
                        b.TotalRead += b.w - b.r
                        
                        b.r = b.w
                        return line, b.readErr()
                }</span>

                <span class="cov8" title="11870">n := b.Buffered()
                b.fill()

                // Search new part of buffer
                if i := bytes.IndexByte(b.buf[n:b.w], delim); i &gt;= 0 </span><span class="cov6" title="2090">{
                        line := b.buf[0 : n+i+1]
                        b.r = n + i + 1
                        
                        b.TotalRead += i + 1
                        
                        return line, nil
                }</span>

                // Buffer is full?
                <span class="cov7" title="9780">if b.Buffered() &gt;= len(b.buf) </span><span class="cov5" title="217">{
                    b.TotalRead += len(b.buf)
                    
                        b.r = b.w
                        return b.buf, ErrBufferFull
                }</span>
        }
}

// ReadLine is a low-level line-reading primitive. Most callers should use
// ReadBytes('\n') or ReadString('\n') instead or use a Scanner.
//
// ReadLine tries to return a single line, not including the end-of-line bytes.
// If the line was too long for the buffer then isPrefix is set and the
// beginning of the line is returned. The rest of the line will be returned
// from future calls. isPrefix will be false when returning the last fragment
// of the line. The returned buffer is only valid until the next call to
// ReadLine. ReadLine either returns a non-nil line or it returns an error,
// never both.
//
// The text returned from ReadLine does not include the line end ("\r\n" or "\n").
// No indication or error is given if the input ends without a final line end.
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) <span class="cov3" title="46">{
        line, err = b.ReadSlice('\n')
        if err == ErrBufferFull </span><span class="cov2" title="6">{
                // Handle the case where "\r\n" straddles the buffer.
                if len(line) &gt; 0 &amp;&amp; line[len(line)-1] == '\r' </span><span class="cov1" title="2">{
                        // Put the '\r' back on buf and drop it from line.
                        // Let the next call to ReadLine check for "\r\n".
                        if b.r == 0 </span><span class="cov0" title="0">{
                                // should be unreachable
                                panic("bfe_bufio: tried to rewind past start of buffer")
                        }</span>
                        <span class="cov1" title="2">b.r--
                        line = line[:len(line)-1]</span>
                }
                <span class="cov2" title="6">return line, true, nil</span>
        }

        <span class="cov3" title="40">if len(line) == 0 </span><span class="cov2" title="8">{
                if err != nil </span><span class="cov2" title="8">{
                        line = nil
                }</span>
                <span class="cov2" title="8">return</span>
        }
        <span class="cov3" title="32">err = nil

        if line[len(line)-1] == '\n' </span><span class="cov3" title="29">{
                drop := 1
                if len(line) &gt; 1 &amp;&amp; line[len(line)-2] == '\r' </span><span class="cov3" title="15">{
                        drop = 2
                }</span>
                <span class="cov3" title="29">line = line[:len(line)-drop]</span>
        }
        <span class="cov3" title="32">return</span>
}

// ReadBytes reads until the first occurrence of delim in the input,
// returning a slice containing the data up to and including the delimiter.
// If ReadBytes encounters an error before finding a delimiter,
// it returns the data read before the error and the error itself (often io.EOF).
// ReadBytes returns err != nil if and only if the returned data does not end in
// delim.
// For simple uses, a Scanner may be more convenient.
func (b *Reader) ReadBytes(delim byte) (line []byte, err error) <span class="cov7" title="4374">{
        // Use ReadSlice to look for array,
        // accumulating full buffers.
        var frag []byte
        var full [][]byte
        err = nil

        for </span><span class="cov7" title="4584">{
                var e error
                frag, e = b.ReadSlice(delim)
                if e == nil </span><span class="cov6" title="2700">{ // got final fragment
                        break</span>
                }
                <span class="cov6" title="1884">if e != ErrBufferFull </span><span class="cov6" title="1674">{ // unexpected error
                        err = e
                        break</span>
                }

                // Make a copy of the buffer.
                <span class="cov5" title="210">buf := make([]byte, len(frag))
                copy(buf, frag)
                full = append(full, buf)</span>
        }

        // Allocate new buffer to hold the full pieces and the fragment.
        <span class="cov7" title="4374">n := 0
        for i := range full </span><span class="cov5" title="210">{
                n += len(full[i])
        }</span>
        <span class="cov7" title="4374">n += len(frag)

        // Copy full pieces and fragment in.
        buf := make([]byte, n)
        n = 0
        for i := range full </span><span class="cov5" title="210">{
                n += copy(buf[n:], full[i])
        }</span>
        <span class="cov7" title="4374">copy(buf[n:], frag)
        return buf, err</span>
}

// ReadString reads until the first occurrence of delim in the input,
// returning a string containing the data up to and including the delimiter.
// If ReadString encounters an error before finding a delimiter,
// it returns the data read before the error and the error itself (often io.EOF).
// ReadString returns err != nil if and only if the returned data does not end in
// delim.
// For simple uses, a Scanner may be more convenient.
func (b *Reader) ReadString(delim byte) (line string, err error) <span class="cov7" title="4374">{
        bytes, err := b.ReadBytes(delim)
        line = string(bytes)
        return line, err
}</span>

// WriteTo implements io.WriterTo.
func (b *Reader) WriteTo(w io.Writer) (n int64, err error) <span class="cov2" title="6">{
        n, err = b.writeBuf(w)
        if err != nil </span><span class="cov1" title="2">{            
                return
        }</span>

        <span class="cov2" title="4">if r, ok := b.rd.(io.WriterTo); ok </span><span class="cov1" title="1">{
                m, err := r.WriteTo(w)

        if m &gt; 0 </span><span class="cov1" title="1">{
            b.TotalRead += int(m)
        }</span>                
                
                <span class="cov1" title="1">n += m
                return n, err</span>
        }

        <span class="cov1" title="3">for b.fill(); b.r &lt; b.w; b.fill() </span><span class="cov1" title="2">{
                m, err := b.writeBuf(w)
                n += m
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }

        <span class="cov1" title="3">if b.err == io.EOF </span><span class="cov1" title="2">{
                b.err = nil
        }</span>

        <span class="cov1" title="3">return n, b.readErr()</span>
}

// writeBuf writes the Reader's buffer to the writer.
func (b *Reader) writeBuf(w io.Writer) (int64, error) <span class="cov2" title="8">{
        n, err := w.Write(b.buf[b.r:b.w])
        b.r += n
        
        if n &gt; 0 </span><span class="cov1" title="3">{
            b.TotalRead += n
        }</span>
        
        <span class="cov2" title="8">return int64(n), err</span>
}

// buffered output

// Writer implements buffering for an io.Writer object.
// If an error occurs writing to a Writer, no more data will be
// accepted and all subsequent writes will return the error.
// After all data has been written, the client should call the
// Flush method to guarantee all data has been forwarded to
// the underlying io.Writer.
type Writer struct {
        err error
        buf []byte
        n   int
        wr  io.Writer
        
        TotalWrite int  // number of bytes total write
}

// NewWriterSize returns a new Writer whose buffer has at least the specified
// size. If the argument io.Writer is already a Writer with large enough
// size, it returns the underlying Writer.
func NewWriterSize(w io.Writer, size int) *Writer <span class="cov4" title="105">{
        // Is it already a Writer?
        b, ok := w.(*Writer)
        if ok &amp;&amp; len(b.buf) &gt;= size </span><span class="cov1" title="1">{
                return b
        }</span>
        <span class="cov4" title="104">if size &lt;= 0 </span><span class="cov0" title="0">{
                size = defaultBufSize
        }</span>
        <span class="cov4" title="104">return &amp;Writer{
                buf: make([]byte, size),
                wr:  w,
                TotalWrite: 0,
        }</span>
}

// NewWriter returns a new Writer whose buffer has the default size.
func NewWriter(w io.Writer) *Writer <span class="cov3" title="17">{
        return NewWriterSize(w, defaultBufSize)
}</span>

// Reset discards any unflushed buffered data, clears any error, and
// resets b to write its output to w.
func (b *Writer) Reset(w io.Writer) <span class="cov1" title="1">{
        b.err = nil
        b.n = 0
        b.wr = w
        b.TotalWrite = 0
}</span>

// Flush writes any buffered data to the underlying io.Writer.
func (b *Writer) Flush() error <span class="cov4" title="102">{
        err := b.flush()
        return err
}</span>

func (b *Writer) flush() error <span class="cov4" title="115">{
        if b.err != nil </span><span class="cov2" title="5">{
                return b.err
        }</span>
        <span class="cov4" title="110">if b.n == 0 </span><span class="cov3" title="41">{
                return nil
        }</span>
        <span class="cov4" title="69">n, err := b.wr.Write(b.buf[0:b.n])
        if n &lt; b.n &amp;&amp; err == nil </span><span class="cov1" title="2">{
                err = io.ErrShortWrite
        }</span>
        <span class="cov4" title="69">if err != nil </span><span class="cov2" title="6">{
                if n &gt; 0 &amp;&amp; n &lt; b.n </span><span class="cov1" title="2">{
                        copy(b.buf[0:b.n-n], b.buf[n:b.n])
                }</span>
                <span class="cov2" title="6">b.n -= n
                b.err = err
                return err</span>
        }
        <span class="cov4" title="63">b.n = 0
        return nil</span>
}

// Available returns how many bytes are unused in the buffer.
func (b *Writer) Available() int <span class="cov6" title="1177">{ return len(b.buf) - b.n }</span>

// Buffered returns the number of bytes that have been written into the current buffer.
func (b *Writer) Buffered() int <span class="cov3" title="50">{ return b.n }</span>

// Write writes the contents of p into the buffer.
// It returns the number of bytes written.
// If nn &lt; len(p), it also returns an error explaining
// why the write is short.
func (b *Writer) Write(p []byte) (nn int, err error) <span class="cov4" title="88">{
        for len(p) &gt; b.Available() &amp;&amp; b.err == nil </span><span class="cov3" title="36">{
                var n int
                if b.Buffered() == 0 </span><span class="cov3" title="36">{
                        // Large write, empty buffer.
                        // Write directly from p to avoid copy.
                        n, b.err = b.wr.Write(p)
                }</span> <span class="cov0" title="0">else {
                        n = copy(b.buf[b.n:], p)
                        b.n += n
                        b.flush()
                }</span>
                <span class="cov3" title="36">nn += n
                p = p[n:]</span>
        }
        <span class="cov4" title="88">if b.err != nil </span><span class="cov0" title="0">{
            b.TotalWrite += nn            
                return nn, b.err
        }</span>
        <span class="cov4" title="88">n := copy(b.buf[b.n:], p)
        b.n += n
        nn += n
        
        b.TotalWrite += nn
        
        return nn, nil</span>
}

// WriteByte writes a single byte.
func (b *Writer) WriteByte(c byte) error <span class="cov4" title="128">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b.err
        }</span>
        <span class="cov4" title="128">if b.Available() &lt;= 0 &amp;&amp; b.flush() != nil </span><span class="cov0" title="0">{
                return b.err
        }</span>
        <span class="cov4" title="128">b.buf[b.n] = c
        b.n++
        b.TotalWrite ++
        return nil</span>
}

// WriteRune writes a single Unicode code point, returning
// the number of bytes written and any error.
func (b *Writer) WriteRune(r rune) (size int, err error) <span class="cov6" title="1000">{
        if r &lt; utf8.RuneSelf </span><span class="cov4" title="128">{
                err = b.WriteByte(byte(r))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov4" title="128">return 1, nil</span>
        }
        <span class="cov6" title="872">if b.err != nil </span><span class="cov0" title="0">{
                return 0, b.err
        }</span>
        <span class="cov6" title="872">n := b.Available()
        if n &lt; utf8.UTFMax </span><span class="cov0" title="0">{
                if b.flush(); b.err != nil </span><span class="cov0" title="0">{
                        return 0, b.err
                }</span>
                <span class="cov0" title="0">n = b.Available()
                if n &lt; utf8.UTFMax </span><span class="cov0" title="0">{
                        // Can only happen if buffer is silly small.
                        return b.WriteString(string(r))
                }</span>
        }
        <span class="cov6" title="872">size = utf8.EncodeRune(b.buf[b.n:], r)

    b.TotalWrite += size        
        
        b.n += size
        return size, nil</span>
}

// WriteString writes a string.
// It returns the number of bytes written.
// If the count is less than len(s), it also returns an error explaining
// why the write is short.
func (b *Writer) WriteString(s string) (int, error) <span class="cov2" title="11">{   
        nn := 0
        for len(s) &gt; b.Available() &amp;&amp; b.err == nil </span><span class="cov2" title="4">{
                n := copy(b.buf[b.n:], s)
                b.n += n
                nn += n
                s = s[n:]
                b.flush()
        }</span>
        <span class="cov2" title="11">if b.err != nil </span><span class="cov0" title="0">{
            b.TotalWrite += nn
                return nn, b.err
        }</span>
        <span class="cov2" title="11">n := copy(b.buf[b.n:], s)
        b.n += n
        nn += n
        b.TotalWrite += nn
        return nn, nil</span>
}

// ReadFrom implements io.ReaderFrom.
func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) <span class="cov2" title="14">{
        if b.Buffered() == 0 </span><span class="cov2" title="9">{
                if w, ok := b.wr.(io.ReaderFrom); ok </span><span class="cov1" title="2">{
                        n, err = w.ReadFrom(r)                        
                        b.TotalWrite += int(n)
                        return n, err
                }</span>
        }
        <span class="cov2" title="12">var m int
        for </span><span class="cov3" title="29">{
                if b.Available() == 0 </span><span class="cov2" title="7">{
                        if err1 := b.flush(); err1 != nil </span><span class="cov1" title="1">{
                                return n, err1
                        }</span>
                }
                <span class="cov3" title="28">m, err = r.Read(b.buf[b.n:])
                if m == 0 </span><span class="cov2" title="9">{
                        break</span>
                }
                                
                <span class="cov3" title="19">b.n += m
                
                if b.n &gt; len(b.buf) </span><span class="cov0" title="0">{
                    log.Logger.Warn("bfe_bufio:Writer.ReadFrom(),len(buf)=%d,b.n=%d,m=%d\n",
                                    len(b.buf), b.n, m)                    
                }</span>
                
                <span class="cov3" title="19">n += int64(m)
                if err != nil </span><span class="cov1" title="2">{
                        break</span>
                }
        }
        <span class="cov2" title="11">if err == io.EOF </span><span class="cov2" title="9">{
                // If we filled the buffer exactly, flush pre-emptively.
                if b.Available() == 0 </span><span class="cov1" title="2">{
                        err = b.flush()
                }</span> <span class="cov2" title="7">else {
                        err = nil
                }</span>
        }
        <span class="cov2" title="11">b.TotalWrite += int(n)
        return n, err</span>
}

// buffered input and output

// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
        *Reader
        *Writer
}

// NewReadWriter allocates a new ReadWriter that dispatches to r and w.
func NewReadWriter(r *Reader, w *Writer) *ReadWriter <span class="cov0" title="0">{
        return &amp;ReadWriter{r, w}
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/* cluster_conf_load.go - load cluster conf from json file  */
/*
modification history
--------------------
2014/5/19, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package cluster_conf

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

/*
   structure of Cluster conf:
    {"Version":"1234", 
     "Config":{"news":{"BackendConf":{},
                       "CheckConf":{},
                       "GslbBasic":{},
                       "ClusterBasic":{}
                      },
               "wenku":{
                       }
              }
     }
*/

// conf of backend check
type BackendCheck struct {
    Schem           *string
    Uri             *string // uri used in health check
    Host            *string // if check request use special host header
    StatusCode      *int    // default value is 200
    FailNum         *int    // if continuous_fail_num reach failNum, backend become
                            // unavailable, and start health check
    CheckInterval   *int    // interval of health check, in ms
}

// conf of backend basic
type BackendBasic struct {
    TimeoutConnSrv      *int    // timeout for connect server, in ms
    TimeoutResponseHeader *int        // timeout for read header from srv
    MaxIdleConnsPerHost        *int
}

// Cluster conf for Gslb
type GslbBasicConf struct {
    CrossRetry          *int    // retry cross sub clusters
    RetryMax                        *int        // inner cluster retry
}

// basic conf for cluster
type ClusterBasicConf struct {
        TimeoutReadClient   *int         // timeout for read client body in ms
        TimeoutWriteClient        *int        // timeout for write response to client 
    TimeoutReadClientAgain *int // timeout for read client again in ms
}

// conf of cluster
type ClusterConf struct {
    BackendConf     *BackendBasic        // backend's basic conf
    CheckConf       *BackendCheck        // how to check backend
    GslbBasic       *GslbBasicConf       // gslb basic conf for cluster
    ClusterBasic    *ClusterBasicConf    // basic conf for cluster
}

type ClusterToConf map[string]ClusterConf

// conf of all bfe cluster
type BfeClusterConf struct {
    Version *string              // version of config
    Config  *ClusterToConf
}

// check BackendBasic
func BackendBasicCheck(conf *BackendBasic) error <span class="cov10" title="2">{
    if conf.TimeoutConnSrv == nil </span><span class="cov0" title="0">{
        return errors.New("no TimeoutConnSrv")
    }</span>

    <span class="cov10" title="2">if conf.TimeoutResponseHeader == nil </span><span class="cov0" title="0">{
        return errors.New("no TimeoutResponseHeader")
    }</span>

    <span class="cov10" title="2">if conf.MaxIdleConnsPerHost == nil </span><span class="cov10" title="2">{
        defaultIdle := 2
        conf.MaxIdleConnsPerHost = &amp;defaultIdle
    }</span>

    <span class="cov10" title="2">return nil</span>    
}

// check BackendCheck
func BackendCheckCheck(conf *BackendCheck) error <span class="cov10" title="2">{
    if conf.Uri == nil </span><span class="cov0" title="0">{
        return errors.New("no Uri")
    }</span>
    
    <span class="cov10" title="2">if conf.StatusCode == nil </span><span class="cov10" title="2">{
        defaultStatusCode := 200
        conf.StatusCode = &amp;defaultStatusCode
    }</span>
    
    <span class="cov10" title="2">if conf.FailNum == nil </span><span class="cov0" title="0">{
        return errors.New("no FailNum")
    }</span>

    <span class="cov10" title="2">if conf.CheckInterval == nil </span><span class="cov0" title="0">{
        return errors.New("no CheckInterval")
    }</span>
    
    <span class="cov10" title="2">return nil</span>
}

// check GslbBasicConf
func GslbBasicConfCheck(conf *GslbBasicConf) error <span class="cov10" title="2">{
    if conf.CrossRetry == nil </span><span class="cov0" title="0">{
        return errors.New("no CrossRetry")
    }</span>
    
    <span class="cov10" title="2">if conf.RetryMax == nil </span><span class="cov0" title="0">{
        return errors.New("no RetryMax")
    }</span>

    <span class="cov10" title="2">return nil</span>
}

// check ClusterBasicConf
func ClusterBasicConfCheck(conf *ClusterBasicConf) error <span class="cov10" title="2">{
    if conf.TimeoutReadClientAgain == nil || 
            conf.TimeoutReadClient == nil ||
            conf.TimeoutWriteClient == nil </span><span class="cov0" title="0">{
            return errors.New("timeout configure error")    
    }</span>

    <span class="cov10" title="2">return nil</span>
}

// check ClusterConf
func ClusterConfCheck(conf ClusterConf) error <span class="cov10" title="2">{
    var err error
    
    // check BackendConf
    if conf.BackendConf == nil </span><span class="cov0" title="0">{
        return errors.New("no BackendConf")
    }</span>
    <span class="cov10" title="2">err = BackendBasicCheck(conf.BackendConf)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("BackendConf:%s", err.Error())
    }</span>
    
    // check CheckConf
    <span class="cov10" title="2">if conf.CheckConf == nil </span><span class="cov0" title="0">{
        return errors.New("no CheckConf")
    }</span>
    <span class="cov10" title="2">err = BackendCheckCheck(conf.CheckConf)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("CheckConf:%s", err.Error())
    }</span>

    // check GslbBasic
    <span class="cov10" title="2">if conf.GslbBasic == nil </span><span class="cov0" title="0">{
        return errors.New("no GslbBasic")
    }</span>
    <span class="cov10" title="2">err = GslbBasicConfCheck(conf.GslbBasic)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("GslbBasic:%s", err.Error())
    }</span>

    // check ClusterBasic
    <span class="cov10" title="2">if conf.ClusterBasic == nil </span><span class="cov0" title="0">{
        return errors.New("no ClusterBasic")
    }</span>
    <span class="cov10" title="2">err = ClusterBasicConfCheck(conf.ClusterBasic)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("ClusterBasic:%s", err.Error())
    }</span>

    <span class="cov10" title="2">return nil</span>
}

// check ClusterToConf
func ClusterToConfCheck(conf *ClusterToConf) error <span class="cov1" title="1">{
    for clusterName, clusterConf := range *conf </span><span class="cov10" title="2">{
        err := ClusterConfCheck(clusterConf)
        
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("conf for %s:%s", clusterName, err.Error())
        }</span>
    }
    <span class="cov1" title="1">return nil</span>
}

// check integrity of config
func BfeClusterConfCheck(conf BfeClusterConf) error <span class="cov1" title="1">{
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>
    
    <span class="cov1" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>
    
    <span class="cov1" title="1">err := ClusterToConfCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("BfeClusterConf.Config:%s", err.Error())
    }</span>
    
    <span class="cov1" title="1">return nil</span>
}

// implement Check interface used for reload-trigger checking conf
func (conf *BfeClusterConf)LoadAndCheck(filename string) (string, error) <span class="cov10" title="2">{
    /* open the file    */
    file, err := os.Open(filename)
    
    if err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>
    
    /* decode the file  */
    <span class="cov10" title="2">decoder := json.NewDecoder(file)
    defer file.Close()
    
    if err := decoder.Decode(&amp;conf); err != nil </span><span class="cov1" title="1">{
        return "", err
    }</span>

    /* check conf   */
    <span class="cov1" title="1">if err := BfeClusterConfCheck(*conf); err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>

    <span class="cov1" title="1">return *(conf.Version), nil</span>
}


/* load config of cluster conf from file  
   
   Returns:
        (BfeClusterConf, error)
*/
func  ClusterConfLoad(filename string) (BfeClusterConf, error) <span class="cov10" title="2">{    
    var config BfeClusterConf
    if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov1" title="1">{
        return config, fmt.Errorf("%s", err)
    }</span>

    <span class="cov1" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/* cluster_table_load.go - load cluster table from json file  */
/*
modification history
--------------------
2014/5/15, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package cluster_table_conf

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
    "reflect"
)

// structure of ClusterTable config:
// {"Version":"1234",
//  "Config":{"news":{"lighttpd-bfe.NEWS.dx":[backend1, backend2,...],
//                    "lighttpd-bfe.NEWS.wt":[backend1, backend2,...]
//                   },
//            "wenku":{
//                    }
//           }
// }
//
// backend: {"name":"tc-bae-static05.tc", "addr":"10.26.35.33", "port":8000, "weight":10}
//
// conf of backend
type BackendConf struct {
    Name   *string // e.g., "tc-bae-static05.tc"
    Addr   *string // e.g., "10.26.35.33"
    Port   *int    // e.g., 8000
    Weight *int    // weight in load balance, e.g., 10
}

type SubClusterBackend []*BackendConf
type ClusterBackend map[string]SubClusterBackend
type AllClusterBackend map[string]ClusterBackend

func (allClusterBackend AllClusterBackend) HasDiff(compared AllClusterBackend) bool <span class="cov0" title="0">{
    if len(allClusterBackend) != len(compared) </span><span class="cov0" title="0">{
        return true
    }</span>

    <span class="cov0" title="0">for cluster, clusterBackend := range allClusterBackend </span><span class="cov0" title="0">{
        comparedClusterBackend, ok := compared[cluster]
        if !ok </span><span class="cov0" title="0">{
            return true
        }</span>

        <span class="cov0" title="0">if clusterBackend.HasDiff(comparedClusterBackend) </span><span class="cov0" title="0">{
            return true
        }</span>
    }

    <span class="cov0" title="0">return false</span>
}

// Compare two AllClusterBackend.
// return true if compared contains all cluster in allClusterBackend, and
// there cluster has same ClusterBackend value
func (allClusterBackend AllClusterBackend) IsSub(compared AllClusterBackend) bool <span class="cov0" title="0">{
    for cluster, clusterBackend := range allClusterBackend </span><span class="cov0" title="0">{
        comparedClusterBackend, ok := compared[cluster]
        if !ok </span><span class="cov0" title="0">{
            return false
        }</span>

        <span class="cov0" title="0">if !clusterBackend.IsSame(comparedClusterBackend) </span><span class="cov0" title="0">{
            return false
        }</span>
    }

    <span class="cov0" title="0">return true</span>
}

func (clusterBackend ClusterBackend) HasDiff(compared ClusterBackend) bool <span class="cov0" title="0">{
    return !reflect.DeepEqual(clusterBackend, compared)
}</span>

// check if 2 ClusterBackends are DeepEqual
func (clusterBackend ClusterBackend) IsSame(compared ClusterBackend) bool <span class="cov0" title="0">{
    return !clusterBackend.HasDiff(compared)
}</span>

// conf of cluster
type ClusterTableConf struct {
    Version *string // version of config
    Config  *AllClusterBackend
}

// check BackendConf
func BackendConfCheck(conf *BackendConf) error <span class="cov10" title="8">{
    if conf.Name == nil </span><span class="cov0" title="0">{
        return errors.New("no Name")
    }</span>

    <span class="cov10" title="8">if conf.Addr == nil </span><span class="cov0" title="0">{
        return errors.New("no Addr")
    }</span>

    <span class="cov10" title="8">if conf.Port == nil </span><span class="cov0" title="0">{
        return errors.New("no Port")
    }</span>

    <span class="cov10" title="8">if conf.Weight == nil </span><span class="cov0" title="0">{
        return errors.New("no Weight")
    }</span>

    <span class="cov10" title="8">return nil</span>
}

func (conf *AllClusterBackend) Check() error <span class="cov0" title="0">{
    return AllClusterBackendCheck(conf)
}</span>

func (sub *SubClusterBackend) Check() error <span class="cov7" title="4">{
    availBackend := false
    for index, backendConf := range *sub </span><span class="cov10" title="8">{
        err := BackendConfCheck(backendConf)

        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%d %s", index, err)
        }</span>

        <span class="cov10" title="8">if *backendConf.Weight &gt; 0 </span><span class="cov10" title="8">{
            availBackend = true
        }</span>
    }

    <span class="cov7" title="4">if !availBackend </span><span class="cov0" title="0">{
        return fmt.Errorf("no avail backend")
    }</span>

    <span class="cov7" title="4">return nil</span>
}

// check AllClusterBackend
func AllClusterBackendCheck(conf *AllClusterBackend) error <span class="cov1" title="1">{
    for clusterName, clusterBackend := range *conf </span><span class="cov4" title="2">{
        for subClusterName, subClusterBackend := range clusterBackend </span><span class="cov7" title="4">{
            if err := subClusterBackend.Check(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s %s %s", clusterName, subClusterName, err)
            }</span>
        }
    }
    <span class="cov1" title="1">return nil</span>
}

// check ClusterTableConf
func ClusterTableConfCheck(conf ClusterTableConf) error <span class="cov1" title="1">{
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    <span class="cov1" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    <span class="cov1" title="1">err := AllClusterBackendCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("ClusterTableConf.Config:%s", err.Error())
    }</span>

    <span class="cov1" title="1">return nil</span>
}

/* load config of cluster table from file

   Returns:
        (ClusterTableConf, error)
*/
func ClusterTableLoad(filename string) (ClusterTableConf, error) <span class="cov4" title="2">{
    var config ClusterTableConf

    /* open the file    */
    file, err1 := os.Open(filename)

    if err1 != nil </span><span class="cov0" title="0">{
        return config, err1
    }</span>

    /* decode the file  */
    <span class="cov4" title="2">decoder := json.NewDecoder(file)

    err2 := decoder.Decode(&amp;config)
    file.Close()

    if err2 != nil </span><span class="cov1" title="1">{
        return config, err2
    }</span>

    // check config
    <span class="cov1" title="1">err3 := ClusterTableConfCheck(config)
    if err3 != nil </span><span class="cov0" title="0">{
        return config, err3
    }</span>

    <span class="cov1" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/* cluster_conf_load.go - load cluster conf from json file  */
/*
modification history
--------------------
2014/5/19, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package gslb_conf

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
    "reflect"
)

//
// structure of gslb config:
// {"clusters":{"tieba":{"GSLB_BLACKHOLE":0,"router.orp.nj":0,
//                       "router.orp.tc":100,"router.orp.jx":0},
//              "columbus":{...},
//             },
//  "hostname":"ai-gslb-sch-20.ai01.baidu.com",
//  "ts":"20140516151616"
// }
//

// gslb conf for one cluster
type GslbClusterConf map[string]int // sub_cluster_name =&gt; weight

// gslb conf for multiple clusters
type GslbClustersConf map[string]GslbClusterConf // cluster_name =&gt; conf

// conf of GSLB
type GslbConf struct {
    Clusters *GslbClustersConf // gslb conf for multiple clusters

    // hostname of gslb scheduler,
    // e.g., "ai-gslb-sch-20.ai01.baidu.com"
    Hostname *string
    Ts       *string // timestamp, e.g., "20140516151616"
}

func (gslb GslbClustersConf) HasDiff(compared GslbClustersConf) bool <span class="cov0" title="0">{
    if len(gslb) != len(compared) </span><span class="cov0" title="0">{
        return true
    }</span>

    <span class="cov0" title="0">for cluster, gslbClusterConf := range gslb </span><span class="cov0" title="0">{
        comparedGslbClusterConf, ok := (compared)[cluster]
        if !ok </span><span class="cov0" title="0">{
            return true
        }</span>

        <span class="cov0" title="0">if gslbClusterConf.HasDiff(comparedGslbClusterConf) </span><span class="cov0" title="0">{
            return true
        }</span>
    }

    <span class="cov0" title="0">return false</span>
}

// compare 2 GslbConf
// return true if compared contains all cluster in gslbConf
// and cluster has same GslbClusterConf
func (gslbConf GslbConf) IsSub(compared GslbConf) bool <span class="cov0" title="0">{
    for cluster, gslbClusterConf := range *gslbConf.Clusters </span><span class="cov0" title="0">{
        comparedGslbClusterConf, ok := (*compared.Clusters)[cluster]
        if !ok </span><span class="cov0" title="0">{
            return false
        }</span>

        <span class="cov0" title="0">if !gslbClusterConf.IsSame(comparedGslbClusterConf) </span><span class="cov0" title="0">{
            return false
        }</span>
    }

    <span class="cov0" title="0">return true</span>
}

// check GslbClusterConf conf
func (conf GslbClusterConf) Check() error <span class="cov6" title="11">{
    total := 0
    for _, weight := range conf </span><span class="cov10" title="40">{
        if weight &gt; 0 </span><span class="cov7" title="13">{
            total += weight
        }</span>
    }

    // total &lt;= 0, no available subcluster
    <span class="cov6" title="11">if total &lt;= 0 </span><span class="cov0" title="0">{
        return errors.New("GslbClusterConf Check , total weight &lt;= 0")
    }</span>

    <span class="cov6" title="11">return nil</span>
}

// compare 2 GslbClusterConf
// return true if it's deep equal
func (conf GslbClusterConf) IsSame(compared GslbClusterConf) bool <span class="cov0" title="0">{
    return !conf.HasDiff(compared)
}</span>

func (conf GslbClusterConf) HasDiff(compared GslbClusterConf) bool <span class="cov0" title="0">{
    return !reflect.DeepEqual(conf, compared)
}</span>

func (conf GslbClustersConf) Check() error <span class="cov1" title="1">{
    for cluster, clusterConf := range conf </span><span class="cov6" title="11">{
        if err := clusterConf.Check(); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("[%s] check conf err [%s]", cluster, err)
        }</span>
    }

    <span class="cov1" title="1">return nil</span>
}

func (conf *GslbConf) Check() error <span class="cov0" title="0">{
    return GslbConfCheck(*conf)
}</span>

func GslbConfNilCheck(conf GslbConf) error <span class="cov1" title="1">{
    if conf.Clusters == nil </span><span class="cov0" title="0">{
        return errors.New("no Clusters")
    }</span>

    <span class="cov1" title="1">if conf.Hostname == nil </span><span class="cov0" title="0">{
        return errors.New("no Hostname")
    }</span>

    <span class="cov1" title="1">if conf.Ts == nil </span><span class="cov0" title="0">{
        return errors.New("no Ts")
    }</span>

    <span class="cov1" title="1">return nil</span>
}

// check GslbConf
func GslbConfCheck(conf GslbConf) error <span class="cov1" title="1">{
    if err := GslbConfNilCheck(conf); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Check Nil: %s", err)
    }</span>

    <span class="cov1" title="1">if err := conf.Clusters.Check(); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Clusters check err %s", err)
    }</span>

    <span class="cov1" title="1">return nil</span>
}

// load gslb config from file
func GslbConfLoad(filename string) (GslbConf, error) <span class="cov2" title="2">{
    var config GslbConf

    /* open the file    */
    file, err1 := os.Open(filename)

    if err1 != nil </span><span class="cov0" title="0">{
        return config, err1
    }</span>

    /* decode the file  */
    <span class="cov2" title="2">decoder := json.NewDecoder(file)

    err2 := decoder.Decode(&amp;config)
    file.Close()

    if err2 != nil </span><span class="cov1" title="1">{
        return config, err2
    }</span>

    // check config
    <span class="cov1" title="1">err3 := GslbConfCheck(config)
    if err3 != nil </span><span class="cov0" title="0">{
        return config, err3
    }</span>

    <span class="cov1" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/* bfe_config_load.go - load config for go-bfe  */
/*
modification history
--------------------
2014/4/16, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bfe_conf

import (
    "code.google.com/p/gcfg"
)

type BfeConfig struct {
    // basic server config
    Server        ConfigBasic

    // basic https config
    HttpsBasic    ConfigHttpsBasic

    // session cache config
    SessionCache  ConfigSessionCache

    // session cache config
    SessionTicket ConfigSessionTicket
}

// load config from config file
// NOTICE: some value will be modified when not set or out of range!!
// TODO: currently even when module is not used, it's configuration must be written and
// checked. need fix
func BfeConfigLoad(filePath string, confRoot string) (BfeConfig, error) <span class="cov8" title="1">{
    var cfg BfeConfig
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return cfg, err
    }</span>

    <span class="cov8" title="1">if err = cfg.Server.Check(confRoot); err != nil </span><span class="cov0" title="0">{
        return cfg, err
    }</span>

    <span class="cov8" title="1">if err = cfg.HttpsBasic.Check(confRoot); err != nil </span><span class="cov0" title="0">{
        return cfg, err
    }</span>

    <span class="cov8" title="1">if err = cfg.SessionCache.Check(confRoot); err != nil </span><span class="cov0" title="0">{
        return cfg, err
    }</span>

    <span class="cov8" title="1">if err = cfg.SessionTicket.Check(confRoot); err != nil </span><span class="cov0" title="0">{
        return cfg, err
    }</span>

    <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/* bfe_basic.go - basic conf for go-bfe */
/*
modification history
--------------------
2014/6/10, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bfe_conf

import (
    "fmt"
    "runtime"
)

import (
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

const (
    SINGLE_PROCESS_MODE = "SingleProcessMode"
    MULTI_PROCESS_MODE  = "MultiProcessMode"
)

// flag for gc switch
var AUTO_GC = false

type ConfigBasic struct {
    HttpPort    int // listen port for http
    HttpsPort   int // listen port for https
    MonitorPort int // if bfe runs in single process mode, this port is
    // web server port for monitor
    // If bfe runs in multi-process mode, this port is
    // port for monitor proxy. And the i th child process'
    // web server port is : MonitorPort + i + 1
    MaxCpus int // number of max cpus to use

    WorkMode string // go_bfe can works in two modes:
    // 1. SingleProcessMode
    //    One process with all functions. Mainly for developing purpose.
    // 2. MultiProcessMode
    //    With parent and children process. Children serve for requests
    //    and parent works as management process.

    ServiceSecs  int // time for bfe service
    OverloapSecs int // time for service overlap
    WaitingSecs  int // time for bfe waiting for long term connections
    GcSecs       int // time for bfe do gc

    // settings of communicate with http client
    ClientReadTimeout  int  // read timeout, in seconds
    ClientWriteTimeout int  // read timeout, in seconds
    MaxHeaderBytes     int  // max header length in bytes in request
    MaxHeaderUriBytes  int  // max URI(in header) length in bytes in request
    KeepAliveEnabled   bool // if false, client connection is shutdown disregard of http headers

    Modules []string // modules to load

    // location of data files for bfe_route
    HostRuleConf  string // path of host_rule.conf
    RouteRuleConf string // path of route conf

    // location of other data files
    ClusterTableConf string // path of cluster_table.conf
    GslbConf         string // path of gslb.conf
    ClusterConf      string // path of cluster_conf.conf

    // interval
    MonitorInterval int // interval for getting diff of proxy-state

    DebugServHttp    bool // whether open server http debug log
    DebugBfeRoute    bool // whether open bferoute debug log
    DebugBal         bool // whether open bal debug log
    DebugHealthCheck bool // whether open health check debug log
}

func (cfg *ConfigBasic) Check(confRoot string) error <span class="cov1" title="1">{
    return ConfBasicCheck(cfg, confRoot)
}</span>

func ConfBasicCheck(cfg *ConfigBasic, confRoot string) error <span class="cov7" title="5">{
    var err error

    // check basic conf
    err = basicConfCheck(cfg)
    if err != nil </span><span class="cov5" title="3">{
        return err
    }</span>

    // check data file conf
    <span class="cov3" title="2">err = dataFileConfCheck(cfg, confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov3" title="2">return nil</span>
}

func basicConfCheck(cfg *ConfigBasic) error <span class="cov10" title="11">{
    // check HttpPort
    if cfg.HttpPort &lt; 8000 || cfg.HttpPort &gt;= 9000 </span><span class="cov3" title="2">{
        return fmt.Errorf("HttpPort[%d] should be in (8000, 9000)",
            cfg.HttpPort)
    }</span>

    // check HttpsPort
    <span class="cov9" title="9">if cfg.HttpsPort &lt; 8000 || cfg.HttpsPort &gt;= 9000 </span><span class="cov0" title="0">{
        return fmt.Errorf("HttpsPort[%d] should be in (8000, 9000)",
            cfg.HttpsPort)
    }</span>

    // check MonitorPort
    <span class="cov9" title="9">if cfg.MonitorPort &lt; 8000 || cfg.MonitorPort &gt;= 9000 </span><span class="cov3" title="2">{
        return fmt.Errorf("MonitorPort[%d] should be in (8000, 9000)",
            cfg.MonitorPort)
    }</span>

    // check bfe work mode
    <span class="cov8" title="7">if cfg.WorkMode != SINGLE_PROCESS_MODE &amp;&amp; cfg.WorkMode != MULTI_PROCESS_MODE </span><span class="cov0" title="0">{
        return fmt.Errorf("WorkMode should be SingleProcessMode or MultiProcessMode: %s",
            cfg.WorkMode)
    }</span>

    // check MULTI_PROCESS_MODE parameters
    <span class="cov8" title="7">if cfg.WorkMode == MULTI_PROCESS_MODE </span><span class="cov6" title="4">{
        // check ServiceSecs
        if cfg.ServiceSecs &lt;= 0 </span><span class="cov1" title="1">{
            return fmt.Errorf("ServiceSecs[%d] should &gt; 0",
                cfg.ServiceSecs)
        }</span>

        // check OverloapSecs
        <span class="cov5" title="3">if cfg.OverloapSecs &lt; 0 </span><span class="cov0" title="0">{
            return fmt.Errorf("OverloapSecs[%d] should &gt;= 0",
                cfg.OverloapSecs)
        }</span>
        // check WaitingSecs
        <span class="cov5" title="3">if cfg.OverloapSecs &lt; 0 </span><span class="cov0" title="0">{
            return fmt.Errorf("WaitingSecs[%d] should &gt;= 0",
                cfg.WaitingSecs)
        }</span>

        // check GcSecs
        <span class="cov5" title="3">if cfg.GcSecs &lt; 0 </span><span class="cov0" title="0">{
            return fmt.Errorf("GcSecs[%d] should &gt;= 0",
                cfg.GcSecs)
        }</span>
    }

    // check MaxCpus
    <span class="cov7" title="6">if cfg.MaxCpus &lt; 0 </span><span class="cov1" title="1">{
        return fmt.Errorf("MaxCpus[%d] is too small", cfg.MaxCpus)
    }</span> <span class="cov7" title="5">else if cfg.MaxCpus == 0 </span><span class="cov1" title="1">{
        // use all logical CPUs on local machine
        cfg.MaxCpus = runtime.NumCPU()  
    }</span>

    // check ClientReadTimeout
    <span class="cov7" title="5">if cfg.ClientReadTimeout &lt;= 0 </span><span class="cov3" title="2">{
        return fmt.Errorf("ClientReadTimeout[%d] should &gt; 0", cfg.ClientReadTimeout)
    }</span>

    // check ClientWriteTimeout
    <span class="cov5" title="3">if cfg.ClientWriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("ClientWriteTimeout[%d] should &gt; 0", cfg.ClientWriteTimeout)
    }</span>

    // check MaxHeaderBytes
    <span class="cov5" title="3">if cfg.MaxHeaderBytes &lt; 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("MaxHeaderBytes[%d] should &gt; 0", cfg.MaxHeaderBytes)
    }</span>

    // check MaxHeaderUriBytes
    <span class="cov5" title="3">if cfg.MaxHeaderUriBytes &lt; 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("MaxHeaderUriBytes[%d] should &gt; 0", cfg.MaxHeaderUriBytes)
    }</span>

    // check MonitorInterval
    <span class="cov5" title="3">if cfg.MonitorInterval &lt;= 0 </span><span class="cov3" title="2">{
        // not set, use default value
        log.Logger.Warn("MonitorInterval not set, use default value(20)")
        cfg.MonitorInterval = 20
    }</span> <span class="cov1" title="1">else if cfg.MonitorInterval &gt; 60 </span><span class="cov0" title="0">{
        log.Logger.Warn("MonitorInterval[%d] &gt; 60, use 60", cfg.MonitorInterval)
        cfg.MonitorInterval = 60
    }</span> <span class="cov1" title="1">else {
        if 60%cfg.MonitorInterval &gt; 0 </span><span class="cov1" title="1">{
            return fmt.Errorf("MonitorInterval[%d] can not divide 60", cfg.MonitorInterval)
        }</span>

        <span class="cov0" title="0">if cfg.MonitorInterval &lt; 20 </span><span class="cov0" title="0">{
            return fmt.Errorf("MonitorInterval[%d] is too small(&lt;20)", cfg.MonitorInterval)
        }</span>
    }

    <span class="cov3" title="2">return nil</span>
}

func dataFileConfCheck(cfg *ConfigBasic, confRoot string) error <span class="cov5" title="3">{
    // check HostRuleConf
    if cfg.HostRuleConf == "" </span><span class="cov1" title="1">{
        cfg.HostRuleConf = "server_data_conf/host_rule.data"
        log.Logger.Warn("HostRuleConf not set, use default value [%s]", cfg.HostRuleConf)
    }</span>
    <span class="cov5" title="3">cfg.HostRuleConf = conf_path.ConfPathProc(cfg.HostRuleConf, confRoot)

    // check RouteRuleConf
    if cfg.RouteRuleConf == "" </span><span class="cov1" title="1">{
        cfg.RouteRuleConf = "server_data_conf/route_rule.data"
        log.Logger.Warn("RouteRuleConf not set, use default value [%s]", cfg.RouteRuleConf)
    }</span>
    <span class="cov5" title="3">cfg.RouteRuleConf = conf_path.ConfPathProc(cfg.RouteRuleConf, confRoot)

    // check ClusterTableConf
    if cfg.ClusterTableConf == "" </span><span class="cov1" title="1">{
        cfg.ClusterTableConf = "cluster_conf/cluster_table.data"
        log.Logger.Warn("ClusterTableConf not set, use default value [%s]", cfg.ClusterTableConf)
    }</span>
    <span class="cov5" title="3">cfg.ClusterTableConf = conf_path.ConfPathProc(cfg.ClusterTableConf, confRoot)

    // check GslbConf
    if cfg.GslbConf == "" </span><span class="cov1" title="1">{
        cfg.GslbConf = "cluster_conf/gslb.data"
        log.Logger.Warn("GslbConf not set, use default value [%s]", cfg.GslbConf)
    }</span>
    <span class="cov5" title="3">cfg.GslbConf = conf_path.ConfPathProc(cfg.GslbConf, confRoot)

    // check ClusterConf
    if cfg.ClusterConf == "" </span><span class="cov1" title="1">{
        cfg.ClusterConf = "server_data_conf/cluster_conf.data"
        log.Logger.Warn("ClusterConf not set, use default value [%s]", cfg.ClusterConf)
    }</span>
    <span class="cov5" title="3">cfg.ClusterConf = conf_path.ConfPathProc(cfg.ClusterConf, confRoot)

    return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/* config_https_basic.go - basic conf for https */
/*
modification history
--------------------
2015/4/16, by Sijie Yang, create
2015/9/07, by Weiwei Zhang, modify
    - add DefaultCertType to 'httpsbasic'
*/
/*
DESCRIPTION
*/
package bfe_conf

import (
    "fmt"
    "bfe_tls"
)

import (
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

const (
    RecordInitPlaintext   = 1024         // initial length of plaintext payload
    RecordBytesThreshold  = 1024 * 1024  // 1 MB
    RecordInactiveSeconds = 1            // 1 second
)

var TlsVersionMap = map[string]uint16 {
    "VersionSSL30": bfe_tls.VersionSSL30,
    "VersionTLS10": bfe_tls.VersionTLS10,
    "VersionTLS11": bfe_tls.VersionTLS11,
    "VersionTLS12": bfe_tls.VersionTLS12,
}

var CurvesMap = map[string]bfe_tls.CurveID {
    "CurveP256": bfe_tls.CurveP256,
    "CurveP384": bfe_tls.CurveP384,
    "CurveP521": bfe_tls.CurveP521,
}

var CipherSuitesMap = map[string]uint16 {
    "TLS_RSA_WITH_RC4_128_SHA"               : bfe_tls.TLS_RSA_WITH_RC4_128_SHA,
    "TLS_RSA_WITH_3DES_EDE_CBC_SHA"          : bfe_tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
    "TLS_RSA_WITH_AES_128_CBC_SHA"           : bfe_tls.TLS_RSA_WITH_AES_128_CBC_SHA,
    "TLS_RSA_WITH_AES_256_CBC_SHA"           : bfe_tls.TLS_RSA_WITH_AES_256_CBC_SHA,
    "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"       : bfe_tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
    "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"   : bfe_tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
    "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"   : bfe_tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
    "TLS_ECDHE_RSA_WITH_RC4_128_SHA"         : bfe_tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
    "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"    : bfe_tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
    "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"     : bfe_tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
    "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"     : bfe_tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"  : bfe_tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
    "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256": bfe_tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
}

type ConfigHttpsBasic struct {
    ServerCertConf          string    // config for server cert and key
    TlsRuleConf             string    // config for server tls rule 

    CipherSuites            []string  // supported cipher suites
    CurvePreferences        []string  // curve perference

    RecordInitPlaintextSize int       // init plain text size for record protocol
    RecordBytesThreshold    int       // bytes threshold for record protocol
    RecordInactiveSeconds   int       // inactive seconds for record protocol

    MaxTlsVersion           string    // max tls version supported
    MinTlsVersion           string    // min tls version supported

    EnableSslv2ClientHello  bool      // support sslv2 client hello for backward compatibility

    DefaultCertType         string    // default cert type
}

func (cfg *ConfigHttpsBasic) Check(confRoot string) error <span class="cov4" title="5">{
    // check cert file conf
    err := certConfCheck(cfg, confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // check cert rule conf
    <span class="cov4" title="5">err = certRuleCheck(cfg, confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // check CipherSuites
    <span class="cov4" title="5">for _, cipher := range(cfg.CipherSuites) </span><span class="cov10" title="46">{
        if _, ok := CipherSuitesMap[cipher]; !ok </span><span class="cov1" title="1">{
            return fmt.Errorf("cipher (%s) not support", cipher)
        }</span>
    }

    // check CurvePreferences
    <span class="cov4" title="4">for _, curve := range(cfg.CurvePreferences) </span><span class="cov4" title="4">{
        if _, ok := CurvesMap[curve]; !ok </span><span class="cov1" title="1">{
            return fmt.Errorf("curve (%s) not support", curve)
        }</span>
    }

    // check record conf
    <span class="cov3" title="3">err = recordConfCheck(cfg, confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // check tls version
    <span class="cov3" title="3">err = tlsVersionCheck(cfg)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // check default cert type
    <span class="cov3" title="3">err = defaultCertTypeCheck(cfg)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov3" title="3">return nil</span>
}

func certConfCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov4" title="5">{
    if cfg.ServerCertConf == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("ServerCertConf not set, use default value")
        cfg.ServerCertConf = "tls_conf/server_cert_conf.data"
    }</span>
    <span class="cov4" title="5">cfg.ServerCertConf = conf_path.ConfPathProc(cfg.ServerCertConf, confRoot)
    return nil</span>
}

func certRuleCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov4" title="5">{
    if cfg.TlsRuleConf == "" </span><span class="cov4" title="5">{
        log.Logger.Warn("TlsRuleConf not set, use default value")
        cfg.TlsRuleConf = "tls_conf/tls_rule_conf.data"
    }</span>
    <span class="cov4" title="5">cfg.TlsRuleConf = conf_path.ConfPathProc(cfg.TlsRuleConf, confRoot)
    return nil</span>
}

func recordConfCheck(cfg *ConfigHttpsBasic, confRoot string) error <span class="cov3" title="3">{
    // check RecordInitPlaintextSize
    if cfg.RecordInitPlaintextSize &lt; RecordInitPlaintext </span><span class="cov0" title="0">{
        cfg.RecordInitPlaintextSize = RecordInitPlaintext
        log.Logger.Warn("RecordInitPlaintextSize not set, use default value")
    }</span>

    // check RecordBytesThreshold
    <span class="cov3" title="3">if cfg.RecordBytesThreshold &lt;= 0 </span><span class="cov0" title="0">{
        cfg.RecordBytesThreshold = RecordBytesThreshold
        log.Logger.Warn("RecordBytesThreshold not set, use default value")
    }</span>

    // check RecordInactiveSeconds
    <span class="cov3" title="3">if cfg.RecordInactiveSeconds &lt;= 0 </span><span class="cov0" title="0">{
        cfg.RecordInactiveSeconds = RecordInactiveSeconds
        log.Logger.Warn("RecordInactiveSeconds not set, use default value")
    }</span>

    <span class="cov3" title="3">return nil</span>
}

func tlsVersionCheck(cfg *ConfigHttpsBasic) error <span class="cov3" title="3">{
    if len(cfg.MaxTlsVersion) == 0 </span><span class="cov3" title="3">{
        cfg.MaxTlsVersion = "VersionTLS12"
    }</span>
    <span class="cov3" title="3">if len(cfg.MinTlsVersion) == 0 </span><span class="cov3" title="3">{
        cfg.MinTlsVersion = "VersionSSL30"
    }</span>

    <span class="cov3" title="3">maxTlsVer, ok := TlsVersionMap[cfg.MaxTlsVersion]
    if !ok </span><span class="cov0" title="0">{
        return fmt.Errorf("Max TLS version(%s) not support", cfg.MaxTlsVersion)
    }</span>
    <span class="cov3" title="3">minTlsVer, ok := TlsVersionMap[cfg.MinTlsVersion]
    if !ok </span><span class="cov0" title="0">{
        return fmt.Errorf("Min TLS version(%s) not support", cfg.MinTlsVersion)
    }</span>

    <span class="cov3" title="3">if maxTlsVer &lt; minTlsVer </span><span class="cov0" title="0">{
        return fmt.Errorf("Max TLS version should not less than Min TLS version")
    }</span>

    <span class="cov3" title="3">return nil</span>
}

func defaultCertTypeCheck(cfg *ConfigHttpsBasic) error <span class="cov3" title="3">{
    if len(cfg.DefaultCertType) == 0 </span><span class="cov2" title="2">{
        log.Logger.Warn("DefaultCertType is not set, use default value(SHA1)")
        cfg.DefaultCertType = bfe_tls.CertTypeSha1
    }</span>

    <span class="cov3" title="3">if cfg.DefaultCertType != bfe_tls.CertTypeSha1 &amp;&amp;
            cfg.DefaultCertType != bfe_tls.CertTypeSha256 </span><span class="cov0" title="0">{
        return fmt.Errorf("DefaultCertType must be SHA1 or SHA256(case sensitive)")
    }</span>

    <span class="cov3" title="3">return nil</span>
}

func GetCurvePreferences(curveConf []string) ([]bfe_tls.CurveID, error) <span class="cov0" title="0">{
    curvePreferences := make([]bfe_tls.CurveID, 0, len(curveConf))
    for _, curveStr := range(curveConf) </span><span class="cov0" title="0">{
        curve, ok := CurvesMap[curveStr]
        if !ok </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("ellptic curve (%s) not support")
        }</span>
        <span class="cov0" title="0">curvePreferences = append(curvePreferences, curve)</span>
    }
    <span class="cov0" title="0">return curvePreferences, nil</span>
}

func GetCipherSuites(cipherConf []string) ([]uint16, error) <span class="cov0" title="0">{
    cipherSuites := make([]uint16, 0, len(cipherConf))
    for _, cipherStr := range(cipherConf) </span><span class="cov0" title="0">{
        cipherSuite, ok := CipherSuitesMap[cipherStr]
        if !ok </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("ciphersuite (%s) not support")
        }</span>
        <span class="cov0" title="0">cipherSuites = append(cipherSuites, cipherSuite)</span>
    }
    <span class="cov0" title="0">return cipherSuites, nil</span>
}

func GetTlsVersion(cfg *ConfigHttpsBasic) (maxVer, minVer uint16) <span class="cov0" title="0">{
    maxTlsVersion, ok := TlsVersionMap[cfg.MaxTlsVersion]
    if !ok </span><span class="cov0" title="0">{
        maxTlsVersion = bfe_tls.VersionTLS12
    }</span>

    <span class="cov0" title="0">minTlsVersion, ok := TlsVersionMap[cfg.MinTlsVersion]
    if !ok </span><span class="cov0" title="0">{
        minTlsVersion = bfe_tls.VersionSSL30
    }</span>

    <span class="cov0" title="0">return maxTlsVersion, minTlsVersion</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/* config_session_cache.go - conf for session cache */
/*
modification history
--------------------
2015/4/10, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package bfe_conf

import (
    "fmt"
    "strings"
)

type ConfigSessionCache struct {
    // disable session cache or not
    SessionCacheDisabled bool

    // tcp address for redis servers
    Servers        string  // one server or multiply servers(seperated by ',')

    // perfix for cache key
    KeyPrefix      string

    // config for connection (ms)
    ConnectTimeout int
    ReadTimeout    int
    WriteTimeout   int

    // max idle connections in pool
    MaxIdle        int

    // expire time for session cache (ms)
    SessionExpire  int
}

func (cfg *ConfigSessionCache) Check(confRoot string) error <span class="cov10" title="3">{
    return ConfSessionCacheCheck(cfg, confRoot)
}</span>

func ConfSessionCacheCheck(cfg *ConfigSessionCache, confRoot string) error <span class="cov10" title="3">{
    // check servers
    names := strings.Split(cfg.Servers, ",")
    if len(cfg.Servers) == 0 || len(names) &lt; 1 </span><span class="cov1" title="1">{
        return fmt.Errorf("Servers[%s] invalid server names", cfg.Servers)
    }</span>

    // check ReadTimeout
    <span class="cov6" title="2">if cfg.ReadTimeout &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("ReadTimeout[%d] should &gt; 0", cfg.ReadTimeout)
    }</span>

    // check WriteTimeout
    <span class="cov6" title="2">if cfg.WriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("WriteTimeout[%d] should &gt; 0", cfg.WriteTimeout)
    }</span>

    // check MaxIdle
    <span class="cov6" title="2">if cfg.MaxIdle &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("MaxIdle[%d] should &gt; 0", cfg.MaxIdle)
    }</span>

    // check SessionExpire
    <span class="cov6" title="2">if cfg.SessionExpire &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("SessionExpire[%d] should &gt; 0", cfg.SessionExpire)
    }</span>

    <span class="cov6" title="2">return nil</span>
}

</pre>
		
		<pre class="file" id="file26" style="display: none">/* config_session_ticket.go - conf for session ticket */
/*
modification history
--------------------
2015/4/10, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package bfe_conf

import (
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfigSessionTicket struct {
    // disable session cache or not
    SessionTicketsDisabled bool

    // session ticket key (in hex format)
    SessionTicketKeyFile string
}

func (cfg *ConfigSessionTicket) Check(confRoot string) error <span class="cov10" title="2">{
    return ConfSessionTicketCheck(cfg, confRoot)
}</span>

func ConfSessionTicketCheck(cfg *ConfigSessionTicket, confRoot string) error <span class="cov10" title="2">{
    // check session ticket
    if cfg.SessionTicketKeyFile == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("SessionTicketKeyFile not set, use default value")
        cfg.SessionTicketKeyFile = "tls_conf/server_ticket_key.data"
    }</span>
    <span class="cov10" title="2">cfg.SessionTicketKeyFile = conf_path.ConfPathProc(cfg.SessionTicketKeyFile, confRoot)
    return nil</span>
}

</pre>
		
		<pre class="file" id="file27" style="display: none">/* host_table_load.go - load host table from json file  */
/*
modification history
--------------------
2014/5/13, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package host_rule_conf

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

// structure of HostTable config
// {"Version":"1234",
//  "Hosts":{"news":["news.baidu.com", "news1.baidu.com"],
//            "wenku":["wenku.baidu.com", "wk.baidu.com"]},
//  "HostTags":{"news":["news"],
//              "wenku":["wenku"]},
// }
//
type HostnameList []string // list of hostname
type HostTagList []string  // list of host-tag

type HostTagToHost map[string]*HostnameList   // host-tag =&gt; hosts
type ProductToHostTag map[string]*HostTagList // product =&gt; host-tags

type Host2HostTag map[string]string    // hostname =&gt; host-tag
type HostTag2Product map[string]string // host-tag =&gt; product

type HostTableConf struct {
    Version  *string           // version of the config
    Hosts    *HostTagToHost    // host-tag =&gt; hosts
    HostTags *ProductToHostTag // product =&gt; host-tags
}

type HostConf struct {
    Version    string          // version of the config
    HostMap    Host2HostTag    // hostname =&gt; host-tag
    HostTagMap HostTag2Product // host-tag =&gt; product
}

func (conf *HostTableConf) LoadAndCheck(filename string) (string, error) <span class="cov7" title="3">{
    /* open the file    */
    file, err := os.Open(filename)
    if err != nil </span><span class="cov1" title="1">{
        return "", err
    }</span>
    <span class="cov4" title="2">defer file.Close()

    /* decode the file  */
    decoder := json.NewDecoder(file)
    if err := decoder.Decode(conf); err != nil </span><span class="cov1" title="1">{
        return "", err
    }</span>

    // check config
    <span class="cov1" title="1">if err := HostTableConfCheck(*conf); err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>

    <span class="cov1" title="1">return *(conf.Version), nil</span>
}

// check HostTableConf
func HostTableConfCheck(conf HostTableConf) error <span class="cov1" title="1">{
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    <span class="cov1" title="1">if conf.Hosts == nil </span><span class="cov0" title="0">{
        return errors.New("no Hosts")
    }</span>

    <span class="cov1" title="1">if conf.HostTags == nil </span><span class="cov0" title="0">{
        return errors.New("no HostTags")
    }</span>

    // check config for each product
    <span class="cov1" title="1">for product, hostTagList := range *conf.HostTags </span><span class="cov4" title="2">{
        if hostTagList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no HostTagList for %s", product)
        }</span>
    }

    // check config for each host-tag
    <span class="cov1" title="1">for hostTag, hostnameList := range *conf.Hosts </span><span class="cov4" title="2">{
        if hostnameList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no HostnameList for %s", hostTag)
        }</span>

        <span class="cov4" title="2">find := false
HOST_TAG_CHECK:
        // check host-tag in Hosts should exist in HostTags
        for _, hostTagList := range *conf.HostTags </span><span class="cov7" title="3">{
            for _, ht := range *hostTagList </span><span class="cov7" title="3">{
                if ht == hostTag </span><span class="cov4" title="2">{
                    find = true
                    break HOST_TAG_CHECK</span>
                }
            }
        }

        <span class="cov4" title="2">if !find </span><span class="cov0" title="0">{
            return fmt.Errorf("hostTag[%s] in Hosts should also exist in HostTags!", hostTag)
        }</span>
    }

    <span class="cov1" title="1">return nil</span>
}

/* load config of host table from file

   Returns:
        (HostConf, error)
*/
func HostRuleConfLoad(filename string) (HostConf, error) <span class="cov7" title="3">{
    var conf HostConf
    var config HostTableConf

    if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov4" title="2">{
        return conf, err
    }</span>

    /* convert HostTagToHost to Host2HostTag    */
    <span class="cov1" title="1">host2HostTag := make(Host2HostTag)

    for hostTag, hostnameList := range *config.Hosts </span><span class="cov4" title="2">{
        for _, hostName := range *hostnameList </span><span class="cov10" title="5">{
            if host2HostTag[hostName] != "" </span><span class="cov0" title="0">{
                return conf, fmt.Errorf("host duplicate for %s", hostName)
            }</span>
            <span class="cov10" title="5">host2HostTag[hostName] = hostTag</span>
        }
    }

    /* convert ProductToHostTag to HostTag2Product    */
    <span class="cov1" title="1">hostTag2Product := make(HostTag2Product)

    for product, hostTagList := range *config.HostTags </span><span class="cov4" title="2">{
        for _, hostTag := range *hostTagList </span><span class="cov4" title="2">{
            hostTag2Product[hostTag] = product
        }</span>
    }

    <span class="cov1" title="1">conf.Version = *config.Version
    conf.HostMap = host2HostTag
    conf.HostTagMap = hostTag2Product

    return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/* route_table_load.go - load route table from json file  */
/*
modification history
--------------------
2015/3/23, by Weiwei, create
*/
/*
DESCRIPTION
*/
package route_rule_conf

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
)

import (
        "bfe_basic/condition"
)

// structure of HostTable config
// {"Version":"1234",
//  "ProductRules":{"news":[{"Cond": ..., "ClusterName": ...}, ...],
// }
//

//a route rule is composed by a condition and cluster to serve
type RouteRule struct {
        Cond        condition.Condition
        ClusterName string
}

type RouteRuleFile struct {
        Cond        *string
        ClusterName *string
}

// a list of rule
type RouteRules []RouteRule
type RouteRuleFiles []RouteRuleFile

// from product to rules
type ProductRouteRule map[string]RouteRules
type ProductRouteRuleFile map[string]RouteRuleFiles

type RouteTableFile struct {
        Version     *string               // version of the config
        ProductRule *ProductRouteRuleFile // product =&gt; rules
}

type RouteTableConf struct {
        Version string // version of the config
        RuleMap ProductRouteRule
}

func convert(fileConf *RouteTableFile) (*RouteTableConf, error) <span class="cov1" title="1">{
        conf := &amp;RouteTableConf{
                RuleMap: make(ProductRouteRule),
        }

        if fileConf.Version == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no Version")
        }</span>

        <span class="cov1" title="1">if fileConf.ProductRule == nil </span><span class="cov0" title="0">{
                return nil, errors.New("no product rule")
        }</span>

        <span class="cov1" title="1">conf.Version = *fileConf.Version

        for product, ruleFiles := range *fileConf.ProductRule </span><span class="cov8" title="40">{
                rules := make(RouteRules, len(ruleFiles))
                for i, ruleFile := range ruleFiles </span><span class="cov10" title="94">{
                        if ruleFile.ClusterName == nil </span><span class="cov0" title="0">{
                                return nil, errors.New("no cluster name")
                        }</span>

                        <span class="cov10" title="94">if ruleFile.Cond == nil </span><span class="cov0" title="0">{
                                return nil, errors.New("no cond")
                        }</span>

                        <span class="cov10" title="94">rules[i].ClusterName = *ruleFile.ClusterName
                        cond, err := condition.Build(*ruleFile.Cond)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error build [%s] [%s]", *ruleFile.Cond, err)
                        }</span>
                        <span class="cov10" title="94">rules[i].Cond = cond</span>
                }

                <span class="cov8" title="40">conf.RuleMap[product] = rules</span>
        }

        <span class="cov1" title="1">return conf, nil</span>
}

func (conf *RouteTableConf) LoadAndCheck(filename string) (string, error) <span class="cov1" title="1">{
        var fileConf RouteTableFile

        // open file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        /* decode the file  */
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;fileConf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">pConf, err := convert(&amp;fileConf)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">*conf = *pConf

        return conf.Version, nil</span>
}

/* load config of route table from file

   Returns:
        (*RouteTableConf, error)
*/
func RouteConfLoad(filename string) (*RouteTableConf, error) <span class="cov1" title="1">{
        var conf RouteTableConf
        if _, err := conf.LoadAndCheck(filename); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;conf, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/* server_cert_conf_load.go - load cert conf from json file  */
/*
modification history
--------------------
2014/4/17, by Sijie Yang, create
2015/9/06, by Weiwei Zhang, support both sha1 and sha256 cert
*/
/*
DESCRIPTION
*/
package server_cert_conf

import (
    "crypto/x509"
    "encoding/json"
    "fmt"
    "io/ioutil"
    "os"
)

import (
    "www.baidu.com/golang-lib/string_slice"
)

import (
    "bfe_tls"
)

/*
   structure of Cert conf:
    {"Version":"1234", 
     "Config" :
         "Default": "cert_name1"
         "CertConf":{
               {"cert-name1":
                     {"ServerCertFile": "path/to/cert",
                      "ServerKeyFile": "path/to/key",
                      "OcspResponseFile": "path/to/ocspstapling" (optional)
                      "ServerCertFileSha256": "path/to/cert_sha256",
                      "ServerKeyFileSha256": "path/to/key_sha256",
                      "OcspResponseFileSha256": "path/to/ocspstapling_sha256" (optional)
                     },
                "cert-name2":
                     {"ServerCertFile": "path/to/cert",
                      "ServerKeyFile": "path/to/key",
                      "OcspResponseFile": "path/to/ocspstapling" (optional)
                      "ServerCertFileSha256": "path/to/cert_sha256",
                      "ServerKeyFileSha256": "path/to/key_sha256",
                      "OcspResponseFileSha256": "path/to/ocspstapling_sha256" (optional)
                     }
               }
         }
    }
*/

const (
    DefaultCert = "BFE_DEFAULT_CERT"
)

// conf of certificate
type ServerCertConf struct {
    ServerCertFile string  // path to server certificate
    ServerKeyFile  string  // path to server priavet key
    OcspResponseFile  string  // path to ocsp response file
    ServerCertFileSha256 string  // path to server certificate(sha256)
    ServerKeyFileSha256  string  // path to server priavet key(sha256)
    OcspResponseFileSha256  string  // path to ocsp response file(sha256)
}

type ServerCertConfMap struct {
    Default  string                    // default cert name
    CertConf map[string]ServerCertConf // (cert name, cert config)
}

// conf of all bfe certificate
type BfeServerCertConf struct {
    Version string              // version of config
    Config  ServerCertConfMap
}

// check ServerCertConf
func ServerCertConfCheck(conf ServerCertConf) error <span class="cov10" title="6">{
    if len(conf.ServerCertFile) == 0 &amp;&amp; len(conf.ServerCertFileSha256) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no ServerCertFile and ServerCertFileSha256")
    }</span>

    // check sha1 cert and key
    <span class="cov10" title="6">if len(conf.ServerCertFile) &gt; 0 </span><span class="cov7" title="4">{
        if _, err := os.Stat(conf.ServerCertFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
            return fmt.Errorf("server cert file not exist: %s", conf.ServerCertFile)
        }</span>

        // check ServerKeyFile
        <span class="cov7" title="4">if len(conf.ServerKeyFile) == 0 </span><span class="cov0" title="0">{
            return fmt.Errorf("no ServerKeyFile")
        }</span>
        <span class="cov7" title="4">if _, err := os.Stat(conf.ServerKeyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
            return fmt.Errorf("server key not exist: %s", conf.ServerKeyFile)
        }</span>

        // check OcspResponseFile 
        // Note: if not specified, it means Ocsp stapling is not enabled
        <span class="cov7" title="4">if len(conf.OcspResponseFile) &gt; 0 </span><span class="cov0" title="0">{
            if _, err := os.Stat(conf.OcspResponseFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("ocsp response not exist: %s", conf.OcspResponseFile)
            }</span>
        }
    }

    // check sha256 cert and key
    <span class="cov10" title="6">if len(conf.ServerCertFileSha256) &gt; 0 </span><span class="cov6" title="3">{
        if _, err := os.Stat(conf.ServerCertFileSha256); os.IsNotExist(err) </span><span class="cov0" title="0">{
            return fmt.Errorf("server sha256 cert file not exist: %s", conf.ServerCertFileSha256)
        }</span>

        // check ServerKeyFileSha256
        <span class="cov6" title="3">if len(conf.ServerKeyFileSha256) == 0 </span><span class="cov1" title="1">{
            return fmt.Errorf("no ServerKeyFileSha256")
        }</span>
        <span class="cov4" title="2">if _, err := os.Stat(conf.ServerKeyFileSha256); os.IsNotExist(err) </span><span class="cov0" title="0">{
            return fmt.Errorf("server sha256 key not exist: %s", conf.ServerKeyFileSha256)
        }</span>

        // check OcspResponseFileSha256 
        // Note: if not specified, it means Ocsp stapling is not enabled
        <span class="cov4" title="2">if len(conf.OcspResponseFileSha256) &gt; 0 </span><span class="cov0" title="0">{
            if _, err := os.Stat(conf.OcspResponseFileSha256); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("ocsp sha256 response not exist: %s", conf.OcspResponseFileSha256)
            }</span>
        }
    }

    <span class="cov9" title="5">return nil</span>
}

// check integrity of config
func BfeServerCertConfCheck(conf BfeServerCertConf) error <span class="cov7" title="4">{
    if len(conf.Version) == 0 </span><span class="cov1" title="1">{
        return fmt.Errorf("no Version")
    }</span>
    
    <span class="cov6" title="3">certConfMap := conf.Config.CertConf
    for name, certConf := range certConfMap </span><span class="cov10" title="6">{
        if name == DefaultCert </span><span class="cov0" title="0">{
            return fmt.Errorf("CertName should not be %s", DefaultCert)
        }</span>

        <span class="cov10" title="6">err := ServerCertConfCheck(certConf)
        if err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("BfeServerCertConf.Config for %s:%s", name, err.Error())
        }</span>
    }

    <span class="cov4" title="2">defaultCert := conf.Config.Default
    if _, ok := certConfMap[defaultCert]; !ok </span><span class="cov0" title="0">{
        return fmt.Errorf("BfeServerCertConf.Config default certificate %s not exit", defaultCert)
    }</span>

    <span class="cov4" title="2">return nil</span>
}

/* load config of certificate from file  
   
   Returns:
        (BfeServerCertConf, error)
*/
func ServerCertConfLoad(filename string) (BfeServerCertConf, error) <span class="cov10" title="6">{    
    var config BfeServerCertConf

    /* open the file    */
    file, err1 := os.Open(filename)
    if err1 != nil </span><span class="cov1" title="1">{
        return config, err1
    }</span>
    <span class="cov9" title="5">defer file.Close()
    
    /* decode the file  */
    decoder := json.NewDecoder(file)
    err2 := decoder.Decode(&amp;config)    
    if err2 != nil </span><span class="cov1" title="1">{
        return config, err2
    }</span>
    
    /* check conf   */
    <span class="cov7" title="4">err3 := BfeServerCertConfCheck(config)
    if err3 != nil </span><span class="cov4" title="2">{
        return config, err3
    }</span>
    
    <span class="cov4" title="2">return config, nil</span>
}

func OcspResponseLoad(filename string) ([]byte, error) <span class="cov0" title="0">{

    /* read binary data from file */
    ocspResponse, err := ioutil.ReadFile(filename)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov0" title="0">return ocspResponse, nil</span>
}

func ServerCertParse(certConf BfeServerCertConf) (map[string]*CertGroup, error) <span class="cov0" title="0">{
    certGroupMap := make(map[string]*CertGroup)

    for name, conf := range(certConf.Config.CertConf) </span><span class="cov0" title="0">{
        var certGroup CertGroup
        certGroup.Certs = make(map[string]*bfe_tls.Certificate)

        // load sha1 cert if exiting
        if len(conf.ServerCertFile) != 0 </span><span class="cov0" title="0">{
            // load x509 certificate and key
            cert, err := bfe_tls.LoadX509KeyPairSafe(conf.ServerCertFile, conf.ServerKeyFile)
            if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("in LoadX509KeyPairSafe() :%s", err.Error())
            }</span>

            // load ocsp response for stapling
            <span class="cov0" title="0">if len(conf.OcspResponseFile) != 0 </span><span class="cov0" title="0">{
                OcspResponse, err := OcspResponseLoad(conf.OcspResponseFile)
                if err != nil </span><span class="cov0" title="0">{
                    return nil, fmt.Errorf("in OcspResponseLoad() :%s", err.Error())
                }</span>
                <span class="cov0" title="0">cert.OCSPStaple = OcspResponse</span>
            }
            <span class="cov0" title="0">certGroup.Certs[bfe_tls.CertTypeSha1] = &amp;cert</span>
        }
        // load sha256 cert if existing
        <span class="cov0" title="0">if len(conf.ServerCertFileSha256) != 0 </span><span class="cov0" title="0">{
            // load x509 certificate and key
            certSha256, err := bfe_tls.LoadX509KeyPairSafe(conf.ServerCertFileSha256, conf.ServerKeyFileSha256)
            if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("in LoadX509KeyPairSafe() :%s", err.Error())
            }</span>

            // load ocsp sha256 response for stapling
            <span class="cov0" title="0">if len(conf.OcspResponseFileSha256) != 0 </span><span class="cov0" title="0">{
                OcspResponseSha256, err := OcspResponseLoad(conf.OcspResponseFileSha256)
                if err != nil </span><span class="cov0" title="0">{
                    return nil, fmt.Errorf("in OcspResponseLoad() :%s", err.Error())
                }</span>
                <span class="cov0" title="0">certSha256.OCSPStaple = OcspResponseSha256</span>
            }
            <span class="cov0" title="0">certGroup.Certs[bfe_tls.CertTypeSha256] = &amp;certSha256</span>
        }
        <span class="cov0" title="0">certGroupMap[name] = &amp;certGroup</span>
    }

    <span class="cov0" title="0">certGroupMap[DefaultCert] = certGroupMap[certConf.Config.Default]
    return certGroupMap, nil</span>
}

// Certificates for the same subject with different type (sha1,sha256)
type CertGroup struct {
    Certs map[string]*bfe_tls.Certificate // cert type -&gt; certificate
}

func (c *CertGroup) GetCert(preferredCertType string) *bfe_tls.Certificate <span class="cov0" title="0">{
    // get preferred cert if this type of cert is configured
    if cert, ok := c.Certs[preferredCertType]; ok </span><span class="cov0" title="0">{
        return cert
    }</span>

    // get cert according to the following priority: SHA256, SHA1
    // usually, this only happened when only one cert is configured
    <span class="cov0" title="0">if c.Certs[bfe_tls.CertTypeSha256] != nil </span><span class="cov0" title="0">{
        return c.Certs[bfe_tls.CertTypeSha256]
    }</span> <span class="cov0" title="0">else {
        return c.Certs[bfe_tls.CertTypeSha1]
    }</span>
}

func (c *CertGroup) GetNames() []string <span class="cov0" title="0">{
    cert1 := c.Certs[bfe_tls.CertTypeSha1]
    cert2 := c.Certs[bfe_tls.CertTypeSha256]

    if cert1 != nil &amp;&amp; cert2 == nil </span><span class="cov0" title="0">{
        return getNamesForCert(cert1)
    }</span> <span class="cov0" title="0">else if cert1 == nil &amp;&amp; cert2 != nil </span><span class="cov0" title="0">{
        return getNamesForCert(cert2)
    }</span> <span class="cov0" title="0">else if cert1 != nil &amp;&amp; cert2 != nil </span><span class="cov0" title="0">{
        names1 := getNamesForCert(cert1)
        names2 := getNamesForCert(cert2)

        // names for different type of certs should be same. If not,
        // just use the intersection of both
        names := make([]string, 0)
        for _, name := range(names1) </span><span class="cov0" title="0">{
            if string_slice.InSlice(name, names2) </span><span class="cov0" title="0">{
                names = append(names, name)
            }</span>
        }
        <span class="cov0" title="0">return names</span>
    } <span class="cov0" title="0">else {
        return nil
    }</span>
}

// get all subject names of cert
func getNamesForCert(cert *bfe_tls.Certificate) []string <span class="cov0" title="0">{
    // parse certificate
    x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
    if err != nil </span><span class="cov0" title="0">{
        return nil
    }</span>

    // get subject name and alternative name of cert
    <span class="cov0" title="0">names := make([]string, 0)
    if len(x509Cert.Subject.CommonName) &gt; 0 </span><span class="cov0" title="0">{
        names = append(names, x509Cert.Subject.CommonName)
    }</span>
    <span class="cov0" title="0">for _, san := range x509Cert.DNSNames </span><span class="cov0" title="0">{
        names = append(names, san)
    }</span>

    <span class="cov0" title="0">return names</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/* session_ticket_key_conf.go - load session ticket key from json file  */
/*
modification history
--------------------
2014/4/17, by Sijie Yang, create
2014/5/29, by Sijie Yang, modify
    - make session ticket key be compatible with OpenSSL
*/
/*
DESCRIPTION
*/
package session_ticket_key_conf 

import (
    "encoding/hex"
    "encoding/json"
    "fmt"
    "os"
)

/*
   structure of Cert conf:
    {"Version":"1234", 
     "SessionTicketKey": "hex-encoded-data"
    }
*/

// config for session ticket key
type SessionTicketKeyConf struct {
    Version          string    // version of config
    SessionTicketKey string    // session ticket key
}

// check integrity of config
func SessionTicketKeyConfCheck(conf SessionTicketKeyConf) error <span class="cov6" title="2">{
    if len(conf.Version) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no Version")
    }</span>
    
    <span class="cov6" title="2">key, err := hex.DecodeString(conf.SessionTicketKey)
    if err != nil </span><span class="cov1" title="1">{
        return fmt.Errorf("session ticket key %s(%s)", err.Error(), conf.SessionTicketKey)
    }</span> 
    <span class="cov1" title="1">if len(key) != 48 </span><span class="cov0" title="0">{
        return fmt.Errorf("session ticket key should be 96 bytes hex string (%s)", conf.SessionTicketKey)
    }</span>

    <span class="cov1" title="1">return nil</span>
}


/* load session ticket key from file  
   
   Returns:
        (BfeSessionTicketKeyConf, error)
*/
func SessionTicketKeyConfLoad(filename string) (SessionTicketKeyConf, error) <span class="cov10" title="3">{    
    var config SessionTicketKeyConf

    /* open the file    */
    file, err1 := os.Open(filename)
    if err1 != nil </span><span class="cov1" title="1">{
        return config, err1
    }</span>
    <span class="cov6" title="2">defer file.Close()
    
    /* decode the file  */
    decoder := json.NewDecoder(file)
    err2 := decoder.Decode(&amp;config)    
    if err2 != nil </span><span class="cov0" title="0">{
        return config, err2
    }</span>
    
    /* check conf   */
    <span class="cov6" title="2">err3 := SessionTicketKeyConfCheck(config)
    if err3 != nil </span><span class="cov1" title="1">{
        return config, err3
    }</span>
    
    <span class="cov1" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/* cert_rule_conf_load.go - load cert rule conf from json file */
/*
modification history
--------------------
2015/7/21, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package tls_rule_conf

import (
    "encoding/json"
    "fmt"
    "net"
    "os"
)

/*
   structure of rule conf:
    {"Version":"1234", 
     "Config": {
         "baike": {
             "CertName": "*.baidu.com",
             "NextProtos": ["spdy/3.1", "spdy/3", "spdy/2"],
             "VipConf": ["123.125.70.105", "61.135.185.24"]
         },
         "news": {
             "CertName": "*.baidu.com",
             "NextProtos": ["spdy/3.1", "spdy/3", "spdy/2"],
             "VipConf": ["61.135.185.119" ]
         }
     },
    }
*/

// application protocols
const (
    SPDY31 = "spdy/3.1"
    SPDY3  = "spdy/3"
    SPDY2  = "spdy/2"
    HTTP11 = "http/1.1"
)

var validNextProtos = []string{SPDY31, SPDY3, SPDY2, HTTP11}

type TlsRuleConf struct {
    CertName   string     // name of certificate
    NextProtos []string   // next protos over TLS
    VipConf    []string   // list of vips for product
}

type TlsRuleMap map[string]TlsRuleConf // product -&gt; tls rule conf

// conf of all bfe certificate
type BfeTlsRuleConf struct {
    Version string              // version of config
    Config  TlsRuleMap
}

// check ServerCertConf
func TlsRuleConfCheck(conf TlsRuleConf) error <span class="cov3" title="2">{
    if len(conf.CertName) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no CertName")
    }</span>

    <span class="cov3" title="2">if err := checkNextProtos(conf.NextProtos); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov3" title="2">for i, vip := range(conf.VipConf) </span><span class="cov5" title="3">{
        if net.ParseIP(vip) == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("invalid vip (%d) %s", i, vip)
        }</span>
    }
    <span class="cov3" title="2">return nil</span>
}

func checkNextProtos(nextProtos []string) error <span class="cov3" title="2">{
    if len(nextProtos) == 0 </span><span class="cov1" title="1">{
        return nil
    }</span>

    <span class="cov1" title="1">for _, proto := range(nextProtos) </span><span class="cov6" title="4">{
        if !checkValidProto(proto) </span><span class="cov0" title="0">{
            return fmt.Errorf("invalid proto (%s) in NextProtos", proto)
        }</span>
    }

    <span class="cov1" title="1">if !checkContainHTTP(nextProtos) </span><span class="cov0" title="0">{
        return fmt.Errorf("no \"http/1.1\" in nonempty NextProtos")
    }</span>

    <span class="cov1" title="1">return nil</span>
}

func checkValidProto(proto string) bool <span class="cov6" title="4">{
    for _, validProto := range(validNextProtos) </span><span class="cov10" title="10">{
        if proto == validProto </span><span class="cov6" title="4">{
            return true
        }</span>
    }
    <span class="cov0" title="0">return false</span>
}

func checkContainHTTP(nextProtos []string) bool <span class="cov1" title="1">{
    for _, nextProto := range(nextProtos) </span><span class="cov6" title="4">{
        if nextProto == HTTP11 </span><span class="cov1" title="1">{
            return true
        }</span>
    }
    <span class="cov0" title="0">return false</span>
}

// check integrity of config
func BfeTlsRuleConfCheck(conf BfeTlsRuleConf) error <span class="cov1" title="1">{
    if len(conf.Version) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no Version")
    }</span>

    <span class="cov1" title="1">if conf.Config == nil </span><span class="cov0" title="0">{
        return fmt.Errorf("no Config")
    }</span>

    <span class="cov1" title="1">for product, rule := range(conf.Config) </span><span class="cov3" title="2">{
        if err := TlsRuleConfCheck(rule); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("BfeTlsRuleConfCheck(): %s wrong rule %s", product, err)
        }</span>
    }

    <span class="cov1" title="1">return nil</span>
}


/* load config of rule from file  
   
   Returns:
        (BfeTlsRuleConf, error)
*/
func TlsRuleConfLoad(filename string) (BfeTlsRuleConf, error) <span class="cov6" title="4">{    
    var config BfeTlsRuleConf

    /* open the file */
    file, err := os.Open(filename)
    if err != nil </span><span class="cov5" title="3">{
        return config, err
    }</span>
    <span class="cov1" title="1">defer file.Close()
    
    /* decode the file */
    decoder := json.NewDecoder(file)
    err = decoder.Decode(&amp;config)    
    if err != nil </span><span class="cov0" title="0">{
        return config, err
    }</span>
    
    /* check conf */
    <span class="cov1" title="1">err = BfeTlsRuleConfCheck(config)
    if err != nil </span><span class="cov0" title="0">{
        return config, err
    }</span>
    
    <span class="cov1" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/* cluster_table.go - table for maintain backend cluster    */
/*
modification history
--------------------
2014/5/5, by Zhang Miao, create
2015/4/12, by caodong, move from src/bfe_balance
        move gslb refer struct to BalTable
*/
/*
DESCRIPTION
*/
package bfe_data

import "fmt"

import (
        "bfe_config/bfe_cluster_conf/cluster_conf"
        "bfe_data/bfe_cluster"

        "www.baidu.com/golang-lib/log"
)

// map from clusterName to cluster
type ClusterMap map[string]*bfe_cluster.BfeCluster

/* cluster table    */
type ClusterTable struct {
        clusterTable ClusterMap
        versions     ClusterVersion
}

// data version in cluster table
type ClusterVersion struct {
        ClusterConfVer string // version of cluster-conf
}

// create new ClusterTable
func newClusterTable() *ClusterTable <span class="cov10" title="5">{
        ct := new(ClusterTable)
        return ct
}</span>

func (t *ClusterTable) Init(clusterConfFilename string) error <span class="cov8" title="4">{
        // init cluster basic
        t.clusterTable = make(ClusterMap)
        clusterConf, err := cluster_conf.ClusterConfLoad(clusterConfFilename)
        if err != nil </span><span class="cov4" title="2">{
                return err
        }</span>

        <span class="cov4" title="2">t.BasicInit(clusterConf)

        log.Logger.Info("init cluster table success")
        return nil</span>
}

func (t *ClusterTable) BasicInit(clusterConfs cluster_conf.BfeClusterConf) <span class="cov4" title="2">{
        t.clusterTable = make(ClusterMap)

        for clusterName, clusterConf := range *clusterConfs.Config </span><span class="cov8" title="4">{
                // create new cluster
                cluster := bfe_cluster.NewBfeCluster(clusterName)

                // initialize
                cluster.BasicInit(clusterConf)
                // add cluster to clusterTable
                t.clusterTable[clusterName] = cluster
        }</span>

        <span class="cov4" title="2">t.versions.ClusterConfVer = *clusterConfs.Version</span>
}

/* Find backend with given cluster-name and request */
func (t *ClusterTable) Lookup(clusterName string) (*bfe_cluster.BfeCluster, error) <span class="cov7" title="3">{
        // lookup in cluster table
        cluster, ok := t.clusterTable[clusterName]
        if !ok </span><span class="cov4" title="2">{
                return cluster, fmt.Errorf("no cluster found for %s", clusterName)
        }</span>

        <span class="cov1" title="1">return cluster, nil</span>
}

// get versions
func (t *ClusterTable) GetVersions() ClusterVersion <span class="cov0" title="0">{
        return t.versions
}</span>

func (t *ClusterTable) ClusterMap() ClusterMap <span class="cov0" title="0">{
        return t.clusterTable
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/* host_table.go - table for mapping hostname to cluster name   */
/*
modification history
--------------------
2014/5/5, by Zhang Miao, create
2014/6/30, by Zhang Miao, move to src/bfe_route
2015/3/23, by Wei wei, remove path/query/cookie/tag2cluster
2015/4/12, by caodong, come from src/bfe_route
*/
/*
DESCRIPTION
*/
package bfe_data

import (
        "errors"
        "strings"
)

import (
        "bfe_basic"
        "bfe_config/bfe_route_conf/host_rule_conf"
        "bfe_config/bfe_route_conf/route_rule_conf"
        "bfe_data/trie"
)

var (
        ErrNoProduct     = errors.New("no product found")
        ErrNoProductRule = errors.New("no route rule found for product")
        ErrNoMatchRule   = errors.New("no rule match for this req")
)

// host table
// contain host -&gt; product and product -&gt; cluster rules
type HostTable struct {
        versions Versions // record conf versions

        hostTable    host_rule_conf.Host2HostTag    // for get host-tag
        hostTagTable host_rule_conf.HostTag2Product // for get product name

        hostTrie          *trie.Trie
        productRouteTable route_rule_conf.ProductRouteRule // all product's route rules
}

type Versions struct {
        HostTag      string // version of host-tag
        ProductRoute string // version of product route rule
}

type Status struct {
        HostTableSize         int
        HostTagTableSize      int
        ProductRouteTableSize int
}

type route struct {
        product string
        tag     string
}

// create new HostTable
func newHostTable() *HostTable <span class="cov2" title="6">{
        t := new(HostTable)
        return t
}</span>

// update host-tag related table
func (t *HostTable) updateHostTable(conf host_rule_conf.HostConf) <span class="cov1" title="3">{
        t.versions.HostTag = conf.Version
        t.hostTable = conf.HostMap
        t.hostTagTable = conf.HostTagMap
        t.hostTrie = buildHostRoute(conf)
}</span>

// update product Route Rule
func (t *HostTable) updateRouteTable(conf *route_rule_conf.RouteTableConf) <span class="cov1" title="3">{
        t.versions.ProductRoute = conf.Version
        t.productRouteTable = conf.RuleMap
}</span>

// update all
func (t *HostTable) Update(hostConf host_rule_conf.HostConf,
        routeConf *route_rule_conf.RouteTableConf) <span class="cov1" title="3">{

        t.updateHostTable(hostConf)
        t.updateRouteTable(routeConf)
}</span>

// Find cluster name with given hostname
func (t *HostTable) Lookup(req *bfe_basic.Request) bfe_basic.RequestRoute <span class="cov2" title="4">{
        route := bfe_basic.RequestRoute{}

        hostRoute, err := findHostRoute(t.hostTrie, req.HttpRequest.Host)
        if err != nil </span><span class="cov1" title="2">{
                route.Error = err
                return route
        }</span>

        <span class="cov1" title="2">route.HostTag = hostRoute.tag
        route.Product = hostRoute.product

        rules, ok := t.productRouteTable[route.Product]
        if !ok </span><span class="cov0" title="0">{
                route.Error = ErrNoProductRule
                return route
        }</span>

        <span class="cov1" title="2">for _, rule := range rules </span><span class="cov1" title="2">{
                if rule.Cond.Match(req) </span><span class="cov1" title="2">{
                        route.ClusterName = rule.ClusterName
                        break</span>
                }
        }

        <span class="cov1" title="2">if route.ClusterName == "" </span><span class="cov0" title="0">{
                route.Error = ErrNoMatchRule
        }</span>

        <span class="cov1" title="2">return route</span>
}

/* Get versions of host table   */
func (t *HostTable) GetVersions() Versions <span class="cov0" title="0">{
        return t.versions
}</span>

/* Get status of host table   */
func (t *HostTable) GetStatus() Status <span class="cov1" title="1">{
        var s Status
        s.ProductRouteTableSize = len(t.productRouteTable)
        s.HostTableSize = len(t.hostTable)
        s.HostTagTableSize = len(t.hostTagTable)
        return s
}</span>

// remove ":port" in hostname
func hostnameStrip(hostname string) string <span class="cov2" title="9">{
        return strings.Split(hostname, ":")[0]
}</span>

// reverse host to make prefix tree smaller
// i.e.: www.baidu.com news.baidu.com -&gt; moc.udiab.swen moc.udiab.www will have same prefix
func reverseFqdnHost(host string) string <span class="cov8" title="3179">{
        r := []rune(host)
        for i, j := 0, len(r)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov10" title="27088">{
                r[i], r[j] = r[j], r[i]
        }</span>

        <span class="cov8" title="3179">if len(r) &gt; 0 &amp;&amp; r[0] == '.' </span><span class="cov1" title="1">{
                r = r[1:]
        }</span>

        <span class="cov8" title="3179">return string(r)</span>
}

func findHostRoute(hostTrie *trie.Trie, host string) (route, error) <span class="cov2" title="9">{
        if hostTrie == nil </span><span class="cov0" title="0">{
                return route{}, ErrNoProduct
        }</span>

        <span class="cov2" title="9">host = strings.ToLower(host)
        // get host-tag by hostname
        match, ok := hostTrie.Get(strings.Split(reverseFqdnHost(hostnameStrip(host)), "."))
        if !ok </span><span class="cov1" title="3">{
                return route{}, ErrNoProduct
        }</span>

        <span class="cov2" title="6">return match.(route), nil</span>
}

func buildHostRoute(conf host_rule_conf.HostConf) *trie.Trie <span class="cov2" title="4">{
        hostTrie := trie.NewTrie()

        for host, tag := range conf.HostMap </span><span class="cov8" title="3170">{
                host = strings.ToLower(host)
                product := conf.HostTagMap[tag]
                hostTrie.Set(strings.Split(reverseFqdnHost(host), "."), route{product: product, tag: tag})
        }</span>

        <span class="cov2" title="4">return hostTrie</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/* server_data_conf.go - for route traffic to backend cluster
/*
modification history
--------------------
2015/04/05, by caodong create
*/
/*
DESCRIPTION

*/
package bfe_data

import (
    "fmt"
    "www.baidu.com/golang-lib/log"
)

import (
    "bfe_config/bfe_route_conf/host_rule_conf"
    "bfe_config/bfe_route_conf/route_rule_conf"
)

type ServerDataConf struct {
    HostTable       *HostTable
    ClusterTable    *ClusterTable
}

// create new ServerDataConf
func newServerDataConf() *ServerDataConf <span class="cov8" title="4">{
    c := new(ServerDataConf)

    // initialize HostTable &amp; ClusterTable
    c.HostTable = newHostTable()
    c.ClusterTable = newClusterTable()

    return c
}</span>

// load ServerDataConf
func LoadServerDataConf(hostFile, routeFile, clusterConfFile string) (*ServerDataConf, error) <span class="cov4" title="2">{
    s := newServerDataConf()

    // load host table
    if err := s.hostTableLoad(hostFile, routeFile); err != nil </span><span class="cov4" title="2">{
        return nil, fmt.Errorf("hostTableLoad Error %s", err)
    }</span>

    // load cluster table
    <span class="cov0" title="0">if err := s.clusterTableLoad(clusterConfFile); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("clusterTableLoad Error %s", err)
    }</span>

    // check host, route, cluster_conf dependent relationship
    <span class="cov0" title="0">if err := s.check(); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("ServerDataConf.check Error %s", err)
    }</span>

    <span class="cov0" title="0">return s, nil</span>
}

// load all data for host table from file
func (s *ServerDataConf) hostTableLoad(hostFile, routeFile string) error <span class="cov10" title="5">{
        // load host rule from file
        hostConf, err := host_rule_conf.HostRuleConfLoad(hostFile)
        if err != nil </span><span class="cov7" title="3">{
                log.Logger.Error("hostTableLoad():err in HostRuleConfLoad():%s", err.Error())
                return err
        }</span>

        // load route conf from file
        <span class="cov4" title="2">routeConf, err := route_rule_conf.RouteConfLoad(routeFile)
        if err != nil </span><span class="cov1" title="1">{
                log.Logger.Error("hostTableLoad():err in RouteConfLoad():%s", err.Error())
                return err
        }</span>

        // update to host table
        <span class="cov1" title="1">s.HostTable.Update(hostConf, routeConf)
        return nil</span>
}

// init load for cluster table
func (s *ServerDataConf) clusterTableLoad(clusterConf string) error <span class="cov4" title="2">{
        err := s.ClusterTable.Init(clusterConf)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">log.Logger.Info("init cluster table success")
        return nil</span>
}

// check host, route, cluster_conf dependent relationship
func (s *ServerDataConf) check() error <span class="cov0" title="0">{
    // check product consistency in host and route
    for product1 := range s.HostTable.productRouteTable </span><span class="cov0" title="0">{
        find := false
        for _, product2 := range s.HostTable.hostTagTable </span><span class="cov0" title="0">{
            if product1 == product2 </span><span class="cov0" title="0">{
                find = true
                break</span>
            }
        }
        <span class="cov0" title="0">if !find </span><span class="cov0" title="0">{
            return fmt.Errorf("product[%s] in route should exist in host!", product1)
        }</span>
    }

    // check cluster_name consistency in route and cluster_conf
    <span class="cov0" title="0">for _, routeRules := range s.HostTable.productRouteTable </span><span class="cov0" title="0">{
        for _, routeRule := range routeRules </span><span class="cov0" title="0">{
            if _, err := s.ClusterTable.Lookup(routeRule.ClusterName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cluster[%s] in route should exist in cluster_conf", 
                                  routeRule.ClusterName)
            }</span>
        }
    }

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package trie implements a simple trie data structure that maps "paths" (which
// are slices of strings) to arbitrary data values (type interface{}).
package trie

import "errors"

type trieChildren map[string]*Trie

type Trie struct {
        Entry      interface{}
        SplatEntry interface{} // to match xxx.xxx.*
        Children   trieChildren
}

// NewTrie makes a new empty Trie
func NewTrie() *Trie <span class="cov8" title="8">{
        return &amp;Trie{
                Children: make(trieChildren),
        }
}</span>

// Get retrieves an element from the Trie
//
// Takes a path (which can be empty, to denote the root element of the Trie),
// and returns the object if the path exists in the Trie, or nil and a status of
// false. Example:
//
//     if res, ok := trie.Get([]string{"foo", "bar"}), ok {
//       fmt.Println("Value at /foo/bar was", res)
//     }
func (t *Trie) Get(path []string) (entry interface{}, ok bool) <span class="cov8" title="9">{
        if len(path) == 0 </span><span class="cov1" title="1">{
                return t.getentry()
        }</span>

        <span class="cov8" title="8">key := path[0]
        newpath := path[1:]

        res, ok := t.Children[key]
        if ok </span><span class="cov7" title="6">{
                entry, ok = res.Get(newpath)
        }</span>

        <span class="cov8" title="8">if entry == nil &amp;&amp; t.SplatEntry != nil </span><span class="cov1" title="1">{
                entry = t.SplatEntry
                ok = true
        }</span>

        <span class="cov8" title="8">return</span>
}

// Set creates an element in the Trie
//
// Takes a path (which can be empty, to denote the root element of the Trie),
// and an arbitrary value (interface{}) to use as the leaf data.
func (t *Trie) Set(path []string, value interface{}) error <span class="cov10" title="12">{
        if len(path) == 0 </span><span class="cov4" title="3">{
                t.setentry(value)
                return nil
        }</span>

        <span class="cov8" title="9">if path[0] == "*" </span><span class="cov1" title="1">{
                if len(path) != 1 </span><span class="cov0" title="0">{
                        return errors.New("* should be last element")
                }</span>
                <span class="cov1" title="1">t.SplatEntry = value</span>
        }

        <span class="cov8" title="9">key := path[0]
        newpath := path[1:]

        res, ok := t.Children[key]
        if !ok </span><span class="cov8" title="7">{
                // Trie node that should hold entry doesn't already exist, so let's create it
                res = NewTrie()
                t.Children[key] = res
        }</span>

        <span class="cov8" title="9">return res.Set(newpath, value)</span>
}

func (t *Trie) setentry(value interface{}) <span class="cov4" title="3">{
        t.Entry = value
}</span>

func (t *Trie) getentry() (entry interface{}, ok bool) <span class="cov1" title="1">{
        return t.Entry, t.Entry != nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The wire protocol for HTTP's "chunked" Transfer-Encoding.

// This code is duplicated in httputil/chunked.go.
// Please make any changes in both files.

package bfe_http

import (
        "errors"
        "fmt"
        "io"
)

import (
    "bfe_bufio"
)

const maxLineLength = 4096 // assumed &lt;= bufio.defaultBufSize

var ErrLineTooLong = errors.New("header line too long")

// newChunkedReader returns a new chunkedReader that translates the data read from r
// out of HTTP "chunked" format before returning it.
// The chunkedReader returns io.EOF when the final 0-length chunk is read.
//
// newChunkedReader is not needed by normal applications. The http package
// automatically decodes chunking when reading response bodies.
func newChunkedReader(r io.Reader) io.Reader <span class="cov3" title="9">{
        br, ok := r.(*bfe_bufio.Reader)
        if !ok </span><span class="cov1" title="2">{
                br = bfe_bufio.NewReader(r)
        }</span>
        <span class="cov3" title="9">return &amp;chunkedReader{r: br}</span>
}

type chunkedReader struct {
        r   *bfe_bufio.Reader
        n   uint64 // unread bytes in chunk
        err error
        buf [2]byte
}

func (cr *chunkedReader) beginChunk() <span class="cov8" title="1212">{
        // chunk-size CRLF
        var line []byte
        line, cr.err = readLine(cr.r)
        if cr.err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1212">cr.n, cr.err = parseHexUint(line)
        if cr.err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1212">if cr.n == 0 </span><span class="cov3" title="9">{
                cr.err = io.EOF
        }</span>
}

func (cr *chunkedReader) Read(b []uint8) (n int, err error) <span class="cov8" title="1582">{
        if cr.err != nil </span><span class="cov2" title="5">{
                return 0, cr.err
        }</span>
        <span class="cov8" title="1577">if cr.n == 0 </span><span class="cov8" title="1212">{
                cr.beginChunk()
                if cr.err != nil </span><span class="cov3" title="9">{
                        return 0, cr.err
                }</span>
        }
        <span class="cov8" title="1568">if uint64(len(b)) &gt; cr.n </span><span class="cov8" title="1445">{
                b = b[0:cr.n]
        }</span>
        <span class="cov8" title="1568">n, cr.err = cr.r.Read(b)
        cr.n -= uint64(n)
        if cr.n == 0 &amp;&amp; cr.err == nil </span><span class="cov8" title="1203">{
                // end of chunk (CRLF)
                if _, cr.err = io.ReadFull(cr.r, cr.buf[:]); cr.err == nil </span><span class="cov8" title="1203">{
                        if cr.buf[0] != '\r' || cr.buf[1] != '\n' </span><span class="cov0" title="0">{
                                cr.err = errors.New("malformed chunked encoding")
                        }</span>
                }
        }
        <span class="cov8" title="1568">return n, cr.err</span>
}

// Read a line of bytes (up to \n) from b.
// Give up if the line exceeds maxLineLength.
// The returned bytes are a pointer into storage in
// the bufio, so they are only valid until the next bufio read.
func readLine(b *bfe_bufio.Reader) (p []byte, err error) <span class="cov8" title="1212">{
        if p, err = b.ReadSlice('\n'); err != nil </span><span class="cov0" title="0">{
                // We always know when EOF is coming.
                // If the caller asked for a line, there should be a line.
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span> <span class="cov0" title="0">else if err == bfe_bufio.ErrBufferFull </span><span class="cov0" title="0">{
                        err = ErrLineTooLong
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1212">if len(p) &gt;= maxLineLength </span><span class="cov0" title="0">{
                return nil, ErrLineTooLong
        }</span>
        <span class="cov8" title="1212">return trimTrailingWhitespace(p), nil</span>
}

func trimTrailingWhitespace(b []byte) []byte <span class="cov8" title="1212">{
        for len(b) &gt; 0 &amp;&amp; isASCIISpace(b[len(b)-1]) </span><span class="cov8" title="2424">{
                b = b[:len(b)-1]
        }</span>
        <span class="cov8" title="1212">return b</span>
}

func isASCIISpace(b byte) bool <span class="cov9" title="3636">{
        return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}</span>

// newChunkedWriter returns a new chunkedWriter that translates writes into HTTP
// "chunked" format before writing them to w. Closing the returned chunkedWriter
// sends the final 0-length chunk that marks the end of the stream.
//
// newChunkedWriter is not needed by normal applications. The http
// package adds chunking automatically if handlers don't set a
// Content-Length header. Using newChunkedWriter inside a handler
// would result in double chunking or chunking with a Content-Length
// length, both of which are wrong.
func newChunkedWriter(w io.Writer) io.WriteCloser <span class="cov3" title="14">{
        return &amp;chunkedWriter{w}
}</span>

// Writing to chunkedWriter translates to writing in HTTP chunked Transfer
// Encoding wire format to the underlying Wire chunkedWriter.
type chunkedWriter struct {
        Wire io.Writer
}

// Write the contents of data as one chunk to Wire.
// NOTE: Note that the corresponding chunk-writing procedure in Conn.Write has
// a bug since it does not check for success of io.WriteString
func (cw *chunkedWriter) Write(data []byte) (n int, err error) <span class="cov8" title="1207">{

        // Don't send 0-length data. It looks like EOF for chunked encoding.
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1207">if _, err = fmt.Fprintf(cw.Wire, "%x\r\n", len(data)); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1207">if n, err = cw.Wire.Write(data); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1207">if n != len(data) </span><span class="cov0" title="0">{
                err = io.ErrShortWrite
                return
        }</span>
        <span class="cov8" title="1207">_, err = io.WriteString(cw.Wire, "\r\n")

        return</span>
}

func (cw *chunkedWriter) Close() error <span class="cov3" title="12">{
        _, err := io.WriteString(cw.Wire, "0\r\n")
        return err
}</span>

func parseHexUint(v []byte) (n uint64, err error) <span class="cov8" title="2448">{
        for _, b := range v </span><span class="cov10" title="6839">{
                n &lt;&lt;= 4
                switch </span>{
                <span class="cov9" title="4914">case '0' &lt;= b &amp;&amp; b &lt;= '9':
                        b = b - '0'</span>
                <span class="cov8" title="1924">case 'a' &lt;= b &amp;&amp; b &lt;= 'f':
                        b = b - 'a' + 10</span>
                <span class="cov0" title="0">case 'A' &lt;= b &amp;&amp; b &lt;= 'F':
                        b = b - 'A' + 10</span>
                <span class="cov1" title="1">default:
                        return 0, errors.New("invalid byte in chunk length")</span>
                }
                <span class="cov9" title="6838">n |= uint64(b)</span>
        }
        <span class="cov8" title="2447">return</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/* client.go - http client  */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
*/
/*
DESCRIPTION
This file is derived from net/http/client.go
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP client. See RFC 2616.
//
// This is the high-level Client interface.
// The low-level implementation is in transport.go.

package bfe_http

import (
        "encoding/base64"
        "errors"
        "io"
        "strings"
)

import (
    "www.baidu.com/golang-lib/log"
)

// RoundTripper is an interface representing the ability to execute a
// single HTTP transaction, obtaining the Response for a given Request.
//
// A RoundTripper must be safe for concurrent use by multiple
// goroutines.
type RoundTripper interface {
        // RoundTrip executes a single HTTP transaction, returning
        // the Response for the request req.  RoundTrip should not
        // attempt to interpret the response.  In particular,
        // RoundTrip must return err == nil if it obtained a response,
        // regardless of the response's HTTP status code.  A non-nil
        // err should be reserved for failure to obtain a response.
        // Similarly, RoundTrip should not attempt to handle
        // higher-level protocol details such as redirects,
        // authentication, or cookies.
        //
        // RoundTrip should not modify the request, except for
        // consuming and closing the Body. The request's URL and
        // Header fields are guaranteed to be initialized.
        RoundTrip(*Request) (*Response, error)
}

// Given a string of the form "host", "host:port", or "[ipv6::address]:port",
// return true if the string includes a port.
func hasPort(s string) bool <span class="cov0" title="0">{ return strings.LastIndex(s, ":") &gt; strings.LastIndex(s, "]") }</span>

// Used in Send to implement io.ReadCloser by bundling together the
// bufio.Reader through which we read the response, and the underlying
// network connection.
type readClose struct {
        io.Reader
        io.Closer
}

// send issues an HTTP request.
// Caller should close resp.Body when done reading from it.
func send(req *Request, t RoundTripper) (resp *Response, err error) <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                t = DefaultTransport
                if t == nil </span><span class="cov0" title="0">{
                        err = errors.New("http: no Client.Transport or DefaultTransport")
                        return
                }</span>
        }

        <span class="cov0" title="0">if req.URL == nil </span><span class="cov0" title="0">{
                return nil, errors.New("http: nil Request.URL")
        }</span>

        <span class="cov0" title="0">if req.RequestURI != "" </span><span class="cov0" title="0">{
                return nil, errors.New("http: Request.RequestURI can't be set in client requests.")
        }</span>

        // Most the callers of send (Get, Post, et al) don't need
        // Headers, leaving it uninitialized.  We guarantee to the
        // Transport that this has been initialized, though.
        <span class="cov0" title="0">if req.Header == nil </span><span class="cov0" title="0">{
                req.Header = make(Header)
        }</span>

        <span class="cov0" title="0">if u := req.URL.User; u != nil </span><span class="cov0" title="0">{
                username := u.Username()
                password, _ := u.Password()
                req.Header.Set("Authorization", "Basic "+basicAuth(username, password))
        }</span>
        <span class="cov0" title="0">resp, err = t.RoundTrip(req)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        log.Logger.Warn("RoundTripper returned a response &amp; error; ignoring response")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return resp, nil</span>
}

// See 2 (end of page 4) http://www.ietf.org/rfc/rfc2617.txt
// "To receive authorization, the client sends the userid and password,
// separated by a single colon (":") character, within a base64
// encoded string in the credentials."
// It is not meant to be urlencoded.
func basicAuth(username, password string) string <span class="cov8" title="1">{
        auth := username + ":" + password
        return base64.StdEncoding.EncodeToString([]byte(auth))
}</span>

// True if the specified HTTP status code is one for which the Get utility should
// automatically redirect.
func shouldRedirectGet(statusCode int) bool <span class="cov0" title="0">{
        switch statusCode </span>{
        <span class="cov0" title="0">case StatusMovedPermanently, StatusFound, StatusSeeOther, StatusTemporaryRedirect:
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// True if the specified HTTP status code is one for which the Post utility should
// automatically redirect.
func shouldRedirectPost(statusCode int) bool <span class="cov0" title="0">{
        switch statusCode </span>{
        <span class="cov0" title="0">case StatusFound, StatusSeeOther:
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func defaultCheckRedirect(req *Request, via []*Request) error <span class="cov0" title="0">{
        if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                return errors.New("stopped after 10 redirects")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/* cookie.go - http cookie  */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
2014/8/29, by Zhang Miao, modify, add CookieMap
*/
/*
DESCRIPTION
This file is derived from net/http/
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package bfe_http

import (
        "bytes"
        "fmt"
        "net"
        "strconv"
        "strings"
        "time"
)

import (
    "www.baidu.com/golang-lib/log"
)


// This implementation is done according to RFC 6265:
//
//    http://tools.ietf.org/html/rfc6265

// A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an
// HTTP response or the Cookie header of an HTTP request.
type Cookie struct {
        Name       string
        Value      string
        Path       string
        Domain     string
        Expires    time.Time
        RawExpires string

        // MaxAge=0 means no 'Max-Age' attribute specified.
        // MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'
        // MaxAge&gt;0 means Max-Age attribute present and given in seconds
        MaxAge   int
        Secure   bool
        HttpOnly bool
        Raw      string
        Unparsed []string // Raw text of unparsed attribute-value pairs
}

type CookieMap map[string]*Cookie

// parse cookies(slice) to req.Route.CookieMap(map)
func CookieMapGet(cookies []*Cookie) CookieMap <span class="cov0" title="0">{
    cookieMap := make(CookieMap)
    
    for _, cookie := range cookies </span><span class="cov0" title="0">{
        // if more than one cookies have the same key, 
        // only the first cookie will be saved in CookieMap
        _, ok := cookieMap[cookie.Name]
        
        if !ok </span><span class="cov0" title="0">{
            cookieMap[cookie.Name] = cookie
        }</span>
    }
    <span class="cov0" title="0">return cookieMap</span>
}

// readSetCookies parses all "Set-Cookie" values from
// the header h and returns the successfully parsed Cookies.
func readSetCookies(h Header) []*Cookie <span class="cov4" title="8">{
        cookies := []*Cookie{}
        for _, line := range h["Set-Cookie"] </span><span class="cov4" title="8">{
                parts := strings.Split(strings.TrimSpace(line), ";")
                if len(parts) == 1 &amp;&amp; parts[0] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">parts[0] = strings.TrimSpace(parts[0])
                j := strings.Index(parts[0], "=")
                if j &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">name, value := parts[0][:j], parts[0][j+1:]
                if !isCookieNameValid(name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">value, success := parseCookieValue(value)
                if !success </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">c := &amp;Cookie{
                        Name:  name,
                        Value: value,
                        Raw:   line,
                }
                for i := 1; i &lt; len(parts); i++ </span><span class="cov5" title="18">{
                        parts[i] = strings.TrimSpace(parts[i])
                        if len(parts[i]) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov5" title="18">attr, val := parts[i], ""
                        if j := strings.Index(attr, "="); j &gt;= 0 </span><span class="cov5" title="12">{
                                attr, val = attr[:j], attr[j+1:]
                        }</span>
                        <span class="cov5" title="18">lowerAttr := strings.ToLower(attr)
                        parseCookieValueFn := parseCookieValue
                        if lowerAttr == "expires" </span><span class="cov3" title="4">{
                                parseCookieValueFn = parseCookieExpiresValue
                        }</span>
                        <span class="cov5" title="18">val, success = parseCookieValueFn(val)
                        if !success </span><span class="cov0" title="0">{
                                c.Unparsed = append(c.Unparsed, parts[i])
                                continue</span>
                        }
                        <span class="cov5" title="18">switch lowerAttr </span>{
                        <span class="cov0" title="0">case "secure":
                                c.Secure = true
                                continue</span>
                        <span class="cov3" title="6">case "httponly":
                                c.HttpOnly = true
                                continue</span>
                        <span class="cov2" title="2">case "domain":
                                c.Domain = val
                                // TODO: Add domain parsing
                                continue</span>
                        <span class="cov0" title="0">case "max-age":
                                secs, err := strconv.Atoi(val)
                                if err != nil || secs != 0 &amp;&amp; val[0] == '0' </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if secs &lt;= 0 </span><span class="cov0" title="0">{
                                        c.MaxAge = -1
                                }</span> <span class="cov0" title="0">else {
                                        c.MaxAge = secs
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        <span class="cov3" title="4">case "expires":
                                c.RawExpires = val
                                exptime, err := time.Parse(time.RFC1123, val)
                                if err != nil </span><span class="cov3" title="4">{
                                        exptime, err = time.Parse("Mon, 02-Jan-2006 15:04:05 MST", val)
                                        if err != nil </span><span class="cov0" title="0">{
                                                c.Expires = time.Time{}
                                                break</span>
                                        }
                                }
                                <span class="cov3" title="4">c.Expires = exptime.UTC()
                                continue</span>
                        <span class="cov3" title="6">case "path":
                                c.Path = val
                                // TODO: Add path parsing
                                continue</span>
                        }
                        <span class="cov0" title="0">c.Unparsed = append(c.Unparsed, parts[i])</span>
                }
                <span class="cov4" title="8">cookies = append(cookies, c)</span>
        }
        <span class="cov4" title="8">return cookies</span>
}

// SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.
func SetCookie(w ResponseWriter, cookie *Cookie) <span class="cov2" title="2">{
        w.Header().Add("Set-Cookie", cookie.String())
}</span>

// String returns the serialization of the cookie for use in a Cookie
// header (if only Name and Value are set) or a Set-Cookie response
// header (if other fields are set).
func (c *Cookie) String() string <span class="cov4" title="10">{
        var b bytes.Buffer
        fmt.Fprintf(&amp;b, "%s=%s", sanitizeCookieName(c.Name), sanitizeCookieValue(c.Value))
        if len(c.Path) &gt; 0 </span><span class="cov2" title="2">{
                fmt.Fprintf(&amp;b, "; Path=%s", sanitizeCookiePath(c.Path))
        }</span>
        <span class="cov4" title="10">if len(c.Domain) &gt; 0 </span><span class="cov3" title="5">{
                if validCookieDomain(c.Domain) </span><span class="cov2" title="2">{
                        // A c.Domain containing illegal characters is not
                        // sanitized but simply dropped which turns the cookie
                        // into a host-only cookie. A leading dot is okay
                        // but won't be sent.
                        d := c.Domain
                        if d[0] == '.' </span><span class="cov1" title="1">{
                                d = d[1:]
                        }</span>
                        <span class="cov2" title="2">fmt.Fprintf(&amp;b, "; Domain=%s", d)</span>
                } <span class="cov2" title="3">else {
                        log.Logger.Warn("net/http: invalid Cookie.Domain %q; dropping domain attribute",
                                            c.Domain)
                }</span>
        }
        <span class="cov4" title="10">if c.Expires.Unix() &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "; Expires=%s", c.Expires.UTC().Format(time.RFC1123))
        }</span>
        <span class="cov4" title="10">if c.MaxAge &gt; 0 </span><span class="cov2" title="2">{
                fmt.Fprintf(&amp;b, "; Max-Age=%d", c.MaxAge)
        }</span> <span class="cov4" title="8">else if c.MaxAge &lt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "; Max-Age=0")
        }</span>
        <span class="cov4" title="10">if c.HttpOnly </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "; HttpOnly")
        }</span>
        <span class="cov4" title="10">if c.Secure </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "; Secure")
        }</span>
        <span class="cov4" title="10">return b.String()</span>
}

// readCookies parses all "Cookie" values from the header h and
// returns the successfully parsed Cookies.
//
// if filter isn't empty, only cookies of that name are returned
func readCookies(h Header, filter string) []*Cookie <span class="cov4" title="8">{
        cookies := []*Cookie{}
        lines, ok := h["Cookie"]
        if !ok </span><span class="cov0" title="0">{
                return cookies
        }</span>

        <span class="cov4" title="8">for _, line := range lines </span><span class="cov5" title="12">{
                parts := strings.Split(strings.TrimSpace(line), ";")
                if len(parts) == 1 &amp;&amp; parts[0] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Per-line attributes
                <span class="cov5" title="12">parsedPairs := 0
                for i := 0; i &lt; len(parts); i++ </span><span class="cov5" title="16">{
                        parts[i] = strings.TrimSpace(parts[i])
                        if len(parts[i]) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="16">name, val := parts[i], ""
                        if j := strings.Index(name, "="); j &gt;= 0 </span><span class="cov5" title="16">{
                                name, val = name[:j], name[j+1:]
                        }</span>
                        <span class="cov5" title="16">if !isCookieNameValid(name) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="16">if filter != "" &amp;&amp; filter != name </span><span class="cov3" title="4">{
                                continue</span>
                        }
                        <span class="cov5" title="12">val, success := parseCookieValue(val)
                        if !success </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="12">cookies = append(cookies, &amp;Cookie{Name: name, Value: val})
                        parsedPairs++</span>
                }
        }
        <span class="cov4" title="8">return cookies</span>
}

// validCookieDomain returns wheter v is a valid cookie domain-value.
func validCookieDomain(v string) bool <span class="cov3" title="5">{
        if isCookieDomainName(v) </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov3" title="4">if net.ParseIP(v) != nil &amp;&amp; !strings.Contains(v, ":") </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov2" title="3">return false</span>
}

// isCookieDomainName returns whether s is a valid domain name or a valid
// domain name with a leading dot '.'.  It is almost a direct copy of
// package net's isDomainName.
func isCookieDomainName(s string) bool <span class="cov3" title="5">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="5">if len(s) &gt; 255 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="5">if s[0] == '.' </span><span class="cov1" title="1">{
                // A cookie a domain attribute may start with a leading dot.
                s = s[1:]
        }</span>
        <span class="cov3" title="5">last := byte('.')
        ok := false // Ok once we've seen a letter.
        partlen := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov6" title="32">{
                c := s[i]
                switch </span>{
                <span class="cov2" title="2">default:
                        return false</span>
                <span class="cov5" title="18">case 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z':
                        // No '_' allowed here (in contrast to package net).
                        ok = true
                        partlen++</span>
                <span class="cov3" title="6">case '0' &lt;= c &amp;&amp; c &lt;= '9':
                        // fine
                        partlen++</span>
                <span class="cov1" title="1">case c == '-':
                        // Byte before dash cannot be dot.
                        if last == '.' </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov1" title="1">partlen++</span>
                <span class="cov3" title="5">case c == '.':
                        // Byte before dot cannot be dot, dash.
                        if last == '.' || last == '-' </span><span class="cov1" title="1">{
                                return false
                        }</span>
                        <span class="cov3" title="4">if partlen &gt; 63 || partlen == 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov3" title="4">partlen = 0</span>
                }
                <span class="cov6" title="29">last = c</span>
        }
        <span class="cov2" title="2">if last == '-' || partlen &gt; 63 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="2">return ok</span>
}

var cookieNameSanitizer = strings.NewReplacer("\n", "-", "\r", "-")

func sanitizeCookieName(n string) string <span class="cov5" title="14">{
        return cookieNameSanitizer.Replace(n)
}</span>

// http://tools.ietf.org/html/rfc6265#section-4.1.1
// cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
// cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
//           ; US-ASCII characters excluding CTLs,
//           ; whitespace DQUOTE, comma, semicolon,
//           ; and backslash
func sanitizeCookieValue(v string) string <span class="cov5" title="18">{
        return sanitizeOrWarn("Cookie.Value", validCookieValueByte, v)
}</span>

func validCookieValueByte(b byte) bool <span class="cov8" title="82">{
        return 0x20 &lt; b &amp;&amp; b &lt; 0x7f &amp;&amp; b != '"' &amp;&amp; b != ',' &amp;&amp; b != ';' &amp;&amp; b != '\\'
}</span>

// path-av           = "Path=" path-value
// path-value        = &lt;any CHAR except CTLs or ";"&gt;
func sanitizeCookiePath(v string) string <span class="cov3" title="5">{
        return sanitizeOrWarn("Cookie.Path", validCookiePathByte, v)
}</span>

func validCookiePathByte(b byte) bool <span class="cov8" title="79">{
        return 0x20 &lt;= b &amp;&amp; b &lt; 0x7f &amp;&amp; b != ';'
}</span>

func sanitizeOrWarn(fieldName string, valid func(byte) bool, v string) string <span class="cov6" title="23">{
        ok := true
        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="111">{
                if valid(v[i]) </span><span class="cov8" title="107">{
                        continue</span>
                }
                <span class="cov3" title="4">log.Logger.Warn("net/http: invalid byte %q in %s; dropping invalid bytes", 
                                v[i], fieldName)
                ok = false
                break</span>
        }
        <span class="cov6" title="23">if ok </span><span class="cov5" title="19">{
                return v
        }</span>
        <span class="cov3" title="4">buf := make([]byte, 0, len(v))
        for i := 0; i &lt; len(v); i++ </span><span class="cov7" title="50">{
                if b := v[i]; valid(b) </span><span class="cov7" title="41">{
                        buf = append(buf, b)
                }</span>
        }
        <span class="cov3" title="4">return string(buf)</span>
}

func unquoteCookieValue(v string) string <span class="cov7" title="38">{
        if len(v) &gt; 1 &amp;&amp; v[0] == '"' &amp;&amp; v[len(v)-1] == '"' </span><span class="cov0" title="0">{
                return v[1 : len(v)-1]
        }</span>
        <span class="cov7" title="38">return v</span>
}

func isCookieByte(c byte) bool <span class="cov10" title="226">{
        switch </span>{
        <span class="cov9" title="210">case c == 0x21, 0x23 &lt;= c &amp;&amp; c &lt;= 0x2b, 0x2d &lt;= c &amp;&amp; c &lt;= 0x3a,
                0x3c &lt;= c &amp;&amp; c &lt;= 0x5b, 0x5d &lt;= c &amp;&amp; c &lt;= 0x7e:
                return true</span>
        }
        <span class="cov5" title="16">return false</span>
}

func isCookieExpiresByte(c byte) (ok bool) <span class="cov8" title="116">{
        return isCookieByte(c) || c == ',' || c == ' '
}</span>

func parseCookieValue(raw string) (string, bool) <span class="cov6" title="34">{
        return parseCookieValueUsing(raw, isCookieByte)
}</span>

func parseCookieExpiresValue(raw string) (string, bool) <span class="cov3" title="4">{
        return parseCookieValueUsing(raw, isCookieExpiresByte)
}</span>

func parseCookieValueUsing(raw string, validByte func(byte) bool) (string, bool) <span class="cov7" title="38">{
        raw = unquoteCookieValue(raw)
        for i := 0; i &lt; len(raw); i++ </span><span class="cov10" title="226">{
                if !validByte(raw[i]) </span><span class="cov0" title="0">{
                        return "", false
                }</span>
        }
        <span class="cov7" title="38">return raw, true</span>
}

func isCookieNameValid(raw string) bool <span class="cov6" title="24">{
        return strings.IndexFunc(raw, isNotToken) &lt; 0
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/* header.go - handle http header   */
/*
modification history
--------------------
2014/8/28, by Zhang Miao, modify, add Keys() to header
*/
/*
DESCRIPTION
*/

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "io"
        "sort"
        "strings"
        "time"
)

import (
        "bfe_net/textproto"
)

// TimeFormat is the time format to use with
// time.Parse and time.Time.Format when parsing
// or generating times in HTTP headers.
// It is like time.RFC1123 but hard codes GMT as the time zone.
const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"


// A Header represents the key-value pairs in an HTTP header.
type Header map[string][]string

// Add adds the key, value pair to the header.
// It appends to any existing values associated with key.
func (h Header) Add(key, value string) <span class="cov1" title="2">{
        textproto.MIMEHeader(h).Add(key, value)
}</span>

// Set sets the header entries associated with key to
// the single element value.  It replaces any existing
// values associated with key.
func (h Header) Set(key, value string) <span class="cov3" title="12">{
        textproto.MIMEHeader(h).Set(key, value)
}</span>

// Get gets the first value associated with the given key.
// If there are no values associated with the key, Get returns "".
// To access multiple values of a key, access the map directly
// with CanonicalHeaderKey.
func (h Header) Get(key string) string <span class="cov5" title="31">{
        return textproto.MIMEHeader(h).Get(key)
}</span>

// get is like Get, but key must already be in CanonicalHeaderKey form.
func (h Header) GetDirect(key string) string <span class="cov6" title="120">{
        if v := h[key]; len(v) &gt; 0 </span><span class="cov4" title="22">{
                return v[0]
        }</span>
        <span class="cov6" title="98">return ""</span>
}

// Del deletes the values associated with key.
func (h Header) Del(key string) <span class="cov4" title="22">{
        textproto.MIMEHeader(h).Del(key)
}</span>

// Write writes a header in wire format.
func (h Header) Write(w io.Writer) error <span class="cov0" title="0">{
        return h.WriteSubset(w, nil)
}</span>

func (h Header) Clone() Header <span class="cov0" title="0">{
        h2 := make(Header, len(h))
        for k, vv := range h </span><span class="cov0" title="0">{
                vv2 := make([]string, len(vv))
                copy(vv2, vv)
                h2[k] = vv2
        }</span>
        <span class="cov0" title="0">return h2</span>
}

// get all keys of header
func (h Header) Keys() []string <span class="cov0" title="0">{
    keys := make([]string, 0)
    for key := range h </span><span class="cov0" title="0">{
        keys = append(keys, key)
    }</span>
    <span class="cov0" title="0">return keys</span>
}

var timeFormats = []string{
        TimeFormat,
        time.RFC850,
        time.ANSIC,
}

// ParseTime parses a time header (such as the Date: header),
// trying each of the three formats allowed by HTTP/1.1:
// TimeFormat, time.RFC850, and time.ANSIC.
func ParseTime(text string) (t time.Time, err error) <span class="cov3" title="6">{
        for _, layout := range timeFormats </span><span class="cov4" title="15">{
                t, err = time.Parse(layout, text)
                if err == nil </span><span class="cov2" title="3">{
                        return
                }</span>
        }
        <span class="cov2" title="3">return</span>
}

var headerNewlineToSpace = strings.NewReplacer("\n", " ", "\r", " ")

type writeStringer interface {
        WriteString(string) (int, error)
}

// stringWriter implements WriteString on a Writer.
type stringWriter struct {
        w io.Writer
}

func (w stringWriter) WriteString(s string) (n int, err error) <span class="cov0" title="0">{
        return w.w.Write([]byte(s))
}</span>

type keyValues struct {
        key    string
        values []string
}

// A headerSorter implements sort.Interface by sorting a []keyValues
// by key. It's used as a pointer, so it can fit in a sort.Interface
// interface value without allocation.
type headerSorter struct {
        kvs []keyValues
}

func (s *headerSorter) Len() int           <span class="cov7" title="153">{ return len(s.kvs) }</span>
func (s *headerSorter) Swap(i, j int)      <span class="cov7" title="167">{ s.kvs[i], s.kvs[j] = s.kvs[j], s.kvs[i] }</span>
func (s *headerSorter) Less(i, j int) bool <span class="cov8" title="450">{ return s.kvs[i].key &lt; s.kvs[j].key }</span>

// TODO: convert this to a sync.Cache (issue 4720)
var headerSorterCache = make(chan *headerSorter, 8)

// sortedKeyValues returns h's keys sorted in the returned kvs
// slice. The headerSorter used to sort is also returned, for possible
// return to headerSorterCache.
func (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter) <span class="cov7" title="153">{
        select </span>{
        <span class="cov7" title="152">case hs = &lt;-headerSorterCache:</span>
        <span class="cov1" title="1">default:
                hs = new(headerSorter)</span>
        }
        <span class="cov7" title="153">if cap(hs.kvs) &lt; len(h) </span><span class="cov2" title="4">{
                hs.kvs = make([]keyValues, 0, len(h))
        }</span>
        <span class="cov7" title="153">kvs = hs.kvs[:0]
        for k, vv := range h </span><span class="cov8" title="457">{
                if !exclude[k] </span><span class="cov8" title="442">{
                        kvs = append(kvs, keyValues{k, vv})
                }</span>
        }
        <span class="cov7" title="153">hs.kvs = kvs
        sort.Sort(hs)
        return kvs, hs</span>
}

// WriteSubset writes a header in wire format.
// If exclude is not nil, keys where exclude[key] == true are not written.
func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error <span class="cov7" title="153">{
        ws, ok := w.(writeStringer)
        if !ok </span><span class="cov1" title="1">{
                ws = stringWriter{w}
        }</span>
        <span class="cov7" title="153">kvs, sorter := h.sortedKeyValues(exclude)
        for _, kv := range kvs </span><span class="cov8" title="442">{
                for _, v := range kv.values </span><span class="cov8" title="451">{
                        v = headerNewlineToSpace.Replace(v)
                        v = textproto.TrimString(v)
                        for _, s := range []string{kv.key, ": ", v, "\r\n"} </span><span class="cov10" title="1804">{
                                if _, err := ws.WriteString(s); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov7" title="153">select </span>{
        <span class="cov7" title="153">case headerSorterCache &lt;- sorter:</span>
        <span class="cov0" title="0">default:</span>
        }
        <span class="cov7" title="153">return nil</span>
}

// CanonicalHeaderKey returns the canonical format of the
// header key s.  The canonicalization converts the first
// letter and any letter following a hyphen to upper case;
// the rest are converted to lowercase.  For example, the
// canonical key for "accept-encoding" is "Accept-Encoding".
func CanonicalHeaderKey(s string) string <span class="cov0" title="0">{ return textproto.CanonicalMIMEHeaderKey(s) }</span>

// hasToken reports whether token appears with v, ASCII
// case-insensitive, with space or comma boundaries.
// token must be all lowercase.
// v may contain mixed cased.
func HasToken(v, token string) bool <span class="cov4" title="26">{
        if len(token) &gt; len(v) || token == "" </span><span class="cov1" title="2">{
                return false
        }</span>
        <span class="cov4" title="24">if v == token </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov4" title="23">for sp := 0; sp &lt;= len(v)-len(token); sp++ </span><span class="cov6" title="88">{
                // Check that first character is good.
                // The token is ASCII, so checking only a single byte
                // is sufficient.  We skip this potential starting
                // position if both the first byte and its potential
                // ASCII uppercase equivalent (b|0x20) don't match.
                // False positives ('^' =&gt; '~') are caught by EqualFold.
                if b := v[sp]; b != token[0] &amp;&amp; b|0x20 != token[0] </span><span class="cov6" title="65">{
                        continue</span>
                }
                // Check that start pos is on a valid token boundary.
                <span class="cov4" title="23">if sp &gt; 0 &amp;&amp; !isTokenBoundary(v[sp-1]) </span><span class="cov1" title="1">{
                        continue</span>
                }
                // Check that end pos is on a valid token boundary.
                <span class="cov4" title="22">if endPos := sp + len(token); endPos != len(v) &amp;&amp; !isTokenBoundary(v[endPos]) </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="21">if strings.EqualFold(v[sp:sp+len(token)], token) </span><span class="cov4" title="21">{
                        return true
                }</span>
        }
        <span class="cov1" title="2">return false</span>
}

func isTokenBoundary(b byte) bool <span class="cov5" title="32">{
        return b == ' ' || b == ',' || b == '\t'
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

// This file deals with lexical matters of HTTP

var isTokenTable = [127]bool{
        '!':  true,
        '#':  true,
        '$':  true,
        '%':  true,
        '&amp;':  true,
        '\'': true,
        '*':  true,
        '+':  true,
        '-':  true,
        '.':  true,
        '0':  true,
        '1':  true,
        '2':  true,
        '3':  true,
        '4':  true,
        '5':  true,
        '6':  true,
        '7':  true,
        '8':  true,
        '9':  true,
        'A':  true,
        'B':  true,
        'C':  true,
        'D':  true,
        'E':  true,
        'F':  true,
        'G':  true,
        'H':  true,
        'I':  true,
        'J':  true,
        'K':  true,
        'L':  true,
        'M':  true,
        'N':  true,
        'O':  true,
        'P':  true,
        'Q':  true,
        'R':  true,
        'S':  true,
        'T':  true,
        'U':  true,
        'W':  true,
        'V':  true,
        'X':  true,
        'Y':  true,
        'Z':  true,
        '^':  true,
        '_':  true,
        '`':  true,
        'a':  true,
        'b':  true,
        'c':  true,
        'd':  true,
        'e':  true,
        'f':  true,
        'g':  true,
        'h':  true,
        'i':  true,
        'j':  true,
        'k':  true,
        'l':  true,
        'm':  true,
        'n':  true,
        'o':  true,
        'p':  true,
        'q':  true,
        'r':  true,
        's':  true,
        't':  true,
        'u':  true,
        'v':  true,
        'w':  true,
        'x':  true,
        'y':  true,
        'z':  true,
        '|':  true,
        '~':  true,
}

func isToken(r rune) bool <span class="cov10" title="285">{
        i := int(r)
        return i &lt; len(isTokenTable) &amp;&amp; isTokenTable[i]
}</span>

func isNotToken(r rune) bool <span class="cov9" title="154">{
        return !isToken(r)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/* request.go - http request */
/*
modification history
--------------------
2014/11/19, by Sijie Yang, modify, add HeaderKeys to Request
    - Note: HeaderKeys is required by mod_header_defence

2015/1/7, by weiwei, modify, use RequestUri instead of URL if no update since readrequest()
*/
/*
DESCRIPTION
*/

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP Request reading and parsing.

package bfe_http

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "mime/multipart"
        "net/url"
        "strconv"
        "strings"
        "time"
)

import (
    "bfe_bufio"
        "bfe_net/textproto"
    "bfe_tls"
)

const (
        maxValueLength   = 4096
        maxHeaderLines   = 1024
        chunkSize        = 4 &lt;&lt; 10  // 4 KB chunks
        defaultMaxMemory = 32 &lt;&lt; 20 // 32 MB
    MaxUriSize       = 1024 * 64
)

// ErrMissingFile is returned by FormFile when the provided file field name
// is either not present in the request or not a file field.
var ErrMissingFile = errors.New("http: no such file")

// HTTP request parsing errors.
type ProtocolError struct {
        ErrorString string
}

func (err *ProtocolError) Error() string <span class="cov0" title="0">{ return err.ErrorString }</span>

var (
        ErrHeaderTooLong        = &amp;ProtocolError{"header too long"}
        ErrShortBody            = &amp;ProtocolError{"entity body too short"}
        ErrNotSupported         = &amp;ProtocolError{"feature not supported"}
        ErrUnexpectedTrailer    = &amp;ProtocolError{"trailer header without chunked transfer encoding"}
        ErrMissingContentLength = &amp;ProtocolError{"missing ContentLength in HEAD response"}
        ErrNotMultipart         = &amp;ProtocolError{"request Content-Type isn't multipart/form-data"}
        ErrMissingBoundary      = &amp;ProtocolError{"no multipart boundary param in Content-Type"}
)

type badStringError struct {
        what string
        str  string
}

func (e *badStringError) Error() string <span class="cov0" title="0">{ return fmt.Sprintf("%s %q", e.what, e.str) }</span>

// Headers that Request.Write handles itself and should be skipped.
var reqWriteExcludeHeader = map[string]bool{
        "Host":              true, // not in Header map anyway
        "User-Agent":        true,
        "Content-Length":    true,
        "Transfer-Encoding": true,
        "Trailer":           true,
}

// A Request represents an HTTP request received by a server
// or to be sent by a client.
type Request struct {
        Method string // GET, POST, PUT, etc.

        // URL is created from the URI supplied on the Request-Line
        // as stored in RequestURI.
        //
        // For most requests, fields other than Path and RawQuery
        // will be empty. (See RFC 2616, Section 5.1.2)
        URL *url.URL

        // The protocol version for incoming requests.
        // Outgoing requests always use HTTP/1.1.
        Proto      string // "HTTP/1.0"
        ProtoMajor int    // 1
        ProtoMinor int    // 0

        // A header maps request lines to their values.
        // If the header says
        //
        //        accept-encoding: gzip, deflate
        //        Accept-Language: en-us
        //        Connection: keep-alive
        //
        // then
        //
        //        Header = map[string][]string{
        //                "Accept-Encoding": {"gzip, deflate"},
        //                "Accept-Language": {"en-us"},
        //                "Connection": {"keep-alive"},
        //        }
        //
        // HTTP defines that header names are case-insensitive.
        // The request parser implements this by canonicalizing the
        // name, making the first character and any characters
        // following a hyphen uppercase and the rest lowercase.
        Header Header

        // a headerKeys represents keys of header in orginal order
        HeaderKeys textproto.MIMEKeys

        // Body is the request's body.
        //
        // For client requests, a nil body means the request has no
        // body, such as a GET request. The HTTP Client's Transport
        // is responsible for calling the Close method.
        //
        // For server requests, the Request Body is always non-nil
        // but will return EOF immediately when no body is present.
        // The Server will close the request body. The ServeHTTP
        // Handler does not need to.
        Body io.ReadCloser

        // ContentLength records the length of the associated content.
        // The value -1 indicates that the length is unknown.
        // Values &gt;= 0 indicate that the given number of bytes may
        // be read from Body.
        // For outgoing requests, a value of 0 means unknown if Body is not nil.
        ContentLength int64

        // TransferEncoding lists the transfer encodings from outermost to
        // innermost. An empty list denotes the "identity" encoding.
        // TransferEncoding can usually be ignored; chunked encoding is
        // automatically added and removed as necessary when sending and
        // receiving requests.
        TransferEncoding []string

        // Close indicates whether to close the connection after
        // replying to this request.
        Close bool

        // The host on which the URL is sought.
        // Per RFC 2616, this is either the value of the Host: header
        // or the host name given in the URL itself.
        // It may be of the form "host:port".
        Host string

        // Form contains the parsed form data, including both the URL
        // field's query parameters and the POST or PUT form data.
        // This field is only available after ParseForm is called.
        // The HTTP client ignores Form and uses Body instead.
        Form url.Values

        // PostForm contains the parsed form data from POST or PUT
        // body parameters.
        // This field is only available after ParseForm is called.
        // The HTTP client ignores PostForm and uses Body instead.
        PostForm url.Values

        // MultipartForm is the parsed multipart form, including file uploads.
        // This field is only available after ParseMultipartForm is called.
        // The HTTP client ignores MultipartForm and uses Body instead.
        MultipartForm *multipart.Form

        // Trailer maps trailer keys to values.  Like for Header, if the
        // response has multiple trailer lines with the same key, they will be
        // concatenated, delimited by commas.
        // For server requests, Trailer is only populated after Body has been
        // closed or fully consumed.
        // Trailer support is only partially complete.
        Trailer Header

        // RemoteAddr allows HTTP servers and other software to record
        // the network address that sent the request, usually for
        // logging. This field is not filled in by ReadRequest and
        // has no defined format. The HTTP server in this package
        // sets RemoteAddr to an "IP:port" address before invoking a
        // handler.
        // This field is ignored by the HTTP client.
        RemoteAddr string

        // RequestURI is the unmodified Request-URI of the
        // Request-Line (RFC 2616, Section 5.1) as sent by the client
        // to a server. Usually the URL field should be used instead.
        // It is an error to set this field in an HTTP client request.
        RequestURI string

    // TLS allows HTTP servers and other software to record
    // information about the TLS connection on which the request
    // was received. This field is not filled in by ReadRequest.
    // The HTTP server in this package sets the field for
    // TLS-enabled connections before invoking a handler;
    // otherwise it leaves the field nil.
    // This field is ignored by the HTTP client.
    TLS *bfe_tls.ConnectionState
}

// ProtoAtLeast reports whether the HTTP protocol used
// in the request is at least major.minor.
func (r *Request) ProtoAtLeast(major, minor int) bool <span class="cov8" title="24">{
        return r.ProtoMajor &gt; major ||
                r.ProtoMajor == major &amp;&amp; r.ProtoMinor &gt;= minor
}</span>

// UserAgent returns the client's User-Agent, if sent in the request.
func (r *Request) UserAgent() string <span class="cov0" title="0">{
        return r.Header.Get("User-Agent")
}</span>

// Cookies parses and returns the HTTP cookies sent with the request.
func (r *Request) Cookies() []*Cookie <span class="cov0" title="0">{
        return readCookies(r.Header, "")
}</span>

var ErrNoCookie = errors.New("http: named cookie not present")

// Cookie returns the named cookie provided in the request or
// ErrNoCookie if not found.
func (r *Request) Cookie(name string) (*Cookie, error) <span class="cov0" title="0">{
        for _, c := range readCookies(r.Header, name) </span><span class="cov0" title="0">{
                return c, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrNoCookie</span>
}

// AddCookie adds a cookie to the request.  Per RFC 6265 section 5.4,
// AddCookie does not attach more than one Cookie header field.  That
// means all cookies, if any, are written into the same line,
// separated by semicolon.
func (r *Request) AddCookie(c *Cookie) <span class="cov4" title="4">{
        s := fmt.Sprintf("%s=%s", sanitizeCookieName(c.Name), sanitizeCookieValue(c.Value))
        if c := r.Header.Get("Cookie"); c != "" </span><span class="cov2" title="2">{
                r.Header.Set("Cookie", c+"; "+s)
        }</span> <span class="cov2" title="2">else {
                r.Header.Set("Cookie", s)
        }</span>
}

// Referer returns the referring URL, if sent in the request.
//
// Referer is misspelled as in the request itself, a mistake from the
// earliest days of HTTP.  This value can also be fetched from the
// Header map as Header["Referer"]; the benefit of making it available
// as a method is that the compiler can diagnose programs that use the
// alternate (correct English) spelling req.Referrer() but cannot
// diagnose programs that use Header["Referrer"].
func (r *Request) Referer() string <span class="cov0" title="0">{
        return r.Header.Get("Referer")
}</span>

// multipartByReader is a sentinel value.
// Its presence in Request.MultipartForm indicates that parsing of the request
// body has been handed off to a MultipartReader instead of ParseMultipartFrom.
var multipartByReader = &amp;multipart.Form{
        Value: make(map[string][]string),
        File:  make(map[string][]*multipart.FileHeader),
}

// MultipartReader returns a MIME multipart reader if this is a
// multipart/form-data POST request, else returns nil and an error.
// Use this function instead of ParseMultipartForm to
// process the request body as a stream.
func (r *Request) MultipartReader() (*multipart.Reader, error) <span class="cov3" title="3">{
        if r.MultipartForm == multipartByReader </span><span class="cov1" title="1">{
                return nil, errors.New("http: MultipartReader called twice")
        }</span>
        <span class="cov2" title="2">if r.MultipartForm != nil </span><span class="cov0" title="0">{
                return nil, errors.New("http: multipart handled by ParseMultipartForm")
        }</span>
        <span class="cov2" title="2">r.MultipartForm = multipartByReader
        return r.multipartReader()</span>
}

func (r *Request) multipartReader() (*multipart.Reader, error) <span class="cov5" title="7">{
        v := r.Header.Get("Content-Type")
        if v == "" </span><span class="cov2" title="2">{
                return nil, ErrNotMultipart
        }</span>
        <span class="cov4" title="5">d, params, err := mime.ParseMediaType(v)
        if err != nil || d != "multipart/form-data" </span><span class="cov1" title="1">{
                return nil, ErrNotMultipart
        }</span>
        <span class="cov4" title="4">boundary, ok := params["boundary"]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrMissingBoundary
        }</span>
        <span class="cov4" title="4">return multipart.NewReader(r.Body, boundary), nil</span>
}

// Return value if nonempty, def otherwise.
func valueOrDefault(value, def string) string <span class="cov8" title="25">{
        if value != "" </span><span class="cov8" title="25">{
                return value
        }</span>
        <span class="cov0" title="0">return def</span>
}

// NOTE: This is not intended to reflect the actual Go version being used.
// It was changed from "Go http package" to "Go 1.1 package http" at the
// time of the Go 1.1 release because the former User-Agent had ended up
// on a blacklist for some intrusion detection systems.
// See https://codereview.appspot.com/7532043.
const defaultUserAgent = "Go 1.1 package http"

// Write writes an HTTP/1.1 request -- header and body -- in wire format.
// This method consults the following fields of the request:
//        Host
//        URL
//        Method (defaults to "GET")
//        Header
//        ContentLength
//        TransferEncoding
//        Body
//
// If Body is present, Content-Length is &lt;= 0 and TransferEncoding
// hasn't been set to "identity", Write adds "Transfer-Encoding:
// chunked" to the header. Body is closed after it is sent.
func (r *Request) Write(w io.Writer) error <span class="cov7" title="18">{
        return r.write(w, false, nil)
}</span>

// WriteProxy is like Write but writes the request in the form
// expected by an HTTP proxy.  In particular, WriteProxy writes the
// initial Request-URI line of the request with an absolute URI, per
// section 5.1.2 of RFC 2616, including the scheme and host.
// In either case, WriteProxy also writes a Host header, using
// either r.Host or r.URL.Host.
func (r *Request) WriteProxy(w io.Writer) error <span class="cov5" title="7">{
        return r.write(w, true, nil)
}</span>

// extraHeaders may be nil
func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) error <span class="cov8" title="25">{
        host := req.Host
        if host == "" </span><span class="cov6" title="11">{
                if req.URL == nil </span><span class="cov0" title="0">{
                        return errors.New("http: Request.Write on Request with no Host or URL set")
                }</span>
                <span class="cov6" title="11">host = req.URL.Host</span>
        }

        <span class="cov8" title="25">ruri := req.URL.RequestURI()
        if usingProxy &amp;&amp; req.URL.Scheme != "" &amp;&amp; req.URL.Opaque == "" </span><span class="cov4" title="5">{
                ruri = req.URL.Scheme + "://" + host + ruri
        }</span> <span class="cov7" title="20">else if req.Method == "CONNECT" &amp;&amp; req.URL.Path == "" </span><span class="cov0" title="0">{
                // CONNECT requests normally give just the host and port, not a full URL.
                ruri = host
        }</span> <span class="cov7" title="20">else {
        // use req.RequestUri instead of req.URL.RequestURI() (decoded/encoded)
        // to be compatiable with non-standard web server ONLY WHEN URL not changed since
        // ReadRequest()
        rawurl, err := url.ParseRequestURI(req.RequestURI)
        if err == nil &amp;&amp; rawurl.RequestURI() == ruri </span><span class="cov0" title="0">{
            if rawurl.Scheme == "" &amp;&amp; rawurl.Host == "" &amp;&amp; rawurl.Opaque == "" </span><span class="cov0" title="0">{
                // if RequestUri contains Scheme Host Opaque, no replace
                ruri = req.RequestURI
            }</span>
        }
    }
        // TODO(bradfitz): escape at least newlines in ruri?

        // Wrap the writer in a bufio Writer if it's not already buffered.
        // Don't always call NewWriter, as that forces a bytes.Buffer
        // and other small bufio Writers to have a minimum 4k buffer
        // size.
        <span class="cov8" title="25">var bw *bfe_bufio.Writer
        if _, ok := w.(io.ByteWriter); !ok </span><span class="cov0" title="0">{
                bw = bfe_bufio.NewWriter(w)
                w = bw
        }</span>

        <span class="cov8" title="25">fmt.Fprintf(w, "%s %s HTTP/1.1\r\n", valueOrDefault(req.Method, "GET"), ruri)

        // Header lines
        fmt.Fprintf(w, "Host: %s\r\n", host)

        // Use the defaultUserAgent unless the Header contains one, which
        // may be blank to not send the header.
    // update by weiwei02, userAgent default to ""
        userAgent := ""
        if req.Header != nil </span><span class="cov8" title="25">{
                if ua := req.Header["User-Agent"]; len(ua) &gt; 0 </span><span class="cov2" title="2">{
                        userAgent = ua[0]
                }</span>
        }
        <span class="cov8" title="25">if userAgent != "" </span><span class="cov2" title="2">{
                fmt.Fprintf(w, "User-Agent: %s\r\n", userAgent)
        }</span>

        // Process Body,ContentLength,Close,Trailer
        <span class="cov8" title="25">tw, err := newTransferWriter(req)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov8" title="24">err = tw.WriteHeader(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: split long values?  (If so, should share code with Conn.Write)
        <span class="cov8" title="24">err = req.Header.WriteSubset(w, reqWriteExcludeHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="24">if extraHeaders != nil </span><span class="cov0" title="0">{
                err = extraHeaders.Write(w)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="24">io.WriteString(w, "\r\n")

        // Write body and trailer
        err = tw.WriteBody(w)
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov7" title="22">if bw != nil </span><span class="cov0" title="0">{
                return bw.Flush()
        }</span>
        <span class="cov7" title="22">return nil</span>
}

// ParseHTTPVersion parses a HTTP version string.
// "HTTP/1.0" returns (1, 0, true).
func ParseHTTPVersion(vers string) (major, minor int, ok bool) <span class="cov10" title="58">{
        const Big = 1000000 // arbitrary upper bound
        switch vers </span>{
        <span class="cov8" title="34">case "HTTP/1.1":
                return 1, 1, true</span>
        <span class="cov7" title="15">case "HTTP/1.0":
                return 1, 0, true</span>
        }
        <span class="cov5" title="9">if !strings.HasPrefix(vers, "HTTP/") </span><span class="cov1" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov5" title="8">dot := strings.Index(vers, ".")
        if dot &lt; 0 </span><span class="cov4" title="4">{
                return 0, 0, false
        }</span>
        <span class="cov4" title="4">major, err := strconv.Atoi(vers[5:dot])
        if err != nil || major &lt; 0 || major &gt; Big </span><span class="cov1" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov3" title="3">minor, err = strconv.Atoi(vers[dot+1:])
        if err != nil || minor &lt; 0 || minor &gt; Big </span><span class="cov1" title="1">{
                return 0, 0, false
        }</span>
        <span class="cov2" title="2">return major, minor, true</span>
}

// NewRequest returns a new Request given a method, URL, and optional body.
//
// If the provided body is also an io.Closer, the returned
// Request.Body is set to body and will be closed by the Client
// methods Do, Post, and PostForm, and Transport.RoundTrip.
func NewRequest(method, urlStr string, body io.Reader) (*Request, error) <span class="cov7" title="19">{
        u, err := url.Parse(urlStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="19">rc, ok := body.(io.ReadCloser)
        if !ok &amp;&amp; body != nil </span><span class="cov6" title="10">{
                rc = ioutil.NopCloser(body)
        }</span>
        <span class="cov7" title="19">req := &amp;Request{
                Method:     method,
                URL:        u,
                Proto:      "HTTP/1.1",
                ProtoMajor: 1,
                ProtoMinor: 1,
                Header:     make(Header),
                Body:       rc,
                Host:       u.Host,
        }
        if body != nil </span><span class="cov6" title="11">{
                switch v := body.(type) </span>{
                <span class="cov4" title="4">case *bytes.Buffer:
                        req.ContentLength = int64(v.Len())</span>
                <span class="cov1" title="1">case *bytes.Reader:
                        req.ContentLength = int64(v.Len())</span>
                <span class="cov2" title="2">case *strings.Reader:
                        req.ContentLength = int64(v.Len())</span>
                }
        }

        <span class="cov7" title="19">return req, nil</span>
}

// SetBasicAuth sets the request's Authorization header to use HTTP
// Basic Authentication with the provided username and password.
//
// With HTTP Basic Authentication the provided username and password
// are not encrypted.
func (r *Request) SetBasicAuth(username, password string) <span class="cov1" title="1">{
        r.Header.Set("Authorization", "Basic "+basicAuth(username, password))
}</span>

// parseRequestLine parses "GET /foo HTTP/1.1" into its three parts.
func parseRequestLine(line string) (method, requestURI, proto string, ok bool) <span class="cov6" title="13">{
        s1 := strings.Index(line, " ")
        s2 := strings.Index(line[s1+1:], " ")
        if s1 &lt; 0 || s2 &lt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov6" title="13">s2 += s1 + 1
        return line[:s1], line[s1+1 : s2], line[s2+1:], true</span>
}

// TODO(bradfitz): use a sync.Cache when available
var textprotoReaderCache = make(chan *textproto.Reader, 4)

func newTextprotoReader(br *bfe_bufio.Reader) *textproto.Reader <span class="cov6" title="14">{
        select </span>{
        <span class="cov6" title="13">case r := &lt;-textprotoReaderCache:
                r.R = br
                return r</span>
        <span class="cov1" title="1">default:
                return textproto.NewReader(br)</span>
        }
}

func putTextprotoReader(r *textproto.Reader) <span class="cov6" title="13">{
        r.R = nil
        select </span>{
        <span class="cov6" title="13">case textprotoReaderCache &lt;- r:</span>
        <span class="cov0" title="0">default:</span>
        }
}

// ReadRequest reads and parses a request from b.
func ReadRequest(b *bfe_bufio.Reader, maxUriBytes int) (req *Request, start time.Time, err error) <span class="cov6" title="14">{
        tp := newTextprotoReader(b)
        req = new(Request)

        // First line: GET /index.html HTTP/1.0
        var s string
        if s, err = tp.ReadLine(); err != nil </span><span class="cov1" title="1">{
                return nil, start, err
        }</span>
        
        // mark start as time of reading out first line
        <span class="cov6" title="13">start = time.Now()
        
        defer func() </span><span class="cov6" title="13">{
                putTextprotoReader(tp)
                if err == io.EOF </span><span class="cov1" title="1">{
                        err = io.ErrUnexpectedEOF
                }</span>
        }()

        <span class="cov6" title="13">var ok bool
        req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s)
        if !ok </span><span class="cov0" title="0">{
                return nil, start, &amp;badStringError{"malformed HTTP request", s}
        }</span>
        <span class="cov6" title="13">rawurl := req.RequestURI
                
        if len(rawurl) &gt; maxUriBytes </span><span class="cov0" title="0">{
            return nil, start, fmt.Errorf("exceed maxUriBytes:%d", len(rawurl))
        }</span>
        
        <span class="cov6" title="13">if req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok </span><span class="cov0" title="0">{
                return nil, start, &amp;badStringError{"malformed HTTP version", req.Proto}
        }</span>

        // CONNECT requests are used two different ways, and neither uses a full URL:
        // The standard use is to tunnel HTTPS through an HTTP proxy.
        // It looks like "CONNECT www.google.com:443 HTTP/1.1", and the parameter is
        // just the authority section of a URL. This information should go in req.URL.Host.
        //
        // The net/rpc package also uses CONNECT, but there the parameter is a path
        // that starts with a slash. It can be parsed with the regular URL parser,
        // and the path will end up in req.URL.Path, where it needs to be in order for
        // RPC to work.
        <span class="cov6" title="13">justAuthority := req.Method == "CONNECT" &amp;&amp; !strings.HasPrefix(rawurl, "/")
        if justAuthority </span><span class="cov2" title="2">{
                rawurl = "http://" + rawurl
        }</span>

        <span class="cov6" title="13">if req.URL, err = url.ParseRequestURI(rawurl); err != nil </span><span class="cov2" title="2">{
                return nil, start, err
        }</span>

        <span class="cov6" title="11">if justAuthority </span><span class="cov2" title="2">{
                // Strip the bogus "http://" back off.
                req.URL.Scheme = ""
        }</span>

        // Subsequent lines: Key: value.
        <span class="cov6" title="11">mimeHeader, headerKeys, err := tp.ReadMIMEHeaderAndKeys()
        if err != nil </span><span class="cov1" title="1">{
                return nil, start, err
        }</span>
        <span class="cov6" title="10">req.Header = Header(mimeHeader)
        req.HeaderKeys = headerKeys

        // RFC2616: Must treat
        //        GET /index.html HTTP/1.1
        //        Host: www.google.com
        // and
        //        GET http://www.google.com/index.html HTTP/1.1
        //        Host: doesntmatter
        // the same.  In the second case, any Host line is ignored.
        req.Host = req.URL.Host
        if req.Host == "" </span><span class="cov5" title="7">{
                req.Host = req.Header.GetDirect("Host")
        }</span>
        <span class="cov6" title="10">delete(req.Header, "Host")

        fixPragmaCacheControl(req.Header)

        // TODO: Parse specific header values:
        //        Accept
        //        Accept-Encoding
        //        Accept-Language
        //        Authorization
        //        Cache-Control
        //        Connection
        //        Date
        //        Expect
        //        From
        //        If-Match
        //        If-Modified-Since
        //        If-None-Match
        //        If-Range
        //        If-Unmodified-Since
        //        Max-Forwards
        //        Proxy-Authorization
        //        Referer [sic]
        //        TE (transfer-codings)
        //        Trailer
        //        Transfer-Encoding
        //        Upgrade
        //        User-Agent
        //        Via
        //        Warning

        err = readTransfer(req, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, start, err
        }</span>

        <span class="cov6" title="10">return req, start, nil</span>
}

// MaxBytesReader is similar to io.LimitReader but is intended for
// limiting the size of incoming request bodies. In contrast to
// io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
// non-EOF error for a Read beyond the limit, and Closes the
// underlying reader when its Close method is called.
//
// MaxBytesReader prevents clients from accidentally or maliciously
// sending a large request and wasting server resources.
func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser <span class="cov0" title="0">{
        return &amp;maxBytesReader{w: w, r: r, n: n}
}</span>

type maxBytesReader struct {
        w       ResponseWriter
        r       io.ReadCloser // underlying reader
        n       int64         // max bytes remaining
        stopped bool
}

func (l *maxBytesReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if l.n &lt;= 0 </span><span class="cov0" title="0">{
                if !l.stopped </span><span class="cov0" title="0">{
                        l.stopped = true
//                        if res, ok := l.w.(*response); ok {
//                                res.requestTooLarge()
//                        }
                }</span>
                <span class="cov0" title="0">return 0, errors.New("http: request body too large")</span>
        }
        <span class="cov0" title="0">if int64(len(p)) &gt; l.n </span><span class="cov0" title="0">{
                p = p[:l.n]
        }</span>
        <span class="cov0" title="0">n, err = l.r.Read(p)
        l.n -= int64(n)
        return</span>
}

func (l *maxBytesReader) Close() error <span class="cov0" title="0">{
        return l.r.Close()
}</span>

func copyValues(dst, src url.Values) <span class="cov2" title="2">{
        for k, vs := range src </span><span class="cov5" title="8">{
                for _, value := range vs </span><span class="cov5" title="9">{
                        dst.Add(k, value)
                }</span>
        }
}

func parsePostForm(r *Request) (vs url.Values, err error) <span class="cov5" title="8">{
        if r.Body == nil </span><span class="cov1" title="1">{
                err = errors.New("missing form body")
                return
        }</span>
        <span class="cov5" title="7">ct := r.Header.Get("Content-Type")
        ct, _, err = mime.ParseMediaType(ct)
        switch </span>{
        <span class="cov1" title="1">case ct == "application/x-www-form-urlencoded":
                var reader io.Reader = r.Body
                maxFormSize := int64(1&lt;&lt;63 - 1)
                if _, ok := r.Body.(*maxBytesReader); !ok </span><span class="cov1" title="1">{
                        maxFormSize = int64(10 &lt;&lt; 20) // 10 MB is a lot of text.
                        reader = io.LimitReader(r.Body, maxFormSize+1)
                }</span>
                <span class="cov1" title="1">b, e := ioutil.ReadAll(reader)
                if e != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = e
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov1" title="1">if int64(len(b)) &gt; maxFormSize </span><span class="cov0" title="0">{
                        err = errors.New("http: POST too large")
                        return
                }</span>
                <span class="cov1" title="1">vs, e = url.ParseQuery(string(b))
                if err == nil </span><span class="cov1" title="1">{
                        err = e
                }</span>
        <span class="cov2" title="2">case ct == "multipart/form-data":</span>
                // handled by ParseMultipartForm (which is calling us, or should be)
                // TODO(bradfitz): there are too many possible
                // orders to call too many functions here.
                // Clean this up and write more tests.
                // request_test.go contains the start of this,
                // in TestRequestMultipartCallOrder.
        }
        <span class="cov5" title="7">return</span>
}

// ParseForm parses the raw query from the URL and updates r.Form.
//
// For POST or PUT requests, it also parses the request body as a form and
// put the results into both r.PostForm and r.Form.
// POST and PUT body parameters take precedence over URL query string values
// in r.Form.
//
// If the request Body's size has not already been limited by MaxBytesReader,
// the size is capped at 10MB.
//
// ParseMultipartForm calls ParseForm automatically.
// It is idempotent.
func (r *Request) ParseForm() error <span class="cov6" title="11">{
        var err error
        if r.PostForm == nil </span><span class="cov6" title="11">{
                if r.Method == "POST" || r.Method == "PUT" </span><span class="cov5" title="8">{
                        r.PostForm, err = parsePostForm(r)
                }</span>
                <span class="cov6" title="11">if r.PostForm == nil </span><span class="cov6" title="10">{
                        r.PostForm = make(url.Values)
                }</span>
        }
        <span class="cov6" title="11">if r.Form == nil </span><span class="cov6" title="11">{
                if len(r.PostForm) &gt; 0 </span><span class="cov1" title="1">{
                        r.Form = make(url.Values)
                        copyValues(r.Form, r.PostForm)
                }</span>
                <span class="cov6" title="11">var newValues url.Values
                if r.URL != nil </span><span class="cov4" title="6">{
                        var e error
                        newValues, e = url.ParseQuery(r.URL.RawQuery)
                        if err == nil </span><span class="cov4" title="5">{
                                err = e
                        }</span>
                }
                <span class="cov6" title="11">if newValues == nil </span><span class="cov4" title="5">{
                        newValues = make(url.Values)
                }</span>
                <span class="cov6" title="11">if r.Form == nil </span><span class="cov6" title="10">{
                        r.Form = newValues
                }</span> <span class="cov1" title="1">else {
                        copyValues(r.Form, newValues)
                }</span>
        }
        <span class="cov6" title="11">return err</span>
}

// ParseMultipartForm parses a request body as multipart/form-data.
// The whole request body is parsed and up to a total of maxMemory bytes of
// its file parts are stored in memory, with the remainder stored on
// disk in temporary files.
// ParseMultipartForm calls ParseForm if necessary.
// After one call to ParseMultipartForm, subsequent calls have no effect.
func (r *Request) ParseMultipartForm(maxMemory int64) error <span class="cov5" title="7">{
        if r.MultipartForm == multipartByReader </span><span class="cov1" title="1">{
                return errors.New("http: multipart handled by MultipartReader")
        }</span>
        <span class="cov4" title="6">if r.Form == nil </span><span class="cov4" title="5">{
                err := r.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="6">if r.MultipartForm != nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="5">mr, err := r.multipartReader()
        if err == ErrNotMultipart </span><span class="cov3" title="3">{
                return nil
        }</span> <span class="cov2" title="2">else if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">f, err := mr.ReadForm(maxMemory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">for k, v := range f.Value </span><span class="cov4" title="4">{
                r.Form[k] = append(r.Form[k], v...)
        }</span>
        <span class="cov2" title="2">r.MultipartForm = f

        return nil</span>
}

// FormValue returns the first value for the named component of the query.
// POST and PUT body parameters take precedence over URL query string values.
// FormValue calls ParseMultipartForm and ParseForm if necessary.
// To access multiple values of the same key use ParseForm.
func (r *Request) FormValue(key string) string <span class="cov6" title="14">{
        if r.Form == nil </span><span class="cov3" title="3">{
                r.ParseMultipartForm(defaultMaxMemory)
        }</span>
        <span class="cov6" title="14">if vs := r.Form[key]; len(vs) &gt; 0 </span><span class="cov6" title="11">{
                return vs[0]
        }</span>
        <span class="cov3" title="3">return ""</span>
}

// PostFormValue returns the first value for the named component of the POST
// or PUT request body. URL query parameters are ignored.
// PostFormValue calls ParseMultipartForm and ParseForm if necessary.
func (r *Request) PostFormValue(key string) string <span class="cov1" title="1">{
        if r.PostForm == nil </span><span class="cov0" title="0">{
                r.ParseMultipartForm(defaultMaxMemory)
        }</span>
        <span class="cov1" title="1">if vs := r.PostForm[key]; len(vs) &gt; 0 </span><span class="cov1" title="1">{
                return vs[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FormFile returns the first file for the provided form key.
// FormFile calls ParseMultipartForm and ParseForm if necessary.
func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error) <span class="cov6" title="10">{
        if r.MultipartForm == multipartByReader </span><span class="cov0" title="0">{
                return nil, nil, errors.New("http: multipart handled by MultipartReader")
        }</span>
        <span class="cov6" title="10">if r.MultipartForm == nil </span><span class="cov1" title="1">{
                err := r.ParseMultipartForm(defaultMaxMemory)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }
        <span class="cov6" title="10">if r.MultipartForm != nil &amp;&amp; r.MultipartForm.File != nil </span><span class="cov5" title="9">{
                if fhs := r.MultipartForm.File[key]; len(fhs) &gt; 0 </span><span class="cov4" title="6">{
                        f, err := fhs[0].Open()
                        return f, fhs[0], err
                }</span>
        }
        <span class="cov4" title="4">return nil, nil, ErrMissingFile</span>
}

func (r *Request) ExpectsContinue() bool <span class="cov0" title="0">{
        return HasToken(r.Header.GetDirect("Expect"), "100-continue")
}</span>

func (r *Request) WantsHttp10KeepAlive() bool <span class="cov0" title="0">{
        if r.ProtoMajor != 1 || r.ProtoMinor != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

    // change http 1.0 keepalive to ignore header Connection, keep consistent with c-bfe
    // just for simplify comparasion in the process of replace bfe
    // TODO: after replacement finish, change back
        //return HasToken(r.Header.GetDirect("Connection"), "keep-alive")
    <span class="cov0" title="0">return false</span>
}

func (r *Request) WantsClose() bool <span class="cov0" title="0">{
        return HasToken(r.Header.GetDirect("Connection"), "close")
}</span>

func (r *Request) closeBody() <span class="cov0" title="0">{
    if r.Body != nil </span><span class="cov0" title="0">{
        r.Body.Close()
    }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP Response reading and parsing.

package bfe_http

import (
        "errors"
        "io"
        "net/url"
        "strconv"
        "strings"
)

import (
    "bfe_bufio"
        "bfe_net/textproto"
    "bfe_tls"
)

var respExcludeHeader = map[string]bool{
        "Content-Length":    true,
        "Transfer-Encoding": true,
        "Trailer":           true,
}

// The SignCalculater interface is used to calculate signature for response
type SignCalculater interface {
    CalcSign(feature string) string
}

// Response represents the response from an HTTP request.
//
type Response struct {
        Status     string // e.g. "200 OK"
        StatusCode int    // e.g. 200
        Proto      string // e.g. "HTTP/1.0"
        ProtoMajor int    // e.g. 1
        ProtoMinor int    // e.g. 0

        // Header maps header keys to values.  If the response had multiple
        // headers with the same key, they may be concatenated, with comma
        // delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers
        // be semantically equivalent to a comma-delimited sequence.) Values
        // duplicated by other fields in this struct (e.g., ContentLength) are
        // omitted from Header.
        //
        // Keys in the map are canonicalized (see CanonicalHeaderKey).
        Header Header

        // Body represents the response body.
        //
        // The http Client and Transport guarantee that Body is always
        // non-nil, even on responses without a body or responses with
        // a zero-lengthed body.
        //
        // The Body is automatically dechunked if the server replied
        // with a "chunked" Transfer-Encoding.
        Body io.ReadCloser

        // ContentLength records the length of the associated content.  The
        // value -1 indicates that the length is unknown.  Unless Request.Method
        // is "HEAD", values &gt;= 0 indicate that the given number of bytes may
        // be read from Body.
        ContentLength int64

        // Contains transfer encodings from outer-most to inner-most. Value is
        // nil, means that "identity" encoding is used.
        TransferEncoding []string

    // Signer calculate signature for response
    Signer SignCalculater

        // Close records whether the header directed that the connection be
        // closed after reading Body.  The value is advice for clients: neither
        // ReadResponse nor Response.Write ever closes a connection.
        Close bool

        // Trailer maps trailer keys to values, in the same
        // format as the header.
        Trailer Header

        // The Request that was sent to obtain this Response.
        // Request's Body is nil (having already been consumed).
        // This is only populated for Client requests.
        Request *Request

    // TLS contains information about the TLS connection on which the
    // response was received. It is nil for unencrypted responses.
    // The pointer is shared between responses and should not be
    // modified.
    TLS *bfe_tls.ConnectionState
}

// Cookies parses and returns the cookies set in the Set-Cookie headers.
func (r *Response) Cookies() []*Cookie <span class="cov0" title="0">{
        return readSetCookies(r.Header)
}</span>

var ErrNoLocation = errors.New("http: no Location header in response")

// Location returns the URL of the response's "Location" header,
// if present.  Relative redirects are resolved relative to
// the Response's Request.  ErrNoLocation is returned if no
// Location header is present.
func (r *Response) Location() (*url.URL, error) <span class="cov3" title="3">{
        lv := r.Header.Get("Location")
        if lv == "" </span><span class="cov1" title="1">{
                return nil, ErrNoLocation
        }</span>
        <span class="cov2" title="2">if r.Request != nil &amp;&amp; r.Request.URL != nil </span><span class="cov2" title="2">{
                return r.Request.URL.Parse(lv)
        }</span>
        <span class="cov0" title="0">return url.Parse(lv)</span>
}

// ReadResponse reads and returns an HTTP response from r.
// The req parameter optionally specifies the Request that corresponds
// to this Response. If nil, a GET request is assumed.
// Clients must call resp.Body.Close when finished reading resp.Body.
// After that call, clients can inspect resp.Trailer to find key/value
// pairs included in the response trailer.
func ReadResponse(r *bfe_bufio.Reader, req *Request) (*Response, error) <span class="cov9" title="34">{
        tp := textproto.NewReader(r)
        resp := &amp;Response{
                Request: req,
        }

        // Parse the first line of the response.
        line, err := tp.ReadLine()
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov9" title="34">f := strings.SplitN(line, " ", 3)
        if len(f) &lt; 2 </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP response", line}
        }</span>
        <span class="cov9" title="34">reasonPhrase := ""
        if len(f) &gt; 2 </span><span class="cov9" title="32">{
                reasonPhrase = f[2]
        }</span>
        <span class="cov9" title="34">resp.Status = f[1] + " " + reasonPhrase
        resp.StatusCode, err = strconv.Atoi(f[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP status code", f[1]}
        }</span>

        <span class="cov9" title="34">resp.Proto = f[0]
        var ok bool
        if resp.ProtoMajor, resp.ProtoMinor, ok = ParseHTTPVersion(resp.Proto); !ok </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"malformed HTTP version", resp.Proto}
        }</span>

        // Parse the response headers.
        <span class="cov9" title="34">mimeHeader, err := tp.ReadMIMEHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="34">resp.Header = Header(mimeHeader)

        fixPragmaCacheControl(resp.Header)

        err = readTransfer(resp, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="34">return resp, nil</span>
}

// RFC2616: Should treat
//        Pragma: no-cache
// like
//        Cache-Control: no-cache
func fixPragmaCacheControl(header Header) <span class="cov10" title="44">{
        if hp, ok := header["Pragma"]; ok &amp;&amp; len(hp) &gt; 0 &amp;&amp; hp[0] == "no-cache" </span><span class="cov0" title="0">{
                if _, presentcc := header["Cache-Control"]; !presentcc </span><span class="cov0" title="0">{
                        header["Cache-Control"] = []string{"no-cache"}
                }</span>
        }
}

// ProtoAtLeast reports whether the HTTP protocol used
// in the response is at least major.minor.
func (r *Response) ProtoAtLeast(major, minor int) bool <span class="cov8" title="20">{
        return r.ProtoMajor &gt; major ||
                r.ProtoMajor == major &amp;&amp; r.ProtoMinor &gt;= minor
}</span>

// Writes the response (header, body and trailer) in wire format. This method
// consults the following fields of the response:
//
//  StatusCode
//  ProtoMajor
//  ProtoMinor
//  Request.Method
//  TransferEncoding
//  Trailer
//  Body
//  ContentLength
//  Header, values for non-canonical keys will have unpredictable behavior
//
func (r *Response) Write(w io.Writer) error <span class="cov8" title="20">{

        // Status line
        text := r.Status
        if text == "" </span><span class="cov4" title="4">{
                var ok bool
                text, ok = StatusText[r.StatusCode]
                if !ok </span><span class="cov0" title="0">{
                        text = "status code " + strconv.Itoa(r.StatusCode)
                }</span>
        }
        <span class="cov8" title="20">protoMajor, protoMinor := strconv.Itoa(r.ProtoMajor), strconv.Itoa(r.ProtoMinor)
        statusCode := strconv.Itoa(r.StatusCode) + " "
        text = strings.TrimPrefix(text, statusCode)
        io.WriteString(w, "HTTP/"+protoMajor+"."+protoMinor+" "+statusCode+text+"\r\n")

        // Process Body,ContentLength,Close,Trailer
        tw, err := newTransferWriter(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="20">err = tw.WriteHeader(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Rest of header
        <span class="cov8" title="20">err = r.Header.WriteSubset(w, respExcludeHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // End-of-header
        <span class="cov8" title="20">io.WriteString(w, "\r\n")

        // Write body and trailer
        err = tw.WriteBody(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Success
        <span class="cov8" title="20">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "bytes"
        "encoding/binary"
)

// The algorithm uses at most sniffLen bytes to make its decision.
const sniffLen = 512

// DetectContentType implements the algorithm described
// at http://mimesniff.spec.whatwg.org/ to determine the
// Content-Type of the given data.  It considers at most the
// first 512 bytes of data.  DetectContentType always returns
// a valid MIME type: if it cannot determine a more specific one, it
// returns "application/octet-stream".
func DetectContentType(data []byte) string <span class="cov0" title="0">{
        if len(data) &gt; sniffLen </span><span class="cov0" title="0">{
                data = data[:sniffLen]
        }</span>

        // Index of the first non-whitespace byte in data.
        <span class="cov0" title="0">firstNonWS := 0
        for ; firstNonWS &lt; len(data) &amp;&amp; isWS(data[firstNonWS]); firstNonWS++ </span><span class="cov0" title="0">{
        }</span>

        <span class="cov0" title="0">for _, sig := range sniffSignatures </span><span class="cov0" title="0">{
                if ct := sig.match(data, firstNonWS); ct != "" </span><span class="cov0" title="0">{
                        return ct
                }</span>
        }

        <span class="cov0" title="0">return "application/octet-stream"</span> // fallback
}

func isWS(b byte) bool <span class="cov0" title="0">{
        return bytes.IndexByte([]byte("\t\n\x0C\r "), b) != -1
}</span>

type sniffSig interface {
        // match returns the MIME type of the data, or "" if unknown.
        match(data []byte, firstNonWS int) string
}

// Data matching the table in section 6.
var sniffSignatures = []sniffSig{
        htmlSig("&lt;!DOCTYPE HTML"),
        htmlSig("&lt;HTML"),
        htmlSig("&lt;HEAD"),
        htmlSig("&lt;SCRIPT"),
        htmlSig("&lt;IFRAME"),
        htmlSig("&lt;H1"),
        htmlSig("&lt;DIV"),
        htmlSig("&lt;FONT"),
        htmlSig("&lt;TABLE"),
        htmlSig("&lt;A"),
        htmlSig("&lt;STYLE"),
        htmlSig("&lt;TITLE"),
        htmlSig("&lt;B"),
        htmlSig("&lt;BODY"),
        htmlSig("&lt;BR"),
        htmlSig("&lt;P"),
        htmlSig("&lt;!--"),

        &amp;maskedSig{mask: []byte("\xFF\xFF\xFF\xFF\xFF"), pat: []byte("&lt;?xml"), skipWS: true, ct: "text/xml; charset=utf-8"},

        &amp;exactSig{[]byte("%PDF-"), "application/pdf"},
        &amp;exactSig{[]byte("%!PS-Adobe-"), "application/postscript"},

        // UTF BOMs.
        &amp;maskedSig{mask: []byte("\xFF\xFF\x00\x00"), pat: []byte("\xFE\xFF\x00\x00"), ct: "text/plain; charset=utf-16be"},
        &amp;maskedSig{mask: []byte("\xFF\xFF\x00\x00"), pat: []byte("\xFF\xFE\x00\x00"), ct: "text/plain; charset=utf-16le"},
        &amp;maskedSig{mask: []byte("\xFF\xFF\xFF\x00"), pat: []byte("\xEF\xBB\xBF\x00"), ct: "text/plain; charset=utf-8"},

        &amp;exactSig{[]byte("GIF87a"), "image/gif"},
        &amp;exactSig{[]byte("GIF89a"), "image/gif"},
        &amp;exactSig{[]byte("\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"), "image/png"},
        &amp;exactSig{[]byte("\xFF\xD8\xFF"), "image/jpeg"},
        &amp;exactSig{[]byte("BM"), "image/bmp"},
        &amp;maskedSig{
                mask: []byte("\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF"),
                pat:  []byte("RIFF\x00\x00\x00\x00WEBPVP"),
                ct:   "image/webp",
        },
        &amp;exactSig{[]byte("\x00\x00\x01\x00"), "image/vnd.microsoft.icon"},
        &amp;exactSig{[]byte("\x4F\x67\x67\x53\x00"), "application/ogg"},
        &amp;maskedSig{
                mask: []byte("\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF"),
                pat:  []byte("RIFF\x00\x00\x00\x00WAVE"),
                ct:   "audio/wave",
        },
        &amp;exactSig{[]byte("\x1A\x45\xDF\xA3"), "video/webm"},
        &amp;exactSig{[]byte("\x52\x61\x72\x20\x1A\x07\x00"), "application/x-rar-compressed"},
        &amp;exactSig{[]byte("\x50\x4B\x03\x04"), "application/zip"},
        &amp;exactSig{[]byte("\x1F\x8B\x08"), "application/x-gzip"},

        // TODO(dsymonds): Re-enable this when the spec is sorted w.r.t. MP4.
        //mp4Sig(0),

        textSig(0), // should be last
}

type exactSig struct {
        sig []byte
        ct  string
}

func (e *exactSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        if bytes.HasPrefix(data, e.sig) </span><span class="cov0" title="0">{
                return e.ct
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type maskedSig struct {
        mask, pat []byte
        skipWS    bool
        ct        string
}

func (m *maskedSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        if m.skipWS </span><span class="cov0" title="0">{
                data = data[firstNonWS:]
        }</span>
        <span class="cov0" title="0">if len(data) &lt; len(m.mask) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for i, mask := range m.mask </span><span class="cov0" title="0">{
                db := data[i] &amp; mask
                if db != m.pat[i] </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        <span class="cov0" title="0">return m.ct</span>
}

type htmlSig []byte

func (h htmlSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        data = data[firstNonWS:]
        if len(data) &lt; len(h)+1 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for i, b := range h </span><span class="cov0" title="0">{
                db := data[i]
                if 'A' &lt;= b &amp;&amp; b &lt;= 'Z' </span><span class="cov0" title="0">{
                        db &amp;= 0xDF
                }</span>
                <span class="cov0" title="0">if b != db </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        // Next byte must be space or right angle bracket.
        <span class="cov0" title="0">if db := data[len(h)]; db != ' ' &amp;&amp; db != '&gt;' </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return "text/html; charset=utf-8"</span>
}

type mp4Sig int

func (mp4Sig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        // c.f. section 6.1.
        if len(data) &lt; 8 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">boxSize := int(binary.BigEndian.Uint32(data[:4]))
        if boxSize%4 != 0 || len(data) &lt; boxSize </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if !bytes.Equal(data[4:8], []byte("ftyp")) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for st := 8; st &lt; boxSize; st += 4 </span><span class="cov0" title="0">{
                if st == 12 </span><span class="cov0" title="0">{
                        // minor version number
                        continue</span>
                }
                <span class="cov0" title="0">seg := string(data[st : st+3])
                switch seg </span>{
                <span class="cov0" title="0">case "mp4", "iso", "M4V", "M4P", "M4B":
                        return "video/mp4"</span>
                        /* The remainder are not in the spec.
                        case "M4A":
                                return "audio/mp4"
                        case "3gp":
                                return "video/3gpp"
                        case "jp2":
                                return "image/jp2" // JPEG 2000
                        */
                }
        }
        <span class="cov0" title="0">return ""</span>
}

type textSig int

func (textSig) match(data []byte, firstNonWS int) string <span class="cov0" title="0">{
        // c.f. section 5, step 4.
        for _, b := range data[firstNonWS:] </span><span class="cov0" title="0">{
                switch </span>{
                <span class="cov0" title="0">case 0x00 &lt;= b &amp;&amp; b &lt;= 0x08,
                        b == 0x0B,
                        0x0E &lt;= b &amp;&amp; b &lt;= 0x1A,
                        0x1C &lt;= b &amp;&amp; b &lt;= 0x1F:
                        return ""</span>
                }
        }
        <span class="cov0" title="0">return "text/plain; charset=utf-8"</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

// HTTP status codes, defined in RFC 2616.
const (
        StatusContinue           = 100
        StatusSwitchingProtocols = 101

        StatusOK                   = 200
        StatusCreated              = 201
        StatusAccepted             = 202
        StatusNonAuthoritativeInfo = 203
        StatusNoContent            = 204
        StatusResetContent         = 205
        StatusPartialContent       = 206

        StatusMultipleChoices   = 300
        StatusMovedPermanently  = 301
        StatusFound             = 302
        StatusSeeOther          = 303
        StatusNotModified       = 304
        StatusUseProxy          = 305
        StatusTemporaryRedirect = 307

        StatusBadRequest                   = 400
        StatusUnauthorized                 = 401
        StatusPaymentRequired              = 402
        StatusForbidden                    = 403
        StatusNotFound                     = 404
        StatusMethodNotAllowed             = 405
        StatusNotAcceptable                = 406
        StatusProxyAuthRequired            = 407
        StatusRequestTimeout               = 408
        StatusConflict                     = 409
        StatusGone                         = 410
        StatusLengthRequired               = 411
        StatusPreconditionFailed           = 412
        StatusRequestEntityTooLarge        = 413
        StatusRequestURITooLong            = 414
        StatusUnsupportedMediaType         = 415
        StatusRequestedRangeNotSatisfiable = 416
        StatusExpectationFailed            = 417
        StatusTeapot                       = 418

        StatusInternalServerError     = 500
        StatusNotImplemented          = 501
        StatusBadGateway              = 502
        StatusServiceUnavailable      = 503
        StatusGatewayTimeout          = 504
        StatusHTTPVersionNotSupported = 505

        // New HTTP status codes from RFC 6585. Not exported yet in Go 1.1.
        // See discussion at https://codereview.appspot.com/7678043/
        statusPreconditionRequired          = 428
        statusTooManyRequests               = 429
        statusRequestHeaderFieldsTooLarge   = 431
        statusNetworkAuthenticationRequired = 511
)

var StatusText = map[int]string{
        StatusContinue:           "Continue",
        StatusSwitchingProtocols: "Switching Protocols",

        StatusOK:                   "OK",
        StatusCreated:              "Created",
        StatusAccepted:             "Accepted",
        StatusNonAuthoritativeInfo: "Non-Authoritative Information",
        StatusNoContent:            "No Content",
        StatusResetContent:         "Reset Content",
        StatusPartialContent:       "Partial Content",

        StatusMultipleChoices:   "Multiple Choices",
        StatusMovedPermanently:  "Moved Permanently",
        StatusFound:             "Found",
        StatusSeeOther:          "See Other",
        StatusNotModified:       "Not Modified",
        StatusUseProxy:          "Use Proxy",
        StatusTemporaryRedirect: "Temporary Redirect",

        StatusBadRequest:                   "Bad Request",
        StatusUnauthorized:                 "Unauthorized",
        StatusPaymentRequired:              "Payment Required",
        StatusForbidden:                    "Forbidden",
        StatusNotFound:                     "Not Found",
        StatusMethodNotAllowed:             "Method Not Allowed",
        StatusNotAcceptable:                "Not Acceptable",
        StatusProxyAuthRequired:            "Proxy Authentication Required",
        StatusRequestTimeout:               "Request Timeout",
        StatusConflict:                     "Conflict",
        StatusGone:                         "Gone",
        StatusLengthRequired:               "Length Required",
        StatusPreconditionFailed:           "Precondition Failed",
        StatusRequestEntityTooLarge:        "Request Entity Too Large",
        StatusRequestURITooLong:            "Request URI Too Long",
        StatusUnsupportedMediaType:         "Unsupported Media Type",
        StatusRequestedRangeNotSatisfiable: "Requested Range Not Satisfiable",
        StatusExpectationFailed:            "Expectation Failed",
        StatusTeapot:                       "I'm a teapot",

        StatusInternalServerError:     "Internal Server Error",
        StatusNotImplemented:          "Not Implemented",
        StatusBadGateway:              "Bad Gateway",
        StatusServiceUnavailable:      "Service Unavailable",
        StatusGatewayTimeout:          "Gateway Timeout",
        StatusHTTPVersionNotSupported: "HTTP Version Not Supported",

        statusPreconditionRequired:          "Precondition Required",
        statusTooManyRequests:               "Too Many Requests",
        statusRequestHeaderFieldsTooLarge:   "Request Header Fields Too Large",
        statusNetworkAuthenticationRequired: "Network Authentication Required",
}

// StatusText returns a text for the HTTP status code. It returns the empty
// string if the code is unknown.
func StatusTextGet(code int) string <span class="cov0" title="0">{
        return StatusText[code]
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_http

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "strconv"
        "strings"
)

import (
        "bfe_bufio"
        "bfe_net/textproto"
)

// transferWriter inspects the fields of a user-supplied Request or Response,
// sanitizes them without changing the user object and provides methods for
// writing the respective header, body and trailer in wire format.
type transferWriter struct {
        Method           string
        Body             io.Reader
        BodyCloser       io.Closer
        ResponseToHEAD   bool
        ContentLength    int64 // -1 means unknown, 0 means exactly none
        Close            bool
        TransferEncoding []string
        Trailer          Header
}

func newTransferWriter(r interface{}) (t *transferWriter, err error) <span class="cov5" title="45">{
        t = &amp;transferWriter{}

        // Extract relevant fields
        atLeastHTTP11 := false
        switch rr := r.(type) </span>{
        <span class="cov4" title="25">case *Request:
                if rr.ContentLength != 0 &amp;&amp; rr.Body == nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("http: Request.ContentLength=%d with nil Body", rr.ContentLength)
                }</span>
                <span class="cov4" title="24">t.Method = rr.Method
                t.Body = rr.Body
                t.BodyCloser = rr.Body
                t.ContentLength = rr.ContentLength
                t.Close = rr.Close
                t.TransferEncoding = rr.TransferEncoding
                t.Trailer = rr.Trailer
                atLeastHTTP11 = rr.ProtoAtLeast(1, 1)
                if t.Body != nil &amp;&amp; len(t.TransferEncoding) == 0 &amp;&amp; atLeastHTTP11 </span><span class="cov3" title="9">{
                        if t.ContentLength == 0 </span><span class="cov2" title="5">{
                                // Test to see if it's actually zero or just unset.
                                var buf [1]byte
                                n, _ := io.ReadFull(t.Body, buf[:])
                                if n == 1 </span><span class="cov2" title="3">{
                                        // Oh, guess there is data in this Body Reader after all.
                                        // The ContentLength field just wasn't set.
                                        // Stich the Body back together again, re-attaching our
                                        // consumed byte.
                                        t.ContentLength = -1
                                        t.Body = io.MultiReader(bytes.NewBuffer(buf[:]), t.Body)
                                }</span> <span class="cov1" title="2">else {
                                        // Body is actually empty.
                                        t.Body = nil
                                        t.BodyCloser = nil
                                }</span>
                        }
                        <span class="cov3" title="9">if t.ContentLength &lt; 0 </span><span class="cov2" title="3">{
                                t.TransferEncoding = []string{"chunked"}
                        }</span>
                }
        <span class="cov4" title="20">case *Response:
                if rr.Request != nil </span><span class="cov4" title="18">{
                        t.Method = rr.Request.Method
                }</span>
                <span class="cov4" title="20">t.Body = rr.Body
                t.BodyCloser = rr.Body
                t.ContentLength = rr.ContentLength
                t.Close = rr.Close
                t.TransferEncoding = rr.TransferEncoding
                t.Trailer = rr.Trailer
                atLeastHTTP11 = rr.ProtoAtLeast(1, 1)
                t.ResponseToHEAD = noBodyExpected(t.Method)</span>
        }

        // Sanitize Body,ContentLength,TransferEncoding
        <span class="cov5" title="44">if t.ResponseToHEAD </span><span class="cov2" title="4">{
                t.Body = nil
                if chunked(t.TransferEncoding) </span><span class="cov1" title="1">{
                        t.ContentLength = -1
                }</span>
        } <span class="cov5" title="40">else {
                if !atLeastHTTP11 || t.Body == nil </span><span class="cov4" title="22">{
                        t.TransferEncoding = nil
                }</span>
                <span class="cov5" title="40">if chunked(t.TransferEncoding) </span><span class="cov3" title="10">{
                        t.ContentLength = -1
                }</span> <span class="cov5" title="30">else if t.Body == nil </span><span class="cov4" title="13">{ // no chunking, no body
                        t.ContentLength = 0
                }</span>
        }

        // Sanitize Trailer
        <span class="cov5" title="44">if !chunked(t.TransferEncoding) </span><span class="cov5" title="33">{
                t.Trailer = nil
        }</span>

        <span class="cov5" title="44">return t, nil</span>
}

func noBodyExpected(requestMethod string) bool <span class="cov6" title="73">{
        return requestMethod == "HEAD"
}</span>

func (t *transferWriter) shouldSendContentLength() bool <span class="cov5" title="44">{
        if chunked(t.TransferEncoding) </span><span class="cov3" title="11">{
                return false
        }</span>
        <span class="cov5" title="33">if t.ContentLength &gt; 0 </span><span class="cov3" title="10">{
                return true
        }</span>
        // Many servers expect a Content-Length for these methods
        <span class="cov4" title="23">if t.Method == "POST" || t.Method == "PUT" </span><span class="cov1" title="2">{
                return true
        }</span>
        <span class="cov4" title="21">if t.ContentLength == 0 &amp;&amp; isIdentity(t.TransferEncoding) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov4" title="21">return false</span>
}

func (t *transferWriter) WriteHeader(w io.Writer) (err error) <span class="cov5" title="44">{
        if t.Close </span><span class="cov4" title="15">{
                _, err = io.WriteString(w, "Connection: close\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Write Content-Length and/or Transfer-Encoding whose values are a
        // function of the sanitized field triple (Body, ContentLength,
        // TransferEncoding)
        <span class="cov5" title="44">if t.shouldSendContentLength() </span><span class="cov3" title="12">{
                io.WriteString(w, "Content-Length: ")
                _, err = io.WriteString(w, strconv.FormatInt(t.ContentLength, 10)+"\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        } <span class="cov5" title="32">else if chunked(t.TransferEncoding) </span><span class="cov3" title="11">{
                _, err = io.WriteString(w, "Transfer-Encoding: chunked\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // Write Trailer header
        <span class="cov5" title="44">if t.Trailer != nil </span><span class="cov0" title="0">{
                // TODO: At some point, there should be a generic mechanism for
                // writing long headers, using HTTP line splitting
                io.WriteString(w, "Trailer: ")
                needComma := false
                for k := range t.Trailer </span><span class="cov0" title="0">{
                        k = CanonicalHeaderKey(k)
                        switch k </span>{
                        <span class="cov0" title="0">case "Transfer-Encoding", "Trailer", "Content-Length":
                                return &amp;badStringError{"invalid Trailer key", k}</span>
                        }
                        <span class="cov0" title="0">if needComma </span><span class="cov0" title="0">{
                                io.WriteString(w, ",")
                        }</span>
                        <span class="cov0" title="0">io.WriteString(w, k)
                        needComma = true</span>
                }
                <span class="cov0" title="0">_, err = io.WriteString(w, "\r\n")</span>
        }

        <span class="cov5" title="44">return</span>
}

func (t *transferWriter) WriteBody(w io.Writer) (err error) <span class="cov5" title="44">{
        var ncopy int64

        // Write body
        if t.Body != nil </span><span class="cov4" title="27">{
            
                if chunked(t.TransferEncoding) </span><span class="cov3" title="10">{
                        cw := newChunkedWriter(w)
                        _, err = io.Copy(cw, t.Body)
                        if err == nil </span><span class="cov3" title="10">{
                                err = cw.Close()
                        }</span>
                } <span class="cov4" title="17">else if t.ContentLength == -1 </span><span class="cov3" title="7">{
                        ncopy, err = io.Copy(w, t.Body)
                }</span> <span class="cov3" title="10">else {
                        ncopy, err = io.Copy(w, io.LimitReader(t.Body, t.ContentLength))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="10">var nextra int64
                        nextra, err = io.Copy(ioutil.Discard, t.Body)
                        ncopy += nextra</span>
                }
                <span class="cov4" title="27">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="27">if err = t.BodyCloser.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="44">if !t.ResponseToHEAD &amp;&amp; t.ContentLength != -1 &amp;&amp; t.ContentLength != ncopy </span><span class="cov1" title="2">{
                return fmt.Errorf("http: Request.ContentLength=%d with Body length %d",
                        t.ContentLength, ncopy)
        }</span>

        // TODO(petar): Place trailer writer code here.
        <span class="cov5" title="42">if chunked(t.TransferEncoding) </span><span class="cov3" title="11">{
                // Last chunk, empty trailer
                _, err = io.WriteString(w, "\r\n")
        }</span>

        <span class="cov5" title="42">return</span>
}

type transferReader struct {
        // Input
        Header        Header
        StatusCode    int
        RequestMethod string
        ProtoMajor    int
        ProtoMinor    int
        // Output
        Body             io.ReadCloser
        ContentLength    int64
        TransferEncoding []string
        Close            bool
        Trailer          Header
}

// bodyAllowedForStatus reports whether a given response status code
// permits a body.  See RFC2616, section 4.4.
func bodyAllowedForStatus(status int) bool <span class="cov3" title="12">{
        switch </span>{
        <span class="cov0" title="0">case status &gt;= 100 &amp;&amp; status &lt;= 199:
                return false</span>
        <span class="cov0" title="0">case status == 204:
                return false</span>
        <span class="cov0" title="0">case status == 304:
                return false</span>
        }
        <span class="cov3" title="12">return true</span>
}

// msg is *Request or *Response.
func readTransfer(msg interface{}, r *bfe_bufio.Reader) (err error) <span class="cov5" title="44">{
        t := &amp;transferReader{RequestMethod: "GET"}

        // Unify input
        isResponse := false
        switch rr := msg.(type) </span>{
        <span class="cov5" title="34">case *Response:
                t.Header = rr.Header
                t.StatusCode = rr.StatusCode
                t.ProtoMajor = rr.ProtoMajor
                t.ProtoMinor = rr.ProtoMinor
                t.Close = shouldClose(t.ProtoMajor, t.ProtoMinor, t.Header)
                isResponse = true
                if rr.Request != nil </span><span class="cov5" title="32">{
                        t.RequestMethod = rr.Request.Method
                }</span>
        <span class="cov3" title="10">case *Request:
                t.Header = rr.Header
                t.ProtoMajor = rr.ProtoMajor
                t.ProtoMinor = rr.ProtoMinor
                // Transfer semantics for Requests are exactly like those for
                // Responses with status code 200, responding to a GET method
                t.StatusCode = 200</span>
        <span class="cov0" title="0">default:
                panic("unexpected type")</span>
        }

        // Default to HTTP/1.1
        <span class="cov5" title="44">if t.ProtoMajor == 0 &amp;&amp; t.ProtoMinor == 0 </span><span class="cov0" title="0">{
                t.ProtoMajor, t.ProtoMinor = 1, 1
        }</span>

        // Transfer encoding, content length
        <span class="cov5" title="44">t.TransferEncoding, err = fixTransferEncoding(t.RequestMethod, t.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="44">realLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="44">if isResponse &amp;&amp; t.RequestMethod == "HEAD" </span><span class="cov3" title="8">{
                if n, err := parseContentLength(t.Header.GetDirect("Content-Length")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> <span class="cov3" title="8">else {
                        t.ContentLength = n
                }</span>
        } <span class="cov5" title="36">else {
                t.ContentLength = realLength
        }</span>

        // Trailer
        <span class="cov5" title="44">t.Trailer, err = fixTrailer(t.Header, t.TransferEncoding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If there is no Content-Length or chunked Transfer-Encoding on a *Response
        // and the status is not 1xx, 204 or 304, then the body is unbounded.
        // See RFC2616, section 4.4.
        <span class="cov5" title="44">switch msg.(type) </span>{
        <span class="cov5" title="34">case *Response:
                if realLength == -1 &amp;&amp;
                        !chunked(t.TransferEncoding) &amp;&amp;
                        bodyAllowedForStatus(t.StatusCode) </span><span class="cov3" title="12">{
                        // Unbounded body.
                        t.Close = true
                }</span>
        }

        // Prepare body reader.  ContentLength &lt; 0 means chunked encoding
        // or close connection when finished, since multipart is not supported yet
        <span class="cov5" title="44">switch </span>{
        <span class="cov3" title="9">case chunked(t.TransferEncoding):
                if noBodyExpected(t.RequestMethod) </span><span class="cov1" title="2">{
                        t.Body = EofReader
                }</span> <span class="cov3" title="7">else {
                        t.Body = &amp;body{Reader: newChunkedReader(r), hdr: msg, r: r, closing: t.Close}
                }</span>
        <span class="cov4" title="18">case realLength == 0:
                t.Body = EofReader</span>
        <span class="cov2" title="5">case realLength &gt; 0:
                // weiwei02: set r for peek data from body
                t.Body = &amp;body{Reader: io.LimitReader(r, realLength), r: r, closing: t.Close}</span>
        <span class="cov3" title="12">default:
                // realLength &lt; 0, i.e. "Content-Length" not mentioned in header
                if t.Close </span><span class="cov3" title="12">{
                        // Close semantics (i.e. HTTP/1.0)
                        t.Body = &amp;body{Reader: r, closing: t.Close}
                }</span> <span class="cov0" title="0">else {
                        // Persistent connection (i.e. HTTP/1.1)
                        t.Body = EofReader
                }</span>
        }

        // Unify output
        <span class="cov5" title="44">switch rr := msg.(type) </span>{
        <span class="cov3" title="10">case *Request:
                rr.Body = t.Body
                rr.ContentLength = t.ContentLength
                rr.TransferEncoding = t.TransferEncoding
                rr.Close = t.Close
                rr.Trailer = t.Trailer</span>
        <span class="cov5" title="34">case *Response:
                rr.Body = t.Body
                rr.ContentLength = t.ContentLength
                rr.TransferEncoding = t.TransferEncoding
                rr.Close = t.Close
                rr.Trailer = t.Trailer</span>
        }

        <span class="cov5" title="44">return nil</span>
}

// Checks whether chunked is part of the encodings stack
func chunked(te []string) bool <span class="cov7" title="329">{ return len(te) &gt; 0 &amp;&amp; te[0] == "chunked" }</span>

// Checks whether the encoding is explicitly "identity".
func isIdentity(te []string) bool <span class="cov4" title="13">{ return len(te) == 1 &amp;&amp; te[0] == "identity" }</span>

// Sanitize transfer encoding
func fixTransferEncoding(requestMethod string, header Header) ([]string, error) <span class="cov5" title="44">{
        raw, present := header["Transfer-Encoding"]
        if !present </span><span class="cov5" title="35">{
                return nil, nil
        }</span>

        <span class="cov3" title="9">delete(header, "Transfer-Encoding")

        encodings := strings.Split(raw[0], ",")
        te := make([]string, 0, len(encodings))
        // TODO: Even though we only support "identity" and "chunked"
        // encodings, the loop below is designed with foresight. One
        // invariant that must be maintained is that, if present,
        // chunked encoding must always come first.
        for _, encoding := range encodings </span><span class="cov3" title="9">{
                encoding = strings.ToLower(strings.TrimSpace(encoding))
                // "identity" encoding is not recorded
                if encoding == "identity" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov3" title="9">if encoding != "chunked" </span><span class="cov0" title="0">{
                        return nil, &amp;badStringError{"unsupported transfer encoding", encoding}
                }</span>
                <span class="cov3" title="9">te = te[0 : len(te)+1]
                te[len(te)-1] = encoding</span>
        }
        <span class="cov3" title="9">if len(te) &gt; 1 </span><span class="cov0" title="0">{
                return nil, &amp;badStringError{"too many transfer encodings", strings.Join(te, ",")}
        }</span>
        <span class="cov3" title="9">if len(te) &gt; 0 </span><span class="cov3" title="9">{
                // Chunked encoding trumps Content-Length. See RFC 2616
                // Section 4.4. Currently len(te) &gt; 0 implies chunked
                // encoding.
                delete(header, "Content-Length")
                return te, nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// Determine the expected body length, using RFC 2616 Section 4.4. This
// function is not a method, because ultimately it should be shared by
// ReadResponse and ReadRequest.
func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) <span class="cov5" title="44">{

        // Logic based on response type or status
        if noBodyExpected(requestMethod) </span><span class="cov3" title="8">{
                return 0, nil
        }</span>
        <span class="cov5" title="36">if status/100 == 1 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov5" title="36">switch status </span>{
        <span class="cov1" title="2">case 204, 304:
                return 0, nil</span>
        }

        // Logic based on Transfer-Encoding
        <span class="cov5" title="34">if chunked(te) </span><span class="cov3" title="7">{
                return -1, nil
        }</span>

        // Logic based on Content-Length
        <span class="cov4" title="27">cl := strings.TrimSpace(header.GetDirect("Content-Length"))
        if cl != "" </span><span class="cov3" title="7">{
                n, err := parseContentLength(cl)
                if err != nil </span><span class="cov0" title="0">{
                        return -1, err
                }</span>
                <span class="cov3" title="7">return n, nil</span>
        } <span class="cov4" title="20">else {
                header.Del("Content-Length")
        }</span>

        <span class="cov4" title="20">if !isResponse &amp;&amp; requestMethod == "GET" </span><span class="cov3" title="8">{
                // RFC 2616 doesn't explicitly permit nor forbid an
                // entity-body on a GET request so we permit one if
                // declared, but we default to 0 here (not -1 below)
                // if there's no mention of a body.
                return 0, nil
        }</span>

        // Body-EOF logic based on other methods (like closing, or chunked coding)
        <span class="cov3" title="12">return -1, nil</span>
}

// Determine whether to hang up after sending a request and body, or
// receiving a response and body
// 'header' is the request headers
func shouldClose(major, minor int, header Header) bool <span class="cov5" title="34">{
        if major &lt; 1 </span><span class="cov0" title="0">{
                return true
        }</span> <span class="cov5" title="34">else if major == 1 &amp;&amp; minor == 0 </span><span class="cov4" title="14">{
                if !strings.Contains(strings.ToLower(header.GetDirect("Connection")), "keep-alive") </span><span class="cov4" title="14">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov4" title="20">else {
                // TODO: Should split on commas, toss surrounding white space,
                // and check each field.
                if strings.ToLower(header.GetDirect("Connection")) == "close" </span><span class="cov1" title="2">{
                        header.Del("Connection")
                        return true
                }</span>
        }
        <span class="cov4" title="18">return false</span>
}

// Parse the trailer header
func fixTrailer(header Header, te []string) (Header, error) <span class="cov5" title="44">{
        raw := header.GetDirect("Trailer")
        if raw == "" </span><span class="cov5" title="44">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">header.Del("Trailer")
        trailer := make(Header)
        keys := strings.Split(raw, ",")
        for _, key := range keys </span><span class="cov0" title="0">{
                key = CanonicalHeaderKey(strings.TrimSpace(key))
                switch key </span>{
                <span class="cov0" title="0">case "Transfer-Encoding", "Trailer", "Content-Length":
                        return nil, &amp;badStringError{"bad trailer key", key}</span>
                }
                <span class="cov0" title="0">trailer.Del(key)</span>
        }
        <span class="cov0" title="0">if len(trailer) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if !chunked(te) </span><span class="cov0" title="0">{
                // Trailer and no chunking
                return nil, ErrUnexpectedTrailer
        }</span>
        <span class="cov0" title="0">return trailer, nil</span>
}

// body turns a Reader into a ReadCloser.
// Close ensures that the body has been fully read
// and then reads the trailer if necessary.
type body struct {
        io.Reader
        hdr     interface{}   // non-nil (Response or Request) value means read trailer
        r       *bfe_bufio.Reader // underlying wire-format reader for the trailer
        closing bool          // is the connection to be closed after reading body?
        closed  bool
}

// ErrBodyReadAfterClose is returned when reading a Request or Response
// Body after the body has been closed. This typically happens when the body is
// read after an HTTP Handler calls WriteHeader or Write on its
// ResponseWriter.
var ErrBodyReadAfterClose = errors.New("http: invalid Read on closed Body")

func (b *body) Read(p []byte) (n int, err error) <span class="cov10" title="1732">{
        if b.closed </span><span class="cov0" title="0">{
                return 0, ErrBodyReadAfterClose
        }</span>
        <span class="cov10" title="1732">n, err = b.Reader.Read(p)

        if err == io.EOF </span><span class="cov5" title="31">{
                // Chunked case. Read the trailer.
                if b.hdr != nil </span><span class="cov3" title="8">{
                        if e := b.readTrailer(); e != nil </span><span class="cov1" title="1">{
                                err = e
                        }</span>
                        <span class="cov3" title="8">b.hdr = nil</span>
                } <span class="cov4" title="23">else {
                        // If the server declared the Content-Length, our body is a LimitedReader
                        // and we need to check whether this EOF arrived early.
                        if lr, ok := b.Reader.(*io.LimitedReader); ok &amp;&amp; lr.N &gt; 0 </span><span class="cov1" title="1">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                }
        }

        <span class="cov10" title="1732">return n, err</span>
}

var (
        singleCRLF = []byte("\r\n")
        doubleCRLF = []byte("\r\n\r\n")
)

func seeUpcomingDoubleCRLF(r *bfe_bufio.Reader) bool <span class="cov1" title="1">{
        for peekSize := 4; ; peekSize++ </span><span class="cov4" title="27">{
                // This loop stops when Peek returns an error,
                // which it does when r's buffer has been filled.
                buf, err := r.Peek(peekSize)
                if bytes.HasSuffix(buf, doubleCRLF) </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov4" title="26">if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

var errTrailerEOF = errors.New("http: unexpected EOF reading trailer")

func (b *body) readTrailer() error <span class="cov3" title="8">{
        // The common case, since nobody uses trailers.
        buf, err := b.r.Peek(2)
        if bytes.Equal(buf, singleCRLF) </span><span class="cov3" title="6">{
                b.r.ReadByte()
                b.r.ReadByte()
                return nil
        }</span>
        <span class="cov1" title="2">if len(buf) &lt; 2 </span><span class="cov1" title="1">{
                return errTrailerEOF
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make sure there's a header terminator coming up, to prevent
        // a DoS with an unbounded size Trailer.  It's not easy to
        // slip in a LimitReader here, as textproto.NewReader requires
        // a concrete *bufio.Reader.  Also, we can't get all the way
        // back up to our conn's LimitedReader that *might* be backing
        // this bufio.Reader.  Instead, a hack: we iteratively Peek up
        // to the bufio.Reader's max size, looking for a double CRLF.
        // This limits the trailer to the underlying buffer size, typically 4kB.
        <span class="cov1" title="1">if !seeUpcomingDoubleCRLF(b.r) </span><span class="cov0" title="0">{
                return errors.New("http: suspiciously long trailer after chunked body")
        }</span>

        <span class="cov1" title="1">hdr, err := textproto.NewReader(b.r).ReadMIMEHeader()
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return errTrailerEOF
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov1" title="1">switch rr := b.hdr.(type) </span>{
        <span class="cov1" title="1">case *Request:
                rr.Trailer = Header(hdr)</span>
        <span class="cov0" title="0">case *Response:
                rr.Trailer = Header(hdr)</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// note: add peek function for waf to process body
// peek from underlying buf reader
func (b *body) Peek(n int) ([]byte, error) <span class="cov0" title="0">{
        return b.r.Peek(n)
}</span>

func (b *body) Close() error <span class="cov4" title="23">{
        if b.closed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="23">var err error
        switch </span>{
        <span class="cov4" title="14">case b.hdr == nil &amp;&amp; b.closing:</span>
                // no trailer and closing the connection next.
                // no point in reading to EOF.
        <span class="cov3" title="9">default:
                // Fully consume the body, which will also lead to us reading
                // the trailer headers after the body, if present.
                _, err = io.Copy(ioutil.Discard, b)</span>
        }
        <span class="cov4" title="23">b.closed = true
        return err</span>
}

// parseContentLength trims whitespace from s and returns -1 if no value
// is set, or the value if it's &gt;= 0.
func parseContentLength(cl string) (int64, error) <span class="cov4" title="15">{
        cl = strings.TrimSpace(cl)
        if cl == "" </span><span class="cov2" title="4">{
                return -1, nil
        }</span>
        <span class="cov3" title="11">n, err := strconv.ParseInt(cl, 10, 64)
        if err != nil || n &lt; 0 </span><span class="cov0" title="0">{
                return 0, &amp;badStringError{"bad Content-Length", cl}
        }</span>
        <span class="cov3" title="11">return n, nil</span>

}
</pre>
		
		<pre class="file" id="file46" style="display: none">/* transport.go - http transport    */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
*/
/*
DESCRIPTION
This file is derived from net/http/
*/
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP client implementation. See RFC 2616.
//
// This is the low-level Transport implementation of RoundTripper.
// The high-level interface is in client.go.

package bfe_http

import (
    "compress/gzip"
    "errors"
    "fmt"
    "io"
    "net"
    "net/url"
    "os"
    "runtime"
    "strings"
    "sync"
    "time"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"    
)

import (
    "bfe_bufio"
    "bfe_tls"
)

// DefaultTransport is the default implementation of Transport and is
// used by DefaultClient. It establishes network connections as needed
// and caches them for reuse by subsequent calls. It uses HTTP proxies
// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and
// $no_proxy) environment variables.
var DefaultTransport RoundTripper = &amp;Transport{Proxy: ProxyFromEnvironment}

// DefaultMaxIdleConnsPerHost is the default value of Transport's
// MaxIdleConnsPerHost.
const DefaultMaxIdleConnsPerHost = 2

// Transport is an implementation of RoundTripper that supports http,
// https, and http proxies (for either http or https with CONNECT).
// Transport can also cache connections for future re-use.
type Transport struct {
    idleMu     sync.Mutex
    idleConn   map[string][]*persistConn
    idleConnCh map[string]chan *persistConn
    reqMu      sync.Mutex
    reqConn    map[*Request]*persistConn
    altMu      sync.RWMutex
    altProto   map[string]RoundTripper // nil or map of URI scheme =&gt; RoundTripper

    // Proxy specifies a function to return a proxy for a given
    // Request. If the function returns a non-nil error, the
    // request is aborted with the provided error.
    // If Proxy is nil or returns a nil *URL, no proxy is used.
    Proxy func(*Request) (*url.URL, error)

    // Dial specifies the dial function for creating TCP
    // connections.
    // If Dial is nil, net.Dial is used.
    Dial func(network, addr string) (net.Conn, error)

    // TLSClientConfig specifies the TLS configuration to use with
    // tls.Client. If nil, the default configuration is used.
    TLSClientConfig *bfe_tls.Config

    // DisableKeepAlives, if true, prevents re-use of TCP connections
    // between different HTTP requests.
    DisableKeepAlives bool

    // DisableCompression, if true, prevents the Transport from
    // requesting compression with an "Accept-Encoding: gzip"
    // request header when the Request contains no existing
    // Accept-Encoding value. If the Transport requests gzip on
    // its own and gets a gzipped response, it's transparently
    // decoded in the Response.Body. However, if the user
    // explicitly requested gzip it is not automatically
    // uncompressed.
    DisableCompression bool

    // MaxIdleConnsPerHost, if non-zero, controls the maximum idle
    // (keep-alive) to keep per-host.  If zero,
    // DefaultMaxIdleConnsPerHost is used.
    MaxIdleConnsPerHost int

    // ResponseHeaderTimeout, if non-zero, specifies the amount of
    // time to wait for a server's response headers after fully
    // writing the request (including its body, if any). This
    // time does not include the time to read the response body.
    ResponseHeaderTimeout time.Duration

    // TODO: tunable on global max cached connections
    // TODO: tunable on timeout on cached connections
    
    // state for collecting status
    State *module_state2.State
}

// ProxyFromEnvironment returns the URL of the proxy to use for a
// given request, as indicated by the environment variables
// $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy).
// An error is returned if the proxy environment is invalid.
// A nil URL and nil error are returned if no proxy is defined in the
// environment, or a proxy should not be used for the given request.
func ProxyFromEnvironment(req *Request) (*url.URL, error) <span class="cov0" title="0">{
    proxy := getenvEitherCase("HTTP_PROXY")
    if proxy == "" </span><span class="cov0" title="0">{
        return nil, nil
    }</span>
    <span class="cov0" title="0">if !useProxy(canonicalAddr(req.URL)) </span><span class="cov0" title="0">{
        return nil, nil
    }</span>
    <span class="cov0" title="0">proxyURL, err := url.Parse(proxy)
    if err != nil || !strings.HasPrefix(proxyURL.Scheme, "http") </span><span class="cov0" title="0">{
        // proxy was bogus. Try prepending "http://" to it and
        // see if that parses correctly. If not, we fall
        // through and complain about the original one.
        if proxyURL, err := url.Parse("http://" + proxy); err == nil </span><span class="cov0" title="0">{
            return proxyURL, nil
        }</span>
    }
    <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("invalid proxy address %q: %v", proxy, err)
    }</span>
    <span class="cov0" title="0">return proxyURL, nil</span>
}

// ProxyURL returns a proxy function (for use in a Transport)
// that always returns the same URL.
func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error) <span class="cov0" title="0">{
    return func(*Request) (*url.URL, error) </span><span class="cov0" title="0">{
        return fixedURL, nil
    }</span>
}

// transportRequest is a wrapper around a *Request that adds
// optional extra headers to write.
type transportRequest struct {
    *Request        // original request, not to be mutated
    extra    Header // extra headers to write, or nil
}

func (tr *transportRequest) extraHeaders() Header <span class="cov0" title="0">{
    if tr.extra == nil </span><span class="cov0" title="0">{
        tr.extra = make(Header)
    }</span>
    <span class="cov0" title="0">return tr.extra</span>
}

// RoundTrip implements the RoundTripper interface.
//
// For higher-level HTTP client support (such as handling of cookies
// and redirects), see Get, Post, and the Client type.
func (t *Transport) RoundTrip(req *Request) (resp *Response, err error) <span class="cov0" title="0">{
    t.State.Inc("TRANSPORT_REQ_ALL", 1)
    if req.URL == nil </span><span class="cov0" title="0">{
        return nil, errors.New("http: nil Request.URL")
    }</span>
    <span class="cov0" title="0">if req.Header == nil </span><span class="cov0" title="0">{
        return nil, errors.New("http: nil Request.Header")
    }</span>
    <span class="cov0" title="0">if req.URL.Scheme != "http" &amp;&amp; req.URL.Scheme != "https" </span><span class="cov0" title="0">{
        t.altMu.RLock()
        var rt RoundTripper
        if t.altProto != nil </span><span class="cov0" title="0">{
            rt = t.altProto[req.URL.Scheme]
        }</span>
        <span class="cov0" title="0">t.altMu.RUnlock()
        if rt == nil </span><span class="cov0" title="0">{
            return nil, &amp;badStringError{"unsupported protocol scheme", req.URL.Scheme}
        }</span>
        <span class="cov0" title="0">return rt.RoundTrip(req)</span>
    }
    <span class="cov0" title="0">if req.URL.Host == "" </span><span class="cov0" title="0">{
        return nil, errors.New("http: no Host in request URL")
    }</span>
    <span class="cov0" title="0">treq := &amp;transportRequest{Request: req}
    cm, err := t.connectMethodForRequest(treq)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // Get the cached or newly-created connection to either the
    // host (for http or https), the http proxy, or the http proxy
    // pre-CONNECTed to https server.  In any case, we'll be ready
    // to send it requests.
    <span class="cov0" title="0">pconn, err := t.getConn(cm)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    resp , err = pconn.roundTrip(treq)
    if err == nil {
        t.State.Inc("TRANSPORT_REQ_SUCC", 1)
    }
    return
}

// RegisterProtocol registers a new protocol with scheme.
// The Transport will pass requests using the given scheme to rt.
// It is rt's responsibility to simulate HTTP request semantics.
//
// RegisterProtocol can be used by other packages to provide
// implementations of protocol schemes like "ftp" or "file".
func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper) {
    if scheme == "http" || scheme == "https" {
        panic("protocol " + scheme + " already registered")
    }
    t.altMu.Lock()
    defer t.altMu.Unlock()
    if t.altProto == nil {
        t.altProto = make(map[string]RoundTripper)
    }
    if _, exists := t.altProto[scheme]; exists {
        panic("protocol " + scheme + " already registered")
    }
    t.altProto[scheme] = rt
}

// CloseIdleConnections closes any connections which were previously
// connected from previous requests but are now sitting idle in
// a "keep-alive" state. It does not interrupt any connections currently
// in use.
func (t *Transport) CloseIdleConnections() {
    t.idleMu.Lock()
    m := t.idleConn
    t.idleConn = nil
    t.idleConnCh = nil
    t.idleMu.Unlock()
    if m == nil {
        return
    }
    for _, conns := range m {
        for _, pconn := range conns {
            pconn.close()
        }
    }
}

// CancelRequest cancels an in-flight request by closing its
// connection.
func (t *Transport) CancelRequest(req *Request) {
    t.reqMu.Lock()
    pc := t.reqConn[req]
    t.reqMu.Unlock()
    if pc != nil {
        pc.conn.Close()
    }
}

//
// Private implementation past this point.
//

func getenvEitherCase(k string) string {
    if v := os.Getenv(strings.ToUpper(k)); v != "" {
        return v
    }
    return os.Getenv(strings.ToLower(k))
}

func (t *Transport) connectMethodForRequest(treq *transportRequest) (*connectMethod, error) {
    cm := &amp;connectMethod{
        targetScheme: treq.URL.Scheme,
        targetAddr:   canonicalAddr(treq.URL),
    }
    if t.Proxy != nil {
        var err error
        cm.proxyURL, err = t.Proxy(treq.Request)
        if err != nil {
            return nil, err
        }
    }
    return cm, nil
}

// proxyAuth returns the Proxy-Authorization header to set
// on requests, if applicable.
func (cm *connectMethod) proxyAuth() string {
    if cm.proxyURL == nil {
        return ""
    }
    if u := cm.proxyURL.User; u != nil {
        username := u.Username()
        password, _ := u.Password()
        return "Basic " + basicAuth(username, password)
    }
    return ""
}

// putIdleConn adds pconn to the list of idle persistent connections awaiting
// a new request.
// If pconn is no longer needed or not in a good state, putIdleConn
// returns false.
func (t *Transport) putIdleConn(pconn *persistConn) bool {
    if t.DisableKeepAlives || t.MaxIdleConnsPerHost &lt; 0 {
        pconn.close()
        return false
    }
    if pconn.isBroken() {
        return false
    }
    key := pconn.cacheKey
    max := t.MaxIdleConnsPerHost
    if max == 0 {
        max = DefaultMaxIdleConnsPerHost
    }
    t.idleMu.Lock()

    waitingDialer := t.idleConnCh[key]
    select {
    case waitingDialer &lt;- pconn:
        // We're done with this pconn and somebody else is
        // currently waiting for a conn of this type (they're
        // actively dialing, but this conn is ready
        // first). Chrome calls this socket late binding.  See
        // https://insouciant.org/tech/connection-management-in-chromium/
        t.idleMu.Unlock()
        return true
    default:
        if waitingDialer != nil {
            // They had populated this, but their dial won
            // first, so we can clean up this map entry.
            delete(t.idleConnCh, key)
        }
    }
    if t.idleConn == nil {
        t.idleConn = make(map[string][]*persistConn)
    }
    if len(t.idleConn[key]) &gt;= max {
        t.idleMu.Unlock()
        pconn.close()
        return false
    }
    for _, exist := range t.idleConn[key] {
        if exist == pconn {
            log.Logger.Error("dup idle pconn %p in freelist", pconn)
        }
    }
    t.idleConn[key] = append(t.idleConn[key], pconn)
    t.idleMu.Unlock()
    return true
}

// getIdleConnCh returns a channel to receive and return idle
// persistent connection for the given connectMethod.
// It may return nil, if persistent connections are not being used.
func (t *Transport) getIdleConnCh(cm *connectMethod) chan *persistConn {
    if t.DisableKeepAlives {
        return nil
    }
    key := cm.key()
    t.idleMu.Lock()
    defer t.idleMu.Unlock()
    if t.idleConnCh == nil {
        t.idleConnCh = make(map[string]chan *persistConn)
    }
    ch, ok := t.idleConnCh[key]
    if !ok {
        ch = make(chan *persistConn)
        t.idleConnCh[key] = ch
    }
    return ch
}

func (t *Transport) getIdleConn(cm *connectMethod) (pconn *persistConn) {
    key := cm.key()
    t.idleMu.Lock()
    defer t.idleMu.Unlock()
    if t.idleConn == nil {
        return nil
    }
    for {
        pconns, ok := t.idleConn[key]
        if !ok {
            return nil
        }
        if len(pconns) == 1 {
            pconn = pconns[0]
            delete(t.idleConn, key)
        } else {
            // 2 or more cached connections; pop last
            // TODO: queue?
            pconn = pconns[len(pconns)-1]
            t.idleConn[key] = pconns[0 : len(pconns)-1]
        }
        if !pconn.isBroken() {
            return
        }
    }
}

func (t *Transport) setReqConn(r *Request, pc *persistConn) {
    t.reqMu.Lock()
    defer t.reqMu.Unlock()
    if t.reqConn == nil {
        t.reqConn = make(map[*Request]*persistConn)
    }
    if pc != nil {
        t.reqConn[r] = pc
    } else {
        delete(t.reqConn, r)
    }
}

func (t *Transport) dial(network, addr string) (c net.Conn, err error) {
    if t.Dial != nil {
        return t.Dial(network, addr)
    }
    return net.Dial(network, addr)
}

// getConn dials and creates a new persistConn to the target as
// specified in the connectMethod.  This includes doing a proxy CONNECT
// and/or setting up TLS.  If this doesn't return an error, the persistConn
// is ready to write requests to.
func (t *Transport) getConn(cm *connectMethod) (*persistConn, error) {
    if pc := t.getIdleConn(cm); pc != nil {
        return pc, nil
    }

    type dialRes struct {
        pc  *persistConn
        err error
    }
    dialc := make(chan dialRes)
    go func() {
        pc, err := t.dialConn(cm)
        t.State.Inc("TRANSPORT_CONN_ALL", 1)
        if err == nil {
            t.State.Inc("TRANSPORT_CONN_SUCC", 1) 
        }
        dialc &lt;- dialRes{pc, err}
    }()

    idleConnCh := t.getIdleConnCh(cm)
    select {
    case v := &lt;-dialc:
        // Our dial finished.
        return v.pc, v.err
    case pc := &lt;-idleConnCh:
        // Another request finished first and its net.Conn
        // became available before our dial. Or somebody
        // else's dial that they didn't use.
        // But our dial is still going, so give it away
        // when it finishes:
        go func() {
            if v := &lt;-dialc; v.err == nil {
                t.putIdleConn(v.pc)
            }
        }()
        return pc, nil
    }
}

func (t *Transport) dialConn(cm *connectMethod) (*persistConn, error) {
    conn, err := t.dial("tcp", cm.addr())
    if err != nil {
        if cm.proxyURL != nil {
            err = fmt.Errorf("http: error connecting to proxy %s: %v", cm.proxyURL, err)
        }
        return nil, err
    }

    pa := cm.proxyAuth()

    pconn := &amp;persistConn{
        t:        t,
        cacheKey: cm.key(),
        conn:     conn,
        reqch:    make(chan requestAndChan, 1),
        writech:  make(chan writeRequest, 1),
        closech:  make(chan struct{}),
        state:    t.State,
    }

    switch {
    case cm.proxyURL == nil:
        // Do nothing.
    case cm.targetScheme == "http":
        pconn.isProxy = true
        if pa != "" {
            pconn.mutateHeaderFunc = func(h Header) {
                h.Set("Proxy-Authorization", pa)
            }
        }
    case cm.targetScheme == "https":
        connectReq := &amp;Request{
            Method: "CONNECT",
            URL:    &amp;url.URL{Opaque: cm.targetAddr},
            Host:   cm.targetAddr,
            Header: make(Header),
        }
        if pa != "" {
            connectReq.Header.Set("Proxy-Authorization", pa)
        }
        connectReq.Write(conn)

        // Read response.
        // Okay to use and discard buffered reader here, because
        // TLS server will not speak until spoken to.
        br := bfe_bufio.NewReader(conn)
        resp, err := ReadResponse(br, connectReq)
        if err != nil {
            conn.Close()
            return nil, err
        }
        if resp.StatusCode != 200 {
            f := strings.SplitN(resp.Status, " ", 2)
            conn.Close()
            return nil, errors.New(f[1])
        }
    }

    if cm.targetScheme == "https" {
        // Initiate TLS and check remote host name against certificate.
        cfg := t.TLSClientConfig
        if cfg == nil || cfg.ServerName == "" {
            host := cm.tlsHost()
            if cfg == nil {
                cfg = &amp;bfe_tls.Config{ServerName: host}
            } else {
                clone := *cfg // shallow clone
                clone.ServerName = host
                cfg = &amp;clone
            }
        }
        conn = bfe_tls.Client(conn, cfg)
        if err = conn.(*bfe_tls.Conn).Handshake(); err != nil {
            return nil, err
        }
        if !cfg.InsecureSkipVerify {
            if err = conn.(*bfe_tls.Conn).VerifyHostname(cfg.ServerName); err != nil {
                return nil, err
            }
        }
        pconn.conn = conn
    }

    pconn.br = bfe_bufio.NewReader(pconn.conn)
    pconn.bw = bfe_bufio.NewWriter(pconn.conn)
    go pconn.readLoop()
    go pconn.writeLoop()
    return pconn, nil
}

// useProxy returns true if requests to addr should use a proxy,
// according to the NO_PROXY or no_proxy environment variable.
// addr is always a canonicalAddr with a host and port.
func useProxy(addr string) bool {
    if len(addr) == 0 {
        return true
    }
    host, _, err := net.SplitHostPort(addr)
    if err != nil {
        return false
    }
    if host == "localhost" {
        return false
    }
    if ip := net.ParseIP(host); ip != nil {
        if ip.IsLoopback() {
            return false
        }
    }

    no_proxy := getenvEitherCase("NO_PROXY")
    if no_proxy == "*" {
        return false
    }

    addr = strings.ToLower(strings.TrimSpace(addr))
    if hasPort(addr) {
        addr = addr[:strings.LastIndex(addr, ":")]
    }

    for _, p := range strings.Split(no_proxy, ",") {
        p = strings.ToLower(strings.TrimSpace(p))
        if len(p) == 0 {
            continue
        }
        if hasPort(p) {
            p = p[:strings.LastIndex(p, ":")]
        }
        if addr == p {
            return false
        }
        if p[0] == '.' &amp;&amp; (strings.HasSuffix(addr, p) || addr == p[1:]) {
            // no_proxy ".foo.com" matches "bar.foo.com" or "foo.com"
            return false
        }
        if p[0] != '.' &amp;&amp; strings.HasSuffix(addr, p) &amp;&amp; addr[len(addr)-len(p)-1] == '.' {
            // no_proxy "foo.com" matches "bar.foo.com"
            return false
        }
    }
    return true
}

// connectMethod is the map key (in its String form) for keeping persistent
// TCP connections alive for subsequent HTTP requests.
//
// A connect method may be of the following types:
//
// Cache key form                Description
// -----------------             -------------------------
// ||http|foo.com                http directly to server, no proxy
// ||https|foo.com               https directly to server, no proxy
// http://proxy.com|https|foo.com  http to proxy, then CONNECT to foo.com
// http://proxy.com|http           http to proxy, http to anywhere after that
//
// Note: no support to https to the proxy yet.
//
type connectMethod struct {
    proxyURL     *url.URL // nil for no proxy, else full proxy URL
    targetScheme string   // "http" or "https"
    targetAddr   string   // Not used if proxy + http targetScheme (4th example in table)
}

func (ck *connectMethod) key() string {
    return ck.String() // TODO: use a struct type instead
}

func (ck *connectMethod) String() string {
    proxyStr := ""
    targetAddr := ck.targetAddr
    if ck.proxyURL != nil {
        proxyStr = ck.proxyURL.String()
        if ck.targetScheme == "http" {
            targetAddr = ""
        }
    }
    return strings.Join([]string{proxyStr, ck.targetScheme, targetAddr}, "|")
}

// addr returns the first hop "host:port" to which we need to TCP connect.
func (cm *connectMethod) addr() string {
    if cm.proxyURL != nil {
        return canonicalAddr(cm.proxyURL)
    }
    return cm.targetAddr
}

// tlsHost returns the host name to match against the peer's
// TLS certificate.
func (cm *connectMethod) tlsHost() string {
    h := cm.targetAddr
    if hasPort(h) {
        h = h[:strings.LastIndex(h, ":")]
    }
    return h
}

// persistConn wraps a connection, usually a persistent one
// (but may be used for non-keep-alive requests as well)
type persistConn struct {
    t        *Transport
    cacheKey string // its connectMethod.String()
    conn     net.Conn
    closed   bool                // whether conn has been closed
    br       *bfe_bufio.Reader       // from conn
    bw       *bfe_bufio.Writer       // to conn
    reqch    chan requestAndChan // written by roundTrip; read by readLoop
    writech  chan writeRequest   // written by roundTrip; read by writeLoop
    closech  chan struct{}       // broadcast close when readLoop (TCP connection) closes
    isProxy  bool

    lk                   sync.Mutex // guards following 3 fields
    numExpectedResponses int
    broken               bool // an error has happened on this connection; marked broken so it's not reused.
    // mutateHeaderFunc is an optional func to modify extra
    // headers on each outbound request before it's written. (the
    // original Request given to RoundTrip is not modified)
    mutateHeaderFunc func(Header)
    
    state   *module_state2.State
}

func (pc *persistConn) isBroken() bool {
    pc.lk.Lock()
    b := pc.broken
    pc.lk.Unlock()
    return b
}

var remoteSideClosedFunc func(error) bool // or nil to use default

func remoteSideClosed(err error) bool {
    if err == io.EOF {
        return true
    }
    if remoteSideClosedFunc != nil {
        return remoteSideClosedFunc(err)
    }
    return false
}

func (pc *persistConn) readLoop() {
    defer close(pc.closech)
    defer func() {
        if err := recover(); err != nil {
            const size = 4096
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            log.Logger.Warn("panic:persistConn.readLoop():%v\n%s", err, buf)

            pc.close()
            pc.state.Inc("PANIC_BACKEND_READ", 1)
        }
    } ()

    alive := true

    for alive {
        pb, err := pc.br.Peek(1)

        pc.lk.Lock()
        if pc.numExpectedResponses == 0 {
            pc.closeLocked()
            pc.lk.Unlock()
            if len(pb) &gt; 0 {
                log.Logger.Info("Unsolicited response received on idle HTTP channel starting with %q; err=%v",
                                string(pb), err)
            }
            return
        }
        pc.lk.Unlock()

        rc := &lt;-pc.reqch

        var resp *Response
        if err == nil {
            resp, err = ReadResponse(pc.br, rc.req)
            if err == nil &amp;&amp; resp.StatusCode == 100 {
                // Skip any 100-continue for now.
                // TODO(bradfitz): if rc.req had "Expect: 100-continue",
                // actually block the request body write and signal the
                // writeLoop now to begin sending it. (Issue 2184) For now we
                // eat it, since we're never expecting one.
                resp, err = ReadResponse(pc.br, rc.req)
            }
        }
        hasBody := resp != nil &amp;&amp; rc.req.Method != "HEAD" &amp;&amp; resp.ContentLength != 0

        if err != nil {
            pc.close()
        } else {
            if rc.addedGzip &amp;&amp; hasBody &amp;&amp; resp.Header.Get("Content-Encoding") == "gzip" {
                resp.Header.Del("Content-Encoding")
                resp.Header.Del("Content-Length")
                resp.ContentLength = -1
                gzReader, zerr := gzip.NewReader(resp.Body)
                if zerr != nil {
                    pc.close()
                    err = zerr
                } else {
                    resp.Body = &amp;readerAndCloser{gzReader, resp.Body}
                }
            }
            resp.Body = &amp;bodyEOFSignal{body: resp.Body}
        }

        if err != nil || resp.Close || rc.req.Close || resp.StatusCode &lt;= 199 {
            // Don't do keep-alive on error if either party requested a close
            // or we get an unexpected informational (1xx) response.
            // StatusCode 100 is already handled above.
            alive = false
        }

        var waitForBodyRead chan bool
        if hasBody {
            waitForBodyRead = make(chan bool, 2)
            resp.Body.(*bodyEOFSignal).earlyCloseFn = func() error {
                // Sending false here sets alive to
                // false and closes the connection
                // below.
                waitForBodyRead &lt;- false
                return nil
            }
            resp.Body.(*bodyEOFSignal).fn = func(err error) {
                alive1 := alive
                if err != nil {
                    alive1 = false
                }
                if alive1 &amp;&amp; !pc.t.putIdleConn(pc) {
                    alive1 = false
                }
                if !alive1 || pc.isBroken() {
                    pc.close()
                }
                waitForBodyRead &lt;- alive1
            }
        }

        if alive &amp;&amp; !hasBody {
            if !pc.t.putIdleConn(pc) {
                alive = false
            }
        }

        rc.ch &lt;- responseAndError{resp, err}

        // Wait for the just-returned response body to be fully consumed
        // before we race and peek on the underlying bufio reader.
        if waitForBodyRead != nil {
            alive = &lt;-waitForBodyRead
        }

        pc.t.setReqConn(rc.req, nil)

        if !alive {
            pc.close()
        }
    }
}

func (pc *persistConn) writeLoop() {
    defer func() {    
        if err := recover(); err != nil {
            const size = 4096
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            // log.Logger.Warn("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
            log.Logger.Warn("panic:persistConn.writeLoop():%v\n%s", err, buf)
            
            // close connection
            pc.close()
            pc.state.Inc("PANIC_BACKEND_WRITE", 1)
        }
    } ()
    
    for {
        select {
        case wr := &lt;-pc.writech:
            if pc.isBroken() {
                wr.ch &lt;- errors.New("http: can't write HTTP request on broken connection")
                continue
            }
            err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra)
            if err == nil {
                err = pc.bw.Flush()
            }
            if err != nil {
                pc.markBroken()
            }
            wr.ch &lt;- err
        case &lt;-pc.closech:
            return
        }
    }
}

type responseAndError struct {
    res *Response
    err error
}

type requestAndChan struct {
    req *Request
    ch  chan responseAndError

    // did the Transport (as opposed to the client code) add an
    // Accept-Encoding gzip header? only if it we set it do
    // we transparently decode the gzip.
    addedGzip bool
}

// A writeRequest is sent by the readLoop's goroutine to the
// writeLoop's goroutine to write a request while the read loop
// concurrently waits on both the write response and the server's
// reply.
type writeRequest struct {
    req *transportRequest
    ch  chan&lt;- error
}

func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {
    pc.t.setReqConn(req.Request, pc)
    pc.lk.Lock()
    pc.numExpectedResponses++
    headerFn := pc.mutateHeaderFunc
    pc.lk.Unlock()

    if headerFn != nil {
        headerFn(req.extraHeaders())
    }

    // Ask for a compressed version if the caller didn't set their
    // own value for Accept-Encoding. We only attempted to
    // uncompress the gzip stream if we were the layer that
    // requested it.
    requestedGzip := false
    if !pc.t.DisableCompression &amp;&amp; req.Header.Get("Accept-Encoding") == "" &amp;&amp; req.Method != "HEAD" {
        // Request gzip only, not deflate. Deflate is ambiguous and
        // not as universally supported anyway.
        // See: http://www.gzip.org/zlib/zlib_faq.html#faq38
        //
        // Note that we don't request this for HEAD requests,
        // due to a bug in nginx:
        //   http://trac.nginx.org/nginx/ticket/358
        //   http://golang.org/issue/5522
        requestedGzip = true
        req.extraHeaders().Set("Accept-Encoding", "gzip")
    }

    // Write the request concurrently with waiting for a response,
    // in case the server decides to reply before reading our full
    // request body.
    writeErrCh := make(chan error, 1)
    pc.writech &lt;- writeRequest{req, writeErrCh}

    resc := make(chan responseAndError, 1)
    pc.reqch &lt;- requestAndChan{req.Request, resc, requestedGzip}

    var re responseAndError
    var pconnDeadCh = pc.closech
    var failTicker &lt;-chan time.Time
    var respHeaderTimer &lt;-chan time.Time
WaitResponse:
    for {
        select {
        case err := &lt;-writeErrCh:
            if err != nil {
                re = responseAndError{nil, err}
                pc.close()
                break WaitResponse
            }
            if d := pc.t.ResponseHeaderTimeout; d &gt; 0 {
                respHeaderTimer = time.After(d)
            }
        case &lt;-pconnDeadCh:
            // The persist connection is dead. This shouldn't
            // usually happen (only with Connection: close responses
            // with no response bodies), but if it does happen it
            // means either a) the remote server hung up on us
            // prematurely, or b) the readLoop sent us a response &amp;
            // closed its closech at roughly the same time, and we
            // selected this case first, in which case a response
            // might still be coming soon.
            //
            // We can't avoid the select race in b) by using a unbuffered
            // resc channel instead, because then goroutines can
            // leak if we exit due to other errors.
            pconnDeadCh = nil                               // avoid spinning
            failTicker = time.After(100 * time.Millisecond) // arbitrary time to wait for resc
        case &lt;-failTicker:
            re = responseAndError{err: errors.New("net/http: transport closed before response was received")}
            break WaitResponse
        case &lt;-respHeaderTimer:
            pc.close()
            re = responseAndError{err: errors.New("net/http: timeout awaiting response headers")}
            break WaitResponse
        case re = &lt;-resc:
            break WaitResponse
        }
    }

    pc.lk.Lock()
    pc.numExpectedResponses--
    pc.lk.Unlock()

    if re.err != nil {
        pc.t.setReqConn(req.Request, nil)
    }
    return re.res, re.err
}

// markBroken marks a connection as broken (so it's not reused).
// It differs from close in that it doesn't close the underlying
// connection for use when it's still being read.
func (pc *persistConn) markBroken() {
    pc.lk.Lock()
    defer pc.lk.Unlock()
    pc.broken = true
}

func (pc *persistConn) close() {
    pc.lk.Lock()
    defer pc.lk.Unlock()
    pc.closeLocked()
}

func (pc *persistConn) closeLocked() {
    pc.broken = true
    if !pc.closed {
        pc.conn.Close()
        pc.closed = true
    }
    pc.mutateHeaderFunc = nil
}

var portMap = map[string]string{
    "http":  "80",
    "https": "443",
}

// canonicalAddr returns url.Host but always with a ":port" suffix
func canonicalAddr(url *url.URL) string {
    addr := url.Host
    if !hasPort(addr) {
        return addr + ":" + portMap[url.Scheme]
    }
    return addr
}

// bodyEOFSignal wraps a ReadCloser but runs fn (if non-nil) at most
// once, right before its final (error-producing) Read or Close call
// returns. If earlyCloseFn is non-nil and Close is called before
// io.EOF is seen, earlyCloseFn is called instead of fn, and its
// return value is the return value from Close.
type bodyEOFSignal struct {
    body         io.ReadCloser
    mu           sync.Mutex   // guards following 4 fields
    closed       bool         // whether Close has been called
    rerr         error        // sticky Read error
    fn           func(error)  // error will be nil on Read io.EOF
    earlyCloseFn func() error // optional alt Close func used if io.EOF not seen
}

func (es *bodyEOFSignal) Read(p []byte) (n int, err error) {
    es.mu.Lock()
    closed, rerr := es.closed, es.rerr
    es.mu.Unlock()
    if closed {
        return 0, errors.New("http: read on closed response body")
    }
    if rerr != nil {
        return 0, rerr
    }

    n, err = es.body.Read(p)
    if err != nil {
        es.mu.Lock()
        defer es.mu.Unlock()
        if es.rerr == nil {
            es.rerr = err
        }
        es.condfn(err)
    }
    return
}

func (es *bodyEOFSignal) Close() error {
    es.mu.Lock()
    defer es.mu.Unlock()
    if es.closed {
        return nil
    }
    es.closed = true
    if es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF {
        return es.earlyCloseFn()
    }
    err := es.body.Close()
    es.condfn(err)
    return err
}

// caller must hold es.mu.
func (es *bodyEOFSignal) condfn(err error) {
    if es.fn == nil {
        return
    }
    if err == io.EOF {
        err = nil
    }
    es.fn(err)
    es.fn = nil
}

type readerAndCloser struct {
    io.Reader
    io.Closer
}

</pre>
		
		<pre class="file" id="file47" style="display: none">/* conf_mod_access.go - config for mod_access   */
/*
modification history
--------------------
2014/6/10, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_access

import (
    "errors"
)

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/log"
)


type ConfModAccess struct {        
    Log struct {
        Network       string
        LogServerAddr string
    }
    
    Template struct {
        ReqTemplate        string  // access log formate string
        ErrReqTemplate     string  // access log formate string
        SessionTemplate    string  // session finish log formate string
        ErrSessionTemplate  string  // error log formate string
    }
}

var defaultReqTemplate         string  // default ConfModAccess.ReqTemplate
var defaultErrReqTemplate      string  // default ConfModAccess.ErrReqTemplate
var defaultSessionTemplate     string  // default ConfModAccess.SessionTemplate
var defaultErrSessionTemplate  string  // default ConfModAccess.ErrSessionTemplate

func init() <span class="cov1" title="1">{
    defaultReqTemplate      = "%t %serverip %clientip %backend %retry_n" + 
                              "%read_req_dur %cluster_dur %last_backend_dur %response_dur " + 
                              "%header_len_in %body_len_in %header_len_out %body_len_out " + 
                              "%{User-Agent}req_header %{Content-Type}res_header " + 
                              "%{BAIDUID}res_cookie %{ID}req_cookie"
    
    defaultErrReqTemplate =  "Error : %error_code " + defaultReqTemplate
    
    defaultSessionTemplate  = "%ses_start_time %ses_end_time %ses_overhead %ses_clientip " + 
                              "%ses_cluster %ses_req_num %ses_read_total %ses_write_total %ses_use100"
    
    defaultErrSessionTemplate  = "Error : %ses_error_code " + defaultSessionTemplate
}</span>

/* load config from config file    */
func ConfLoad(filePath string) (*ConfModAccess, error) <span class="cov10" title="4">{
    var err error
    var cfg ConfModAccess

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_access
    <span class="cov10" title="4">err = cfg.Check()
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="4">return &amp;cfg, nil</span>
}

func (cfg *ConfModAccess) Check() error <span class="cov10" title="4">{
    return ConfModAccessCheck(cfg)
}</span>

func ConfModAccessCheck(cfg *ConfModAccess) error <span class="cov10" title="4">{
    if cfg.Log.Network != "unixgram" &amp;&amp; cfg.Log.Network != "upd" </span><span class="cov0" title="0">{
        return errors.New("cfg.Log.Network config error")
    }</span>
    <span class="cov10" title="4">if cfg.Log.LogServerAddr == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("ModAccess.LogServerAddr not set, use default value")
        cfg.Log.LogServerAddr = "/tmp/bfe_log.sock"
    }</span>
    
    <span class="cov10" title="4">if cfg.Template.ReqTemplate == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("ModAccess.ReqTemplate not set, use default value")
        cfg.Template.ReqTemplate = defaultReqTemplate
    }</span>
    
    <span class="cov10" title="4">if cfg.Template.ErrReqTemplate == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModAccess.ErrReqTemplate not set, use default value")
        cfg.Template.ErrReqTemplate = defaultErrReqTemplate
    }</span>
    
    <span class="cov10" title="4">if cfg.Template.SessionTemplate == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModAccess.SessionTemplate not set, use default value")
        cfg.Template.SessionTemplate = defaultSessionTemplate
    }</span>
    
    <span class="cov10" title="4">if cfg.Template.ErrSessionTemplate == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModAccess.ErrSessionTemplate not set, use default value")
        cfg.Template.ErrSessionTemplate = defaultErrSessionTemplate
    }</span>
    
    <span class="cov10" title="4">return nil</span>
}

</pre>
		
		<pre class="file" id="file48" style="display: none">/* mod_access.go - module for print access log  */
/*
modification history
--------------------
2014/6/9, by Zhang Miao, create
2014/10/9, by taochunhua, push log data into remote log-server
*/
/*
DESCRIPTION
*/
package mod_access

import (
    "bytes"
    "errors"
    "fmt"
    "strconv"
    "strings"
    "time"
)

import (
    "code.google.com/p/log4go"
    "www.baidu.com/golang-lib/access_log"
    "www.baidu.com/golang-lib/web_monitor" 
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
)

// all format types
const (
    FORMAT_STRING = iota
    FORMAT_HOST
    FORMAT_TIME
    FORMAT_HTTP
    FORMAT_REQ_COOKIE
    FORMAT_URI
    FORMAT_REQUEST_URI
    FORMAT_CLIENT_READ_TIME
    FORMAT_PROXY_DELAY_TIME
    FORMAT_SERVICE_ALL_TIME
    FORMAT_CONNECT_SRV_TIME
    FORMAT_SINCE_SESSION_TIME
    FORMAT_READWRITE_SRV_TIME
    FORMAT_HEADER_LEN
    FORMAT_CONTENT_LEN
    FORMAT_OUT_HEADER_LEN
    FORMAT_OUT_CONTENT_LEN
    FORMAT_KEEPALIVE_NUM
    FORMAT_OUT_STATUS
    FORMAT_SERVICE_NAME
    FORMAT_SUB_CLUSTER_NAME
    FORMAT_MEMCACHED_STATUS
    FORMAT_LOGID
    FORMAT_CACHE_KEY
    FORMAT_RESPONSED_HEADER
    FORMAT_FIRST_LINE
    FORMAT_PAGE_NUM
    FORMAT_BWS_TIME
    FORMAT_SRV_IP
    FORMAT_VIP
    FORMAT_FEATURE_CODE
    FORMAT_ACTION_CODE
    FORMAT_INNOCENT_TAG
    FORMAT_SERVICE_TAG
    FORMAT_WAF_SPENT_TIME
    FORMAT_WAF_STATUS
    FORMAT_NTH_REQ_IN_SESSION
    FORMAT_WRITE_SRV_TIME
    
    FORMAT_READ_REQ_DURATION
    FORMAT_CLUSTER_DURATION
    FORMAT_LAST_BACKEND_DURATION
    FORMAT_RESPONSE_DURATION
    
    FORMAT_HEADER_LEN_IN
    FORMAT_BODY_LEN_IN
    FORMAT_HEADER_LEN_OUT
    FORMAT_BODY_LEN_OUT
    FORMAT_REQUEST_HEADER
    FORMAT_RES_COOKIE
    
    FORMATE_BACKEND
    FORMATE_REDIRECT
    FORMATE_RETRY_NUM
    FORMATE_BAIDU_ID
    FORMAT_REMOTE_ADDR
    FORMAT_SERVER_ADDR
    
    FORMAT_RES_STATUS
    FORMAT_RES_PROTO
    FORMATE_IS_TRUSTIP
    
    FORMAT_SES_START_TIME
    FORMAT_SES_END_TIME
    FORMAT_SES_OVERHEAD
    FORMAT_SES_CLIENT_IP
    FORMAT_SES_CLUSTER
    FORMAT_SES_REQ_NUM
    FORMAT_SES_READ_TOTAL
    FORMAT_SES_WRITE_TOTAL
    FORMATE_SES_USE100
    FORMAT_SES_IS_HTTPS
    FORMAT_SES_IS_RESUME
    
    FORMATE_ERROR_CODE_REQ
    FORMATE_ERROR_CODE_SES
    
    FORMAT_UNKNOW
)

// each format item should be in one of following template place
const REQUEST = "REQUEST"
const SESSION = "SESSION"
const DOMAIN_ALL = "DOMAIN_ALL"

// each log format in log template
type LogFmtItem struct {
    Key  string
    Type int
}

// table of format string =&gt; format type mapping
var fmtTable map[string]int
// table of formate type =&gt; item valid template
var fmtItemDomainTable map[int]string
// table of format type =&gt; format print handler mapping
var fmtHandlerTable map[int]interface{}

// setup fmtTable, fmtItemDomainTable and fmtHandlerTable
func init() <span class="cov1" title="1">{
    fmtTable = map[string]int {"host": FORMAT_HOST,
                               "t": FORMAT_TIME,
                               "i": FORMAT_HTTP,
                               //"co": FORMAT_REQ_COOKIE,
                               "u": FORMAT_URI,
                               "req_uri": FORMAT_REQUEST_URI,
                               "rt": FORMAT_CLIENT_READ_TIME,
                               "dt": FORMAT_PROXY_DELAY_TIME,
                               "at": FORMAT_SERVICE_ALL_TIME,
                               "ct": FORMAT_CONNECT_SRV_TIME,
                               "wt": FORMAT_WRITE_SRV_TIME,
                               "xt": FORMAT_READWRITE_SRV_TIME,
                               "lh": FORMAT_HEADER_LEN,
                               "lc": FORMAT_CONTENT_LEN,
                               "oh": FORMAT_OUT_HEADER_LEN,
                               "oc": FORMAT_OUT_CONTENT_LEN,
                               "nts": FORMAT_SINCE_SESSION_TIME,
                               
                               "st": FORMAT_OUT_STATUS,
                               "sn": FORMAT_SERVICE_NAME,
                               "sc": FORMAT_SUB_CLUSTER_NAME,
                               "mc": FORMAT_MEMCACHED_STATUS,
                               "ld": FORMAT_LOGID,
                               "ck": FORMAT_CACHE_KEY,
                               "rs": FORMAT_RESPONSED_HEADER,
                               "fl": FORMAT_FIRST_LINE,
                               "pn": FORMAT_PAGE_NUM,
                               "bt": FORMAT_BWS_TIME,
                               "sp": FORMAT_SRV_IP,
                               "vip": FORMAT_VIP,
                               "fc": FORMAT_FEATURE_CODE,
                               "ac": FORMAT_ACTION_CODE,
                               "gi": FORMAT_INNOCENT_TAG,
                               "wst": FORMAT_WAF_SPENT_TIME,
                               "waf_status": FORMAT_WAF_STATUS,
                               "gs": FORMAT_SERVICE_TAG,
                               "nth": FORMAT_NTH_REQ_IN_SESSION,
                               
                               // new added
                               // common
                               "res_header"       : FORMAT_RESPONSED_HEADER,
                               "req_header"       : FORMAT_REQUEST_HEADER,
                               "res_cookie"       : FORMAT_RES_COOKIE,
                               "req_cookie"       : FORMAT_REQ_COOKIE,
                               "read_req_dur"     : FORMAT_READ_REQ_DURATION,
                               "cluster_dur"      : FORMAT_CLUSTER_DURATION,
                               "last_backend_dur" : FORMAT_LAST_BACKEND_DURATION,
                               "response_dur"     : FORMAT_RESPONSE_DURATION,
                               "header_len_in"    : FORMAT_HEADER_LEN_IN,
                               "body_len_in"      : FORMAT_BODY_LEN_IN,
                               "header_len_out"   : FORMAT_HEADER_LEN_OUT,
                               "body_len_out"     : FORMAT_BODY_LEN_OUT,
                               
                               // request related
                               "backend"  : FORMATE_BACKEND,
                               "redirect" : FORMATE_REDIRECT,
                               "retry_n"  : FORMATE_RETRY_NUM,
                               "baiduid"  : FORMATE_BAIDU_ID,
                               "remote_addr" : FORMAT_REMOTE_ADDR,
                               "server_addr" : FORMAT_SERVER_ADDR,
                                
                               // response related
                               "res_status" : FORMAT_RES_STATUS,
                               "res_proto"  : FORMAT_RES_PROTO,
                               "Trustip"    : FORMATE_IS_TRUSTIP,
                               
                               // session related
                               "kt"              : FORMAT_KEEPALIVE_NUM,
                               "ses_start_time"  : FORMAT_SES_START_TIME,
                               "ses_end_time"    : FORMAT_SES_END_TIME,
                               "ses_overhead"    : FORMAT_SES_OVERHEAD,
                               "ses_clientip"    : FORMAT_SES_CLIENT_IP,
                               "ses_cluster"     : FORMAT_SES_CLUSTER,
                               "ses_req_num"     : FORMAT_SES_REQ_NUM,
                               "ses_read_total"  : FORMAT_SES_READ_TOTAL,
                               "ses_write_total" : FORMAT_SES_WRITE_TOTAL,
                               "ses_use100"      : FORMATE_SES_USE100,
                               "ses_is_https"    : FORMAT_SES_IS_HTTPS,
                               "ses_is_resume"   : FORMAT_SES_IS_RESUME,
                               
                               // error code
                               "error"          : FORMATE_ERROR_CODE_REQ,
                               "ses_error"      : FORMATE_ERROR_CODE_SES,
                              }
    
    fmtItemDomainTable = map[int]string {
                                FORMAT_STRING             : DOMAIN_ALL,
                                FORMAT_TIME               : DOMAIN_ALL,
                                
                                FORMAT_HOST               : REQUEST,
                                FORMAT_HTTP               : REQUEST,
                                FORMAT_REQ_COOKIE         : REQUEST,
                                FORMAT_URI                : REQUEST,
                                FORMAT_REQUEST_URI        : REQUEST,
                                FORMAT_CLIENT_READ_TIME   : REQUEST,
                                FORMAT_PROXY_DELAY_TIME   : REQUEST,
                                FORMAT_SERVICE_ALL_TIME   : REQUEST,
                                FORMAT_CONNECT_SRV_TIME   : REQUEST,
                                FORMAT_WRITE_SRV_TIME     : REQUEST,
                                FORMAT_READWRITE_SRV_TIME : REQUEST,
                                FORMAT_HEADER_LEN         : REQUEST,
                                FORMAT_CONTENT_LEN        : REQUEST,
                                FORMAT_OUT_HEADER_LEN     : REQUEST,
                                FORMAT_OUT_CONTENT_LEN    : REQUEST,
                                
                                FORMAT_OUT_STATUS         : REQUEST,
                                FORMAT_SERVICE_NAME       : REQUEST,
                                FORMAT_SUB_CLUSTER_NAME   : REQUEST,
                                FORMAT_MEMCACHED_STATUS   : REQUEST,
                                FORMAT_LOGID              : REQUEST,
                                FORMAT_CACHE_KEY          : REQUEST,
                                FORMAT_RESPONSED_HEADER   : REQUEST,
                                FORMAT_FIRST_LINE         : REQUEST,
                                FORMAT_PAGE_NUM           : REQUEST,
                                FORMAT_BWS_TIME           : REQUEST,
                                FORMAT_SRV_IP             : REQUEST,
                                FORMAT_VIP                : REQUEST,
                                FORMAT_FEATURE_CODE       : REQUEST,
                                FORMAT_ACTION_CODE        : REQUEST,
                                FORMAT_INNOCENT_TAG       : REQUEST,
                                FORMAT_SERVICE_TAG        : REQUEST,
                                FORMAT_WAF_SPENT_TIME     : REQUEST,
                                FORMAT_WAF_STATUS         : REQUEST,
                                FORMAT_NTH_REQ_IN_SESSION : REQUEST,
                                FORMAT_SINCE_SESSION_TIME : REQUEST,
                                
                                FORMAT_READ_REQ_DURATION     : REQUEST,
                                FORMAT_CLUSTER_DURATION      : REQUEST,
                                FORMAT_LAST_BACKEND_DURATION : REQUEST,
                                FORMAT_RESPONSE_DURATION     : REQUEST,
                                
                                FORMAT_HEADER_LEN_IN  : REQUEST,
                                FORMAT_BODY_LEN_IN    : REQUEST,
                                FORMAT_HEADER_LEN_OUT : REQUEST,
                                FORMAT_BODY_LEN_OUT   : REQUEST,
                                FORMAT_REQUEST_HEADER : REQUEST,
                                FORMAT_RES_COOKIE     : REQUEST,
                                
                                FORMATE_BACKEND   : REQUEST,
                                FORMATE_REDIRECT  : REQUEST,
                                FORMATE_RETRY_NUM : REQUEST,
                                FORMATE_BAIDU_ID  : REQUEST,
                                FORMAT_REMOTE_ADDR  : REQUEST,
                                FORMAT_SERVER_ADDR  : REQUEST,
                                
                                FORMAT_RES_STATUS : REQUEST,
                                FORMAT_RES_PROTO  : REQUEST,
                                FORMATE_IS_TRUSTIP : REQUEST,
                                
                                FORMAT_KEEPALIVE_NUM   : SESSION,
                                FORMAT_SES_START_TIME  : SESSION,
                                FORMAT_SES_END_TIME    : SESSION,
                                FORMAT_SES_OVERHEAD    : SESSION,
                                FORMAT_SES_CLIENT_IP   : SESSION,
                                FORMAT_SES_CLUSTER     : SESSION,
                                FORMAT_SES_REQ_NUM     : SESSION,
                                FORMAT_SES_READ_TOTAL  : SESSION,
                                FORMAT_SES_WRITE_TOTAL : SESSION,
                                FORMATE_SES_USE100     : SESSION,
                                FORMAT_SES_IS_HTTPS    : SESSION,
                                FORMAT_SES_IS_RESUME   : SESSION,
                                
                                FORMATE_ERROR_CODE_REQ : REQUEST,
                                FORMATE_ERROR_CODE_SES : SESSION,
                         }
    
    fmtHandlerTable = map[int]interface{} {
                            FORMAT_HOST               : onLogFmtHost,
                            FORMAT_HTTP               : onLogFmtHttp,
                            //FORMAT_COOKIE: onLogFmtCookie,
                            FORMAT_URI                : onLogFmtUri,
                            FORMAT_REQUEST_URI        : onLogFmtRequestUri,
                            FORMAT_CLIENT_READ_TIME   : onLogFmtClientReadTime,
                            FORMAT_PROXY_DELAY_TIME   : onLogFmtProxyDelayTime,
                            FORMAT_SERVICE_ALL_TIME   : onLogFmtServiceAllTime,
                            FORMAT_CONNECT_SRV_TIME   : onLogFmtConnectSrvTime,
                            FORMAT_WRITE_SRV_TIME     : onLogFmtWriteSrvTime,
                            FORMAT_READWRITE_SRV_TIME : onLogFmtReadWriteSrvTime,
                            FORMAT_HEADER_LEN         : onLogFmtHeaderLen,
                            FORMAT_CONTENT_LEN        : onLogFmtContentLen,
                            FORMAT_OUT_HEADER_LEN     : onLogFmtOutHeaderLen,
                            FORMAT_OUT_CONTENT_LEN    : onLogFmtOutContentLen,
                            FORMAT_KEEPALIVE_NUM      : onLogFmtKeepAliveNum,
                            FORMAT_OUT_STATUS         : onLogFmtOutStatus,
                            FORMAT_SERVICE_NAME       : onLogFmtServiceName,
                            FORMAT_SUB_CLUSTER_NAME   : onLogFmtSubClusterName,
                            FORMAT_MEMCACHED_STATUS   : onLogFmtMemCachedStatus,
                            FORMAT_LOGID              : onLogFmtLogId,
                            FORMAT_CACHE_KEY          : onLogFmtCacheKey,
                            FORMAT_RESPONSED_HEADER   : onLogFmtResponseHeader,
                            FORMAT_FIRST_LINE         : onLogFmtFirstLine,
                            FORMAT_PAGE_NUM           : onLogFmtPageNum,
                            FORMAT_BWS_TIME           : onLogFmtBwsTime,
                            FORMAT_SRV_IP             : onLogFmtSrvIp,
                            FORMAT_VIP                : onLogFmtVip,
                            FORMAT_FEATURE_CODE       : onLogFmtFeatureCode,
                            FORMAT_ACTION_CODE        : onLogFmtActionCode,
                            FORMAT_INNOCENT_TAG       : onLogFmtInnocentTag,
                            FORMAT_WAF_SPENT_TIME     : onLogFmtWafSpentTime,
                            FORMAT_WAF_STATUS         : onLogFmtWafStatus,
                            FORMAT_SERVICE_TAG        : onLogFmtServiceTag,
                            FORMAT_NTH_REQ_IN_SESSION : onLogFmtNthReqInSession,
                            FORMAT_SINCE_SESSION_TIME : onLogFmtSinceSessionTime,
                            
                            FORMAT_READ_REQ_DURATION     : onLogFmtReadReqDuration,
                            FORMAT_CLUSTER_DURATION      : onLogFmtClusterDuration,
                            FORMAT_LAST_BACKEND_DURATION : onLogFmtLastBackendDuration,
                            FORMAT_RESPONSE_DURATION     : onLogFmtResponseDuration,
                            FORMAT_HEADER_LEN_IN         : onLogFmtHeaderLenIn,
                            FORMAT_BODY_LEN_IN           : onLogFmtBodyLenIn,
                            FORMAT_HEADER_LEN_OUT        : onLogFmtHeaderLenOut,
                            FORMAT_BODY_LEN_OUT          : onLogFmtBodyLenOut,
                            FORMAT_REQUEST_HEADER        : onLogFmtRequestHeader,
                            FORMAT_RES_COOKIE            : onLogFmtResCookie,
                            FORMAT_REQ_COOKIE            : onLogFmtReqCookie,
                            FORMATE_BACKEND              : onLogFmtBackend,
                            FORMATE_REDIRECT             : onLogFmtRedirect,
                            FORMATE_RETRY_NUM            : onLogFmtRetryNum,
                            FORMATE_BAIDU_ID             : onLogFmtBaiduId,
                            FORMAT_REMOTE_ADDR           : onLogFmtClientIp,
                            FORMAT_SERVER_ADDR           : onLogFmtServerIp,
                            FORMAT_RES_STATUS            : onLogFmtResStatus,
                            FORMAT_RES_PROTO             : onLogFmtResProto,
                            FORMATE_IS_TRUSTIP           : onLogFmtIsTrustip,
                            
                            FORMAT_SES_START_TIME  : onLogFmtSesStartTime,
                            FORMAT_SES_END_TIME    : onLogFmtSesEndTime,
                            FORMAT_SES_OVERHEAD    : onLogFmtSesOverhead,
                            FORMAT_SES_CLIENT_IP   : onLogFmtSesClinetIp,
                            FORMAT_SES_CLUSTER     : onLogFmtSesCluster,
                            FORMAT_SES_REQ_NUM     : onLogFmtSesReqNum,
                            FORMAT_SES_READ_TOTAL  : onLogFmtSesReadTotal,
                            FORMAT_SES_WRITE_TOTAL : onLogFmtSesWriteTotal,
                            FORMATE_SES_USE100     : onLogFmtSesUse100,
                            FORMAT_SES_IS_HTTPS    : onLogFmtSesIsHttps,
                            FORMAT_SES_IS_RESUME   : onLogFmtSesIsResume,
                            
                            FORMATE_ERROR_CODE_REQ : onLogFmtErrorCode,
                            FORMATE_ERROR_CODE_SES : onLogFmtSesErrorCode,
                        }
}</span>

type ModuleAccess struct {
    name            string          // name of module
    logger          log4go.Logger   // remote logger
    conf            *ConfModAccess  // raw config
    
    reqFmts         []LogFmtItem    // log formate meta data
                                    // parsed from LogTemplate
    errReqFmts      []LogFmtItem    // connect log formate meta data
                                    // parse from ErrLogTemplate
    
    sessionFmts     []LogFmtItem    // session finish log formate meta data
                                    // parsed from FinishTemplate
    errSessionFmts  []LogFmtItem    // connect log formate meta data
                                    // parse from ErrLogTemplate
}

func NewModuleAccess() *ModuleAccess <span class="cov2" title="4">{
    m := new(ModuleAccess)
    m.name = "mod_access"
    return m
}</span>

func (m *ModuleAccess) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModuleAccess) Attr() map[string]interface{} <span class="cov0" title="0">{
    return nil
}</span>

func (m *ModuleAccess) ParseConfig(conf *ConfModAccess) error <span class="cov2" title="3">{
    var err error
    
    // parse request finish template
    m.reqFmts, err = parseLogTemplate(conf.Template.ReqTemplate)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): ReqTemplate %s", m.name, err.Error())
    }</span>
    
    // parse request error template
    <span class="cov2" title="3">m.errReqFmts, err = parseLogTemplate(conf.Template.ErrReqTemplate)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): ErrReqTemplate %s", m.name, err.Error())
    }</span>
    
    // parse session finish template
    <span class="cov2" title="3">m.sessionFmts, err = parseLogTemplate(conf.Template.SessionTemplate)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): SessionTemplate %s", m.name, err.Error())
    }</span>
    
    // parse error tempate
    <span class="cov2" title="3">m.errSessionFmts, err = parseLogTemplate(conf.Template.ErrSessionTemplate)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): ErrSessionTemplate %s", m.name, err.Error())
    }</span>
    
    <span class="cov2" title="3">return nil</span>
}

func (m *ModuleAccess) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                            cr string) error <span class="cov0" title="0">{
    var err error    
    var conf *ConfModAccess
    
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleAccess) init(conf *ConfModAccess, cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers) error <span class="cov2" title="3">{
    var err error
    
    // parse config
    if err = m.ParseConfig(conf); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): ParseConfig %s", m.name, err.Error())
    }</span>
    
    // check all log items in templates
    <span class="cov2" title="3">if err = m.CheckLogFormat(); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): CheckLogFormat %s", m.name, err.Error())
    }</span>
    
    // init logger agent
    <span class="cov2" title="3">m.logger, err = access_log.LoggerInitWithSvr("go-bfe", "access_txt", 
                                                 conf.Log.Network, conf.Log.LogServerAddr)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): create logger", m.name)
    }</span>
    
    // register handler
    // for finish request
    <span class="cov2" title="3">err = cbs.AddFilter(bfe_module.HANDLE_REQUEST_FINISH, m.requestFinish)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.requestFinish): %s", m.name, err.Error())
    }</span>
    // for finish connection
    <span class="cov2" title="3">err = cbs.AddFilter(bfe_module.HANDLE_FINISH, m.sessionFinish)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.sessionFinish): %s", m.name, err.Error())
    }</span>

    // save conf pointer
    <span class="cov2" title="3">m.conf = conf
    
    return nil</span>
}

func (m *ModuleAccess) CheckLogFormat() error <span class="cov2" title="3">{
    // log format item should in right template
    // otherwise, during runtime interface type will not match and panic.
    for _, item := range m.reqFmts </span><span class="cov6" title="420">{
        domain, found := fmtItemDomainTable[item.Type]
        if !found </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
        
        <span class="cov6" title="420">if domain != DOMAIN_ALL &amp;&amp; domain != REQUEST </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) should not in request finish log",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
    }
    
    <span class="cov2" title="3">for _, item := range m.errReqFmts </span><span class="cov6" title="252">{
        domain, found := fmtItemDomainTable[item.Type]
        if !found </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
        
        <span class="cov6" title="252">if domain != DOMAIN_ALL &amp;&amp; domain != REQUEST </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) should not in request finish log",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
    }
    
    <span class="cov2" title="3">for _, item := range m.sessionFmts </span><span class="cov4" title="60">{
        domain, found := fmtItemDomainTable[item.Type]
        if !found </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
        
        <span class="cov4" title="60">if domain != DOMAIN_ALL &amp;&amp; domain != SESSION </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) should not in session finish log",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
    }
    
    <span class="cov2" title="3">for _, item := range m.errSessionFmts </span><span class="cov4" title="66">{
        domain, found := fmtItemDomainTable[item.Type]
        if !found </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
        
        <span class="cov4" title="66">if domain != DOMAIN_ALL &amp;&amp; domain != SESSION </span><span class="cov0" title="0">{
            msg := fmt.Sprintf("type : (%d, %s) should not in session finish log",
                               item.Type, item.Key)
            return errors.New(msg)
        }</span>
    }
    
    <span class="cov2" title="3">return nil</span>
}

//----------------------------------------------------------------------------------------------------------
// parse log format template

// get token in format table
// return format type, end of token, and error
func tokenTypeGet(templatePtr *string, offset int) (int, int, error)<span class="cov6" title="402">{
    templateLen := len(*templatePtr)
    
    for key, logItemType := range fmtTable </span><span class="cov10" title="13863">{
        n := len(key)
        if offset + n &gt; templateLen </span><span class="cov5" title="117">{
            continue</span>
        }
        
        <span class="cov9" title="13746">if key == (*templatePtr)[offset : (offset+n)] </span><span class="cov6" title="402">{
            return logItemType, offset + n - 1, nil
        }</span>
    }
    
    // not found
    <span class="cov0" title="0">return -1, -1, errors.New("no such log item format type : " + *templatePtr)</span>
}

// parse template token in "{}"
func parseBracketToken(templatePtr *string, offset int) (LogFmtItem, int, error)<span class="cov4" title="37">{
    length := len(*templatePtr)
    
    // find the closing '}'
    var endOfBracket int
    for endOfBracket = offset+1; endOfBracket &lt; length; endOfBracket++ </span><span class="cov6" title="375">{
        if (*templatePtr)[endOfBracket] == '}' </span><span class="cov4" title="37">{
            break</span>
        }
    }
    
    // if no '}' exists
    <span class="cov4" title="37">if endOfBracket &gt;= length </span><span class="cov0" title="0">{
        msg := "log format: { must be terminated by a }"
        return LogFmtItem{}, -1, errors.New(msg)
    }</span>
    
    // is empty string after '}'
    <span class="cov4" title="37">if endOfBracket == (length - 1) </span><span class="cov0" title="0">{
        msg := "log format: } must followed a charactor"
        return LogFmtItem{}, -1, errors.New(msg)
    }</span>
    
    // the key in "{}"
    <span class="cov4" title="37">key := (*templatePtr)[offset+1 : endOfBracket]
    
    // find type
    logItemType, end, err := tokenTypeGet(templatePtr, endOfBracket+1)
    if err != nil</span><span class="cov0" title="0">{
        return LogFmtItem{}, -1, err
    }</span>
    
    <span class="cov4" title="37">return LogFmtItem{key, logItemType}, end, nil</span>
}

// parse logTemplate from config file
func parseLogTemplate(logTemplate string) ([]LogFmtItem, error) <span class="cov3" title="12">{
    reqFmts := []LogFmtItem{}
    
    start := 0
    templateLen := len(logTemplate)
    var token string
    
    for i := 0; i &lt; templateLen; i++ </span><span class="cov8" title="4419">{
        if logTemplate[i] == '%' </span><span class="cov6" title="399">{
            if (i+1) == templateLen </span><span class="cov0" title="0">{
                msg := "log format: % must followed with a charactor"
                return nil, errors.New(msg)
            }</span>
            
            // saving string before '%'
            <span class="cov6" title="399">if start &lt;= (i-1) </span><span class="cov6" title="387">{
                token = logTemplate[start:i]
                item := LogFmtItem{token, FORMAT_STRING}
                reqFmts = append(reqFmts, item)
            }</span>
            
            <span class="cov6" title="399">if logTemplate[i+1] == '{' </span><span class="cov4" title="36">{
                item, end, err := parseBracketToken(&amp;logTemplate, i+1)
                if err != nil </span><span class="cov0" title="0">{
                    return nil, err
                }</span>
                // add item to reqFmts
                <span class="cov4" title="36">reqFmts = append(reqFmts, item)
                i = end
                start = end + 1</span>
                
            } <span class="cov6" title="363">else {
                // normal log formate
                // longest string first : %abc &gt; %ab &gt; %a
                logItemType, end, err := tokenTypeGet(&amp;logTemplate, i+1)
                if err != nil</span><span class="cov0" title="0">{
                    return nil, err
                }</span>
                
                <span class="cov6" title="363">token = logTemplate[(i+1) : end+1]
                item := LogFmtItem{token, logItemType}
                reqFmts = append(reqFmts, item)
                
                i = end
                start = end + 1</span>
            }
        }
    }
    
    // saving tail string
    <span class="cov3" title="12">if start &lt; templateLen </span><span class="cov3" title="12">{
        token = logTemplate[start:templateLen]
        item := LogFmtItem{token, FORMAT_STRING}
        reqFmts = append(reqFmts, item)
    }</span>
    
    <span class="cov3" title="12">return reqFmts, nil</span>
}

// log item handlers
// FORMAT_HOST
func onLogFmtHost(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                  req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov1" title="1">{
        return errors.New("req.HttpRequest is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(req.HttpRequest.Host)
    
    return nil</span>
}

// FORMAT_SRV_IP
func onLogFmtSrvIp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                   req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if req.Connection != nil </span><span class="cov0" title="0">{
        buff.WriteString(req.Connection.LocalAddr().String())
    }</span> <span class="cov1" title="2">else {
        buff.WriteString("-")
    }</span>
    
    <span class="cov1" title="2">return nil</span>
}

// FORMAT_VIP
func onLogFmtVip(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                 req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if req.Session.Vip != nil </span><span class="cov1" title="1">{
        vip := req.Session.Vip.String()
        if len(vip) == 0 </span><span class="cov0" title="0">{
            vip = "-"
        }</span>
        <span class="cov1" title="1">buff.WriteString(vip)</span>
    } <span class="cov1" title="1">else {
        buff.WriteString("-")
    }</span>

    <span class="cov1" title="2">return nil</span>
}

// FORMAT_FEATURE_CODE
func onLogFmtFeatureCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                         req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")  // used by BDS
    
    return nil</span>
}

// FORMAT_ACTION_CODE
func onLogFmtActionCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")  // used by BDS
    
    return nil</span>
}

// FORMAT_INNOCENT_TAG
func onLogFmtInnocentTag(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                         req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")  // Is IP in white list
    
    return nil</span>
}

// FORMAT_SERVICE_TAG
func onLogFmtServiceTag(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")  // used by BDS
    
    return nil</span>
}

// FORMAT_NTH_REQ_IN_SESSION
func onLogFmtNthReqInSession(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                             req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if req.Session == nil </span><span class="cov0" title="0">{
        return errors.New("req.Session is nil")
    }</span>

    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Session.ReqNum)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_SINCE_SESSION_TIME
func onLogFmtSinceSessionTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov0" title="0">if req.Session == nil </span><span class="cov0" title="0">{
        return errors.New("req.Session is nil")
    }</span>

    <span class="cov0" title="0">ms := time.Since(req.Session.StartTime).Nanoseconds()/1000000

    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_WAF_SPENT_TIME
func onLogFmtWafSpentTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>

    <span class="cov1" title="2">if req.Stat == nil </span><span class="cov1" title="1">{
        return errors.New("req.Stat is nil")
    }</span>

    <span class="cov1" title="1">buff.WriteString(strconv.Itoa(int(req.Stat.WafSpentTime)))

    return nil</span>
}

// FORMAT_WAF_STATUS
func onLogFmtWafStatus(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>

    <span class="cov1" title="2">if req.Stat == nil </span><span class="cov1" title="1">{
        return errors.New("req.Stat is nil")
    }</span>

    <span class="cov1" title="1">buff.WriteString(strconv.Itoa(int(req.Stat.WafStatus)))

    return nil</span>
}



// FORMAT_TIME
func onLogFmtTime(m *ModuleAccess, buff *bytes.Buffer) error <span class="cov2" title="3">{
    now := time.Now()
    timeNowStr := fmt.Sprintf("%04d-%02d-%02d %02d:%02d:%02d", 
                              now.Year(), now.Month(), now.Day(),
                              now.Hour(), now.Minute(), now.Second())
    buff.WriteString(timeNowStr)
    
    return nil
}</span>

// FORMAT_HTTP
func onLogFmtHttp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                  req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov1" title="1">{
        return errors.New("req.HttpRequest is nil")
    }</span>
    
    <span class="cov1" title="1">data, found := req.HttpRequest.Header[logItem.Key]
    if !found </span><span class="cov1" title="1">{
        buff.WriteString("-")
    }</span> <span class="cov0" title="0">else {
        buff.WriteString(strings.Join(data, ","))
    }</span>
    
    <span class="cov1" title="1">return nil</span>
}

// FORMAT_RESPONSED_HEADER
func onLogFmtResponseHeader(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
        return nil
    }</span>
    
    <span class="cov1" title="2">data, found := res.Header[logItem.Key]
    
    if !found </span><span class="cov1" title="2">{
        buff.WriteString("-")
    }</span> <span class="cov0" title="0">else {
        buff.WriteString(strings.Join(data, ","))
    }</span>
    
    <span class="cov1" title="2">return nil</span>
}

// FORMAT_RES_COOKIE
func onLogFmtResCookie(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                    req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov0" title="0">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
        return nil
    }</span>
    
    <span class="cov0" title="0">data := "-"
    cookies := res.Cookies()
    for _, co := range cookies </span><span class="cov0" title="0">{
        //fmt.Printf("cookie.Name .Value = %v, %v\n", co.Name, co.Value)
        if co.Name == logItem.Key </span><span class="cov0" title="0">{
            data = co.Value
            break</span>
        }
    }
    
    <span class="cov0" title="0">buff.WriteString(data)
    
    return nil</span>
}

// FORMAT_REQ_COOKIE
func onLogFmtReqCookie(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                    req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov0" title="0">data := "-"
    
    for _, co := range req.Cookies </span><span class="cov0" title="0">{
        //fmt.Printf("cookie.Name .Value = %v, %v\n", co.Name, co.Value)
        if co.Name == logItem.Key </span><span class="cov0" title="0">{
            data = co.Value
            break</span>
        }
    }
    
    <span class="cov0" title="0">buff.WriteString(data)
    
    return nil</span>
}

// FORMAT_URI
func onLogFmtUri(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                 req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov1" title="1">{
        return errors.New("req.HttpRequest is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(req.HttpRequest.URL.String())
    
    return nil</span>
}

// FORMAT_REQUEST_URI
func onLogFmtRequestUri(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov1" title="1">{
        return errors.New("req.HttpRequest is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(req.HttpRequest.RequestURI)
    
    return nil</span>
}

// FORMAT_CLIENT_READ_TIME
func onLogFmtClientReadTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.Stat == nil </span><span class="cov1" title="1">{
        return errors.New("req.Stat is nil")
    }</span>
    
    // tv_sub(&amp;sub_ptr-&gt;connect_backend_tv,&amp;sub_ptr-&gt;read_client_tv)
    <span class="cov1" title="1">ms := req.Stat.ReadReqEnd.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_PROXY_DELAY_TIME
func onLogFmtProxyDelayTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.Stat == nil </span><span class="cov1" title="1">{
        return errors.New("req.Stat is nil")
    }</span>
    
    // only output "internal delay" for successful request
    <span class="cov1" title="1">if !req.Stat.BackendFirst.IsZero() </span><span class="cov0" title="0">{
        ms := req.Stat.BackendFirst.Sub(req.Stat.ReadReqEnd).Nanoseconds() / 1000000
        msg := fmt.Sprintf("%d", ms)
        buff.WriteString(msg)
    }</span> <span class="cov1" title="1">else {
        buff.WriteString("-")
    }</span>
    
    <span class="cov1" title="1">return nil</span>
}

// FORMAT_SERVICE_ALL_TIME
func onLogFmtServiceAllTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    //tv_sub(&amp;now_time,&amp;sub_ptr-&gt;read_client_tv)
    <span class="cov1" title="2">now := time.Now()
    ms := now.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_CONNECT_SRV_TIME
func onLogFmtConnectSrvTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    // tv_sub(&amp;sub_ptr-&gt;write_backend_tv,&amp;sub_ptr-&gt;connect_backend_tv)
    <span class="cov1" title="2">ms := req.Stat.ClusterEnd.Sub(req.Stat.ClusterStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_WRITE_SRV_TIME
func onLogFmtWriteSrvTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    // tv_sub(&amp;sub_ptr-&gt;read_backend_write_client_data,&amp;sub_ptr-&gt;write_backend_tv)
    <span class="cov1" title="2">ms := req.Stat.BackendEnd.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_READWRITE_SRV_TIME
func onLogFmtReadWriteSrvTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                              req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    // tv_sub(&amp;now_time,&amp;sub_ptr-&gt;read_backend_write_client_data)
    <span class="cov1" title="2">now := time.Now()
    ms := now.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_HEADER_LEN
func onLogFmtHeaderLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Stat.HeaderLenIn)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_KEEPALIVE_NUM
func onLogFmtKeepAliveNum(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">msg := fmt.Sprintf("%d", session.ReqNum)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_CONTENT_LEN
func onLogFmtContentLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov1" title="1">{
        return errors.New("req.HttpRequest is nil")
    }</span>
    
    <span class="cov1" title="1">msg := fmt.Sprintf("%d", req.HttpRequest.ContentLength)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_OUT_HEADER_LEN
func onLogFmtOutHeaderLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
        return nil
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Stat.HeaderLenOut)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_OUT_CONTENT_LEN
func onLogFmtOutContentLen(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                           req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
        return nil
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", res.ContentLength) // req.Stat.BodyLenOut
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_OUT_STATUS
func onLogFmtOutStatus(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
    }</span> <span class="cov1" title="2">else {
        msg := fmt.Sprintf("%d", res.StatusCode)
        buff.WriteString(msg)
    }</span>
    
    <span class="cov1" title="2">return nil</span>
}

// FORMAT_SERVICE_NAME
func onLogFmtServiceName(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                         req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString(req.Backend.ClusterName)
    
    return nil</span>
}

// FORMAT_SUB_CLUSTER_NAME
func onLogFmtSubClusterName(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString(req.Backend.SubclusterName)
    
    return nil</span>
}

// FORMAT_MEMCACHED_STATUS
func onLogFmtMemCachedStatus(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                             req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">cache_stat := 0
    switch cache_stat </span>{
        <span class="cov1" title="2">case 0:
            buff.WriteString("no_cache")</span>
        <span class="cov0" title="0">case 1:
            buff.WriteString("cache_hit_local")</span>
        <span class="cov0" title="0">case 2:
            buff.WriteString("cache_hit_global")</span>
        <span class="cov0" title="0">case 3:
            buff.WriteString("cache_miss")</span>
        <span class="cov0" title="0">default:
            buff.WriteString("-")</span>
    }
    
    <span class="cov1" title="2">return nil</span>
}

// FORMAT_LOGID
func onLogFmtLogId(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                   req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.LogId)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_CACHE_KEY
func onLogFmtCacheKey(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")
    
    return nil</span>
}

// FORMAT_PAGE_NUM
func onLogFmtPageNum(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                     req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")
    
    return nil</span>
}

// FORMAT_FIRST_LINE
func onLogFmtFirstLine(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">buff.WriteString("-")
    
    return nil</span>
}

// FORMAT_BWS_TIME
func onLogFmtBwsTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                     req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    //snprintf(buf, sizeof(buf), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
    //                    t2.tm_mday, month_snames[t2.tm_mon], t2.tm_year + 1900,
    //                    t2.tm_hour, t2.tm_min, t2.tm_sec,
    //                    sign, timz / 60, timz % 60);
    <span class="cov1" title="2">buff.WriteString("-")
    
    return nil</span>
}

// FORMAT_READ_REQ_DURATION
func onLogFmtReadReqDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                             req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">ms := req.Stat.ReadReqEnd.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_CLUSTER_DURATION
func onLogFmtClusterDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                             req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">ms := req.Stat.ClusterEnd.Sub(req.Stat.ClusterStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_LAST_BACKEND_DURATION
func onLogFmtLastBackendDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                                 req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">ms := req.Stat.BackendEnd.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_RESPONSE_DURATION
func onLogFmtResponseDuration(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                              req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">ms := req.Stat.ResponseEnd.Sub(req.Stat.ResponseStart).Nanoseconds() / 1000000
    msg := fmt.Sprintf("%d", ms)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_HEADER_LEN_IN
func onLogFmtHeaderLenIn(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                              req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Stat.HeaderLenIn)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_BODY_LEN_IN
func onLogFmtBodyLenIn(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                              req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Stat.BodyLenIn)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_HEADER_LEN_OUT
func onLogFmtHeaderLenOut(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                              req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Stat.HeaderLenOut)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_BODY_LEN_OUT
func onLogFmtBodyLenOut(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                              req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov2" title="4">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov2" title="4">if req.Stat == nil </span><span class="cov1" title="2">{
        return errors.New("req.Stat is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.Stat.BodyLenOut)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_REQUEST_HEADER
func onLogFmtRequestHeader(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                            req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov3" title="10">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    <span class="cov3" title="10">if req.HttpRequest == nil </span><span class="cov2" title="5">{
        return errors.New("req.HttpRequest is nil")
    }</span>
    
    <span class="cov2" title="5">data, found := req.HttpRequest.Header[logItem.Key]
    if !found </span><span class="cov2" title="5">{
        buff.WriteString("-")
    }</span> <span class="cov0" title="0">else {
        buff.WriteString(strings.Join(data, ","))
    }</span>
    
    <span class="cov2" title="5">return nil</span>
}

// FORMATE_BACKEND
func onLogFmtBackend(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                     req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%s,%s,%s,%s", req.Backend.ClusterName, req.Backend.SubclusterName,
                       req.Backend.BackendAddr, req.Backend.BackendName)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_REDIRECT
func onLogFmtRedirect(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">url := req.Redirect.Url
    if len(url) == 0 </span><span class="cov1" title="2">{
        url = "-"
    }</span>
    <span class="cov1" title="2">msg := fmt.Sprintf("%s,%d", url, req.Redirect.Code)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_RETRY_NUM
func onLogFmtRetryNum(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%d", req.RetryTime)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_BAIDU_ID
func onLogFmtBaiduId(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">id := req.Baiduid
    if len(id) == 0 </span><span class="cov1" title="2">{
        id = "-"
    }</span>
    <span class="cov1" title="2">buff.WriteString(id)
    
    return nil</span>
}

// FORMAT_REMOTE_ADDR
func onLogFmtClientIp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    //msg := fmt.Sprintf("%s", req.RemoteAddr.String())
    <span class="cov1" title="2">buff.WriteString(req.RemoteAddr.String())
    
    return nil</span>
}

// FORMAT_SERVER_ADDR
func onLogFmtServerIp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if req.Connection != nil </span><span class="cov0" title="0">{
        msg := fmt.Sprintf("%s", req.Connection.LocalAddr().String())
        buff.WriteString(msg)
    }</span> <span class="cov1" title="2">else {
        buff.WriteString("-")
    }</span>
    
    <span class="cov1" title="2">return nil</span>
}

// FORMAT_RES_STATUS
func onLogFmtResStatus(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
        return nil
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%s", res.Status)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_RES_PROTO
func onLogFmtResProto(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                      req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
        buff.WriteString("-")
        return nil
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%s", res.Proto)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_IS_TRUSTIP
func onLogFmtIsTrustip(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov1" title="2">msg := fmt.Sprintf("%v", req.Session.IsTrustIP)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_SES_START_TIME
func onLogFmtSesStartTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(session.StartTime.String())
    
    return nil</span>
}

// FORMAT_SES_END_TIME
func onLogFmtSesEndTime(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(session.EndTime.String())
    
    return nil</span>
}

// FORMAT_SES_OVERHEAD
func onLogFmtSesOverhead(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                         session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">msg := fmt.Sprintf("%d", session.Overhead)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_SES_CLIENT_IP
func onLogFmtSesClinetIp(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                         session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(session.RemoteAddr.String())
    return nil</span>
}

// FORMAT_SES_CLUSTER
func onLogFmtSesCluster(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">buff.WriteString(session.ClusterName)
    
    return nil</span>
}

// FORMAT_SES_REQ_NUM
func onLogFmtSesReqNum(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">msg := fmt.Sprintf("%d", session.ReqNum)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_SES_READ_TOTAL
func onLogFmtSesReadTotal(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                          session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">msg := fmt.Sprintf("%d", session.ReadTotal)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_SES_WRITE_TOTAL
func onLogFmtSesWriteTotal(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                           session *bfe_basic.Session) error <span class="cov1" title="1">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov1" title="1">msg := fmt.Sprintf("%d", session.WriteTotal)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_SES_USE100
func onLogFmtSesUse100(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       session *bfe_basic.Session) error <span class="cov0" title="0">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov0" title="0">if session.Use100Continue </span><span class="cov0" title="0">{
        buff.WriteString("1")
    }</span> <span class="cov0" title="0">else {
        buff.WriteString("0")
    }</span>
    
    <span class="cov0" title="0">return nil</span>
}

// FORMAT_SES_IS_HTTPS
func onLogFmtSesIsHttps(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                        session *bfe_basic.Session) error <span class="cov0" title="0">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov0" title="0">msg := fmt.Sprintf("%v", session.IsHttps)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMAT_SES_IS_RESUME
func onLogFmtSesIsResume(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                         session *bfe_basic.Session) error <span class="cov0" title="0">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov0" title="0">msg := fmt.Sprintf("%v", session.IsResume)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_ERROR_CODE_REQ
func onLogFmtErrorCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
    if req == nil </span><span class="cov0" title="0">{
        return errors.New("req is nil")
    }</span>
    
    <span class="cov0" title="0">errMsg := req.ErrMsg
    if len(req.ErrMsg) == 0 </span><span class="cov0" title="0">{
        errMsg = "-"
    }</span>
    <span class="cov0" title="0">msg := fmt.Sprintf("%s,%s", req.ErrCode.Error(), errMsg)
    buff.WriteString(msg)
    
    return nil</span>
}

// FORMATE_ERROR_CODE_SES
func onLogFmtSesErrorCode(m *ModuleAccess, logItem *LogFmtItem, buff *bytes.Buffer,
                       session *bfe_basic.Session) error <span class="cov0" title="0">{
    if session == nil </span><span class="cov0" title="0">{
        return errors.New("session is nil")
    }</span>
    
    <span class="cov0" title="0">errMsg := session.ErrMsg
    if len(session.ErrMsg) == 0 </span><span class="cov0" title="0">{
        errMsg = "-"
    }</span>
    <span class="cov0" title="0">msg := fmt.Sprintf("%s,%s", session.ErrCode.Error(), errMsg)
    buff.WriteString(msg)
    
    return nil</span>
}
//------------------------------------------------------------------------------------------------
// module call backs

// handler for finish http request
func (m *ModuleAccess) requestFinish(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov1" title="2">{
    //fmt.Printf("%s.requestFinish():req from %s, %s\n", m.name, req.RemoteAddr.String(), req.Stat)
    
    var fmtItems []LogFmtItem
    byteStr := bytes.NewBuffer(nil)
    
    if req.ErrCode == nil </span><span class="cov1" title="2">{
        fmtItems = m.reqFmts
    }</span> <span class="cov0" title="0">else {
        fmtItems = m.errReqFmts
    }</span>
    
    // write log
    <span class="cov1" title="2">for _, item := range fmtItems </span><span class="cov6" title="280">{
        // literal string
        if item.Type == FORMAT_STRING </span><span class="cov5" title="140">{
            byteStr.WriteString(item.Key)
        }</span> <span class="cov5" title="140">else if item.Type == FORMAT_TIME </span><span class="cov1" title="2">{
            onLogFmtTime(m, byteStr)
        }</span> <span class="cov5" title="138">else {
            handler, found := fmtHandlerTable[item.Type]
            if found </span><span class="cov5" title="138">{
                h := handler.(func (*ModuleAccess, *LogFmtItem, *bytes.Buffer,
                                    *bfe_basic.Request, *bfe_http.Response) error)
                h(m, &amp;item, byteStr, req, res)
            }</span>
        }
    }
    
    
    <span class="cov1" title="2">byteStr.WriteString("\n")
    m.logger.Info(byteStr.Bytes())

    return bfe_module.BFE_HANDLER_GOON</span>
}

// handler for finish http connection
func (m *ModuleAccess) sessionFinish(session *bfe_basic.Session) int <span class="cov1" title="1">{
    var fmtItems []LogFmtItem
    byteStr := bytes.NewBuffer(nil)
    
    // normal finish
    if session.ErrCode == nil </span><span class="cov1" title="1">{
        fmtItems = m.sessionFmts
    }</span> <span class="cov0" title="0">else {
        fmtItems = m.errSessionFmts
    }</span>
    
    // write log
    <span class="cov1" title="1">for _, item := range fmtItems </span><span class="cov3" title="20">{
        // literal string
        if item.Type == FORMAT_STRING </span><span class="cov3" title="10">{
            byteStr.WriteString(item.Key)
        }</span> <span class="cov3" title="10">else if item.Type == FORMAT_TIME </span><span class="cov1" title="1">{
            onLogFmtTime(m, byteStr)
        }</span> <span class="cov3" title="9">else {
            handler, found := fmtHandlerTable[item.Type]
            if found </span><span class="cov3" title="9">{
                //println("item", item.Key, item.Type)
                h := handler.(func (*ModuleAccess, *LogFmtItem, *bytes.Buffer,
                                    *bfe_basic.Session) error)
                h(m, &amp;item, byteStr, session)
            }</span>
        }
    }
    
    <span class="cov1" title="1">byteStr.WriteString("\n")
    m.logger.Info(byteStr.Bytes())
    //m.logAgent.Send(byteStr.Bytes())
    
    return bfe_module.BFE_HANDLER_GOON</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/* conf_mod_access_pb.go - config for mod_access_pb   */
/*
modification history
--------------------
2014/07/01, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package mod_access_pb

import (
    "errors"
)

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/log"
)


type ConfModAccessPb struct {    
    Log struct {
        Network       string
        LogServerAddr string
    }
    
    Template struct {
        ReqTemplate        string  // access log formate string
        ErrReqTemplate     string  // access log formate string
        SessionTemplate    string  // session finish log formate string
        ErrSessionTemplate  string  // error log formate string
    }
}

var defaultReqPbTemplate         string  // default ConfModAccessPb.ReqTemplate
var defaultErrReqPbTemplate      string  // default ConfModAccessPb.ErrReqTemplate
var defaultSessionPbTemplate     string  // default ConfModAccessPb.SessionTemplate
var defaultErrSessionPbTemplate  string  // default ConfModAccessPb.ErrSessionTemplate

func init() <span class="cov1" title="1">{
    defaultReqPbTemplate        = ""
    defaultErrReqPbTemplate     = ""
    defaultSessionPbTemplate    = ""
    defaultErrSessionPbTemplate = ""
}</span>


/* load config from config file    */
func ConfLoad(filePath string) (*ConfModAccessPb, error) <span class="cov10" title="6">{
    var cfg ConfModAccessPb
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_access_pb
    <span class="cov10" title="6">err = cfg.Check()
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="6">return &amp;cfg, nil</span>
}

func (cfg *ConfModAccessPb) Check() error <span class="cov10" title="6">{
    return ConfModAccessPbCheck(cfg)
}</span>

func ConfModAccessPbCheck(cfg *ConfModAccessPb) error <span class="cov10" title="6">{
    if cfg.Log.Network != "unixgram" &amp;&amp; cfg.Log.Network != "upd" </span><span class="cov0" title="0">{
        return errors.New("cfg.Log.Network config error")
    }</span>
    
    <span class="cov10" title="6">if cfg.Log.LogServerAddr == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("ModAccessPb.LogServerAddr not set, use default value")
        cfg.Log.LogServerAddr = "/tmp/bfe_log_pb.sock"
    }</span>
    
    <span class="cov10" title="6">if cfg.Template.ReqTemplate == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("ModAccessPb.ReqTemplate not set, use default value")
        cfg.Template.ReqTemplate = defaultReqPbTemplate
    }</span>
    
    <span class="cov10" title="6">if cfg.Template.ErrReqTemplate == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModAccessPb.ErrReqTemplate not set, use default value")
        cfg.Template.ErrReqTemplate = defaultErrReqPbTemplate
    }</span>
    
    <span class="cov10" title="6">if cfg.Template.SessionTemplate == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModAccessPb.SessionTemplate not set, use default value")
        cfg.Template.SessionTemplate = defaultSessionPbTemplate
    }</span>
    
    <span class="cov10" title="6">if cfg.Template.ErrSessionTemplate == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModAccessPb.ErrSessionTemplate not set, use default value")
        cfg.Template.ErrSessionTemplate = defaultErrSessionPbTemplate
    }</span>
    
    <span class="cov10" title="6">return nil</span>
}

</pre>
		
		<pre class="file" id="file50" style="display: none">/* mod_access_pb.go - module for save access log in protobuf */
/*
modification history
--------------------
2014/07/01, by Taochunhua, create
2014/09/26, modified by weiwei:
    recycle byte slice to reduce memory consumption
2014/10/9, by taochunhua, push log data into remote log-server
2015/09/26, by niexiaohui, add tcp log
*/
/*
DESCRIPTION
*/
package mod_access_pb

import (
        "encoding/binary"
        "errors"
        "fmt"
        "net"
        "strings"
        "time"
)

import (
        "code.google.com/p/gogoprotobuf/proto"
        "code.google.com/p/log4go"
        "www.baidu.com/golang-lib/access_log"
        "www.baidu.com/golang-lib/baidu_id"
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
        bfe_access_pb "bfe_modules/mod_access_pb/bfe_access_pb"
)

// all format types
const (
        FORMAT_STRING = iota
        FORMAT_HOST
        FORMAT_TIME
        FORMAT_COOKIE
        FORMAT_URI
        FORMAT_CLIENT_READ_TIME
        FORMAT_SERVICE_ALL_TIME
        FORMAT_CONNECT_SRV_TIME
        FORMAT_WRITE_SRV_TIME
        FORMAT_READWRITE_SRV_TIME
        FORMAT_IN_HEADER_LEN
        FORMAT_IN_BODY_LEN
        FORMAT_OUT_HEADER_LEN
        FORMAT_KEEPALIVE_NUM
        FORMAT_STATUS_CODE
        FORMAT_SRV_CLUSTER_NAME
        FORMAT_SUB_CLUSTER_NAME
        FORMAT_MEMCACHED_STATUS
        FORMAT_LOGID
        FORMAT_CACHE_KEY
        FORMAT_CONTENT_TYPE
        FORMAT_FIRST_LINE
        FORMAT_PAGE_NUM
        FORMAT_BWS_TIME
        FORMAT_SRV_IP
        FORMAT_VIP
        FORMAT_FEATURE_CODE
        FORMAT_ACTION_CODE
        FORMAT_INNOCENT_TAG
        FORMAT_SERVICE_TAG
        FORMAT_WAF_SPENT_TIME
        FORMAT_WAF_STATUS
        FORMAT_OUT_BODY_LEN
        FORMAT_REFERER
        FORMAT_BAIDUID
        FORMAT_BDUSS
        FORMAT_USERAGENT
        FORMAT_X_FORWARD_FOR
        FORMAT_ACCEPT_LANGUAGE
        FORMAT_AUTHORIZATION
        FORMAT_HEADER_CLIENTIP
        FORMAT_CLIENT_IP
        FORMAT_SERVER_IP
        FORMAT_HEADER_HOST
        FORMAT_ERROR_STRING_REQ
        FORMAT_SHIFEN
        FORMAT_UNKNOW
        FORMAT_SES_START_TIME
        FORMAT_SES_ALL_TIME
        FORMAT_SES_CLIENT_IP
        FORMAT_BFE_IP
        FORMAT_SES_READ_TOTAL
        FORMAT_SES_WRITE_TOTAL
        FORMAT_FLOW_INFO
)

// each format item should be in one of following template place
const REQUEST = "REQUEST"
const SESSION = "SESSION"
const DOMAIN_ALL = "DOMAIN_ALL"

// each log format in log template
type LogFmtItem struct {
        Key  string
        Type int
}

// table of format string =&gt; format type mapping
var fmtTable map[string]int

// table of formate type =&gt; item valid template
var fmtItemDomainTable map[int]string

// table of format type =&gt; format print handler mapping
var fmtHandlerTable map[int]interface{}

// setup fmtTable, fmtItemDomainTable and fmtHandlerTable
func init() <span class="cov1" title="1">{
        fmtTable = map[string]int{"host": FORMAT_HOST,
                "time":                FORMAT_TIME,
                "uri":                 FORMAT_URI,
                "client_read_time":    FORMAT_CLIENT_READ_TIME,
                "serv_all_time":       FORMAT_SERVICE_ALL_TIME,
                "connect_server_time": FORMAT_CONNECT_SRV_TIME,
                "write_server_time":   FORMAT_WRITE_SRV_TIME,
                "read_write_srv_time": FORMAT_READWRITE_SRV_TIME,
                "in_header_len":       FORMAT_IN_HEADER_LEN,
                "in_body_len":         FORMAT_IN_BODY_LEN,
                "out_header_len":      FORMAT_OUT_HEADER_LEN,
                "status_code":         FORMAT_STATUS_CODE,
                "svr_cluster_name":    FORMAT_SRV_CLUSTER_NAME,
                "sub_cluster_name":    FORMAT_SUB_CLUSTER_NAME,
                "memcache_status":     FORMAT_MEMCACHED_STATUS,
                "logid":               FORMAT_LOGID,
                "cache_key":           FORMAT_CACHE_KEY,
                "content_type":        FORMAT_CONTENT_TYPE,
                "first_line":          FORMAT_FIRST_LINE,
                "page_num":            FORMAT_PAGE_NUM,
                "bws_time":            FORMAT_BWS_TIME,
                "svr_ip":              FORMAT_SRV_IP,
                "vip":                 FORMAT_VIP,
                "feature_code":        FORMAT_FEATURE_CODE,
                "action_code":         FORMAT_ACTION_CODE,
                "innocent_tag":        FORMAT_INNOCENT_TAG,
                "waf_cost_time":       FORMAT_WAF_SPENT_TIME,
                "waf_status":          FORMAT_WAF_STATUS,
                "service_tag":         FORMAT_SERVICE_TAG,
                "referer":             FORMAT_REFERER,
                "baiduid":             FORMAT_BAIDUID,
                "bduss":               FORMAT_BDUSS,
                "user_agent":          FORMAT_USERAGENT,
                "cookie":              FORMAT_COOKIE,
                "x_forward_for":       FORMAT_X_FORWARD_FOR,
                "accept_language":     FORMAT_ACCEPT_LANGUAGE,
                "author":              FORMAT_AUTHORIZATION,
                "out_body_len":        FORMAT_OUT_BODY_LEN,
                "clientip":            FORMAT_CLIENT_IP,
                "serverip":            FORMAT_SERVER_IP,
                "header_host":         FORMAT_HEADER_HOST,
                "header_client_ip":    FORMAT_HEADER_CLIENTIP,
                // session related
                "ses_start_time": FORMAT_SES_START_TIME,
                "ses_all_time":   FORMAT_SES_ALL_TIME,
                "ses_client_ip":  FORMAT_SES_CLIENT_IP,
                "bfe_ip":         FORMAT_BFE_IP,
                "keepalive_num":  FORMAT_KEEPALIVE_NUM,
                "read_total":     FORMAT_SES_READ_TOTAL,
                "write_total":    FORMAT_SES_WRITE_TOTAL,
                "flow_info":      FORMAT_FLOW_INFO,
                // error string
                "error_string": FORMAT_ERROR_STRING_REQ,
                "shifen":       FORMAT_SHIFEN,
        }

        fmtItemDomainTable = map[int]string{
                FORMAT_STRING:             DOMAIN_ALL,
                FORMAT_TIME:               DOMAIN_ALL,
                FORMAT_LOGID:              REQUEST,
                FORMAT_HOST:               REQUEST,
                FORMAT_COOKIE:             REQUEST,
                FORMAT_URI:                REQUEST,
                FORMAT_CLIENT_READ_TIME:   REQUEST,
                FORMAT_SERVICE_ALL_TIME:   REQUEST,
                FORMAT_CONNECT_SRV_TIME:   REQUEST,
                FORMAT_WRITE_SRV_TIME:     REQUEST,
                FORMAT_READWRITE_SRV_TIME: REQUEST,
                FORMAT_IN_HEADER_LEN:      REQUEST,
                FORMAT_IN_BODY_LEN:        REQUEST,
                FORMAT_OUT_HEADER_LEN:     REQUEST,
                FORMAT_STATUS_CODE:        REQUEST,
                FORMAT_SRV_CLUSTER_NAME:   REQUEST,
                FORMAT_SUB_CLUSTER_NAME:   REQUEST,
                FORMAT_MEMCACHED_STATUS:   REQUEST,
                FORMAT_CACHE_KEY:          REQUEST,
                FORMAT_CONTENT_TYPE:       REQUEST,
                FORMAT_FIRST_LINE:         REQUEST,
                FORMAT_PAGE_NUM:           REQUEST,
                FORMAT_BWS_TIME:           REQUEST,
                FORMAT_SRV_IP:             REQUEST,
                FORMAT_VIP:                REQUEST,
                FORMAT_FEATURE_CODE:       REQUEST,
                FORMAT_ACTION_CODE:        REQUEST,
                FORMAT_INNOCENT_TAG:       REQUEST,
                FORMAT_SERVICE_TAG:        REQUEST,
                FORMAT_WAF_SPENT_TIME:     REQUEST,
                FORMAT_WAF_STATUS:         REQUEST,
                FORMAT_OUT_BODY_LEN:       REQUEST,
                FORMAT_CLIENT_IP:          REQUEST,
                FORMAT_SERVER_IP:          REQUEST,
                FORMAT_HEADER_HOST:        REQUEST,
                FORMAT_REFERER:            REQUEST,
                FORMAT_HEADER_CLIENTIP:    REQUEST,
                FORMAT_BAIDUID:            REQUEST,
                FORMAT_BDUSS:              REQUEST,
                FORMAT_USERAGENT:          REQUEST,
                FORMAT_X_FORWARD_FOR:      REQUEST,
                FORMAT_ACCEPT_LANGUAGE:    REQUEST,
                FORMAT_AUTHORIZATION:      REQUEST,
                FORMAT_ERROR_STRING_REQ:   REQUEST,
                FORMAT_SHIFEN:             REQUEST,
                FORMAT_SES_START_TIME:     SESSION,
                FORMAT_SES_ALL_TIME:       SESSION,
                FORMAT_SES_CLIENT_IP:      SESSION,
                FORMAT_BFE_IP:             SESSION,
                FORMAT_KEEPALIVE_NUM:      SESSION,
                FORMAT_SES_READ_TOTAL:     SESSION,
                FORMAT_SES_WRITE_TOTAL:    SESSION,
                FORMAT_FLOW_INFO:          SESSION,
        }

        fmtHandlerTable = map[int]interface{}{
                FORMAT_HOST:               onLogFmtHost,
                FORMAT_LOGID:              onLogFmtLogId,
                FORMAT_URI:                onLogFmtUri,
                FORMAT_CLIENT_READ_TIME:   onLogFmtClientReadTime,
                FORMAT_SERVICE_ALL_TIME:   onLogFmtServiceAllTime,
                FORMAT_CONNECT_SRV_TIME:   onLogFmtConnectSrvTime,
                FORMAT_WRITE_SRV_TIME:     onLogFmtWriteSrvTime,
                FORMAT_READWRITE_SRV_TIME: onLogFmtReadWriteSrvTime,
                FORMAT_IN_HEADER_LEN:      onLogFmtInHeaderLen,
                FORMAT_IN_BODY_LEN:        onLogFmtInBodyLen,
                FORMAT_OUT_HEADER_LEN:     onLogFmtOutHeaderLen,
                FORMAT_STATUS_CODE:        onLogFmtOutStatus,
                FORMAT_SRV_CLUSTER_NAME:   onLogFmtServiceName,
                FORMAT_SUB_CLUSTER_NAME:   onLogFmtSubClusterName,
                FORMAT_MEMCACHED_STATUS:   onLogFmtMemCachedStatus,
                FORMAT_CACHE_KEY:          onLogFmtCacheKey,
                FORMAT_CONTENT_TYPE:       onLogFmtContentType,
                FORMAT_FIRST_LINE:         onLogFmtFirstLine,
                FORMAT_PAGE_NUM:           onLogFmtPageNum,
                FORMAT_BWS_TIME:           onLogFmtBwsTime,
                FORMAT_SRV_IP:             onLogFmtSrvIp,
                FORMAT_VIP:                onLogFmtVip,
                FORMAT_FEATURE_CODE:       onLogFmtFeatureCode,
                FORMAT_ACTION_CODE:        onLogFmtActionCode,
                FORMAT_INNOCENT_TAG:       onLogFmtInnocentTag,
                FORMAT_WAF_SPENT_TIME:     onLogFmtWafSpentTime,
                FORMAT_WAF_STATUS:         onLogFmtWafStatus,
                FORMAT_SERVICE_TAG:        onLogFmtServiceTag,
                FORMAT_OUT_BODY_LEN:       onLogFmtBodyLenOut,
                FORMAT_HEADER_HOST:        onLogFmtHeaderHost,
                FORMAT_REFERER:            onLogFmtReferer,
                FORMAT_HEADER_CLIENTIP:    onLogFmtHeaderClientIp,
                FORMAT_BAIDUID:            onLogFmtBaiduid,
                FORMAT_BDUSS:              onLogFmtBduss,
                FORMAT_USERAGENT:          onLogFmtUserAgent,
                FORMAT_COOKIE:             onLogFmtCookie,
                FORMAT_ACCEPT_LANGUAGE:    onLogFmtAcceptLanguage,
                FORMAT_AUTHORIZATION:      onLogFmtAuthorization,
                FORMAT_X_FORWARD_FOR:      onLogFmtXForwardFor,
                // session related
                FORMAT_SES_START_TIME:  onLogFmtSesStartTime,
                FORMAT_SES_ALL_TIME:    onLogFmtSesAllTime,
                FORMAT_SES_CLIENT_IP:   onLogFmtSesClientIP,
                FORMAT_BFE_IP:          onLogFmtBfeIP,
                FORMAT_KEEPALIVE_NUM:   onLogFmtKeepAliveNum,
                FORMAT_SES_READ_TOTAL:  onLogFmtSesReadTotal,
                FORMAT_SES_WRITE_TOTAL: onLogFmtSesWriteTotal,
                FORMAT_FLOW_INFO:       onLogFmtFlowInfo,
                // error string
                FORMAT_ERROR_STRING_REQ: onLogFmtErrString,
                FORMAT_SHIFEN:           onLogFmtShifen,
        }
}</span>

const (
        B2LOG_HEADER_VERSION = 1
        B2LOG_MAGIC_NUMBER   = 0xB0AEBEA7
)

type B2LogHeader struct {
        Magic         uint32 // magic number
        Version       uint32 // 
        UncompressLen uint32 // 
        CompressLen   uint32 // 
}

func MakeB2LogHeader(dataLen uint32) *B2LogHeader <span class="cov2" title="4">{
        return &amp;B2LogHeader{B2LOG_MAGIC_NUMBER,
                B2LOG_HEADER_VERSION,
                dataLen,
                0}
}</span>

type ModuleAccessPb struct {
        name   string           // name of module
        logger log4go.Logger    // remote logger
        conf   *ConfModAccessPb // raw config

        reqFmts []LogFmtItem // log formate meta data
        // parsed from LogTemplate
        errReqFmts []LogFmtItem // connect log formate meta data
        // parse from ErrLogTemplate

        sessionFmts []LogFmtItem // session finish log formate meta data
        // parsed from FinishTemplate
        errSessionFmts []LogFmtItem // connect log formate meta data
        // parse from ErrLogTemplate
}

func NewModuleAccessPb() *ModuleAccessPb <span class="cov3" title="6">{
        m := new(ModuleAccessPb)
        m.name = "mod_access_pb"
        return m
}</span>

func (m *ModuleAccessPb) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleAccessPb) Attr() map[string]interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (m *ModuleAccessPb) ParseConfig(conf *ConfModAccessPb) error <span class="cov3" title="5">{
        var err error

        // parse request finish template
        m.reqFmts, err = parseLogTemplate(conf.Template.ReqTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): ReqTemplate %s", m.name, err.Error())
        }</span>

        // parse request error template
        <span class="cov3" title="5">m.errReqFmts, err = parseLogTemplate(conf.Template.ErrReqTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): ErrReqTemplate %s", m.name, err.Error())
        }</span>

        // parse session finish template
        <span class="cov3" title="5">m.sessionFmts, err = parseLogTemplate(conf.Template.SessionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): SessionTemplate %s", m.name, err.Error())
        }</span>

        // parse error tempate
        <span class="cov3" title="5">m.errSessionFmts, err = parseLogTemplate(conf.Template.ErrSessionTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): ErrSessionTemplate %s", m.name, err.Error())
        }</span>

        <span class="cov3" title="5">return nil</span>
}

func (m *ModuleAccessPb) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var conf *ConfModAccessPb

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleAccessPb) init(conf *ConfModAccessPb, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov3" title="5">{
        var err error

        // parse config
        if err = m.ParseConfig(conf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): ParseConfig %s", m.name, err.Error())
        }</span>

        // check all log items in templates
        <span class="cov3" title="5">if err = m.CheckLogFormat(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): CheckLogFormat %s", m.name, err.Error())
        }</span>

        // init log agent
        <span class="cov3" title="5">m.logger, err = access_log.LoggerInitWithSvr("go-bfe", "access_pb",
                conf.Log.Network, conf.Log.LogServerAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): create logger", m.name)
        }</span>

        // register handler
        // for finish request
        <span class="cov3" title="5">err = cbs.AddFilter(bfe_module.HANDLE_REQUEST_FINISH, m.requestFinish)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.requestFinish): %s", m.name, err.Error())
        }</span>
        // for session
        <span class="cov3" title="5">err = cbs.AddFilter(bfe_module.HANDLE_FINISH, m.sessionFinish)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.sessionFinish): %s", m.name, err.Error())
        }</span>

        // save conf pointer
        <span class="cov3" title="5">m.conf = conf

        return nil</span>
}

func (m *ModuleAccessPb) CheckLogFormat() error <span class="cov3" title="5">{
        // log format item should in right template
        // otherwise, during runtime interface type will not match and panic.
        for _, item := range m.reqFmts </span><span class="cov8" title="182">{
                domain, found := fmtItemDomainTable[item.Type]
                if !found </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>

                <span class="cov8" title="182">if domain != DOMAIN_ALL &amp;&amp; domain != REQUEST </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) should not in request finish log",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>
        }

        <span class="cov3" title="5">for _, item := range m.errReqFmts </span><span class="cov8" title="220">{
                domain, found := fmtItemDomainTable[item.Type]
                if !found </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>

                <span class="cov8" title="220">if domain != DOMAIN_ALL &amp;&amp; domain != REQUEST </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) should not in request finish log",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>
        }

        <span class="cov3" title="5">for _, item := range m.sessionFmts </span><span class="cov6" title="45">{
                domain, found := fmtItemDomainTable[item.Type]
                if !found </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>

                <span class="cov6" title="45">if domain != DOMAIN_ALL &amp;&amp; domain != SESSION </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) should not in session finish log",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>
        }

        <span class="cov3" title="5">for _, item := range m.errSessionFmts </span><span class="cov6" title="45">{
                domain, found := fmtItemDomainTable[item.Type]
                if !found </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) not configured in domain table",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>

                <span class="cov6" title="45">if domain != DOMAIN_ALL &amp;&amp; domain != SESSION </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("type : (%d, %s) should not in session finish log",
                                item.Type, item.Key)
                        return errors.New(msg)
                }</span>
        }

        <span class="cov3" title="5">return nil</span>
}

// write pb message as b2log format
func (m *ModuleAccessPb) WriteB2LogMessage(message *bfe_access_pb.BaiduLog) error <span class="cov2" title="4">{
        msize := message.Size()
        buf, err := log4go.NewBuffer(24 + msize) // 16 bytes for header + 8 bytes header
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("WriteB2LogMessage log4go.NewBuffer return err [%s]", err)
                return err
        }</span>

        <span class="cov2" title="4">header := MakeB2LogHeader(uint32(msize))

        // marshal header to buf
        binary.LittleEndian.PutUint32(buf[0:4], header.Magic)
        binary.LittleEndian.PutUint32(buf[4:8], header.Version)
        binary.LittleEndian.PutUint32(buf[8:12], header.UncompressLen)
        binary.LittleEndian.PutUint32(buf[12:16], header.CompressLen)

        // marshal time to buf
        t := time.Now()
        sec := t.Unix()
        usec := t.Nanosecond() / 1000
        ts := sec*1000 + int64(usec)/1000

        binary.LittleEndian.PutUint64(buf[16:24], uint64(ts))

        // marshal pb message to buf
        n, err := message.MarshalTo(buf[24:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // get binary log
        <span class="cov2" title="4">b2logMessage := buf[:24+n]

        // write binary log
        m.logger.Info(b2logMessage)

        return nil</span>
}

//----------------------------------------------------------------------------------------------------------
// parse log format template

// get token in format table
// return format type, end of token, and error
func tokenTypeGet(templatePtr *string, offset int) (int, int, error) <span class="cov3" title="8">{
        templateLen := len(*templatePtr)

        for key, logItemType := range fmtTable </span><span class="cov8" title="243">{
                n := len(key)
                if offset+n &gt; templateLen </span><span class="cov8" title="163">{
                        continue</span>
                }

                <span class="cov7" title="80">if key == (*templatePtr)[offset:(offset+n)] </span><span class="cov3" title="8">{
                        return logItemType, offset + n - 1, nil
                }</span>
        }

        // not found
        <span class="cov0" title="0">return -1, -1, errors.New("no such log item format type : " + *templatePtr)</span>
}

// parse template token in "{}"
func parseBracketToken(templatePtr *string, offset int) (LogFmtItem, int, error) <span class="cov1" title="1">{
        length := len(*templatePtr)

        // find the closing '}'
        var endOfBracket int
        for endOfBracket = offset + 1; endOfBracket &lt; length; endOfBracket++ </span><span class="cov3" title="6">{
                if (*templatePtr)[endOfBracket] == '}' </span><span class="cov1" title="1">{
                        break</span>
                }
        }

        // if no '}' exists
        <span class="cov1" title="1">if endOfBracket &gt;= length </span><span class="cov0" title="0">{
                msg := "log format: { must be terminated by a }"
                return LogFmtItem{}, -1, errors.New(msg)
        }</span>

        // is empty string after '}'
        <span class="cov1" title="1">if endOfBracket == (length - 1) </span><span class="cov0" title="0">{
                msg := "log format: } must followed a charactor"
                return LogFmtItem{}, -1, errors.New(msg)
        }</span>

        // the key in "{}"
        <span class="cov1" title="1">key := (*templatePtr)[offset+1 : endOfBracket]

        // find type
        logItemType, end, err := tokenTypeGet(templatePtr, endOfBracket+1)
        if err != nil </span><span class="cov0" title="0">{
                return LogFmtItem{}, -1, err
        }</span>

        <span class="cov1" title="1">return LogFmtItem{key, logItemType}, end, nil</span>
}

// parse logTemplate from config file
func parseLogTemplate(logTemplate string) ([]LogFmtItem, error) <span class="cov5" title="20">{
        reqFmts := []LogFmtItem{}
        var token string

        logTemplate = strings.TrimSpace(logTemplate)

        // check if all fileds needed.
        if logTemplate == "all_req_items" </span><span class="cov4" title="9">{
                for _, logItemType := range fmtTable </span><span class="cov9" title="468">{
                        if fmtItemDomainTable[logItemType] == SESSION </span><span class="cov7" title="72">{
                                continue</span>
                        }
                        <span class="cov9" title="396">item := LogFmtItem{"", logItemType} // logItem.Key is not used in mod_access_pb
                        reqFmts = append(reqFmts, item)</span>
                }
                <span class="cov4" title="9">return reqFmts, nil</span>
        }

        // check if all fileds needed.
        <span class="cov4" title="11">if logTemplate == "all_ses_items" </span><span class="cov4" title="10">{
                for _, logItemType := range fmtTable </span><span class="cov10" title="520">{
                        if fmtItemDomainTable[logItemType] == REQUEST </span><span class="cov9" title="430">{
                                continue</span>
                        }
                        <span class="cov7" title="90">item := LogFmtItem{"", logItemType} // logItem.Key is not used in mod_access_pb
                        reqFmts = append(reqFmts, item)</span>
                }
                <span class="cov4" title="10">return reqFmts, nil</span>
        }

        // items in template string are seperated by ","
        <span class="cov1" title="1">tokens := strings.Split(logTemplate, ",")

        for n := 0; n &lt; len(tokens); n++ </span><span class="cov3" title="6">{
                tokenLen := len(tokens[n])
                for i := 0; i &lt; tokenLen; i++ </span><span class="cov3" title="6">{
                        if tokens[n][i] == '%' </span><span class="cov3" title="6">{
                                if (i + 1) == tokenLen </span><span class="cov0" title="0">{
                                        msg := "log format: % must followed with a charactor"
                                        return nil, errors.New(msg)
                                }</span>

                                <span class="cov3" title="6">if tokens[n][i+1] == '{' </span><span class="cov1" title="1">{
                                        item, _, err := parseBracketToken(&amp;tokens[n], i+1)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        // add item to reqFmts
                                        <span class="cov1" title="1">reqFmts = append(reqFmts, item)
                                        break</span>
                                } <span class="cov3" title="5">else {
                                        // normal log formate
                                        logItemType, end, err := tokenTypeGet(&amp;tokens[n], i+1)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>

                                        <span class="cov3" title="5">token = tokens[n][(i + 1) : end+1]
                                        item := LogFmtItem{token, logItemType}
                                        reqFmts = append(reqFmts, item)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov1" title="1">return reqFmts, nil</span>
}

//-----------------------------------------------------------------------------------------------------
// log item handlers

func bytesToUint32(ipBytes []byte) (uint32, error) <span class="cov2" title="4">{
        if len(ipBytes) != 4 </span><span class="cov2" title="4">{
                msg := fmt.Sprintf("ip bytes len error: %d", len(ipBytes))
                return 0, errors.New(msg)
        }</span>

        <span class="cov0" title="0">var ipNum uint32
        var tmp uint32

        for i, b := range ipBytes </span><span class="cov0" title="0">{
                tmp = uint32(b)
                ipNum = ipNum | (tmp &lt;&lt; uint((3-i)*8))
        }</span>

        <span class="cov0" title="0">return ipNum, nil</span>
}

// FORMAT_HOST
// here host is not a hostname. It means the client ip.
func onLogFmtHost(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        //host is used as client ip
        <span class="cov1" title="2">clientIp := req.RemoteAddr.IP.To4()
        ip, err := bytesToUint32(clientIp)
        if err == nil </span><span class="cov0" title="0">{
                pbMsg.Host = proto.Uint32(ip)
        }</span>

        <span class="cov1" title="2">return nil</span>
}

// FORMAT_SRV_IP
func onLogFmtSrvIp(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Connection == nil </span><span class="cov1" title="1">{
                return errors.New("req.Connection is nil")
        }</span>

        // BFE server ip
        <span class="cov0" title="0">localIp := req.Connection.LocalAddr().(*net.TCPAddr).IP.To4()
        ip, err := bytesToUint32(localIp)
        if err == nil </span><span class="cov0" title="0">{
                pbMsg.SrvIp = proto.Uint32(ip)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FORMAT_VIP
func onLogFmtVip(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Session.Vip != nil </span><span class="cov0" title="0">{
                vip, err := bytesToUint32(req.Session.Vip)
                if err == nil </span><span class="cov0" title="0">{
                        pbMsg.VipStr = proto.Uint32(vip)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_FEATURE_CODE
func onLogFmtFeatureCode(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        //buff.WriteString("FORMAT_FEATURE_CODE")  // used by BDS

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_ACTION_CODE
func onLogFmtActionCode(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        //buff.WriteString("FORMAT_ACTION_CODE")  // used by BDS

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_INNOCENT_TAG
func onLogFmtInnocentTag(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        //buff.WriteString("0 OR 1")  // Is IP in white list

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_SERVICE_TAG
func onLogFmtServiceTag(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        //buff.WriteString("FORMAT_SERVICE_TAG")  // used by BDS

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_WAF_SPENT_TIME
func onLogFmtWafSpentTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.WafSpentTime = proto.Uint32(uint32(req.Stat.WafSpentTime))

        return nil</span>
}

// FORMAT_WAF_STATUS
func onLogFmtWafStatus(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">wafStatus := proto.Int32(int32(req.Stat.WafStatus))
        pbMsg.WafStatus = (*bfe_access_pb.WafStatus)(wafStatus)

        return nil</span>
}

// FORMAT_TIME
func onLogFmtTime(m *ModuleAccessPb, pbMsg *bfe_access_pb.BaiduLog) error <span class="cov1" title="2">{
        if pbMsg == nil </span><span class="cov0" title="0">{
                return errors.New("pb message is nil")
        }</span>

        <span class="cov1" title="2">now := time.Now()
        pbMsg.Timestamp = proto.Uint64(uint64(now.Unix()))

        return nil</span>
}

// FORMAT_CONTENT_TYPE
func onLogFmtContentType(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if res == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">if values, found := res.Header["Content-Type"]; found </span><span class="cov0" title="0">{
                data := strings.Join(values, ",")
                pbMsg.ContentType = proto.String(data)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_BAIDUID
func onLogFmtBaiduid(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="2">if res == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="2">if req.BaiduidHex != nil </span><span class="cov0" title="0">{
                // used baiduid in request
                pbMsg.BaiduidByte = req.BaiduidHex
                pbMsg.BaiduIdHasFlag = proto.Bool(req.BaiduidHasFlag)
        }</span> <span class="cov1" title="2">else {
                // try convert BAIDUID to hex
                hex, flag, err := baidu_id.BaiduIDStrToHex(req.Baiduid)
                if err != nil </span><span class="cov1" title="2">{
                        // convert failed, using raw string
                        pbMsg.BaiduidStr = proto.String(req.Baiduid)
                }</span> <span class="cov0" title="0">else {
                        // convert success, using hex baiduid
                        req.BaiduidHex = hex
                        req.BaiduidHasFlag = flag
                        pbMsg.BaiduidByte = hex
                        pbMsg.BaiduIdHasFlag = proto.Bool(flag)
                }</span>
        }

        <span class="cov1" title="2">return nil</span>
}

// FORMAT_BDUSS
func onLogFmtBduss(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        // get BDUSS from http request
        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">cookie, err := req.HttpRequest.Cookie("BDUSS")
        if err == nil </span><span class="cov0" title="0">{
                pbMsg.Bduss = proto.String(cookie.Value)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_COOKIE
func onLogFmtCookie(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
        return nil
}</span>

// FORMAT_URI
func onLogFmtUri(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.Uri = proto.String(req.HttpRequest.URL.String())

        return nil</span>
}

// FORMAT_CLIENT_READ_TIME
func onLogFmtClientReadTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">ms := req.Stat.ReadReqEnd.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
        pbMsg.ReadClientTime = proto.Uint32(uint32(ms))

        return nil</span>
}

// FORMAT_SERVICE_ALL_TIME
func onLogFmtServiceAllTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">now := time.Now()
        ms := now.Sub(req.Stat.ReadReqStart).Nanoseconds() / 1000000
        pbMsg.AllTime = proto.Uint32(uint32(ms)) // also used by FORMAT_SES_ALL_TIME

        return nil</span>
}

// FORMAT_CONNECT_SRV_TIME
func onLogFmtConnectSrvTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">ms := req.Stat.ClusterEnd.Sub(req.Stat.ClusterStart).Nanoseconds() / 1000000
        pbMsg.ConnectServerTime = proto.Uint32(uint32(ms))

        return nil</span>
}

// FORMAT_WRITE_SRV_TIME
func onLogFmtWriteSrvTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">ms := req.Stat.BackendEnd.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
        pbMsg.WriteServerTime = proto.Uint32(uint32(ms))

        return nil</span>
}

// FORMAT_READWRITE_SRV_TIME
func onLogFmtReadWriteSrvTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">now := time.Now()
        ms := now.Sub(req.Stat.BackendStart).Nanoseconds() / 1000000
        pbMsg.ReadServerTime = proto.Uint32(uint32(ms))

        return nil</span>
}

// FORMAT_IN_HEADER_LEN
func onLogFmtInHeaderLen(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.ReqHeaderLen = proto.Uint64(uint64(req.Stat.HeaderLenIn))

        return nil</span>
}

// FORMAT_IN_BODY_LEN
func onLogFmtInBodyLen(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.ReqBodyLen = proto.Uint64(uint64(req.Stat.BodyLenIn))

        return nil</span>
}

// FORMAT_OUT_HEADER_LEN
func onLogFmtOutHeaderLen(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.Stat == nil </span><span class="cov0" title="0">{
                return errors.New("req.Stat is nil")
        }</span>

        <span class="cov1" title="1">if res != nil </span><span class="cov1" title="1">{
                pbMsg.ResHeaderLen = proto.Uint64(uint64(req.Stat.HeaderLenOut))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_OUT_BODY_LEN
func onLogFmtBodyLenOut(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if res != nil </span><span class="cov1" title="1">{
                pbMsg.ResBodyLen = proto.Uint64(uint64(req.Stat.BodyLenOut))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_STATUS_CODE
func onLogFmtOutStatus(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if res != nil </span><span class="cov1" title="1">{
                pbMsg.OutStatus = proto.Uint32(uint32(res.StatusCode))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_SRV_CLUSTER_NAME
func onLogFmtServiceName(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        //buff.WriteString(req.Backend.ClusterName)
        <span class="cov1" title="1">pbMsg.ServerName = proto.String(req.Backend.ClusterName)

        return nil</span>
}

// FORMAT_SUB_CLUSTER_NAME
func onLogFmtSubClusterName(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        //buff.WriteString(req.Backend.SubclusterName)
        <span class="cov1" title="1">pbMsg.ClusterName = proto.String(req.Backend.SubclusterName)

        return nil</span>
}

// FORMAT_MEMCACHED_STATUS
func onLogFmtMemCachedStatus(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        /*cache_stat := 0
          switch cache_stat {
              case 0:
                  buff.WriteString("no_cache")
              case 1:
                  buff.WriteString("cache_hit_local")
              case 2:
                  buff.WriteString("cache_hit_global")
              case 3:
                  buff.WriteString("cache_miss")
              default:
                  buff.WriteString("-")
          }
        */

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_LOGID
func onLogFmtLogId(m *ModuleAccessPb, logid uint64, pbMsg *bfe_access_pb.BaiduLog) error <span class="cov1" title="2">{
        if pbMsg == nil </span><span class="cov0" title="0">{
                return errors.New("pb message is nil")
        }</span>

        <span class="cov1" title="2">pbMsg.Logid = proto.Uint64(logid)

        return nil</span>
}

// FORMAT_CACHE_KEY
func onLogFmtCacheKey(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        //buff.WriteString("sub_ptr-&gt;cache_key")

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_PAGE_NUM
func onLogFmtPageNum(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        //buff.WriteString("sub_ptr-&gt;pn")

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_FIRST_LINE
func onLogFmtFirstLine(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        //buff.WriteString("sub_ptr-&gt;first_line_back")

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_BWS_TIME
func onLogFmtBwsTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        //snprintf(buf, sizeof(buf), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
        //                    t2.tm_mday, month_snames[t2.tm_mon], t2.tm_year + 1900,
        //                    t2.tm_hour, t2.tm_min, t2.tm_sec,
        //                    sign, timz / 60, timz % 60);
        //buff.WriteString("FORMAT_BWS_TIME")

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_HEADER_HOST
func onLogFmtHeaderHost(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.HeaderHost = proto.String(req.HttpRequest.Host)

        return nil</span>
}

// FORMAT_REFERER
func onLogFmtReferer(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">values, found := req.HttpRequest.Header["Referer"]
        if !found </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">data := strings.Join(values, ",")
        pbMsg.Referrer = proto.String(data)

        return nil</span>
}

// FORMAT_HEADER_CLIENTIP
func onLogFmtHeaderClientIp(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">values, found := req.HttpRequest.Header["CLIENTIP"]
        if !found </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">data := strings.Join(values, ",")
        pbMsg.HeaderClientip = proto.String(data)

        return nil</span>
}

// FORMAT_USERAGENT
func onLogFmtUserAgent(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">values, found := req.HttpRequest.Header["User-Agent"]
        if !found </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">data := strings.Join(values, ",")
        pbMsg.UserAgent = proto.String(data)

        return nil</span>
}

// FORMAT_X_FORWARD_FOR
func onLogFmtXForwardFor(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="2">values, found := req.HttpRequest.Header["X-Forwarded-For"]
        if !found </span><span class="cov1" title="2">{
                return nil
        }</span>

        <span class="cov0" title="0">data := strings.Join(values, ",")
        pbMsg.XForwardFor = proto.String(data)

        return nil</span>
}

// FORMAT_SHIFEN
func onLogFmtShifen(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">if strings.HasSuffix(req.Route.HostTag, "shifen.com") </span><span class="cov0" title="0">{
                pbMsg.Shifen = proto.String(req.Route.HostTag)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// FORMAT_SHIFEN
func onLogFmtErrString(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="1">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.ErrorString = proto.String(req.ErrMsg)

        return nil</span>
}

// FORMAT_ACCEPT_LANGUAGE
func onLogFmtAcceptLanguage(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="2">values, found := req.HttpRequest.Header["Accept-Language"]
        if !found </span><span class="cov1" title="2">{
                return nil
        }</span>

        <span class="cov0" title="0">data := strings.Join(values, ",")
        pbMsg.AcceptLanguage = proto.String(data)

        return nil</span>
}

// FORMAT_AUTHORIZATION
func onLogFmtAuthorization(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov1" title="2">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>
        <span class="cov1" title="2">if req.HttpRequest == nil </span><span class="cov0" title="0">{
                return errors.New("req.HttpRequest is nil")
        }</span>

        <span class="cov1" title="2">values, found := req.HttpRequest.Header["Authorization"]
        if !found </span><span class="cov1" title="2">{
                return nil
        }</span>

        <span class="cov0" title="0">data := strings.Join(values, ",")
        pbMsg.Authorization = proto.String(data)

        return nil</span>
}

//FORMAT_SES_START_TIME
func onLogFmtSesStartTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov1" title="2">ms := session.StartTime.UnixNano() / 1000000
        pbMsg.SesStartTime = proto.Uint64(uint64(ms))

        return nil</span>
}

// FORMAT_SES_ALL_TIME
func onLogFmtSesAllTime(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov1" title="2">ms := session.EndTime.Sub(session.StartTime).Nanoseconds() / 1000000
        pbMsg.AllTime = proto.Uint32(uint32(ms)) // this field is also used in FORMAT_SERVICE_ALL_TIME

        return nil</span>
}

//FORMAT_SES_CLIENT_IP
func onLogFmtSesClientIP(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>
        //host is used as client ip
        <span class="cov1" title="2">clientIp := session.RemoteAddr.IP.To4()
        ip, err := bytesToUint32(clientIp)
        if err == nil </span><span class="cov0" title="0">{
                pbMsg.Host = proto.Uint32(ip) // also used in FORMAT_HOST
        }</span>

        <span class="cov1" title="2">return nil</span>
}

//FORMAT_BFE_IP
func onLogFmtBfeIP(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>
        <span class="cov1" title="2">if session.Connection == nil </span><span class="cov1" title="2">{
                return errors.New("session.Connection is nil")
        }</span>

        // BFE server ip
        <span class="cov0" title="0">localIp := session.Connection.LocalAddr().(*net.TCPAddr).IP.To4()
        ip, err := bytesToUint32(localIp)
        if err == nil </span><span class="cov0" title="0">{
                pbMsg.SrvIp = proto.Uint32(ip) // also used in FORMAT_SRV_IP
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FORMAT_KEEPALIVE_NUM
func onLogFmtKeepAliveNum(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov1" title="2">pbMsg.KeepaliveNum = proto.Uint32(uint32(session.ReqNum))

        return nil</span>
}

// FORMAT_SES_READ_TOTAL
func onLogFmtSesReadTotal(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>
        // total bytes read from client socket
        <span class="cov1" title="2">pbMsg.ReadLen = proto.Uint64(uint64(session.ReadTotal))

        return nil</span>
}

//FORMAT_SES_WRITE_TOTAL
func onLogFmtSesWriteTotal(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>
        // total bytes write to client socket
        <span class="cov1" title="2">pbMsg.WriteLen = proto.Uint64(uint64(session.WriteTotal))

        return nil</span>
}

// FORMATE_TCP_INFO
func onLogFmtFlowInfo(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="2">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>
        <span class="cov1" title="2">if session.FlowInfo == nil </span><span class="cov1" title="1">{
                return errors.New("session.FlowInfo is nil")
        }</span>
        <span class="cov1" title="1">tcpWiseInfoLen := len(session.FlowInfo.AllTcpWiseInfo)
        // tcp wise info number must &gt;= 2, because the first tcp wise info is empty
        if len(session.FlowInfo.AllTcpWiseInfo) &lt; 2 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">tcpFlowinfo := new(bfe_access_pb.TcpFlowInfo)
        // initial cwnd
        initialCwnd := session.FlowInfo.InitialCwnd
        tcpFlowinfo.InitialCwnd = proto.Uint32(initialCwnd)

        // set tcpLatencyInfo, start from the first one tcp wise info struct
        for i := 1; i &lt; tcpWiseInfoLen; i++ </span><span class="cov0" title="0">{
                tcpLatencyInfo := new(bfe_access_pb.TcpLatencyInfo)
                tcpLatencyInfo.Latency = proto.Uint32(session.FlowInfo.AllTcpWiseInfo[i].Latency)
                tcpLatencyInfo.TransDataSize = proto.Uint32(session.FlowInfo.AllTcpWiseInfo[i].TransDataSize)
                tcpLatencyInfo.LastTimeOut = proto.Uint32(session.FlowInfo.AllTcpWiseInfo[i].LastTimeOut)
                tcpLatencyInfo.AvgCwnd = proto.Uint32(session.FlowInfo.AllTcpWiseInfo[i].AvgCwnd)
                tcpFlowinfo.TcpLatencyInfo = append(tcpFlowinfo.TcpLatencyInfo, tcpLatencyInfo)
        }</span>

        <span class="cov0" title="0">lastTcpWiseInfo := session.FlowInfo.AllTcpWiseInfo[tcpWiseInfoLen-1]
    if lastTcpWiseInfo.TotalTrans == 0 </span><span class="cov0" title="0">{
        tcpFlowinfo.RetransmissionRate = proto.Float32(0.0)
    }</span> <span class="cov0" title="0">else {
        tcpFlowinfo.RetransmissionRate = proto.Float32(float32(lastTcpWiseInfo.TotalRetrans) * 100 / float32(lastTcpWiseInfo.TotalTrans))
    }</span>
        <span class="cov0" title="0">tcpFlowinfo.Mss = proto.Uint32(lastTcpWiseInfo.Mss)
        tcpFlowinfo.Rtt = proto.Uint32(lastTcpWiseInfo.Rtt)
        tcpFlowinfo.Rttvar = proto.Uint32(lastTcpWiseInfo.Rttvar)
        tcpFlowinfo.ClientInitRwnd = proto.Uint32(lastTcpWiseInfo.ClientInitRwnd)
        tcpFlowinfo.ClientMaxRwnd = proto.Uint32(lastTcpWiseInfo.ClientMaxRwnd)

        pbMsg.TcpFlowInfo = tcpFlowinfo
        return nil</span>
}

// FORMATE_ERROR_CODE_REQ
func onLogFmtErrorCode(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        req *bfe_basic.Request, res *bfe_http.Response) error <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return errors.New("req is nil")
        }</span>

        <span class="cov0" title="0">pbMsg.ErrorString = proto.String(req.ErrCode.Error())

        return nil</span>
}

// FORMATE_ERROR_CODE_SES
func onLogFmtSesErrorCode(m *ModuleAccessPb, logItem *LogFmtItem, pbMsg *bfe_access_pb.BaiduLog,
        session *bfe_basic.Session) error <span class="cov1" title="1">{
        if session == nil </span><span class="cov0" title="0">{
                return errors.New("session is nil")
        }</span>

        <span class="cov1" title="1">pbMsg.ErrorString = proto.String(session.ErrCode.Error())

        return nil</span>
}

//------------------------------------------------------------------------------------------------
// module call backs

// handler for finish http request
func (m *ModuleAccessPb) requestFinish(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov1" title="2">{
        var fmtItems []LogFmtItem
        pbMessage := &amp;bfe_access_pb.BaiduLog{}

        if req.ErrCode == nil </span><span class="cov1" title="2">{
                fmtItems = m.reqFmts
        }</span> <span class="cov0" title="0">else {
                fmtItems = m.errReqFmts
        }</span>

        // product ID :  BFE
        <span class="cov1" title="2">productID := proto.Int32(int32(bfe_access_pb.ProductID_BFE))
        pbMessage.Product = (*bfe_access_pb.ProductID)(productID)

        // set log type
        if req.ErrCode == nil </span><span class="cov1" title="2">{
                logType := proto.Int32(int32(bfe_access_pb.BfeLogType_BfeCompleteLog))
                pbMessage.BfeLogType = (*bfe_access_pb.BfeLogType)(logType)
        }</span> <span class="cov0" title="0">else {
                //if ErrCode is time_out use BfeLogType_BfeTimeoutLog
                logType := proto.Int32(int32(bfe_access_pb.BfeLogType_BfeWrongLog))
                pbMessage.BfeLogType = (*bfe_access_pb.BfeLogType)(logType)
        }</span>

    <span class="cov1" title="2">outputLogType := proto.Int32(int32(bfe_access_pb.OutputLogType_RequestLog))
    pbMessage.OutputLogType = (*bfe_access_pb.OutputLogType)(outputLogType)

        // insert log data into pb message
        for _, item := range fmtItems </span><span class="cov6" title="50">{
                if item.Type == FORMAT_LOGID </span><span class="cov1" title="1">{
                        onLogFmtLogId(m, req.LogId, pbMessage)
                }</span> <span class="cov6" title="49">else if item.Type == FORMAT_TIME </span><span class="cov1" title="1">{
                        onLogFmtTime(m, pbMessage)
                }</span> <span class="cov6" title="48">else {
                        handler, found := fmtHandlerTable[item.Type]
                        if found </span><span class="cov6" title="46">{
                                h := handler.(func(*ModuleAccessPb, *LogFmtItem, *bfe_access_pb.BaiduLog,
                                        *bfe_basic.Request, *bfe_http.Response) error)
                                h(m, &amp;item, pbMessage, req, res)
                        }</span>
                }
        }

        // set LogTag
        <span class="cov1" title="2">pbMessage.LogTag = proto.String(req.Backend.ClusterName)
        // write pb message to file
        m.WriteB2LogMessage(pbMessage)

        return bfe_module.BFE_HANDLER_GOON</span>
}

// handler for finish http connection
func (m *ModuleAccessPb) sessionFinish(session *bfe_basic.Session) int <span class="cov1" title="1">{
        var fmtItems []LogFmtItem
        pbMessage := &amp;bfe_access_pb.BaiduLog{}

        // normal finish
        if session.ErrCode == nil </span><span class="cov0" title="0">{
                fmtItems = m.sessionFmts
        }</span> <span class="cov1" title="1">else {
                fmtItems = m.errSessionFmts
        }</span>

        // product ID :  BFE
        <span class="cov1" title="1">productID := proto.Int32(int32(bfe_access_pb.ProductID_BFE))
        pbMessage.Product = (*bfe_access_pb.ProductID)(productID)

        // set log type
        if session.ErrCode == nil </span><span class="cov0" title="0">{
                logType := proto.Int32(int32(bfe_access_pb.BfeLogType_BfeCompleteLog))
                pbMessage.BfeLogType = (*bfe_access_pb.BfeLogType)(logType)
        }</span> <span class="cov1" title="1">else {
                logType := proto.Int32(int32(bfe_access_pb.BfeLogType_BfeWrongLog))
                pbMessage.BfeLogType = (*bfe_access_pb.BfeLogType)(logType)
        }</span>

    <span class="cov1" title="1">outputLogType := proto.Int32(int32(bfe_access_pb.OutputLogType_SessionLog))
    pbMessage.OutputLogType = (*bfe_access_pb.OutputLogType)(outputLogType)

        // insert log data into pb message
        for _, item := range fmtItems </span><span class="cov4" title="9">{
                if item.Type == FORMAT_TIME </span><span class="cov1" title="1">{
                        onLogFmtTime(m, pbMessage)
                }</span> <span class="cov3" title="8">else {
                        handler, found := fmtHandlerTable[item.Type]
                        if found </span><span class="cov3" title="8">{
                                //println("item", item.Key, item.Type)
                                h := handler.(func(*ModuleAccessPb, *LogFmtItem, *bfe_access_pb.BaiduLog,
                                        *bfe_basic.Session) error)
                                h(m, &amp;item, pbMessage, session)
                        }</span>
                }
        }

        // logid is required in pb message
        <span class="cov1" title="1">onLogFmtLogId(m, 0, pbMessage)

        // write pb message to file
        m.WriteB2LogMessage(pbMessage)

        return bfe_module.BFE_HANDLER_GOON</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/* anti_tlsdos_conf_load.go - load anti_tlsdos_config from json file */
/*
modification history
--------------------
2015/6/15, by Xiong Zongtao, create
*/
/*
DESCRIPTION
*/

package mod_anti_tlsdos

import (
        "encoding/json"
        "encoding/hex"
        "fmt"
        "os"        
)

import (
        "www.baidu.com/golang-lib/hash_set"
)

const (
        CLIENT_HELLO_RANDOM_LEN = 28 // skip first 4 bytes unix time
)

type RandomItem struct {
        Name   string
        Random string
}

//raw data directly read from file
type AntiTlsDosConfDataRaw struct {
        Version                    string
        DosRandom []RandomItem
}

type AntiTlsDosConfData struct {
        version                  string
        dosRandom    *hash_set.HashSet
}

// load config from config file
func AntiTlsDosConfDataLoad(filePath string) (*AntiTlsDosConfData, error) <span class="cov7" title="6">{
    var confRaw   AntiTlsDosConfDataRaw
        var confData *AntiTlsDosConfData

    /* open the config file */
    file, err := os.Open(filePath)
        defer file.Close()

    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    /* decode the file  */
    <span class="cov7" title="6">decoder := json.NewDecoder(file)
    err = decoder.Decode(&amp;confRaw)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

        <span class="cov7" title="6">confData, err = convertConfData(&amp;confRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="6">return confData, nil</span>
}

// from hex string to []byte
func convertRandom(randoms []RandomItem) (*hash_set.HashSet, error) <span class="cov7" title="6">{
        dosRandom, err:= hash_set.NewHashSet(len(randoms), CLIENT_HELLO_RANDOM_LEN, true, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
                                
        <span class="cov7" title="6">for _, v := range randoms </span><span class="cov10" title="12">{
                r, err := hex.DecodeString(v.Random)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Invalid random: %s", v.Random)
                }</span>

                <span class="cov10" title="12">if len(r) != CLIENT_HELLO_RANDOM_LEN </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Random's length is not valid: %x", r)
                }</span>

                <span class="cov10" title="12">dosRandom.Add(r)</span>
        }
        
        <span class="cov7" title="6">return dosRandom, nil</span>        
}

func convertConfData(confRaw *AntiTlsDosConfDataRaw) (*AntiTlsDosConfData, error) <span class="cov7" title="6">{
        var confData AntiTlsDosConfData

        //set version
        confData.version = confRaw.Version

        //convert random from hex string to []byte
        random, err := convertRandom(confRaw.DosRandom)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="6">confData.dosRandom = random

        return &amp;confData, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/* conf_mod_anti_tlsdos.go - config for mod_anti_tlsdos */
/*
modification history
--------------------
2015/6/15, by Xiong Zongtao, created.
*/
/*
DESCRIPTION
*/
package mod_anti_tlsdos

import (
        "fmt"
)

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfModAntiTlsDos struct {
    Basic struct {
        DataPath    string      // path of config data (rewrite)
    }

        Counter struct {
                // counter for lastest "CounterInterval" seconds
                CounterInterval            int64

                // lru cache size
                FailHandshakeCacheSize     int
                FullHandshakeCacheSize     int
        }

        //threshold for counter
        Thresh struct{
                EccCgoThresh           int64
                FailHandshakeThresh    int64
                FullHandshakeThresh    int64
        }

        //dump tls handshake info in ratio Ratio/Base
        Dump struct {
                Base      int
                Ratio     int
        }
        
        Log struct {
                OpenDebug bool
        }
}


/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModAntiTlsDos, error) <span class="cov10" title="6">{
    var err error
    var cfg ConfModAntiTlsDos

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_anti_tlsdos.go
    <span class="cov10" title="6">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="6">return &amp;cfg, nil</span>
}


func (cfg *ConfModAntiTlsDos) Check(confRoot string) error <span class="cov10" title="6">{
    return ConfModAntiTlsDosCheck(cfg, confRoot)
}</span>

func ConfModAntiTlsDosCheck(cfg *ConfModAntiTlsDos, confRoot string) error <span class="cov10" title="6">{
    if cfg.Basic.DataPath == "" </span><span class="cov0" title="0">{
        log.Logger.Warn("ModAntiTlsDos.DataPath not set, use default value")
        cfg.Basic.DataPath = "mod_anti_tlsdos/mod_anti_tlsdos.data"
    }</span>
    
    <span class="cov10" title="6">cfg.Basic.DataPath = conf_path.ConfPathProc(cfg.Basic.DataPath, confRoot)

        if err := checkCounter(cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">if err := checkThreshParam(cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">if err := checkDumpParam(cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov10" title="6">return nil</span>
}

func checkCounter(cfg *ConfModAntiTlsDos) error <span class="cov10" title="6">{
        if cfg.Counter.CounterInterval &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("counter interval should be greater than 0")
        }</span>

        <span class="cov10" title="6">if cfg.Counter.FailHandshakeCacheSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("FailHandshakeCacheSize should be greater than 0")
        }</span>

        <span class="cov10" title="6">if cfg.Counter.FullHandshakeCacheSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("FullHandshakeCacheSize should be greater than 0")
        }</span>
        <span class="cov10" title="6">return nil</span>
}

func checkThreshParam(cfg *ConfModAntiTlsDos) error <span class="cov10" title="6">{
        if cfg.Thresh.EccCgoThresh &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("eccCgoThresh should be greater than 0") 
        }</span>

        <span class="cov10" title="6">if cfg.Thresh.FailHandshakeThresh &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("FailHandshakeThresh should be greater than 0") 
        }</span>

        <span class="cov10" title="6">if cfg.Thresh.FullHandshakeThresh &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("FullHandshakeThresh should be greater than 0") 
        }</span>
        
        <span class="cov10" title="6">return nil</span>
}

func checkDumpParam(cfg *ConfModAntiTlsDos) error <span class="cov10" title="6">{
        if cfg.Dump.Base &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Base should be greater than 0")
        }</span>
        <span class="cov10" title="6">if cfg.Dump.Ratio &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Ratio should be greater than 0")
        }</span>
        <span class="cov10" title="6">if cfg.Dump.Ratio &gt; cfg.Dump.Base </span><span class="cov0" title="0">{
                return fmt.Errorf("Ratio should be less than Base")
        }</span>

        <span class="cov10" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/* mod_anti_dos.go - module for https anit-DOS */
/*
modification history
--------------------
2015/6/10, by Xiong Zongtao, create
*/
/*
DESCRIPTION
*/

package mod_anti_tlsdos

import (
    "fmt"
        "net/url"
        "sync"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/lru_cache"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_module"
        "bfe_tls"
        "bfe_util"
)

// log tag 
const (
        LOG_BUSY  = "Busy"  //ecc cgo is busy
        LOG_FAIL  = "Fail"        //tls handshake fail
    LOG_FULL  = "Full"  //tls handshake complete
)

var COUNTER_KEYS = []string {
        "DOS_RANDOM_HIT",   // number of client-hello random matches dos-random

        "ECC_CGO_BUSY",   // number of times ecc cgo compute is busy

        "RSA_CIPHER_SUITE",
        "ECDHE_CIPHER_SUITE",

        //log count
        "LOG_ECC_CGO_BUSY",   // number log send to logserver for ecc cgo busy
        "LOG_FULL_HANDSHAKE", // number log send to logserver for full handshake above threshold 
        "LOG_FAIL_HANDSHAKE", // number log send to logserver for fail handshake above threshold
        "LOG_ECC_CGO_BUSY_TOTAL",   // number log send to logserver for ecc cgo busy
        "LOG_FULL_HANDSHAKE_TOTAL", // number log send to logserver for full handshake above threshold 
        "LOG_FAIL_HANDSHAKE_TOTAL", // number log send to logserver for fail handshake above threshold
}

var (
    openDebug = false
)

type ModuleAntiTlsDos struct {
    name           string               // name of module
        configDataPath string               // config data path

    state  *module_state2.State         // module counter state

        eccCgoCounter  *bfe_util.RollingCounter  //count ecc cgo 
        rsaCounter     *bfe_util.RollingCounter  //count rsa (cgo and remote)

        //lru cache for failed handshake counter
        failHandshakeCounter *lru_cache.LRUCache
        failHandshakeLock     sync.Mutex

        //lru cache for full handshake counter
        fullHandshakeCounter *lru_cache.LRUCache
        fullHandshakeLock     sync.Mutex
        
        //probability generator at ratio N/M
        prob     *bfe_util.ProbGenerator

    conf     *ConfModAntiTlsDos       // anti-DOS config
        confData *AntiTlsDosConfData      // anti-Dos config Data
        confDataLock  sync.Mutex
}

func NewModuleAntiTlsDos() *ModuleAntiTlsDos <span class="cov2" title="5">{
    m := new(ModuleAntiTlsDos)
    m.name = "mod_anti_tlsdos"
    m.state = new(module_state2.State)
    
    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_ANTI_TLSDOS)
    
    return m
}</span>

func (m *ModuleAntiTlsDos) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModuleAntiTlsDos) Attr() map[string]interface{} <span class="cov0" title="0">{
        // reload items
    reloadEntries := []string {
        m.name,
    }

    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD : reloadEntries,
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>


// init a probability generator 
func (m *ModuleAntiTlsDos) createProbGenerator() <span class="cov2" title="5">{
        m.prob = bfe_util.NewProbGenerator(m.conf.Dump.Base, m.conf.Dump.Ratio)
}</span>

func (m *ModuleAntiTlsDos) createCounter() <span class="cov2" title="5">{
        inter := m.conf.Counter.CounterInterval

        //init cipher counter
        m.eccCgoCounter = bfe_util.NewRollingCounter(inter)
        m.rsaCounter    = bfe_util.NewRollingCounter(inter)

        //init lru cache, element of cache is RollingCounter
        size := m.conf.Counter.FailHandshakeCacheSize
        m.failHandshakeCounter = lru_cache.NewLRUCache(size)

        size = m.conf.Counter.FullHandshakeCacheSize
        m.fullHandshakeCounter = lru_cache.NewLRUCache(size)
}</span>

func (m *ModuleAntiTlsDos) isEccCgoBusy() bool <span class="cov4" title="20">{
        eccCgoThresh := m.conf.Thresh.EccCgoThresh
        return !m.eccCgoCounter.CheckAndInc(eccCgoThresh)
}</span>

// if given random match that fund in DOS; return true on match, 
// return false on don't match
func (m *ModuleAntiTlsDos) IsMatchDosRandom(random []byte) bool <span class="cov2" title="3">{
        // first 4 bytes in random is unix time, skip it
        if isMatch := m.confData.dosRandom.Exist(random[4:]); isMatch </span><span class="cov1" title="1">{
                m.state.Inc("DOS_RANDOM_HIT", 1)
                return true
        }</span>

        <span class="cov1" title="2">return false</span>
}

// count handshake from the same "ip", 
// if above thresh, return false, otherwise, true
func (m *ModuleAntiTlsDos) handshakeInc(c *lru_cache.LRUCache, lock *sync.Mutex, ip string, thresh int64) bool <span class="cov10" title="4020">{
    // get counter for specific IP
    value, ok := c.Get(ip)
    if !ok </span><span class="cov2" title="3">{
                lock.Lock()
                //double check
                value, ok = c.Get(ip)
                if !ok </span><span class="cov2" title="3">{
                        // insert new counter if not found
                        counter := bfe_util.NewRollingCounter(m.conf.Counter.CounterInterval)
                        counter.Inc()
                        c.Add(ip, counter)

                    lock.Unlock()
                        return true
                }</span>
                <span class="cov0" title="0">lock.Unlock()</span>
    }

    <span class="cov9" title="4017">counter := value.(*bfe_util.RollingCounter)

        return counter.IncAndCheck(thresh)</span>
}

func (m *ModuleAntiTlsDos) fullHandshakeInc(ip string) bool <span class="cov9" title="4010">{
        return m.handshakeInc(m.fullHandshakeCounter, 
                &amp;m.fullHandshakeLock, ip, m.conf.Thresh.FullHandshakeThresh)
}</span>

func (m *ModuleAntiTlsDos) failHandshakeInc(ip string) bool <span class="cov3" title="10">{
        return m.handshakeInc(m.failHandshakeCounter, 
                &amp;m.failHandshakeLock, ip, m.conf.Thresh.FailHandshakeThresh)
}</span>

func (m *ModuleAntiTlsDos) LogHandshakeInfo(hi *bfe_tls.HandshakeInfo) <span class="cov4" title="20">{
        //handshake failed
        if !hi.HandshakeComplete </span><span class="cov3" title="10">{
                if !m.failHandshakeInc(hi.ClientIp) </span><span class="cov3" title="7">{
                        //failed handshakes above threshold
                        m.sendToLogger(LOG_FAIL, hi)
                }</span>
        } <span class="cov3" title="10">else { //handshake successfull
                if !m.fullHandshakeInc(hi.ClientIp) </span><span class="cov2" title="6">{
                        //full handshake above threshold
                        m.sendToLogger(LOG_FULL, hi)
                }</span> 
        }

        <span class="cov4" title="20">thresh := m.conf.Thresh.EccCgoThresh
        if m.eccCgoCounter.Get() &gt;= thresh </span><span class="cov0" title="0">{ 
                // no more ecc can be computed
                m.sendToLogger(LOG_BUSY, hi)
        }</span>
}

func (m *ModuleAntiTlsDos) TryCipherSuite(preferenceList, supportedList []uint16, handshakeState interface{}) interface{} <span class="cov1" title="1">{
    for _, id := range preferenceList </span><span class="cov1" title="2">{
                suite := bfe_tls.TryCipherSuiteWrapper(id, supportedList, handshakeState)
                
                //ecdhe cipher suite
                if bfe_tls.IsEcdheCipherSuite(suite) </span><span class="cov0" title="0">{
                        if m.isEccCgoBusy() </span><span class="cov0" title="0">{
                                m.state.Inc("ECC_CGO_BUSY", 1)
                                continue</span>
                        }
                        <span class="cov0" title="0">m.state.Inc("ECDHE_CIPHER_SUITE", 1)</span>
                } <span class="cov1" title="2">else {
                        m.state.Inc("RSA_CIPHER_SUITE", 1)
                        m.rsaCounter.Inc()
                }</span>

                <span class="cov1" title="2">if suite != nil </span><span class="cov0" title="0">{
                        return suite
                }</span>
        }
        
        <span class="cov1" title="1">return nil</span>
}

func (m *ModuleAntiTlsDos) sendToLogger(tag string, hi *bfe_tls.HandshakeInfo) <span class="cov3" title="13">{
        var counters = map[string]string{
                LOG_FAIL:"LOG_FAIL_HANDSHAKE",
                LOG_FULL:"LOG_FULL_HANDSHAKE",
                LOG_BUSY:"LOG_ECC_CGO_BUSY",
        }
        var totalCounters = map[string]string{
                LOG_FAIL:"LOG_FAIL_HANDSHAKE_TOTAL",
                LOG_FULL:"LOG_FULL_HANDSHAKE_TOTAL",
                LOG_BUSY:"LOG_ECC_CGO_BUSY_TOTAL",
        }
        
        m.state.Inc(totalCounters[tag], 1)
        if m.prob.IsHit() </span><span class="cov3" title="13">{
                str := fmt.Sprintf("[%s]ip:%s clientHello:%x", tag, hi.ClientIp, hi.ClientHello)
                log.Logger.Info(str)        
                m.state.Inc(counters[tag], 1)
        }</span>
}

// load from config file, also a registered reload callback
func (m *ModuleAntiTlsDos) loadConfData(query url.Values) error <span class="cov2" title="5">{
    // get file path
    path := query.Get("path")
    if path == "" </span><span class="cov2" title="5">{
        // use default
        path = m.configDataPath
    }</span>

    // load from config file
    <span class="cov2" title="5">confData, err := AntiTlsDosConfDataLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in AntiTlsDosConfDataLoad(%s):%s", path, err.Error())
    }</span>

    // update to configure data
    <span class="cov2" title="5">m.Update(confData)

    return nil</span>
}

func (m *ModuleAntiTlsDos) Update(confData *AntiTlsDosConfData) <span class="cov2" title="5">{
        m.confDataLock.Lock()
        defer m.confDataLock.Unlock()
        
        m.confData = confData
}</span>

func (m *ModuleAntiTlsDos) getState() *module_state2.StateData <span class="cov0" title="0">{
    return m.state.GetAll()
}</span>

func (m *ModuleAntiTlsDos) monitorHandlers() map[string]interface{} <span class="cov2" title="5">{
            handlers := map[string]interface{} {
        m.name: web_monitor.CreateStateDataHandler(m.getState),
    }
    return handlers
}</span>

func (m *ModuleAntiTlsDos) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                             cr string) error <span class="cov2" title="5">{
    var err error    
    var conf *ConfModAntiTlsDos
    
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>
        
        <span class="cov2" title="5">m.conf = conf

    return m.init(conf, cbs, whs)</span>
}

func (m *ModuleAntiTlsDos) init(cfg *ConfModAntiTlsDos, cbs *bfe_module.BfeCallbacks,
                             whs *web_monitor.WebHandlers) error <span class="cov2" title="5">{   
    openDebug = cfg.Log.OpenDebug

    m.configDataPath = cfg.Basic.DataPath
    
    // load from config file
    if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadConfData(): %s", err.Error())
    }</span>

        <span class="cov2" title="5">m.createCounter()
        m.createProbGenerator()

    // register https anti-DOS engine
    bfe_tls.SetAntiDosEngine(m)

        // register web handler for monitor
    err := web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>
    
    // register web handler for reload
    <span class="cov2" title="5">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfData)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
    }</span>

    <span class="cov2" title="5">return nil</span>
}

</pre>
		
		<pre class="file" id="file54" style="display: none">/* action.go - action for block */
/*
modification history
--------------------
2014/8/27, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_block

import (
        "errors"
        "fmt"
)

type ActionFile struct {
        Cmd    *string  // command of action
        Params []string // params of action
}

type Action struct {
        Cmd    string   // command of action
        Params []string // params of action
}

// check ActionFile
func ActionFileCheck(conf *ActionFile) error <span class="cov10" title="4">{
        var paramsLenCheck int

        // check command
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        // validate command, and get how many params should exist for each command
        <span class="cov10" title="4">switch *conf.Cmd </span>{
        <span class="cov10" title="4">case "CLOSE":
                paramsLenCheck = 0</span>
        <span class="cov0" title="0">default:
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        // check params
        <span class="cov10" title="4">if conf.Params == nil </span><span class="cov0" title="0">{
                return errors.New("no Params")
        }</span>

        <span class="cov10" title="4">if paramsLenCheck != -1 </span><span class="cov10" title="4">{
                paramsLen := len(conf.Params)
                if paramsLenCheck != paramsLen </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, paramsLen)
                }</span>
        }

        <span class="cov10" title="4">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov10" title="4">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params
        return action
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">/* conf_mod_block.go - config for mod_block */
/*
modification history
--------------------
2014/8/27, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_block

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfModBlock struct {
    Basic struct {
        ProductRulePath string  // path of product block rule data
        IPBlacklistPath string  // path of ip blacklist data
    }

    Log struct {
        OpenDebug bool    //  whether open debug
    }
}


/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModBlock, error) <span class="cov10" title="5">{
    var cfg ConfModBlock
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_block
    <span class="cov10" title="5">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="5">return &amp;cfg, nil</span>
}

func (cfg *ConfModBlock) Check(confRoot string) error <span class="cov10" title="5">{
    return ConfModBlockCheck(cfg, confRoot)
}</span>

func ConfModBlockCheck(cfg *ConfModBlock, confRoot string) error <span class="cov10" title="5">{
    if cfg.Basic.ProductRulePath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModBlock.ProductRulePath not set, use default value")
        cfg.Basic.ProductRulePath = "mod_block/block_rules.data"
    }</span>
    <span class="cov10" title="5">cfg.Basic.ProductRulePath = conf_path.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

    if cfg.Basic.IPBlacklistPath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModBlock.IPBlacklistPath not set, use default value")
        cfg.Basic.IPBlacklistPath = "mod_block/ip_blacklist.data"
    }</span>
    <span class="cov10" title="5">cfg.Basic.IPBlacklistPath = conf_path.ConfPathProc(cfg.Basic.IPBlacklistPath, confRoot)

    return nil</span>
}

</pre>
		
		<pre class="file" id="file56" style="display: none">/* global_ip_table_load.go - load global ip table */
/*
modification history
--------------------
2014/8/27, by Sijie YANG, create
*/
/*
DESCRIPTION

*/
package mod_block

import (
    "fmt"
)

import (
    "www.baidu.com/golang-lib/ipdict"
    "www.baidu.com/golang-lib/ipdict/txt_load"
)

// load global ip table 
func GlobalIPTableLoad(path string) (*ipdict.IPItems, error) <span class="cov10" title="3">{
    var items *ipdict.IPItems
    var err error

    // load dict file
    txtLoader := txt_load.NewTxtFileLoader(path)
    curVersion := "" // initial version ""
    items, err = txtLoader.CheckAndLoad(curVersion)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("load dict: %s", err.Error())
    }</span>

    <span class="cov10" title="3">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/* mod_block.go - module for blocking request */
/*
modification history
--------------------
2014/8/27, by Sijie YANG, create
2014/9/4, by Zhang Miao, set ErrCode of session/request to bfe_basic.ERR_BLACKLIST if blocked
*/
/*
DESCRIPTION
  Note: mod_block MUST be registered after mod_dict_client
*/
package mod_block

import (
        "encoding/json"
        "fmt"
        "net/url"
)

import (
        "www.baidu.com/golang-lib/ipdict"
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/module_state2"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
)

var (
        openDebug = false
)

// key for counter of mod_block
var COUNTER_KEYS = []string{
        "CONN_TOTAL",    // all connnetion checked
        "CONN_ACCEPT",   // connection passed
        "CONN_REFUSE",   // connection refused
        "REQ_TOTAL",     // all request in
        "REQ_TO_CHECK",  // request to check
        "REQ_ACCEPT",    // request accepted
        "REQ_REFUSE",    // request refused
        "WRONG_COMMAND", // request with condition satisfied, but wrong command
}

type ModuleBlock struct {
        name  string               // name of module
        state *module_state2.State // module state

        productRulePath string // path of block rule data file
        ipBlacklistPath string // path of ip blacklist data file

        ruleTable *ProductRuleTable // table for product block rules
        ipTable   *ipdict.IPTable   // table for global ip blacklist
}

func NewModuleBlock() *ModuleBlock <span class="cov8" title="3">{
        m := new(ModuleBlock)
        m.name = "mod_block"
        m.state = new(module_state2.State)

        m.state.Init()
        m.state.CountersInit(COUNTER_KEYS)
        m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_BLOCK)

        m.ruleTable = NewProductRuleTable()
        m.ipTable = ipdict.NewIPTable()

        return m
}</span>

func (m *ModuleBlock) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleBlock) Attr() map[string]interface{} <span class="cov1" title="1">{
        // reload items
        reloadEntries := []string{
                m.name + ".global_ip_table",
                m.name + ".product_rule_table",
        }

        // monitor items (item name, item type)
        monitorEntries := map[string]string{
                m.name: bfe_basic.MON_TYPE_STATE,
        }

        return map[string]interface{}{
                bfe_basic.MON_ATTR_RELOAD:  reloadEntries,
                bfe_basic.MON_ATTR_MONITOR: monitorEntries,
        }
}</span>

// load global ip blacklist
// loadGlobalIPTable is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleBlock) loadGlobalIPTable(query url.Values) error <span class="cov8" title="3">{
        // get reload file path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="3">{
                // use default
                path = m.ipBlacklistPath
        }</span>

        // load data
        <span class="cov8" title="3">items, err := GlobalIPTableLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in GlobalIPTableLoad(%s):%s", path, err)
        }</span>

        <span class="cov8" title="3">m.ipTable.Update(items)
        return nil</span>
}

// load from config file
// loadProductRuleConf is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to loaded
//          if query["path"] is not set, use default path
func (m *ModuleBlock) loadProductRuleConf(query url.Values) error <span class="cov8" title="3">{
        // get path
        path := query.Get("path")
        if path == "" </span><span class="cov8" title="3">{
                // use default
                path = m.productRulePath
        }</span>

        // load file
        <span class="cov8" title="3">conf, err := ProductRuleConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ProductRuleConfLoad(%s):%s", path, err)
        }</span>

        <span class="cov8" title="3">m.ruleTable.Update(conf)
        return nil</span>
}

// handler for doing global block
func (m *ModuleBlock) globalBlockHandler(session *bfe_basic.Session) int <span class="cov5" title="2">{
        if openDebug </span><span class="cov5" title="2">{
                log.Logger.Debug("%s check connection (remote: %v)",
                        m.name, session.RemoteAddr)
        }</span>
        <span class="cov5" title="2">m.state.Inc("CONN_TOTAL", 1)

        clientIP := session.RemoteAddr.IP
        if m.ipTable.Search(clientIP) </span><span class="cov1" title="1">{
                session.ErrCode = bfe_basic.ERR_BLACKLIST
                log.Logger.Debug("%s refuse connection (remote: %v)",
                        m.name, session.RemoteAddr)
                m.state.Inc("CONN_REFUSE", 1)
                return bfe_module.BFE_HANDLER_FINISH
        }</span>

        <span class="cov1" title="1">if openDebug </span><span class="cov1" title="1">{
                log.Logger.Debug("%s accept connection (remote: %v)",
                        m.name, session.RemoteAddr)
        }</span>
        <span class="cov1" title="1">m.state.Inc("CONN_ACCEPT", 1)
        return bfe_module.BFE_HANDLER_GOON</span>
}

// handler for doing product block
func (m *ModuleBlock) productBlockHandler(request *bfe_basic.Request) (
        int, *bfe_http.Response) <span class="cov5" title="2">{
        if openDebug </span><span class="cov5" title="2">{
                log.Logger.Debug("%s check request", m.name)
        }</span>
        <span class="cov5" title="2">m.state.Inc("REQ_TOTAL", 1)

        // find block rules for given request
        rules, err := m.ruleTable.Search(request.Route.Product)
        if err != nil </span><span class="cov1" title="1">{ // no rules found
                if openDebug </span><span class="cov1" title="1">{
                        log.Logger.Debug("%s product %s not found, just pass",
                                m.name, request.Route.Product)
                }</span>
                <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON, nil</span>
        }

        <span class="cov1" title="1">m.state.Inc("REQ_TO_CHECK", 1)
        return m.productRulesProcess(request, rules)</span>
}

// process block rules
func (m *ModuleBlock) productRulesProcess(req *bfe_basic.Request, rules *blockRuleList) (
        int, *bfe_http.Response) <span class="cov1" title="1">{
        for _, rule := range *rules </span><span class="cov1" title="1">{
                if openDebug </span><span class="cov1" title="1">{
                        log.Logger.Debug("%s process rule: %v", m.name, rule)
                }</span>

                // rule condition is satisfied ?
                <span class="cov1" title="1">if rule.Cond.Match(req) </span><span class="cov1" title="1">{
                        switch rule.Action.Cmd </span>{
                        <span class="cov1" title="1">case "CLOSE":
                                req.ErrCode = bfe_basic.ERR_BLACKLIST
                                log.Logger.Debug("%s block connection (rule:%v, remote:%s)",
                                        m.name, rule, req.RemoteAddr)
                                m.state.Inc("REQ_REFUSE", 1)
                                return bfe_module.BFE_HANDLER_FINISH, nil</span>
                        <span class="cov0" title="0">default:
                                if openDebug </span><span class="cov0" title="0">{
                                        log.Logger.Debug("%s unknown block command (%s), just pass",
                                                rule.Action.Cmd)
                                }</span>
                                <span class="cov0" title="0">m.state.Inc("WRONG_COMMAND", 1)</span>
                        }
                }
        }

        <span class="cov0" title="0">if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("%s accept request", m.name)
        }</span>
        <span class="cov0" title="0">m.state.Inc("REQ_ACCEPT", 1)
        return bfe_module.BFE_HANDLER_GOON, nil</span>
}

func (m *ModuleBlock) getState(query url.Values) ([]byte, error) <span class="cov1" title="1">{
        state := m.state.GetAll()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov1" title="1">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov1" title="1">var buff []byte
        var err error

        switch format </span>{
        <span class="cov1" title="1">case "json":
                buff, err = json.Marshal(state)</span>
        <span class="cov0" title="0">case "noah":
                buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov1" title="1">return buff, err</span>
}

// all monitor handlers
func (m *ModuleBlock) monitorHandlers() map[string]interface{} <span class="cov10" title="4">{
        handlers := map[string]interface{}{
                m.name: m.getState,
        }
        return handlers
}</span>

// all reload handlers
func (m *ModuleBlock) reloadHandlers() map[string]interface{} <span class="cov10" title="4">{
        handlers := map[string]interface{}{
                m.name + ".global_ip_table":    m.loadGlobalIPTable,
                m.name + ".product_rule_table": m.loadProductRuleConf,
        }
        return handlers
}</span>

func (m *ModuleBlock) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov8" title="3">{
        var conf *ConfModBlock
        var err error

        // load module config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="3">m.productRulePath = conf.Basic.ProductRulePath
        m.ipBlacklistPath = conf.Basic.IPBlacklistPath
        openDebug = conf.Log.OpenDebug

        // load conf data
        if err = m.loadGlobalIPTable(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadGlobalIPTable() err %s", m.name, err.Error())
        }</span>
        <span class="cov8" title="3">if err = m.loadProductRuleConf(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadProductRuleConf() err %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov8" title="3">err = cbs.AddFilter(bfe_module.HANDLE_ACCEPT, m.globalBlockHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.globalBlockHandler): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="3">err = cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.productBlockHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.productBlockHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for monitor
        <span class="cov8" title="3">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>
        // register web handler for reload
        <span class="cov8" title="3">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
        }</span>

        <span class="cov8" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/* product_rule_load.go - load block rule config from json file */
/*
modification history
--------------------
2014/8/27, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_block

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

import (
    "bfe_basic/condition"
)

type blockRuleFile struct {
    Cond   *string     // condition for block
    Action *ActionFile // action for block
}

type blockRule struct {
    Cond   condition.Condition // condition for block
    Action Action              // action for block
}

type blockRuleFileList []blockRuleFile
type blockRuleList []blockRule

type ProductRulesFile map[string]*blockRuleFileList // product =&gt; list of block rules
type ProductRules map[string]*blockRuleList

type productRuleConfFile struct {
    Version *string // version of the config
    Config  *ProductRulesFile
}

type productRuleConf struct {
    Version string       // version of the config
    Config  ProductRules // product rules for block
}

// check blockRule
func blockRuleCheck(conf blockRuleFile) error <span class="cov7" title="4">{
    // check Cond
    if conf.Cond == nil </span><span class="cov0" title="0">{
        return errors.New("no Cond")
    }</span>

    // check Actions
    <span class="cov7" title="4">if conf.Action == nil </span><span class="cov0" title="0">{
        return errors.New("no Action")
    }</span>

    <span class="cov7" title="4">if err := ActionFileCheck(conf.Action); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Action:%s", err.Error())
    }</span>

    <span class="cov7" title="4">return nil</span>
}

// check blockRuleList
func blockRuleListCheck(conf *blockRuleFileList) error <span class="cov10" title="8">{
    for index, rule := range *conf </span><span class="cov7" title="4">{
        err := blockRuleCheck(rule)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("blockRule:%d, %s", index, err.Error())
        }</span>
    }

    <span class="cov10" title="8">return nil</span>
}

// check ProductRules
func productRulesCheck(conf *ProductRulesFile) error <span class="cov7" title="4">{
    for product, ruleList := range *conf </span><span class="cov10" title="8">{
        if ruleList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no blockRuleList for product:%s", product)
        }</span>

        <span class="cov10" title="8">err := blockRuleListCheck(ruleList)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
        }</span>
    }

    <span class="cov7" title="4">return nil</span>
}

// check productRuleConf
func productRuleConfCheck(conf productRuleConfFile) error <span class="cov7" title="4">{
    var err error

    // check Version
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    // check Config
    <span class="cov7" title="4">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    <span class="cov7" title="4">err = productRulesCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Config:%s", err.Error())
    }</span>

    <span class="cov7" title="4">return nil</span>
}

func ruleConvert(ruleFile blockRuleFile) (blockRule, error) <span class="cov7" title="4">{
    rule := blockRule{}

    cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov0" title="0">{
        return rule, err
    }</span>
    <span class="cov7" title="4">rule.Cond = cond
    rule.Action = actionConvert(*ruleFile.Action)
    return rule, nil</span>
}

func ruleListConvert(ruleFileList *blockRuleFileList) (*blockRuleList, error) <span class="cov10" title="8">{
    ruleList := new(blockRuleList)
    *ruleList = make([]blockRule, 0)

    for _, ruleFile := range *ruleFileList </span><span class="cov7" title="4">{
        rule, err := ruleConvert(ruleFile)
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
        <span class="cov7" title="4">*ruleList = append(*ruleList, rule)</span>
    }

    <span class="cov10" title="8">return ruleList, nil</span>
}

/* load block rule config from file

   Returns:
        (productRuleConf, error)
*/
func ProductRuleConfLoad(filename string) (productRuleConf, error) <span class="cov7" title="5">{
    var conf productRuleConf
    var err error

    // open the file
    file, err := os.Open(filename)
    defer file.Close()
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // decode the file
    <span class="cov7" title="5">decoder := json.NewDecoder(file)
    var config productRuleConfFile
    err = decoder.Decode(&amp;config)
    if err != nil </span><span class="cov1" title="1">{
        return conf, err
    }</span>

    // check config
    <span class="cov7" title="4">err = productRuleConfCheck(config)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // convert config
    <span class="cov7" title="4">conf.Version = *config.Version
    conf.Config = make(ProductRules)
    for product, ruleFileList := range *config.Config </span><span class="cov10" title="8">{
        ruleList, err := ruleListConvert(ruleFileList)
        if err != nil </span><span class="cov0" title="0">{
            return conf, err
        }</span>
        <span class="cov10" title="8">conf.Config[product] = ruleList</span>
    }

    <span class="cov7" title="4">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/* product_rule_table.go - table for storing product block rules   */
/*
modification history
--------------------
2014/8/27, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_block

import (
    "fmt"
    "sync"
)

type ProductRuleTable struct {
    lock            sync.Mutex
    version         string
    productRules    ProductRules
}

func NewProductRuleTable() *ProductRuleTable <span class="cov10" title="3">{
    t := new(ProductRuleTable)
    t.productRules = make(ProductRules)
    return t
}</span>

// update
func (t *ProductRuleTable) Update(conf productRuleConf) <span class="cov10" title="3">{
    t.lock.Lock()
    t.version = conf.Version
    t.productRules = conf.Config
    t.lock.Unlock()
}</span>

/* Search for block rules
 
   Returns:
        (*RuleList, nil), if succeed
        (nil, error), if fail
*/
func (t *ProductRuleTable) Search(product string) (*blockRuleList, error)<span class="cov6" title="2">{
    t.lock.Lock()
    //  find rules for given product
    rules, ok := t.productRules[product]
    t.lock.Unlock()

    if ok </span><span class="cov1" title="1">{
        return rules, nil
    }</span> <span class="cov1" title="1">else {
        return nil, fmt.Errorf("no block rules for %s", product)
    }</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/* conf_mod_cross_region.go - config for mod_cross_region */
/*
modification history
--------------------
2015/7/1, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_cross_region

import (
    "fmt"
)

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

import (
    "bfe_config/bfe_cluster_conf/cluster_conf"
)

const (
    DefaultIdleConnPerHost = 10    // defualt max connections to each downstream bfe
    DefaultTimeoutConnSrv  = 200   // default timeout for connecting downstream bfe (ms)
)

type ConfModCrossRegion struct {
    Basic struct {
        ProductRulePath     string // path for product_rule.data
        RegionConfPath      string // path for region_conf.data
        ClusterTablePath    string // path for region_cluster_table.data
        MaxIdleConnsPerHost int    // max connections to each downstream bfe
        TimeoutConnSrv      int    // timeout for connecting downstream bfe (ms)
    }

    BackendCheck struct {
        Schem               string
        Uri                 string // uri used in health check
        Host                string // if check request use special host header
        StatusCode          int    // default value is 200
        FailNum             int    // if continuous_fail_num reach failNum, backend become
                                   // unavailable, and start health check
        CheckInterval       int    // interval of health check, in ms
    }

    Log struct {
        OpenDebug bool            // whether open debug
    }
}

// load config from config file
func ConfLoad(filePath string, confRoot string) (*ConfModCrossRegion, error) <span class="cov10" title="14">{
    var cfg ConfModCrossRegion
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov1" title="1">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_block
    <span class="cov9" title="13">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov9" title="13">return &amp;cfg, nil</span>
}

func (cfg *ConfModCrossRegion) Check(confRoot string) error <span class="cov9" title="13">{
    return ConfModCrossRegionCheck(cfg, confRoot)
}</span>

func ConfModCrossRegionCheck(cfg *ConfModCrossRegion, confRoot string) error <span class="cov9" title="13">{
    if err := cfg.CheckBasic(confRoot); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov9" title="13">if err := cfg.CheckBackendCheck(); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov9" title="13">return nil</span>
}

func (cfg *ConfModCrossRegion) CheckBasic(confRoot string) error <span class="cov9" title="13">{
    if cfg.Basic.ProductRulePath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModCrossRegion.ProductRulePath not set, use default value")
        cfg.Basic.ProductRulePath = "mod_cross_region/product_rule.data"
    }</span>
    <span class="cov9" title="13">cfg.Basic.ProductRulePath = conf_path.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

    if cfg.Basic.RegionConfPath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModCrossRegion.RegionConfPath not set, use default value")
        cfg.Basic.RegionConfPath = "mod_cross_region/region_conf.data"
    }</span>
    <span class="cov9" title="13">cfg.Basic.RegionConfPath = conf_path.ConfPathProc(cfg.Basic.RegionConfPath, confRoot)

    if cfg.Basic.ClusterTablePath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModCrossRegion.ClusterTablePath not set, use default value")
        cfg.Basic.ClusterTablePath = "mod_cross_region/cluster_table.data"
    }</span>
    <span class="cov9" title="13">cfg.Basic.ClusterTablePath = conf_path.ConfPathProc(cfg.Basic.ClusterTablePath, confRoot)

    if cfg.Basic.MaxIdleConnsPerHost &lt;= 0 </span><span class="cov0" title="0">{
        log.Logger.Warn("ModCrossRegion.MaxIdleConnsPerHost not set, use default value")
        cfg.Basic.MaxIdleConnsPerHost = DefaultIdleConnPerHost
    }</span>

    <span class="cov9" title="13">if cfg.Basic.TimeoutConnSrv &lt;= 0 </span><span class="cov1" title="1">{
        log.Logger.Warn("ModCrossRegion.TimeoutConnSrv not set, use default value")
        cfg.Basic.TimeoutConnSrv = DefaultTimeoutConnSrv
    }</span>

    <span class="cov9" title="13">return nil</span>
}

func (cfg *ConfModCrossRegion) CheckBackendCheck() error <span class="cov9" title="13">{
    if len(cfg.BackendCheck.Uri) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no Uri")
    }</span>

    <span class="cov9" title="13">if cfg.BackendCheck.StatusCode == 0 </span><span class="cov0" title="0">{
        cfg.BackendCheck.StatusCode = 200
    }</span>

    <span class="cov9" title="13">if cfg.BackendCheck.FailNum == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no FailNum")
    }</span>

    <span class="cov9" title="13">if cfg.BackendCheck.CheckInterval == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no CheckInterval")
    }</span>

    <span class="cov9" title="13">return nil</span>
}

func (cfg *ConfModCrossRegion) ConvertBackendCheck() *cluster_conf.BackendCheck <span class="cov9" title="11">{
    conf := new(cluster_conf.BackendCheck)
    conf.Schem = &amp;cfg.BackendCheck.Schem
    conf.Uri = &amp;cfg.BackendCheck.Uri
    conf.Host = &amp;cfg.BackendCheck.Host
    conf.StatusCode = &amp;cfg.BackendCheck.StatusCode
    conf.FailNum = &amp;cfg.BackendCheck.FailNum
    conf.CheckInterval = &amp;cfg.BackendCheck.CheckInterval

    return conf
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">/* product_rule_load.go - load product rule from json file  */
/*
modification history
--------------------
2015/7/1, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_cross_region

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

/*
structure of Product rule conf:
    {
        "Version":"1234", 
        "Config":{
            "globalSwitch": true,
            "productSwitch":{
                "news": true,
                "baike": true,
                "music": true,
            }
        }
    }
*/

// conf of product rule
type ProductRuleConf struct {
    GlobalSwitch  bool             // whether enable corss region schedule
    ProductSwitch map[string]bool  // whether enable cross region schedule for product
}

// rule conf of all bfe product
type BfeProductRuleConf struct {
    Version string                 // version of config
    Config  ProductRuleConf        // region rule
}

// implement Check interface used for reload-trigger checking conf
func (conf *BfeProductRuleConf) LoadAndCheck(filename string) (string, error) <span class="cov10" title="15">{
    /* open the file */
    file, err := os.Open(filename)
    if err != nil </span><span class="cov1" title="1">{
        return "", err
    }</span>
    <span class="cov9" title="14">defer file.Close()
    
    /* decode the file */
    decoder := json.NewDecoder(file)
    if err := decoder.Decode(&amp;conf); err != nil </span><span class="cov1" title="1">{
        return "", err
    }</span>

    /* check conf */
    <span class="cov9" title="13">if len(conf.Version) == 0 </span><span class="cov0" title="0">{
        return "", errors.New("no Version")
    }</span>

    <span class="cov9" title="13">return conf.Version, nil</span>
}

// load config of region conf from file  
func ProductRuleConfLoad(filename string) (BfeProductRuleConf, error) <span class="cov10" title="15">{    
    var config BfeProductRuleConf
    if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov3" title="2">{
        return config, fmt.Errorf("%s", err)
    }</span>

    <span class="cov9" title="13">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/* region_conf_load.go - load region conf from json file */
/*
modification history
--------------------
2015/7/1, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_cross_region

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

import (
    "www.baidu.com/golang-lib/ipdict/txt_load"
)

/*
structure of Region conf:
    {
        "Version":"1234", 
        "Config": {
            "region_bj":{
                "IpDictFile" : "/path/to/network/segment/conf"
                "ServiceName": "group.bj.BFE.cn",
            },
            "region_nj":{
            }
        }
    }
*/

// conf of region
type RegionConf struct {
    IpDictFile  string    // ip addresses in region
    ServiceName string    // bns name for bfe in region
}

type RegionConfMap map[string]RegionConf

// conf of all bfe region
type BfeRegionConf struct {
    Version string        // version of config
    Config  RegionConfMap // all region conf
}

// check RegionConf
func RegionConfCheck(conf RegionConf) error <span class="cov10" title="28">{
    if len(conf.ServiceName) == 0 </span><span class="cov0" title="0">{
        return errors.New("no ServiceName")
    }</span>
    
    <span class="cov10" title="28">if len(conf.IpDictFile) == 0 </span><span class="cov0" title="0">{
        return errors.New("no IpDictFile")
    }</span>

    <span class="cov10" title="28">fileLoader := txt_load.NewTxtFileLoader(conf.IpDictFile)
    if _, err := fileLoader.CheckAndLoad(""); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("CheckConf:%s", err.Error())
    }</span>

    <span class="cov10" title="28">return nil</span>
}

// check RegionConfMap
func RegionConfMapCheck(conf RegionConfMap) error <span class="cov8" title="14">{
    for regionName, regionConf := range conf </span><span class="cov10" title="28">{
        err := RegionConfCheck(regionConf)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("conf for %s:%s", regionName, err.Error())
        }</span>
    }
    <span class="cov8" title="14">return nil</span>
}

// check integrity of config
func BfeRegionConfCheck(conf *BfeRegionConf) error <span class="cov8" title="14">{
    if len(conf.Version) == 0 </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>
    
    <span class="cov8" title="14">err := RegionConfMapCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("BfeRegionConf.Config:%s", err.Error())
    }</span>
    
    <span class="cov8" title="14">return nil</span>
}

// implement Check interface used for reload-trigger checking conf
func (conf *BfeRegionConf)LoadAndCheck(filename string) (string, error) <span class="cov8" title="14">{
    /* open the file */
    file, err := os.Open(filename)
    if err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>
    <span class="cov8" title="14">defer file.Close()
    
    /* decode the file */
    decoder := json.NewDecoder(file)
    if err := decoder.Decode(&amp;conf); err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>

    /* check conf */
    <span class="cov8" title="14">if err := BfeRegionConfCheck(conf); err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>

    <span class="cov8" title="14">return conf.Version, nil</span>
}

// load region conf from file
func RegionConfLoad(filename string) (BfeRegionConf, error) <span class="cov8" title="14">{
    var config BfeRegionConf
    if _, err := config.LoadAndCheck(filename); err != nil </span><span class="cov0" title="0">{
        return config, fmt.Errorf("%s", err)
    }</span>

    <span class="cov8" title="14">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/* mod_cross_region.go - schedule cross-region requests to transport with qos guarantee */
/*
modification history
--------------------
2015/07/01, by Sijie Yang, create
*/
/*
DESCRIPTION
    For more information, See BFE-HTTPS 2-003.
*/
package mod_cross_region

import (
    "fmt"
    "net"
    "net/url"
    "time"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_config/bfe_cluster_conf/cluster_table_conf"
    "bfe_config/bfe_cluster_conf/cluster_conf"
    "bfe_http"
    "bfe_module"
)

const (
    BfeCrReqHeader = "bfe_cr_request"
)

var (
    openDebug = false
)

var COUNTER_KEYS = []string {
    "SCHEDL1_PRODUCT_DISABLE",
    "SCHEDL1_CURRENT_REGION_UNKNOWN",
    "SCHEDL1_SAME_REGION",
    "SCHEDL1_CROSS_REGION",
    "SCHEDL1_UNKNOWN_REGION",
    "SCHEDL1_WITHOUT_AVAIL_BFE",
    "SCHEDL1_WITH_AVAIL_BFE",
    "SCHEDL1_IGNORE_REQ_WITH_CR_HEADER",
    "SCHEDL2_CURRENT_REGION_UNKNOWN",
    "SCHEDL2_SAME_REGION",
    "SCHEDL2_CROSS_REGION",
    "SCHEDL2_UNKNOWN_REGION",
    "REGION_NOT_EXISTS",
    "REGION_CLUSTER_WITHOUT_BACKEND",
}

type ModuleCrossRegion struct {
    name          string                 // module name
    conf          *ConfModCrossRegion    // module config
    checkConf     *cluster_conf.BackendCheck // conf for health check

    ruleTable     *ProductRuleTable      // rules for cross region schedule
    clusterTable  *RegionClusterTable    // region cluster table
    transport     *bfe_http.Transport    // transport to downstream bfe servers 
                                         // with qos guarantee
    state         *module_state2.State   // module state
}

func NewModuleCrossRegion() *ModuleCrossRegion <span class="cov10" title="11">{
    m := new(ModuleCrossRegion)

    m.name = "mod_cross_region"
    m.ruleTable = NewProductRuleTable()
    m.clusterTable = NewRegionClusterTable(m.state)
    m.state = new(module_state2.State)

    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_CROSS_REGION)

    return m
}</span>

func (m *ModuleCrossRegion) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

// schedule cross-region requests
func (m *ModuleCrossRegion) scheduleHandler(req *bfe_basic.Request) int <span class="cov9" title="10">{
    if !req.Session.IsTrustIP </span><span class="cov7" title="6">{
        return m.scheduleLevel1(req)
    }</span> <span class="cov6" title="4">else {
        return m.scheduleLevel2(req)
    }</span>
}

// schedule requests comming from outside
func (m *ModuleCrossRegion) scheduleLevel1(req *bfe_basic.Request) int <span class="cov7" title="6">{
    // check current region
    currentRegion := m.clusterTable.GetCurrentRegion()
    if openDebug </span><span class="cov7" title="6">{
        log.Logger.Debug("%s: SchedL1(%s) start schedule request", m.name, currentRegion)
    }</span>
    <span class="cov7" title="6">if currentRegion == DEFAULT_REGION </span><span class="cov1" title="1">{
        m.state.Inc("SCHEDL1_CURRENT_REGION_UNKNOWN", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span>

    // check cross-region header
    <span class="cov7" title="5">value := req.OutRequest.Header.Get(BfeCrReqHeader)
    if len(value) &gt; 0 </span><span class="cov0" title="0">{
        m.state.Inc("SCHEDL1_IGNORE_REQ_WITH_CR_HEADER", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span>

    // check if cross-region schedule is enabled for product
    <span class="cov7" title="5">product := req.Route.Product
    if !m.ruleTable.Check(req.Route.Product) </span><span class="cov3" title="2">{
        m.state.Inc("SCHEDL1_PRODUCT_DISABLE", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span>

    // check if backend is located in another region
    <span class="cov5" title="3">address := req.Trans.Backend.Addr
    region := m.clusterTable.LocateRegion(address)
    if region == DEFAULT_REGION </span><span class="cov1" title="1">{
        m.state.Inc("SCHEDL1_UNKNOWN_REGION", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span> <span class="cov3" title="2">else if region == currentRegion </span><span class="cov1" title="1">{
        m.state.Inc("SCHEDL1_SAME_REGION", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span>
    <span class="cov1" title="1">m.state.Inc("SCHEDL1_CROSS_REGION", 1)

    // choose a downstream bfe with qos guarantee
    newBackend, err := m.clusterTable.Balance(region)
    if err != nil </span><span class="cov0" title="0">{
        m.state.Inc("SCHEDL1_WITHOUT_AVAIL_BFE", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span>
    <span class="cov1" title="1">m.state.Inc("SCHEDL1_WITH_AVAIL_BFE", 1)

    if openDebug </span><span class="cov1" title="1">{
        log.Logger.Debug("%s: SchedL1(%s) schedule %s request to %s:%s (oringal %s, client %d)",
            m.name, currentRegion, product, region, newBackend.Addr, address, req.RemoteAddr)
    }</span>

    // set cross region header
    <span class="cov1" title="1">req.OutRequest.Header.Set(BfeCrReqHeader, address)

    // set transport for request
    req.Trans.Transport = m.transport
    req.Trans.Backend = newBackend
    req.Trans.CheckConf = m.checkConf

    return bfe_module.BFE_HANDLER_GOON</span>
}

// schedule requests comming from upstream bfe server
func (m *ModuleCrossRegion) scheduleLevel2(req *bfe_basic.Request) int <span class="cov6" title="4">{
    // check current region
    currentRegion := m.clusterTable.GetCurrentRegion()
    if currentRegion == DEFAULT_REGION </span><span class="cov1" title="1">{
        m.state.Inc("SCHEDL2_CURRENT_REGION_UNKNOWN", 1)
        req.OutRequest.Header.Del(BfeCrReqHeader)
        return bfe_module.BFE_HANDLER_GOON
    }</span>

    // check if cross-region request 
    <span class="cov5" title="3">backend := req.OutRequest.Header.Get(BfeCrReqHeader)
    if len(backend) &gt; 0 </span><span class="cov3" title="2">{
        // check region of actual backend for incoming request
        address := req.Trans.Backend.Addr
        region := m.clusterTable.LocateRegion(address)
        if region == DEFAULT_REGION </span><span class="cov0" title="0">{
            m.state.Inc("SCHEDL2_UNKNOWN_REGION", 1)
        }</span> <span class="cov3" title="2">else if region == currentRegion </span><span class="cov1" title="1">{
            m.state.Inc("SCHEDL2_SAME_REGION", 1)
        }</span> <span class="cov1" title="1">else {
            m.state.Inc("SCHEDL2_CROSS_REGION", 1)
        }</span>
        <span class="cov3" title="2">if openDebug </span><span class="cov3" title="2">{
            log.Logger.Debug("%s: SchedL2(%s) got %s request from %s, backend expect %s, actual %s(%d)", 
                m.name, currentRegion, req.Route.Product, req.RemoteAddr, backend, address, region)
        }</span>
    } <span class="cov1" title="1">else {
        m.state.Inc("SCHEDL2_WITHOUT_CR_HEADER", 1)
    }</span>

    <span class="cov5" title="3">req.OutRequest.Header.Del(BfeCrReqHeader)
    return bfe_module.BFE_HANDLER_GOON</span>
}

func (m *ModuleCrossRegion) Attr() map[string]interface{} <span class="cov1" title="1">{
    // reload items
    reloadEntries := []string {
        m.name + ".product_rule",
        m.name + ".region_conf",
        m.name + ".cluster_table",
    }

    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD : reloadEntries,
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>

func (m *ModuleCrossRegion) getState() *module_state2.StateData <span class="cov0" title="0">{
    return m.state.GetAll()
}</span>

// all monitor handlers
func (m *ModuleCrossRegion) monitorHandlers() map[string]interface{} <span class="cov10" title="11">{
    handlers := map[string]interface{} {
        m.name: web_monitor.CreateStateDataHandler(m.getState),
    }
    return handlers
}</span>

// all reload handlers
func (m *ModuleCrossRegion) reloadHandlers() map[string]interface{} <span class="cov10" title="11">{
    handlers := map[string]interface{} {
        m.name + ".product_rule"   : m.loadProductRuleTable,
        m.name + ".region_conf"   : m.loadRegionConf,
        m.name + ".cluster_table" : m.loadRegionClusterTable,
    }
    return handlers
}</span>

// load region config 
func (m *ModuleCrossRegion) loadRegionConf(query url.Values) error <span class="cov1" title="1">{
    path := getPathParam(query, m.conf.Basic.RegionConfPath)
    regionConf, err := RegionConfLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadRegionConf(%s) %s", path, err)
    }</span>

    <span class="cov1" title="1">return m.clusterTable.Reload(regionConf)</span>
}

// load region cluster config
func (m *ModuleCrossRegion) loadRegionClusterTable(query url.Values) error <span class="cov1" title="1">{
    path := getPathParam(query, m.conf.Basic.ClusterTablePath)
    clusterConf, err := cluster_table_conf.ClusterTableLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadRegionClusterTable(%s) %s", path, err)
    }</span>

    <span class="cov1" title="1">return m.clusterTable.BackendReload(clusterConf)</span>
}

// load config for region rule
func (m *ModuleCrossRegion) loadProductRuleTable(query url.Values) error <span class="cov1" title="1">{
    path := getPathParam(query, m.conf.Basic.ProductRulePath)
    ruleConf, err := ProductRuleConfLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadProductRuleTable(%s) %s", path, err)
    }</span>

    <span class="cov1" title="1">m.ruleTable.Update(&amp;ruleConf)
    return nil</span>
}

// get file path param
func getPathParam(query url.Values, defaultPath string) string <span class="cov5" title="3">{
    path := query.Get("path")
    if path == "" </span><span class="cov5" title="3">{
        path = defaultPath
    }</span>
    <span class="cov5" title="3">return path</span>
}

func (m *ModuleCrossRegion) initRegionConfAll() (err error) <span class="cov10" title="11">{
    conf := m.conf.Basic

    // load config for region rule
    ruleConf, err := ProductRuleConfLoad(conf.ProductRulePath)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov10" title="11">m.ruleTable.Update(&amp;ruleConf)

    // init region config
    regionConf, err := RegionConfLoad(conf.RegionConfPath)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov10" title="11">if err = m.clusterTable.Init(regionConf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // init region cluster table
    <span class="cov10" title="11">clusterConf, err := cluster_table_conf.ClusterTableLoad(conf.ClusterTablePath)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov10" title="11">if err = m.clusterTable.BackendInit(clusterConf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov10" title="11">m.checkConf = m.conf.ConvertBackendCheck()

    return nil</span>
}

func (m *ModuleCrossRegion) initTransport() <span class="cov10" title="11">{
    conf := m.conf.Basic

    dailer := func(network, add string) (net.Conn, error) </span><span class="cov0" title="0">{
        timeout := time.Duration(conf.TimeoutConnSrv) * time.Millisecond
        return net.DialTimeout(network, add, timeout)
    }</span>

    <span class="cov10" title="11">m.transport = &amp;bfe_http.Transport{
        Dial:                dailer,
        MaxIdleConnsPerHost: conf.MaxIdleConnsPerHost,
        DisableKeepAlives:   false,
        DisableCompression:  true,
        State:               m.state,
    }</span>
}

func (m *ModuleCrossRegion) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers, 
    cr string) error <span class="cov10" title="11">{
    var conf *ConfModCrossRegion
    var err error

    // load module config
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>
    <span class="cov10" title="11">m.conf = conf
    openDebug = conf.Log.OpenDebug

    // init all region related conf
    if err := m.initRegionConfAll(); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():initRegionConfAll(): %s", m.name, err.Error())
    }</span>

    // init transport to downstream bfe servers
    <span class="cov10" title="11">m.initTransport()

    // register handler
    err = cbs.AddFilter(bfe_module.HANDLE_FORWARD, m.scheduleHandler)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.scheduleHandler): %s", m.name, err.Error())
    }</span>

    // register web handler for monitor
    <span class="cov10" title="11">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>

    // register web handler for reload
    <span class="cov10" title="11">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
    }</span>

    <span class="cov10" title="11">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">/* product_rule_table.go - product rule table */
/*
modification history
--------------------
2015/07/03, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_cross_region

import (
    "sync"
)

type ProductRuleTable struct {
    rule *BfeProductRuleConf
    lock sync.RWMutex
}

func NewProductRuleTable() *ProductRuleTable <span class="cov9" title="11">{
    t := new(ProductRuleTable)
    return t
}</span>

// check if cross region schedule is enabled for 'product'
func (t *ProductRuleTable) Check(product string) bool <span class="cov6" title="5">{
    t.lock.RLock()
    defer t.lock.RUnlock()

    if t.rule == nil </span><span class="cov0" title="0">{
        return false
    }</span>

    <span class="cov6" title="5">if t.rule.Config.GlobalSwitch &amp;&amp; t.rule.Config.ProductSwitch[product] </span><span class="cov4" title="3">{
        return true
    }</span>

    <span class="cov3" title="2">return false</span>
}

// update region rule config
func (t *ProductRuleTable) Update(rule *BfeProductRuleConf) <span class="cov10" title="12">{
    t.lock.Lock()
    t.rule = rule
    t.lock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">/* region_cluster.go - cluster for a region */
/*
modification history
--------------------
2015/07/03, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_cross_region

import (
    "fmt"
)

import (
    "bfe_balance/backend"
    "bfe_balance/bal_rr"
    "bfe_config/bfe_cluster_conf/cluster_table_conf"
)

// cluster for a region
type RegionCluster struct {
    Name        string             // serice name for region
    backends    *bal_rr.BalanceRR  // backend with round robin
}

func NewRegionCluster(name string) *RegionCluster <span class="cov10" title="24">{
    r := new(RegionCluster)
    r.Name = name
    r.backends = bal_rr.NewBalanceRR(name)
    return r
}</span>

// init region cluster with backends
func (r *RegionCluster) init(backends cluster_table_conf.SubClusterBackend) <span class="cov10" title="24">{
    r.backends.Init(backends)
}</span>

// update region cluster with backends
func (r *RegionCluster) update(backends cluster_table_conf.SubClusterBackend) <span class="cov2" title="2">{
    r.backends.Update(backends)
}</span>

// release all backends
func (r *RegionCluster) release() <span class="cov0" title="0">{
    r.backends.Release()   
}</span>

// choose a backend from cluster in WRR
func (r *RegionCluster) balance() (*backend.BfeBackend, error) <span class="cov1" title="1">{
    if r.backends.Len() == 0 </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("no backend in r cluster [%s]", r.Name)
    }</span>
    <span class="cov1" title="1">return r.backends.Balance()</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/* region_cluster_table.go - region cluster table */
/*
modification history
--------------------
2015/07/06, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_cross_region

import (
    "fmt"
    "net"
    "sync"
)

import (
    "www.baidu.com/golang-lib/ipdict"
    "www.baidu.com/golang-lib/ipdict/txt_load"
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
)

import (
    "bfe_balance/backend"
    "bfe_config/bfe_cluster_conf/cluster_table_conf"
)

const (
    CLUSTER_BFE    = "cluster_bfe"
    DEFAULT_REGION = "unknown"
)

var (
    errLocalRegionUnknown = fmt.Errorf("region ip dict not contain local address")
)

// clusters for all regions
type RegionClusterTable struct {
    currentRegion string                     // name of current region
    clusterTable  map[string]*RegionCluster  // &lt;region name, region cluster&gt;
    ipDictTable   map[string]*ipdict.IPTable // &lt;region name, ip dict&gt;
    lock          sync.RWMutex
    state         *module_state2.State
}

func NewRegionClusterTable(state *module_state2.State) *RegionClusterTable <span class="cov7" title="13">{
    t := new(RegionClusterTable)
    t.currentRegion = DEFAULT_REGION
    t.clusterTable = make(map[string]*RegionCluster)
    t.ipDictTable = make(map[string]*ipdict.IPTable)
    t.state = state
    return t
}</span>

// choose a backend from cluster in 'regionName'
func (t *RegionClusterTable) Balance(regionName string) (*backend.BfeBackend, error) <span class="cov2" title="2">{
    t.lock.RLock()
    r := t.clusterTable[regionName]
    t.lock.RUnlock()
    if r == nil </span><span class="cov1" title="1">{
        t.state.Inc("REGION_NOT_EXISTS", 1)
        return nil, fmt.Errorf("region not exists")
    }</span>

    <span class="cov1" title="1">backend, err := r.balance()
    if err != nil </span><span class="cov0" title="0">{
        t.state.Inc("REGION_CLUSTER_WITHOUT_BACKEND", 1)
        return nil, fmt.Errorf("region not exists")
    }</span>

    <span class="cov1" title="1">return backend, err</span>
}

// find region for 'backend'
func (t *RegionClusterTable) LocateRegion(backend string) string <span class="cov5" title="6">{
    t.lock.RLock()
    defer t.lock.RUnlock()

    return t.locateRegion(backend)
}</span>

func (t *RegionClusterTable) locateRegion(backend string) string <span class="cov8" title="19">{
    // parse ip address
    ip := net.ParseIP(backend)
    if ip == nil </span><span class="cov0" title="0">{
        return DEFAULT_REGION
    }</span>

    // match ip with ip dict for each region
    <span class="cov8" title="19">for region, dict := range(t.ipDictTable) </span><span class="cov10" title="34">{
        if dict.Search(ip) </span><span class="cov4" title="4">{
            return region
        }</span>
    }
    <span class="cov7" title="15">return DEFAULT_REGION</span>
}

// init current region
func (t *RegionClusterTable) initCurrentRegion() error <span class="cov7" title="13">{
    addrs, err := net.InterfaceAddrs()
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("init current region error: %s", err.Error())
    }</span>

    <span class="cov7" title="13">for _, addr := range(addrs) </span><span class="cov9" title="26">{
        ipAddr, ok := addr.(*net.IPNet)
        if !ok </span><span class="cov0" title="0">{
            continue</span>
        }

        <span class="cov9" title="26">ipStr := ipAddr.IP.String()
        if ipStr == "127.0.0.1" </span><span class="cov7" title="13">{
            continue</span>
        }

        <span class="cov7" title="13">region := t.locateRegion(ipStr)
        if region != DEFAULT_REGION </span><span class="cov0" title="0">{
            t.currentRegion = region
            return nil
        }</span>
    }
    <span class="cov7" title="13">return errLocalRegionUnknown</span>
}

// init region cluster table with region conf
func (t *RegionClusterTable) Init(conf BfeRegionConf) error <span class="cov7" title="12">{
    t.lock.Lock()
    defer t.lock.Unlock()

    regionConfMap := conf.Config

    // init cluster table
    for regionName, regionConf := range(regionConfMap) </span><span class="cov9" title="24">{
        cluster := NewRegionCluster(regionConf.ServiceName)
        t.clusterTable[regionName] = cluster
    }</span>

    // init ipdict table
    <span class="cov7" title="12">for regionName, regionConf := range(regionConfMap) </span><span class="cov9" title="24">{
        dict, err := loadIpDict(regionConf.IpDictFile, "")
        if err != nil </span><span class="cov0" title="0">{
            return err
        }</span>
        <span class="cov9" title="24">t.ipDictTable[regionName] = dict</span>
    }

    // init name of current region
    <span class="cov7" title="12">if err := t.initCurrentRegion(); err != nil </span><span class="cov7" title="12">{
        log.Logger.Warn("initCurrentRegion() error: %s, just ignore", err)
    }</span>

    <span class="cov7" title="12">return nil</span>
}

// init region cluster table with backends
func (t *RegionClusterTable) BackendInit(conf cluster_table_conf.ClusterTableConf) error <span class="cov7" title="12">{
    t.lock.Lock()
    defer t.lock.Unlock()

    bfeCluster := (*conf.Config)[CLUSTER_BFE]
    if bfeCluster == nil </span><span class="cov0" title="0">{
        return fmt.Errorf("cluster_bfe not exist")
    }</span>

    <span class="cov7" title="12">for _, cluster := range(t.clusterTable) </span><span class="cov9" title="24">{
        if backends, ok := bfeCluster[cluster.Name]; ok </span><span class="cov9" title="24">{
            cluster.init(backends)
        }</span>
    }
    <span class="cov7" title="12">return nil</span>
}

// reload region conf for region cluster table
func (t *RegionClusterTable) Reload(conf BfeRegionConf) error <span class="cov1" title="1">{
    // reload cluster table
    if err := t.clusterTableReload(conf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // reload dict table
    <span class="cov1" title="1">if err := t.ipDictTableReload(conf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // init name of curent region
    <span class="cov1" title="1">if err := t.initCurrentRegion(); err != nil </span><span class="cov1" title="1">{
        return err
    }</span>

    <span class="cov0" title="0">return nil</span>
}

func (t *RegionClusterTable) clusterTableReload(conf BfeRegionConf) error <span class="cov1" title="1">{
    t.lock.Lock()
    defer t.lock.Unlock()

    newTable := make(map[string]*RegionCluster)

    regionConfMap := conf.Config
    for regionName, regionConf := range(regionConfMap) </span><span class="cov2" title="2">{
        cluster, ok := t.clusterTable[regionName]
        if !ok </span><span class="cov0" title="0">{
            cluster = NewRegionCluster(regionConf.ServiceName)
        }</span>
        <span class="cov2" title="2">newTable[regionName] = cluster</span>
    }

    <span class="cov1" title="1">for regionName, cluster := range(t.clusterTable) </span><span class="cov2" title="2">{
        if _, ok := regionConfMap[regionName]; !ok </span><span class="cov0" title="0">{
            cluster.release()
        }</span>
    }

    <span class="cov1" title="1">return nil</span>
}

func (t *RegionClusterTable) ipDictTableReload(conf BfeRegionConf) error <span class="cov1" title="1">{
    newIpDictTable := make(map[string]*ipdict.IPTable)

    // get current dicts
    regionConfMap := conf.Config
    t.lock.Lock()
    for regionName, _ := range(regionConfMap) </span><span class="cov2" title="2">{
        if dict, ok := t.ipDictTable[regionName]; ok </span><span class="cov2" title="2">{
            newIpDictTable[regionName] = dict
        }</span>
    }
    <span class="cov1" title="1">t.lock.Unlock()

    // reload dicts
    for regionName, regionConf := range(regionConfMap) </span><span class="cov2" title="2">{
        version := ""
        if curDict, ok := newIpDictTable[regionName]; ok </span><span class="cov2" title="2">{
            version = curDict.Version()
        }</span>

        <span class="cov2" title="2">newDict, err := loadIpDict(regionConf.IpDictFile, version)
        if err != nil &amp;&amp; err != txt_load.ERR_NO_NEED_UPDATE </span><span class="cov0" title="0">{
            return err
        }</span>
        <span class="cov2" title="2">if err == txt_load.ERR_NO_NEED_UPDATE </span><span class="cov2" title="2">{
            log.Logger.Debug("Ingore dict with version unchanged (%s)", regionConf.IpDictFile) 
        }</span>
        <span class="cov2" title="2">if err == nil </span><span class="cov0" title="0">{
            newIpDictTable[regionName] = newDict
        }</span>
    }

    // update dict table
    <span class="cov1" title="1">t.lock.Lock()
    t.ipDictTable = newIpDictTable
    t.lock.Unlock()

    return nil</span>
}

// reload backends conf for region cluster table
func (t *RegionClusterTable) BackendReload(conf cluster_table_conf.ClusterTableConf) error <span class="cov1" title="1">{
    t.lock.Lock()
    defer t.lock.Unlock()

    bfeCluster := (*conf.Config)[CLUSTER_BFE]
    if bfeCluster == nil </span><span class="cov0" title="0">{
        return fmt.Errorf("cluster_bfe not exist")
    }</span>

    <span class="cov1" title="1">for _, cluster := range(t.clusterTable) </span><span class="cov2" title="2">{
        if backends, ok := bfeCluster[cluster.Name]; ok </span><span class="cov2" title="2">{
            cluster.update(backends)
        }</span>
    }
    <span class="cov1" title="1">return nil</span>
}

// release region cluster table
func (t *RegionClusterTable) Release() <span class="cov0" title="0">{
    t.lock.Lock()
    defer t.lock.Unlock()
    for _, cluster := range(t.clusterTable) </span><span class="cov0" title="0">{
        cluster.release()
    }</span>
}

func loadIpDict(filePath string, version string) (*ipdict.IPTable, error) <span class="cov9" title="26">{
    txtLoader := txt_load.NewTxtFileLoader(filePath)
    items, err := txtLoader.CheckAndLoad(version)
    if err != nil </span><span class="cov2" title="2">{
        return nil, err
    }</span>

    <span class="cov9" title="24">dict := ipdict.NewIPTable()
    dict.Update(items)
    return dict, nil</span>
}

// get name of current region
func (t *RegionClusterTable) GetCurrentRegion() string <span class="cov7" title="11">{
    t.lock.Lock()
    region := t.currentRegion
    t.lock.Unlock()

    return region
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">/* conf_mod_crypto.go - config for mod_crypto */
/*
modification history
--------------------
2015/3/27, by Sijie Yang, create
 - merge code from crypto-agent demo written by Guang Yao
 - improve configuration for rsa/ecc
*/
/*
DESCRIPTION
*/
package mod_crypto

import (
    "fmt"
    "strings"
)

import (
    "code.google.com/p/gcfg"
)

const (
    CRYPTO_NATIVE = "native"
    CRYPTO_CGO    = "cgo"
    CRYPTO_REMOTE = "remote"
    CRYPTO_HYBRID = "hybrid"
)

type ConfModCrypto struct {
    Basic struct {
        RSA string  // method for perform RSA compution: native, cgo, remote, hybrid
        ECC string  // method for perform ECC compution: native, cgo
    }

    // config for *remote*
    Remote struct {
        Address         string  // server address (bns name)
        ConnNum         int     // the concurrent connections with the server
        Timeout         int     // the remote call timeout, in milliseconds
        PendingNum      int     // the maximum pending request number
        Format          string  // format for crypto request: raw, compact
    }

    // config for *hybrid*
    Hybrid struct {
        RsaCgoRate      int     // maximum rsa cgo operations per second
        RsaCgoBurst     int     // maximum burst number of rsa cgo operations
    }

    Log struct {
        OpenDebug bool    //  whether open debug
    }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModCrypto, error) <span class="cov10" title="6">{
    var cfg ConfModCrypto
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_block
    <span class="cov10" title="6">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov4" title="2">{
        return &amp;cfg, err
    }</span>

    <span class="cov7" title="4">return &amp;cfg, nil</span>
}

func (cfg *ConfModCrypto) Check(confRoot string) error <span class="cov10" title="6">{
    if err := cfg.CheckConfBasic(); err != nil </span><span class="cov4" title="2">{
        return err
    }</span>

    <span class="cov7" title="4">if err := cfg.CheckConfRemote(); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov7" title="4">if err := cfg.CheckConfHybrid(); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov7" title="4">return nil</span>
}

func (cfg *ConfModCrypto) CheckConfBasic() error <span class="cov10" title="6">{
    cfg.Basic.RSA = strings.ToLower(cfg.Basic.RSA)
    rsa := cfg.Basic.RSA
    if rsa != "native" &amp;&amp; rsa != "cgo" &amp;&amp; rsa != "remote" &amp;&amp; rsa != "hybrid" </span><span class="cov1" title="1">{
        return fmt.Errorf("Wrong Basic.RSA(%s), should be native|cgo|remote|hybrid", rsa)
    }</span>

    <span class="cov9" title="5">cfg.Basic.ECC = strings.ToLower(cfg.Basic.ECC)
    ecc := cfg.Basic.ECC
    if ecc != "native" &amp;&amp; ecc != "cgo" </span><span class="cov1" title="1">{
        return fmt.Errorf("Wrong Basic.ECC(%s), should be native|cgo", ecc)
    }</span>

    <span class="cov7" title="4">return nil</span>
}

func (cfg *ConfModCrypto) CheckConfRemote() error <span class="cov7" title="4">{
    // not need to check 'Remote' section
    if cfg.Basic.RSA != CRYPTO_REMOTE || cfg.Basic.RSA != CRYPTO_HYBRID </span><span class="cov7" title="4">{
        return nil
    }</span>

    // check Address
    <span class="cov0" title="0">if len(cfg.Remote.Address) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("No service names configured")
    }</span>

    // check ConnNum
    <span class="cov0" title="0">if cfg.Remote.ConnNum &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("ConnNum should be larger than 0")
    }</span>

    // check Timeout
    <span class="cov0" title="0">if cfg.Remote.Timeout &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("Timeout should be larger than 0")
    }</span>

    // check PendingNum
    <span class="cov0" title="0">if cfg.Remote.PendingNum &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("PendingNum should be larger than 0")
    }</span>

    // check Format
    <span class="cov0" title="0">cfg.Remote.Format = strings.ToLower(cfg.Remote.Format)
    if cfg.Remote.Format != "raw" || cfg.Remote.Format != "compact" </span><span class="cov0" title="0">{
        return fmt.Errorf("Format should be raw|compact")
    }</span>

    <span class="cov0" title="0">return nil</span>
}

func (cfg *ConfModCrypto) CheckConfHybrid() error <span class="cov7" title="4">{
    // not need to check 'Hybird' section
    if cfg.Basic.RSA != CRYPTO_HYBRID </span><span class="cov1" title="1">{
        return nil
    }</span>

    // check RsaCgoRate
    <span class="cov6" title="3">if cfg.Hybrid.RsaCgoRate == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("RsaCgoRate should be larger than 0")
    }</span>

    // check RsaCgoBurst
    <span class="cov6" title="3">if cfg.Hybrid.RsaCgoBurst == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("RsaCgoBurst should be larger than 0")
    }</span>

    <span class="cov6" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/* crypto_cgo_ecc.go - cgo implementation of elliptic curves cryptography */
/*
modification history
--------------------
2015/3/11, by Sijie Yang, create
*/
/*
DESCRIPTION

*/
package mod_crypto

import (
    "crypto/elliptic"
    "errors"
    "fmt"
    "math/big"
    "unsafe"
)

import (
    "bfe_util"
)

/*
#include "openssl/ec.h"
#include "openssl/obj_mac.h"
*/
import "C"

// reuse buffer to reduce memory usage when bfe_server is not in GC state
var bufPool = bfe_util.NewFixedPool(4096)

func EccGenkeyP256() ([]byte, *big.Int, *big.Int, error) <span class="cov10" title="4">{
    buf := bufPool.GetBlock()
    defer bufPool.PutBlock(buf)

    /* 1. generate EC Key */
    key := C.EC_KEY_new_by_curve_name(C.int(415))// NID_X9_62_prime256v1; 415
    if key == nil {
        return nil, nil, nil, fmt.Errorf("C.EC_KEY_new_by_curve_name error")
    }
    ret := C.EC_KEY_generate_key(key);
    if (ret != 1) {
        C.EC_KEY_free(key)
        return nil, nil, nil, fmt.Errorf("C.EC_KEY_generate_key error");
    }

    /* 2. get private key */
    privKey := C.EC_KEY_get0_private_key(key)
    size := C.BN_bn2bin(privKey, (*C.uchar)(unsafe.Pointer(&amp;buf[0])))
    priv := make([]byte, int(size))
    copy(priv, buf[:int(size)])

    /* 3. get public key */
    pubKey := C.EC_KEY_get0_public_key(key)
    group := C.EC_KEY_get0_group(key)
    ctx := C.BN_CTX_new()
    plen := C.EC_POINT_point2oct(group, pubKey, 4,
                                 (*C.uchar)(unsafe.Pointer(&amp;buf[0])),
                                 C.size_t(len(buf)), ctx)

    curve := elliptic.P256()
    x, y := elliptic.Unmarshal(curve, buf[:plen])

    /* 4. clean up */
    C.EC_KEY_free(key)
    C.BN_CTX_free(ctx)

    return priv, x, y, nil
}

func EccScalarMultP256(Bx, By *big.Int, k []byte) (*big.Int, *big.Int, error) {
    buf := bufPool.GetBlock()
    defer bufPool.PutBlock(buf)

    group := C.EC_GROUP_new_by_curve_name(C.int(415))// NID_X9_62_prime256v1; 415
    p := C.EC_POINT_new(group)
    ctx := C.BN_CTX_new()

    /* 1. preprae for point */
    curve := elliptic.P256()
    pdata := elliptic.Marshal(curve, Bx, By)
    ret := C.EC_POINT_oct2point(group, p, (*C.uchar)(unsafe.Pointer(&amp;pdata[0])),
                                C.size_t(len(pdata)), ctx)
    if ret != 1 {
        C.EC_GROUP_free(group)
        C.EC_POINT_free(p)
        C.BN_CTX_free(ctx)
        return nil, nil, errors.New("openssl EC_POINT_oct2point error")
    }

    /* 2. prepare for scalar */
    s := C.BN_bin2bn((*C.uchar)(unsafe.Pointer(&amp;k[0])), C.int(len(k)), nil)

    /* 3. scalar multiply */
    r := C.EC_POINT_new(group)
    C.EC_POINT_mul(group, r, nil, p, s, ctx)

    /* 4. get result */
    plen := C.EC_POINT_point2oct(group, r, 4, (*C.uchar)(unsafe.Pointer(&amp;buf[0])),
                                 C.size_t(len(buf)), ctx)
    x, y := elliptic.Unmarshal(curve, buf[:plen])

    /* 5. clean up */
    C.EC_GROUP_free(group)
    C.EC_POINT_free(p)
    C.BN_free(s)
    C.EC_POINT_free(r)
    C.BN_CTX_free(ctx)

    return x, y, nil
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/* crypto_cgo_rsa.go - cgo implementation for RSA */
/*
modification history
--------------------
2015/3/9, by Sijie Yang, create
*/
/*
DESCRIPTION

*/
package mod_crypto

/*
#include "openssl/rsa.h"
#include "openssl/x509.h"
*/
import "C"

import (
    "crypto/rsa"
    "crypto/x509"
    "fmt"
    "math/big"
    "unsafe"
)

// RsaDecrypt based on openssl lib
func RsaDecryptCgo(priv *rsa.PrivateKey, c *big.Int) (m *big.Int, err error) <span class="cov10" title="2">{
    // prepare struct for openssl
    key := x509.MarshalPKCS1PrivateKey(priv)
    ciphertext := c.Bytes()

    // parse RSA private key
    pkey := &amp;key[0]
    ppkey := (**C.uchar)(unsafe.Pointer(&amp;pkey))
    klen := C.long(len(key))

    rsa := C.d2i_RSAPrivateKey(nil, ppkey, klen)
    if rsa == nil {
        return nil, fmt.Errorf("openssl d2i_RSAPrivateKey() parse key error")
    }

    // RSA decrypt
    src := (*C.uchar)(unsafe.Pointer(&amp;ciphertext[0]))
    slen := C.int(len(ciphertext))
    plaintext := make([]byte, len(key))
    dst := (*C.uchar)(unsafe.Pointer(&amp;plaintext[0]))
    padding := C.int(3) // no padding

    ret := C.RSA_private_decrypt(slen, src, dst, rsa, padding)
    dlen := int(ret)
    if dlen &lt;= 0 {
        C.RSA_free(rsa)
        return nil, fmt.Errorf("openssl RSA_private_decrypt() err: %d", int(ret))
    }

    // clean up
    C.RSA_free(rsa)

    m = new(big.Int)
    m.SetBytes(plaintext[:dlen])

    return m, nil
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/* crypto_remote.go - remote client for crypto */
/*
modification history
--------------------
2015/3/16, by Guang Yao, create
2015/9/6, by Sijie Yang, modify
  - support remote request in compact format
  - avoid unnecessary marshal of rsa key 
*/
/*
DESCRIPTION
*/

package mod_crypto

import (
    "crypto/md5"
    "crypto/rsa"
    "crypto/x509"
    "encoding/binary"
    "fmt"
    "math/big"
    "net"
    "time"
)

import (
    "www.baidu.com/golang-lib/lru_cache"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/remote"
)

const (
    KEY_CACHE_SIZE = 1000  // size of rsa key cache
)

type RemoteClient struct {
    client   *remote.Client       // crypto client 
    conf     *ConfModCrypto       // crypto config
    keyCache *lru_cache.LRUCache  // cache for rsa key
    state    *module_state2.State
}

func NewRemoteClient(cfg *ConfModCrypto, state *module_state2.State) *RemoteClient <span class="cov10" title="3">{
    r := new(RemoteClient)
    r.conf = cfg
    timeout := time.Duration(cfg.Remote.Timeout) * time.Millisecond
    r.client = remote.NewClientByName(cfg.Remote.Address, timeout, cfg.Remote.ConnNum,
                                      CreateCryptoCodec, cfg.Remote.PendingNum)
    r.keyCache = lru_cache.NewLRUCache(KEY_CACHE_SIZE)
    r.state = state

    return r
}</span>

// RsaDecrypt based on remote crypto-server
func (r *RemoteClient) RsaDecrypt(priv *rsa.PrivateKey, c *big.Int) (m *big.Int, err error) <span class="cov1" title="1">{
    timeout := time.Duration(r.conf.Remote.Timeout) * time.Millisecond
    format := r.conf.Remote.Format

    request := r.createRSADecryptRequest(c, priv, format)
    response := new(RSADecryptResponse)

    // select a client connected to remote server
    sclient, err := r.client.Balance() 
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // process crypto request and response
    <span class="cov1" title="1">instance := sclient.GetInternal()
    err = instance.Call(request, response, timeout)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // Note: if ErrRsaKeyNotExist, it hints that the remote server doesn't 
    // load corresponding rsa key. Just retry request with piggybacking key.
    <span class="cov1" title="1">if format == "compact" &amp;&amp; response.Code == ERR_RSA_KEY_NOT_EXIST </span><span class="cov0" title="0">{
        r.state.Inc("ERR_RSA_REMOTE_KEY_NOT_EXIST", 1)
        request = r.createRSADecryptRequest(c, priv, "raw")
        err = r.repair(sclient, request, response, timeout)
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
    }

    <span class="cov1" title="1">if response.Code != OK </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("CryptoRemote status (%s)", response.Code)
    }</span>

    <span class="cov1" title="1">m = new(big.Int)
    m.SetBytes(response.M)
    return</span>
}

// send crypto request with piggybacking key to specified remote server
// Note: 
// - repair() should be called if given key not found on remote server unexpectedly
// - the remote server should cache key in crypto request
func (r *RemoteClient) repair(sclient *remote.SClient, request *RSADecryptRequest, 
    response *RSADecryptResponse, timeout time.Duration) error <span class="cov0" title="0">{
    conn, err := net.Dial("tcp", sclient.Address)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov0" title="0">client := remote.NewInternalClient(conn, CreateCryptoCodec, 1)
    return client.Call(request, response, timeout)</span>
}

// create RsaDecrypt request
func (r *RemoteClient) createRSADecryptRequest(c *big.Int, key *rsa.PrivateKey, 
    keyType string) *RSADecryptRequest <span class="cov6" title="2">{
    request := &amp;RSADecryptRequest {
        C  : c.Bytes(),
        Key: r.getKeyData(key, keyType),
    }
    return request
}</span>

func (r *RemoteClient) getKeyData(priv *rsa.PrivateKey, keyType string) []byte <span class="cov6" title="2">{
    keyInfo, ok := r.keyCache.Get(priv)
    if !ok </span><span class="cov6" title="2">{
        keyInfo = NewRsaKeyInfo(priv)
        r.keyCache.Add(priv, keyInfo)
    }</span>

    <span class="cov6" title="2">switch keyType </span>{
    <span class="cov0" title="0">case "compact":
        return keyInfo.(*RsaKeyInfo).idData</span>

    <span class="cov1" title="1">case "raw":
        return keyInfo.(*RsaKeyInfo).rawData</span>

    /* never go here */
    <span class="cov1" title="1">default:
        return keyInfo.(*RsaKeyInfo).rawData</span>
    }
}

type RsaKeyInfo struct {
    rawData []byte // bytes of RSA key in pkcs1 format
    idData  []byte // bytes of RSA Key id 
}

func NewRsaKeyInfo(priv *rsa.PrivateKey) *RsaKeyInfo <span class="cov6" title="2">{
    keyInfo := new(RsaKeyInfo)
    key := x509.MarshalPKCS1PrivateKey(priv)

    keyInfo.rawData = make([]byte, len(key)+2)
    binary.BigEndian.PutUint16(keyInfo.rawData[:2], RSA_KEY_PKCS1) // key type
    copy(keyInfo.rawData[2:], key)

    keyInfo.idData = make([]byte, md5.Size+2)
    binary.BigEndian.PutUint16(keyInfo.idData[:2], RSA_KEY_ID) // key type
    id := md5.Sum(key)
    copy(keyInfo.idData[2:], id[:])

    return keyInfo
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">/* crypto_remote_codec.go - serialization/deserialization of crypto message */
/*
modification history
--------------------
2015/3/2, by Sijie Yang, create
*/
/*
DESCRIPTION
    implementation of interface remote.ClientCodec 
*/
package mod_crypto

import (
    "encoding/binary"
    "fmt"
    "io"
)

import (
    "www.baidu.com/golang-lib/remote"
)

import (
    "bfe_util"
)

const (
    MaxReqSize = 2048
    MaxResSize = 512
)

var (
    ErrCodecType = fmt.Errorf("type not CryptoMessage")
)

var (
    reqBufPool = bfe_util.NewFixedPool(MaxResSize)
    resBufPool = bfe_util.NewFixedPool(MaxResSize)
)

type CryptoCodec struct {
    wrc io.ReadWriteCloser

    // body size parsed from header
    bodySize uint32
}

func CreateCryptoCodec(wrc io.ReadWriteCloser) remote.ClientCodec <span class="cov10" title="34">{
    codec := new(CryptoCodec)
    codec.wrc = wrc
    return codec
}</span>

func (c *CryptoCodec) WriteRequest(h *remote.Header, body interface{}) error <span class="cov2" title="2">{
    msg, ok := body.(CryptoMessage)
    if !ok </span><span class="cov0" title="0">{
        return ErrCodecType
    }</span>

    <span class="cov2" title="2">buf := reqBufPool.GetBlock()
    defer reqBufPool.PutBlock(buf)

    buf, err := msg.Marshal(buf)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov2" title="2">h.MessageSize = uint32(len(buf) + remote.HEADER_LEN)
    if err := binary.Write(c.wrc, binary.BigEndian, h); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov2" title="2">_, err = c.wrc.Write(buf)

    return err</span>
}

func (c *CryptoCodec) ReadResponseHeader(h *remote.Header) error <span class="cov10" title="34">{
    err := binary.Read(c.wrc, binary.BigEndian, h)
    if err == nil </span><span class="cov2" title="2">{
        c.bodySize = h.MessageSize - uint32(remote.HEADER_LEN)
    }</span>
    <span class="cov2" title="2">return err</span>
}

func (c *CryptoCodec) ReadResponseBody(body interface{}) error <span class="cov2" title="2">{
    buf := resBufPool.GetBlock()
    defer resBufPool.PutBlock(buf)

    if c.bodySize &lt;= MaxResSize </span><span class="cov2" title="2">{
        buf = buf[:c.bodySize]
    }</span> <span class="cov0" title="0">else {
        // never go here
        buf = make([]byte, c.bodySize)
    }</span>
    <span class="cov2" title="2">_, err := io.ReadFull(c.wrc, buf)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Note: if body is nil, it hints that the response is timeout and
    // should be just read and discarded.
    <span class="cov2" title="2">if body == nil </span><span class="cov0" title="0">{
        return nil
    }</span>

    <span class="cov2" title="2">msg, ok := body.(CryptoMessage)
    if !ok </span><span class="cov0" title="0">{
        return ErrCodecType
    }</span>
    <span class="cov2" title="2">err = msg.Unmarshal(buf)

    return err</span>
}

func (c *CryptoCodec) Close() error <span class="cov0" title="0">{
    return c.wrc.Close()
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">/* crypto_remote_msg.go - msg between crypto-client and crypto-server */
/*
modification history
--------------------
2015/3/2, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_crypto

import (
    "encoding/binary"
    "fmt"
)

// request type
const (
    UNKNOWN         = 0
    RSA_DECRYPT     = 1
    ECC_GEN_KEY     = 2
    ECC_SCALAR_MULT = 3
)

// status code
const (
    OK                             = 1
    ERR_WRONG_FORMAT               = 2
    ERR_UNKNOWN_TYPE               = 3
    ERR_RSA_KEY_DECODE_FAIL        = 4
    ERR_RSA_CIPHERTEXT_DECODE_FAIL = 5
    ERR_RSA_CIPHERTEXT_TOO_LONG    = 6
    ERR_RSA_DECRYPT_FAIL           = 7
    ERR_INTERNAL                   = 8
    ERR_TIMEOUT                    = 9
    ERR_RSA_KEY_NOT_EXIST          = 10
)

// format type of RSA key
const (
    RSA_KEY_PKCS1 = 1
    RSA_KEY_ID    = 2
)

// error info
var (
    ErrBufTooSmall    = fmt.Errorf("buffer is too small")
    ErrUnknownType    = fmt.Errorf("unknown message type")
    ErrWrongLength    = fmt.Errorf("wrong length value")
    ErrIllegalRequest = fmt.Errorf("illegal request")
    ErrBadPrivateKey  = fmt.Errorf("malformed private key")
    ErrBadCiphertext  = fmt.Errorf("malformed ciphertext")
    ErrBadPlaintext   = fmt.Errorf("malformed plaintext")
)

type CryptoMessage interface {
    // encode message
    Marshal([]byte) ([]byte, error)

    // decode message
    Unmarshal(buf []byte) error
}

// request for RSA Decrypt
type RSADecryptRequest struct {
    C   []byte  // ciphertext
    Key []byte  // private key
}

func (req *RSADecryptRequest) Marshal(buf []byte) ([]byte, error) <span class="cov7" title="4">{
    if req.C == nil || req.Key == nil </span><span class="cov0" title="0">{
        return nil, ErrIllegalRequest
    }</span>

    <span class="cov7" title="4">length := 8 + len(req.C) + len(req.Key)
    buf = prepareBuffer(buf, length) 
    cbuf := buf

    // type
    binary.BigEndian.PutUint16(cbuf, RSA_DECRYPT)
    cbuf = cbuf[4:] // skip reserved field

    // ciphertext
    clen := uint16(len(req.C))
    binary.BigEndian.PutUint16(cbuf, clen)
    copy(cbuf[2:2+clen], req.C)
    cbuf = cbuf[2+clen:]

    // key
    klen := uint16(len(req.Key))
    binary.BigEndian.PutUint16(cbuf, klen)
    copy(cbuf[2:2+klen], req.Key)

    return buf, nil</span>
}

func (req *RSADecryptRequest) Unmarshal(buf []byte) error <span class="cov1" title="1">{
    var err error 

    // skip type field and reserved field
    buf = buf[4:]
    
    // ciphertext
    if req.C, buf, err = parseField(buf); err != nil </span><span class="cov0" title="0">{
        return ErrBadCiphertext
    }</span>

    // key
    <span class="cov1" title="1">if req.Key, buf, err = parseField(buf); err != nil </span><span class="cov0" title="0">{
        return ErrBadPrivateKey
    }</span>
    <span class="cov1" title="1">return nil</span>
}

// respones for RSA Decrypt
type RSADecryptResponse struct {
    Code int     // status code
    M    []byte  // plaintext
}

func NewRSADecryptResponse(code int) *RSADecryptResponse <span class="cov0" title="0">{
    resp := new(RSADecryptResponse)
    resp.Code = code
    return resp
}</span>

func (resp *RSADecryptResponse) Marshal(buf []byte) ([]byte, error) <span class="cov6" title="3">{
    if resp.Code == OK &amp;&amp; resp.M == nil </span><span class="cov0" title="0">{
        return nil, ErrIllegalRequest
    }</span>

    <span class="cov6" title="3">length := 4
    if resp.Code == OK </span><span class="cov6" title="3">{
        length += (2 + len(resp.M))
    }</span>

    // if input buffer is too small, just alloc a new buf
    <span class="cov6" title="3">buf = prepareBuffer(buf, length)
    cbuf := buf

    // encode operation type
    binary.BigEndian.PutUint16(cbuf, RSA_DECRYPT)
    cbuf = cbuf[2:] // skip reserved field

    // encode status code
    binary.BigEndian.PutUint16(cbuf, uint16(resp.Code))
    cbuf = cbuf[2:]

    // encode plaintext
    if resp.Code == OK </span><span class="cov6" title="3">{
        mlen := uint16(len(resp.M))
        binary.BigEndian.PutUint16(cbuf, mlen)
        copy(cbuf[2:2+mlen], resp.M)
    }</span>

    <span class="cov6" title="3">return buf, nil</span>
}

func (resp *RSADecryptResponse) Unmarshal(buf []byte) error <span class="cov6" title="3">{
    var err error 

    // skip operation type
    cbuf := buf[2:]

    // status code
    resp.Code = int(binary.BigEndian.Uint16(cbuf))
    if resp.Code == OK </span><span class="cov6" title="3">{
        cbuf = cbuf[2:]

        // plaintext
        if resp.M, buf,  err = parseField(cbuf); err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("malformed plaintext")
        }</span>
    }

    <span class="cov6" title="3">return nil</span>
}

func parseField(buf []byte) ([]byte, []byte, error) <span class="cov8" title="5">{
    if len(buf) &lt; 2 </span><span class="cov0" title="0">{
        return nil, nil, ErrBufTooSmall
    }</span>
    
    // length
    <span class="cov8" title="5">length := int(binary.BigEndian.Uint16(buf[0:2]))
    if length &lt;= 0 </span><span class="cov0" title="0">{
        return nil, nil, ErrWrongLength 
    }</span>
    <span class="cov8" title="5">buf = buf[2:]

    // value
    if len(buf) &lt; length </span><span class="cov0" title="0">{
        return nil, nil, ErrBufTooSmall
    }</span>
    <span class="cov8" title="5">field := buf[:length]
    buf = buf[length:]

    return field, buf, nil</span>
}

func CryptoRequestDecode(body []byte) (interface{}, error) <span class="cov0" title="0">{
    if len(body) &lt; 2 </span><span class="cov0" title="0">{
        return nil, ErrBufTooSmall
    }</span>

    <span class="cov0" title="0">msgType := int(binary.BigEndian.Uint16(body[:2]))
    switch msgType </span>{
    <span class="cov0" title="0">case RSA_DECRYPT:
        request := new(RSADecryptRequest)
        err := request.Unmarshal(body)
        return request, err</span>

    <span class="cov0" title="0">default:
        return nil, ErrUnknownType</span>
    }
}

// Special response for report error status
type CryptoResponseErr struct {
    Type int
    Code int
}

func (resp *CryptoResponseErr) Marshal(buf []byte) ([]byte, error) <span class="cov0" title="0">{
    buf = prepareBuffer(buf, 4)
    binary.BigEndian.PutUint16(buf[:2], uint16(resp.Type))
    binary.BigEndian.PutUint16(buf[2:4], uint16(resp.Code))
    return buf, nil
}</span>

func (resp *CryptoResponseErr) Unmarshal(buf []byte) error <span class="cov0" title="0">{
    if len(buf) &lt; 4 </span><span class="cov0" title="0">{
        return ErrBufTooSmall
    }</span>
    <span class="cov0" title="0">resp.Type = int(binary.BigEndian.Uint16(buf[0:2]))
    resp.Code = int(binary.BigEndian.Uint16(buf[2:4]))
    return nil</span>
}

func prepareBuffer(buf []byte, length int) []byte <span class="cov10" title="7">{
    // if input buffer is too small(or nil), just alloc a new buf
    if len(buf) &lt; length </span><span class="cov8" title="5">{
        return make([]byte, length)
    }</span>
    <span class="cov4" title="2">return buf[:length]</span>
}

</pre>
		
		<pre class="file" id="file73" style="display: none">/* mod_crypto.go - module for speed-up compution in asymmetric cryptography */
/*
modification history
--------------------
2015/3/27, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_crypto

import (
    "crypto/elliptic"
    "crypto/rand"
    "crypto/rsa"
    "fmt"
    "math/big"
    "time"
)

import (
    "www.baidu.com/golang-lib/delay_counter"
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_module"
    "bfe_tls"
    "bfe_util"
)

// setting for DelayCounter
const (
    DC_INTERVAL      = 60    // interval for moving current to past (in s)
    DC_BUCKET_SIZE   = 1     // size of delay counter bucket (in ms)
    DC_BUCKET_NUM    = 10    // number of delay counter bucket
)

var (
    openDebug = false
)

// key for counter of mod_crypto
var COUNTER_KEYS = []string {
    "ECC_SCALAR_MULT_CGO",          // executions of cgo 
    "ECC_SCALAR_MULT",              // total executions of EccScalarMultEccScalarMult
    "ECC_SCALAR_MULT_NATIVE",       // executions of native EccScalarMult
    "ECC_SCALAR_MULT_FAIL",         // fail when execution of EccScalarMult
    "ECC_GEN_KEY_CGO",              // executions of cgo ecc key gen
    "ECC_GEN_KEY",                  // total executions of EccGenerateKey
    "ECC_GEN_KEY_NATIVE",           // executions of native ecc key gen
    "ECC_GEN_KEY_FAIL",             // fail when execution of EccGenerateKey

    "RSA_DECRYPT",                  // total executions of RsaDecrypt
    "RSA_DECRYPT_REMOTE",           // executions of remote RsaDecrypt
    "RSA_DECRYPT_CGO",              // executions of cgo RsaDecrypt
    "RSA_DECRYPT_NATIVE",           // executions of native RsaDecrypt
    "RSA_DECRYPT_HYBRID",           // executions of hybrid RsaDecrypt
    "RSA_DECRYPT_HYBRID_REMOTE",    // executions of hybrid RsaDecrypt (remote)
    "RSA_DECRYPT_HYBRID_CGO",       // executions of hybrid RsaDecrypt (cgo)
    "RSA_DECRYPT_FAIL",             // fail when execution of RsaDecrypt
    "ERR_RSA_CGO_RATE_LIMIT",       // rsa cgo operations exceed rate limit 
    "ERR_RSA_REMOTE_KEY_NOT_EXIST", // remote server not found rsa key
}

type ModuleCrypto struct {
    name   string               // name of module
    state  *module_state2.State // module state

    delayRsaDec *delay_counter.DelayRecent // delay for RsaDecrypt
    delayEccMul *delay_counter.DelayRecent // delay for EccScalarMult
    delayEccGenkey *delay_counter.DelayRecent // delay for EccGenerateKey
    
    conf   *ConfModCrypto       // crypto config
    client *RemoteClient        // crypto client 

    limitRsaCgo *bfe_util.RateLimiter // rate limiter for Cgo RSA operations
}

func NewModuleCrypto() *ModuleCrypto <span class="cov10" title="4">{
    m := new(ModuleCrypto)
    m.name = "mod_crypto"
    m.state = new(module_state2.State)
    
    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_CRYPTO)
    
    m.delayRsaDec = new(delay_counter.DelayRecent)
    m.delayRsaDec.Init(DC_INTERVAL, DC_BUCKET_SIZE, DC_BUCKET_NUM)
    m.delayRsaDec.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_CRYPTO_RSA_DEC_DELAY)

    m.delayEccMul = new(delay_counter.DelayRecent)
    m.delayEccMul.Init(DC_INTERVAL, DC_BUCKET_SIZE, DC_BUCKET_NUM)
    m.delayEccMul.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_CRYPTO_ECC_MUL_DELAY)

    m.delayEccGenkey = new(delay_counter.DelayRecent)
    m.delayEccGenkey.Init(DC_INTERVAL, DC_BUCKET_SIZE, DC_BUCKET_NUM)
    m.delayEccGenkey.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_CRYPTO_ECC_GKY_DELAY)

    return m
}</span>

func (m *ModuleCrypto) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

// initial crypto lib and crypto client
func (m *ModuleCrypto) initCrypto() <span class="cov8" title="3">{
    // register thirdparty implementation for RSA
    rsa.SetRsaAgent(m)

    // register thirdparty implementation for ECC
    elliptic.SetEccAgent(m)
    
    // initial crypto client
    if m.shouldUseClient() </span><span class="cov8" title="3">{
        m.client = NewRemoteClient(m.conf, m.state)
    }</span>
}

func (m *ModuleCrypto) shouldUseClient() bool <span class="cov8" title="3">{
    if m.conf.Basic.RSA == CRYPTO_REMOTE || m.conf.Basic.RSA == CRYPTO_HYBRID </span><span class="cov8" title="3">{
        return true
    }</span>
    <span class="cov0" title="0">return false</span>
}

// initial rate limiter 
func (m *ModuleCrypto) initRateLimiter() <span class="cov8" title="3">{
    if m.conf.Basic.RSA == CRYPTO_HYBRID </span><span class="cov8" title="3">{
        cgoRate := int64(m.conf.Hybrid.RsaCgoRate)
        cgoBurst := int64(m.conf.Hybrid.RsaCgoBurst)
        m.limitRsaCgo = bfe_util.NewRateLimiter(cgoRate, cgoBurst)
    }</span>
}

func (mod *ModuleCrypto) RsaDecrypt(priv *rsa.PrivateKey, c *big.Int) (m *big.Int, err error) <span class="cov8" title="3">{
    mod.state.Inc("RSA_DECRYPT", 1)
    start := time.Now()

    method := mod.conf.Basic.RSA
    switch method </span>{
    <span class="cov0" title="0">case CRYPTO_REMOTE:
        mod.state.Inc("RSA_DECRYPT_REMOTE", 1)
        m, err = mod.client.RsaDecrypt(priv, c)</span>

    <span class="cov1" title="1">case CRYPTO_CGO:
        mod.state.Inc("RSA_DECRYPT_CGO", 1)
        m, err = RsaDecryptCgo(priv, c)</span>

    <span class="cov1" title="1">case CRYPTO_NATIVE:
        mod.state.Inc("RSA_DECRYPT_NATIVE", 1)
        m, err = rsa.Decrypt(nil, priv, c)</span>

    <span class="cov1" title="1">case CRYPTO_HYBRID:
        mod.state.Inc("RSA_DECRYPT_HYBRID", 1)

        // try 'REMOTE' first
        mod.state.Inc("RSA_DECRYPT_HYBRID_REMOTE", 1)
        m, err = mod.client.RsaDecrypt(priv, c)
        if err == nil </span><span class="cov1" title="1">{
             break</span>
        }

        // if failed, fallback to 'CGO'
        // Note: Since RsaDecryptCgo() is not effective enough and may excessively 
        // consume cpu resource,  we had better limit the rate of calling RsaDecryptCgo()
        <span class="cov0" title="0">if !mod.limitRsaCgo.Try() </span><span class="cov0" title="0">{
            mod.state.Inc("ERR_RSA_CGO_RATE_LIMIT", 1)
            err = fmt.Errorf("exceed rate limit for RsaDecryptCgo (remote:%s)", err.Error())
            break</span>
        }
        <span class="cov0" title="0">mod.state.Inc("RSA_DECRYPT_HYBRID_CGO", 1)
        m, err = RsaDecryptCgo(priv, c)</span>

    /* never go here */
    <span class="cov0" title="0">default:
        m, err = mod.client.RsaDecrypt(priv, c)</span>
    }

    <span class="cov8" title="3">mod.delayRsaDec.AddBySub(start, time.Now())
    if err != nil </span><span class="cov0" title="0">{
        mod.state.Inc("RSA_DECRYPT_FAIL", 1)
    }</span>

    <span class="cov8" title="3">if openDebug </span><span class="cov8" title="3">{
        log.Logger.Debug("%s RsaDecrypt(%s) finish(%v), elapse %d us", mod.name, method, err,
                         time.Since(start).Nanoseconds() / 1000)
    }</span>
    <span class="cov8" title="3">return</span>
}

func (mod *ModuleCrypto) EccScalarMult(bigX, bigY *big.Int, scalar []byte, curveId uint16) (
                                       x1 *big.Int, y1 *big.Int, err error) <span class="cov5" title="2">{
    mod.state.Inc("ECC_SCALAR_MULT", 1)
    start := time.Now()

    method := mod.conf.Basic.ECC
    switch method </span>{
    <span class="cov5" title="2">case CRYPTO_CGO:
        mod.state.Inc("ECC_SCALAR_MULT_CGO", 1)
        if curveId == uint16(bfe_tls.CurveP256) </span><span class="cov5" title="2">{
            x1, y1, err = EccScalarMultP256(bigX, bigY, scalar)
        }</span> <span class="cov0" title="0">else {
            // never go here 
            x1, y1, err = nil, nil, fmt.Errorf("unsupported curve[%d] for CGO ScalarMult", curveId)
        }</span>

    <span class="cov0" title="0">case CRYPTO_NATIVE:
        mod.state.Inc("ECC_SCALAR_MULT_NATIVE", 1)
        fallthrough</span>

    <span class="cov0" title="0">default:
        mod.state.Inc("ECC_SCALAR_MULT_DEFAULT", 1)
        // Note: will fallback to native implementation
        x1, y1, err = nil, nil, fmt.Errorf("fallback to native implementation")</span>  
    }

    <span class="cov5" title="2">mod.delayEccMul.AddBySub(start, time.Now())
    if openDebug </span><span class="cov5" title="2">{
        log.Logger.Debug("%s EccScalarMultP256(%s) finish(%v), elapse %d us", mod.name, method, err,
                         time.Since(start).Nanoseconds() / 1000)
    }</span>
    <span class="cov5" title="2">return</span>
}

func (mod *ModuleCrypto) EccGenerateKey(curveId uint16) (key []byte, x *big.Int, y *big.Int, err error) <span class="cov8" title="3">{
    mod.state.Inc("ECC_GEN_KEY", 1)
    start := time.Now()
    
    method := mod.conf.Basic.ECC
    switch method </span>{
    <span class="cov5" title="2">case CRYPTO_CGO:
        mod.state.Inc("ECC_GEN_KEY_CGO", 1)
        if curveId == uint16(bfe_tls.CurveP256) </span><span class="cov1" title="1">{
            key, x, y, err = EccGenkeyP256()
        }</span> <span class="cov1" title="1">else {
            key, x, y, err = nil, nil, nil, fmt.Errorf("unsupported curve[%d] for CGO generate key", curveId)
        }</span>

    <span class="cov1" title="1">case CRYPTO_NATIVE:
        mod.state.Inc("ECC_GEN_KEY_NATIVE", 1)
        curve, _ := bfe_tls.CurveForCurveID(bfe_tls.CurveID(curveId))
        if curve == nil </span><span class="cov0" title="0">{
            key, x, y, err = nil, nil, nil, fmt.Errorf("unknown curveId[%d]", curveId)
        }</span> <span class="cov1" title="1">else {
            key, x, y, err = elliptic.GenerateKeyNative(curve, rand.Reader)
        }</span>

    <span class="cov0" title="0">default:
        /* never go here */
        mod.state.Inc("ECC_GEN_KEY_DEFAULT", 1)
        curve, _ := bfe_tls.CurveForCurveID(bfe_tls.CurveID(curveId))
        if curve == nil </span><span class="cov0" title="0">{
            key, x, y, err = nil, nil, nil, fmt.Errorf("unknown curveId[%d]", curveId)
        }</span> <span class="cov0" title="0">else {
            key, x, y, err = elliptic.GenerateKeyNative(curve, rand.Reader)
        }</span>
    }

    <span class="cov8" title="3">mod.delayEccGenkey.AddBySub(start, time.Now())

    if err != nil </span><span class="cov1" title="1">{
        mod.state.Inc("ECC_GEN_KEY_FAIL", 1)      
    }</span>

    <span class="cov8" title="3">if openDebug </span><span class="cov8" title="3">{
        log.Logger.Debug("%s EccGenerateKeyP256(%s) finish(%v), elapse %d us", mod.name, method, err,
                         time.Since(start).Nanoseconds() / 1000)
    }</span>
    <span class="cov8" title="3">return</span>
}

func (m *ModuleCrypto) Attr() map[string]interface{} <span class="cov1" title="1">{
    // reload items
    reloadEntries := []string {
    }

    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
        m.name + ".delay_rsa_dec": bfe_basic.MON_TYPE_DELAY_RECENT,
        m.name + ".delay_ecc_mul": bfe_basic.MON_TYPE_DELAY_RECENT,
        m.name + ".delay_ecc_genkey": bfe_basic.MON_TYPE_DELAY_RECENT,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD : reloadEntries,
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>

func (m *ModuleCrypto) getState() *module_state2.StateData <span class="cov1" title="1">{
    return m.state.GetAll()
}</span>

func (m *ModuleCrypto) getDelayRsaDec() *delay_counter.DelayOutput <span class="cov0" title="0">{
    delayOuput := m.delayRsaDec.Get()
    return &amp;delayOuput
}</span>

func (m *ModuleCrypto) getDelayEccMul() *delay_counter.DelayOutput <span class="cov0" title="0">{
    delayOuput := m.delayEccMul.Get()
    return &amp;delayOuput
}</span>

func (m *ModuleCrypto) getDelayEccGenKey() *delay_counter.DelayOutput <span class="cov0" title="0">{
    delayOuput := m.delayEccGenkey.Get()
    return &amp;delayOuput
}</span>

// all monitor handlers
func (m *ModuleCrypto) monitorHandlers() map[string]interface{} <span class="cov10" title="4">{
    handlers := map[string]interface{} {
        m.name: web_monitor.CreateStateDataHandler(m.getState),
        m.name + ".delay_rsa_dec": web_monitor.CreateDelayOutputHandler(m.getDelayRsaDec),
        m.name + ".delay_ecc_mul": web_monitor.CreateDelayOutputHandler(m.getDelayEccMul),
        m.name + ".delay_ecc_genkey": web_monitor.CreateDelayOutputHandler(m.getDelayEccGenKey),
    }
    return handlers
}</span>

// all reload handlers
func (m *ModuleCrypto) reloadHandlers() map[string]interface{} <span class="cov0" title="0">{
    handlers := map[string]interface{} {
    }
    return handlers
}</span>

func (m *ModuleCrypto) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                           cr string) error <span class="cov8" title="3">{
    var conf *ConfModCrypto
    var err error

    // load module config
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>
    <span class="cov8" title="3">openDebug = conf.Log.OpenDebug
    m.conf = conf

    // register thirdparty crypto implementation
    m.initCrypto()

    m.initRateLimiter()

    // register web handler for monitor
    err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov8" title="3">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>
    // register web handler for reload
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/* conf_mod_decrypt_uri.go - config for mod_decrypt_uri */
/*
modification history
--------------------
2014/7/23, by Weiwei, create
*/
/*
DESCRIPTION
*/
package mod_decrypt_uri

import (
        "errors"
)

import (
    "code.google.com/p/gcfg"
        "www.baidu.com/golang-lib/conf_path"
        "www.baidu.com/golang-lib/log"
)

var ErrPathNotSet = errors.New("decrypt conf path not set")

type ConfModDecryptUri struct {
        Basic struct {
                Path string
        }

    Log struct {
        OpenDebug bool
    }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModDecryptUri, error) <span class="cov0" title="0">{
    var err error
    var cfg ConfModDecryptUri

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_access
    <span class="cov0" title="0">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov0" title="0">return &amp;cfg, nil</span>
}

func (cfg *ConfModDecryptUri) Check(confRoot string) error <span class="cov0" title="0">{
        if cfg.Basic.Path == "" </span><span class="cov0" title="0">{
                log.Logger.Error("ModDecrypt Path not set")
                return ErrPathNotSet
        }</span>

        <span class="cov0" title="0">cfg.Basic.Path = conf_path.ConfPathProc(cfg.Basic.Path, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/* decrypt_uri_conf_load.go - load decrypt uri  */
/*
modification history
--------------------
2014/7/8, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_decrypt_uri

import (
    "fmt"
    "sync"
)

import (
    "bfe_util"
)

type DecryptConfTable struct {
        mutex        sync.Mutex
        decryptConf map[string]*DecryptConf
}

type DecryptConfFile struct {
        DecryptUri   *bool
        DecryptRefer *bool

        Key1 *string
        Key2 *string

        BakKey1 *string
        BakKey2 *string
}

func (rawDecryptConf *DecryptConfFile) Check() error <span class="cov1" title="1">{
        // here just check if all field is not nil
        return bfe_util.CheckNilField(*rawDecryptConf, false)
}</span>

// generate from bfe_conf.ConfModDecryptUri
type DecryptConf struct {
        DecryptUri   bool
        DecryptRefer bool

        // decryption needs two key, key1 key2
        Key1 []byte
        Key2 []byte

        // if decrypt using key1|key2 failed, try use bakkey1|bakkey2 to decrypt
        BakKey1 []byte
        BakKey2 []byte
}

// str to []byte whose underlying array terminate with '\0'
// return []byte don't contain terminating '\0'
// typically used with cgo
func strToByteZeroTerm(str string) []byte <span class="cov10" title="4">{
    bZeroTerm := make([]byte, 0, len(str)+1)
    bZeroTerm = append(bZeroTerm, str...)
    return bZeroTerm
}</span>

func NewDecryptConf(conf *DecryptConfFile) *DecryptConf <span class="cov1" title="1">{
        decryptConf := &amp;DecryptConf{
                DecryptUri:   *conf.DecryptUri,
                DecryptRefer: *conf.DecryptRefer,
                Key1:         strToByteZeroTerm(*conf.Key1),
                Key2:         strToByteZeroTerm(*conf.Key2),
        }

        if conf.BakKey1 != nil &amp;&amp; conf.BakKey2 != nil </span><span class="cov1" title="1">{
                decryptConf.BakKey1 = strToByteZeroTerm(*conf.BakKey1)
                decryptConf.BakKey2 = strToByteZeroTerm(*conf.BakKey2)
        }</span>

        <span class="cov1" title="1">return decryptConf</span>
}

func checkDecryptConfFile(conf map[string] *DecryptConfFile) error <span class="cov1" title="1">{
        // cluster decrypt conf check 
        for cluster, cluster_conf := range conf </span><span class="cov1" title="1">{
                if err := cluster_conf.Check(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cluster %s decrypt conf error %s", cluster, err.Error())
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (decTable *DecryptConfTable) loadConfig(path string) error <span class="cov1" title="1">{
        var conf map[string]*DecryptConfFile

        if err := bfe_util.LoadJsonFile(path, &amp;conf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load decrypt config error, %s", err.Error())
        }</span>

        // check configure
        <span class="cov1" title="1">if err := checkDecryptConfFile(conf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">newDecryptConf := make(map[string]*DecryptConf)
        for cluster, clusterConf := range conf </span><span class="cov1" title="1">{
                newDecryptConf[cluster] = NewDecryptConf(clusterConf)
        }</span>

        <span class="cov1" title="1">decTable.mutex.Lock()
        decTable.decryptConf = newDecryptConf
        decTable.mutex.Unlock()

        return nil</span>
}

func (decTable *DecryptConfTable) get(clusterName string) *DecryptConf <span class="cov1" title="1">{
        decTable.mutex.Lock()
        defer decTable.mutex.Unlock()

        return decTable.decryptConf[clusterName]
}</span>

</pre>
		
		<pre class="file" id="file76" style="display: none">/* ps_se_enc_linux.go - decrypt cbinding for linux  */
/*
modification history
--------------------
2014/7/23, by Weiwei, create
*/
/*
DESCRIPTION:
*/

package enc

/*
#cgo pkg-config: 
#include &lt;enc_for_go.h&gt;
#include &lt;stdlib.h&gt;
*/
import "C"

import (
    "bytes"
    "errors"
    "sync"
    "unsafe"
)

const (
    // decrypt buffer size
    MAX_DECRYPT_LEN = 4096
)

// decrypt pool
var decryptPool sync.Pool

func newDecryptBuf() []byte <span class="cov10" title="3">{
    if v := decryptPool.Get(); v != n</span><span class="cov6" title="2">il {
        return v.([]byte)
  </span>  }

 <span class="cov1" title="1">   return make([]byte, MAX_DECRYPT_L</span>EN)
}

func putDecryptBuf(buf []byte) <span class="cov10" title="3">{
    decryptPool.Put(buf)
}</span>

func GetDecryptionUrl(encryptionUrl string, encryKeyStr []byte, ivec []byte,
        flag int) (string, <span class="cov10" title="3">error) {
    // buf to put decrypt url
    decrypt := newDecryptBuf()
    defer putDecryptBuf(decrypt)

    ceu := C.CString(encryptionUrl)

    err := C.Decrypt((*C.char)(unsafe.Pointer(&amp;decrypt[0])),
                 C.int(MAX_DECRYPT_LEN),
                 ceu,
                 (*C.char)(unsafe.Pointer(&amp;encryKeyStr[0])),
                 (*C.uchar)(unsafe.Pointer(&amp;ivec[0])),
                 C.int(flag),
                )

    C.free(unsafe.Pointer(ceu))

    if err !=</span><span class="cov1" title="1"> 0 {
        return "", errors.New("decrype failed")
    }

    n := bytes.Index(decrypt, []byte{0})

    return string(decrypt[:n]), nil
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/* mod_decrypt_uri.go - module for decrypt  */
/*
modification history
--------------------
2014/7/23, by Weiwei, create
*/
/*
DESCRIPTION:
        provide uri and referer decryption when flag(DecryptUri/DecryptRefer) is set.
        Decrypt implementation is c-binding of ps/se/enc module.

        Each cluster (NOT PRODUCT) has a seperate decrypt configuration (need decrypt/decrypt keys).
*/

package mod_decrypt_uri

import (
        "errors"
        "fmt"
        "net/url"
        "strings"
)

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
        "bfe_modules/mod_decrypt_uri/enc"
)

var ErrNoDecrypt = errors.New("no need decrypt")

type ModuleDecryptUri struct {
        name string // name of module

        conf         *ConfModDecryptUri
        path         string // decrypt configure path
        decryptTable *DecryptConfTable
}

var (
    openDebug = false
)

func decryptDebug(format string, a ...interface{}) <span class="cov4" title="2">{
        if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug(format, a...)
        }</span>
}

func NewModuleDecryptUri() *ModuleDecryptUri <span class="cov1" title="1">{
        m := new(ModuleDecryptUri)
        m.name = "mod_decrypt_uri"
        m.decryptTable = new(DecryptConfTable)
        return m
}</span>

func (m *ModuleDecryptUri) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleDecryptUri) Attr() map[string]interface{} <span class="cov0" title="0">{
    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD: []string {m.name}, // reload items
    }
}</span>

// loadConfig is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleDecryptUri) loadConfig(query url.Values) error <span class="cov1" title="1">{
    // get file path
    path := query.Get("path")
    if path == "" </span><span class="cov1" title="1">{
        // default to m.path
        path = m.path
    }</span>

        // load decrypt configure table
        <span class="cov1" title="1">return m.decryptTable.loadConfig(path)</span>
}

func (m *ModuleDecryptUri) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var conf *ConfModDecryptUri

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleDecryptUri) init(conf *ConfModDecryptUri, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov0" title="0">{
        m.path = conf.Basic.Path

    // debug switch
    openDebug = conf.Log.OpenDebug

        if err := m.loadConfig(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfig(): %s", err.Error())
        }</span>

        // register handler
        // for after location
        <span class="cov0" title="0">err := cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.decryptHandler)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%s.Init(): AddFilter(m.decryptHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfig)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfig): %s", m.name, err.Error())
        }</span>

        // save conf pointer
        <span class="cov0" title="0">m.conf = conf

        return nil</span>
}

// if normal key decrypt failed, use bakkey to decrypt
func wwwDecrypt(encryption string, conf *DecryptConf) (string, error) <span class="cov10" title="8">{
        // decrypt use first priority keys
        decryption, err := enc.GetDecryptionUrl(encryption, conf.Key1, conf.Key2, 0)

        // if failed and bakkey is not empty, use bakkey to decrypt
        if err != nil &amp;&amp; conf.BakKey1 != nil &amp;&amp; conf.BakKey2 != nil &amp;&amp;
                len(conf.BakKey1) != 0 &amp;&amp; len(conf.BakKey2) != 0 </span><span class="cov1" title="1">{
                decryption, err = enc.GetDecryptionUrl(encryption, conf.BakKey1, conf.BakKey2, 0)
        }</span>
    
        <span class="cov10" title="8">return decryption, err</span>
}

func decrypt(u *url.URL, conf *DecryptConf) (string, error) <span class="cov8" title="6">{
        values, err := url.ParseQuery(u.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="6">encrypt := values.Get("url")
        if u.Path != "/link" || encrypt == "" </span><span class="cov1" title="1">{
                return "", ErrNoDecrypt
        }</span>

        <span class="cov7" title="5">return wwwDecrypt(encrypt, conf)</span>
}

// decrypt refer like link?url=[encrypttext], decrypt encrypttext, the result should also be a url
//  use it as refer
// note: if url contains "www.baidu.com/link?url=", skip decrypt
func decryptRefer(req *bfe_http.Request, conf *DecryptConf) error <span class="cov4" title="2">{
        header := req.Header
        referer := header.Get("Referer")
        if referer == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // don't decrypt the referer www.baidu.com/link?url=xxxx
        <span class="cov4" title="2">if strings.Contains(referer, "www.baidu.com/link?url=") </span><span class="cov1" title="1">{
                return nil
        }</span>

        // parse refer
        <span class="cov1" title="1">referUrl, err := url.Parse(referer)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // decrypt refer
        <span class="cov1" title="1">decryptBuf, err := decrypt(referUrl, conf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">decryptDebug("after decrypt url [%s]", decryptBuf)
        // replace refer
        header.Set("Referer", decryptBuf)
        return nil</span>
}

func decryptUri(req *bfe_http.Request, conf *DecryptConf) error <span class="cov4" title="2">{
        u := req.URL

        decryptBuf, err := decrypt(u, conf)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // parse decrypted url
        <span class="cov1" title="1">fixUrl, err := url.Parse(decryptBuf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // attach previous query params
        <span class="cov1" title="1">u.Path = fixUrl.Path
        values, err := url.ParseQuery(u.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // remove "url=xxx" part.
        <span class="cov1" title="1">values.Del("url")

        // merge the rest part with decrypt query params
        newValues, err := url.ParseQuery(fixUrl.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // merge newValues with prev values
        <span class="cov1" title="1">for k, vs := range newValues </span><span class="cov0" title="0">{
                for _, v := range vs </span><span class="cov0" title="0">{
                        values.Add(k, v)
                }</span>
        }

        <span class="cov1" title="1">u.RawQuery = values.Encode()
        decryptDebug("after decrypt url [%s]", u.String())

        return nil</span>
}

func (m *ModuleDecryptUri) decrypt(req *bfe_basic.Request, conf *DecryptConf) <span class="cov0" title="0">{
        if conf.DecryptRefer </span><span class="cov0" title="0">{
                decryptDebug("start decrypt refer %s", req.HttpRequest.URL.String())
                decryptRefer(req.HttpRequest, conf)
        }</span>

        <span class="cov0" title="0">if conf.DecryptUri </span><span class="cov0" title="0">{
                decryptDebug("start decrypt url %s", req.HttpRequest.URL.String())
                decryptUri(req.HttpRequest, conf)
        }</span>

        <span class="cov0" title="0">return</span>
}

// module call backs
// handler for finish http request
func (m *ModuleDecryptUri) decryptHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
        conf := m.decryptTable.get(req.Route.Product)

        // no decrypt check
        if conf == nil </span><span class="cov0" title="0">{
                decryptDebug("no decrypt found %s", req.Route.Product)
                return bfe_module.BFE_HANDLER_GOON, nil
        }</span>

        <span class="cov0" title="0">m.decrypt(req, conf)

        return bfe_module.BFE_HANDLER_GOON, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/* conf_mod_dict_client.go - config for mod_dict_client */
/*
modification history
--------------------
2014/8/11, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_dict_client

import (
    "errors"
    "fmt"
    "net"
)

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
)

type ConfModDictClient struct {
    DictClient struct {
        Network        string // service network
        Address        string // service address
        ConnectTimeout int    // connect timeout
        Concurrency    int    // num of connections to dict server
        PendingNum     int    // max num of pending requests
    }
    
    CondRules struct {
        Path           string // path of rules configuration file
    }

    Log struct {
        OpenDebug bool
    }
}

func (conf *ConfModDictClient) Check(cr string) error <span class="cov10" title="2">{
    cfg := conf.DictClient
    rulePath := conf.CondRules
    // check server network and address
    if cfg.Network == "unix" </span><span class="cov1" title="1">{
        if cfg.Address == "" </span><span class="cov0" title="0">{
            return fmt.Errorf("address not set")
        }</span>
    } <span class="cov1" title="1">else {
        _, err := net.ResolveTCPAddr(cfg.Network, cfg.Address)
        if err != nil </span><span class="cov1" title="1">{
            return err
        }</span>
    }

    // check pendingnum
    <span class="cov1" title="1">if cfg.PendingNum &gt; 10000 || cfg.PendingNum &lt;= 0 </span><span class="cov0" title="0">{
        return errors.New("pending num shoulud be in [0, 10000)")
    }</span>

    // check concurrency
    <span class="cov1" title="1">if cfg.Concurrency &lt;= 0 </span><span class="cov0" title="0">{
        return errors.New("concurrency not set")
    }</span>

    // check timeout
    <span class="cov1" title="1">if cfg.ConnectTimeout &lt;= 0 </span><span class="cov0" title="0">{
        return errors.New("connect timeout not set")
    }</span>

    // check rules path
    <span class="cov1" title="1">if rulePath.Path == "" </span><span class="cov0" title="0">{
        return errors.New("rules file path not set")
    }</span>
    <span class="cov1" title="1">conf.CondRules.Path = conf_path.ConfPathProc(rulePath.Path, cr)

    return nil</span>
}

func ConfLoad(path string, confRoot string) (*ConfModDictClient, error) <span class="cov10" title="2">{
    var err error
    var conf ConfModDictClient

    // read config from file
    if err = gcfg.ReadFileInto(&amp;conf, path); err != nil </span><span class="cov0" title="0">{
        return &amp;conf, err
    }</span>
    // check conf of mod_dict_client
    <span class="cov10" title="2">err = conf.Check(confRoot)
    if err != nil </span><span class="cov1" title="1">{
        return &amp;conf, err
    }</span>    

    <span class="cov1" title="1">return &amp;conf, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Code generated by protoc-gen-gogo.
// source: bfe_dict_gogo.proto
// DO NOT EDIT!

/*
        Package dict_pb is a generated protocol buffer package.

        It is generated from these files:
                bfe_dict_gogo.proto

        It has these top-level messages:
                DictRequest
                DictResponse
*/
package dict_pb

import proto "code.google.com/p/gogoprotobuf/proto"
import math "math"

// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"

import io "io"
import fmt "fmt"
import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"

import fmt1 "fmt"
import strings "strings"
import reflect "reflect"

import fmt2 "fmt"
import strings1 "strings"
import code_google_com_p_gogoprotobuf_proto1 "code.google.com/p/gogoprotobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect1 "reflect"

import fmt3 "fmt"
import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type DictResponse_ResponseCode int32

const (
        DictResponse_OK                DictResponse_ResponseCode = 0
        DictResponse_ERR_BAD_REQ       DictResponse_ResponseCode = 1
        DictResponse_ERR_WRONG_PRODUCT DictResponse_ResponseCode = 2
        DictResponse_ERR_WRONG_PARAMS  DictResponse_ResponseCode = 3
        DictResponse_ERR_INTERNAL      DictResponse_ResponseCode = 4
)

var DictResponse_ResponseCode_name = map[int32]string{
        0: "OK",
        1: "ERR_BAD_REQ",
        2: "ERR_WRONG_PRODUCT",
        3: "ERR_WRONG_PARAMS",
        4: "ERR_INTERNAL",
}
var DictResponse_ResponseCode_value = map[string]int32{
        "OK":                0,
        "ERR_BAD_REQ":       1,
        "ERR_WRONG_PRODUCT": 2,
        "ERR_WRONG_PARAMS":  3,
        "ERR_INTERNAL":      4,
}

func (x DictResponse_ResponseCode) Enum() *DictResponse_ResponseCode <span class="cov0" title="0">{
        p := new(DictResponse_ResponseCode)
        *p = x
        return p
}</span>
func (x DictResponse_ResponseCode) String() string <span class="cov1" title="2">{
        return proto.EnumName(DictResponse_ResponseCode_name, int32(x))
}</span>
func (x *DictResponse_ResponseCode) UnmarshalJSON(data []byte) error <span class="cov1" title="1">{
        value, err := proto.UnmarshalJSONEnum(DictResponse_ResponseCode_value, data, "DictResponse_ResponseCode")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">*x = DictResponse_ResponseCode(value)
        return nil</span>
}

type DictRequest struct {
        Product          *string `protobuf:"bytes,1,req,name=product" json:"product,omitempty"`
        ClientIP         []byte  `protobuf:"bytes,2,opt,name=clientIP" json:"clientIP,omitempty"`
        BaiduID          []byte  `protobuf:"bytes,3,opt,name=baiduID" json:"baiduID,omitempty"`
        Logid            *uint64 `protobuf:"varint,5,opt,name=logid" json:"logid,omitempty"`
        Ua               []byte  `protobuf:"bytes,6,opt,name=ua" json:"ua,omitempty"`
        IpCookie         []byte  `protobuf:"bytes,7,opt,name=ipCookie" json:"ipCookie,omitempty"`
        XXX_unrecognized []byte  `json:"-"`
}

func (m *DictRequest) Reset()      <span class="cov2" title="5">{ *m = DictRequest{} }</span>
func (*DictRequest) ProtoMessage() <span class="cov0" title="0">{}</span>

func (m *DictRequest) GetProduct() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Product != nil </span><span class="cov0" title="0">{
                return *m.Product
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DictRequest) GetClientIP() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ClientIP
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DictRequest) GetBaiduID() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BaiduID
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DictRequest) GetLogid() uint64 <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Logid != nil </span><span class="cov0" title="0">{
                return *m.Logid
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *DictRequest) GetUa() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Ua
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DictRequest) GetIpCookie() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IpCookie
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DictResponse struct {
        Code             *DictResponse_ResponseCode `protobuf:"varint,1,req,name=code,enum=dict_pb.DictResponse_ResponseCode,def=0" json:"code,omitempty"`
        Message          *string                    `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
        TagsClientIP     []string                   `protobuf:"bytes,3,rep,name=tagsClientIP" json:"tagsClientIP,omitempty"`
        TagsBaiduID      []string                   `protobuf:"bytes,4,rep,name=tagsBaiduID" json:"tagsBaiduID,omitempty"`
        TagsUa           []string                   `protobuf:"bytes,5,rep,name=tagsUa" json:"tagsUa,omitempty"`
        TagsIpCookie     []string                   `protobuf:"bytes,6,rep,name=tagsIpCookie" json:"tagsIpCookie,omitempty"`
        XXX_unrecognized []byte                     `json:"-"`
}

func (m *DictResponse) Reset()      <span class="cov2" title="5">{ *m = DictResponse{} }</span>
func (*DictResponse) ProtoMessage() <span class="cov0" title="0">{}</span>

const Default_DictResponse_Code DictResponse_ResponseCode = DictResponse_OK

func (m *DictResponse) GetCode() DictResponse_ResponseCode <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Code != nil </span><span class="cov0" title="0">{
                return *m.Code
        }</span>
        <span class="cov0" title="0">return Default_DictResponse_Code</span>
}

func (m *DictResponse) GetMessage() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Message != nil </span><span class="cov0" title="0">{
                return *m.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DictResponse) GetTagsClientIP() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TagsClientIP
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DictResponse) GetTagsBaiduID() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TagsBaiduID
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DictResponse) GetTagsUa() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TagsUa
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DictResponse) GetTagsIpCookie() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TagsIpCookie
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov1" title="1">{
        proto.RegisterEnum("dict_pb.DictResponse_ResponseCode", DictResponse_ResponseCode_name, DictResponse_ResponseCode_value)
}</span>
func (m *DictRequest) Unmarshal(data []byte) error <span class="cov2" title="3">{
        l := len(data)
        index := 0
        for index &lt; l </span><span class="cov4" title="24">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov4" title="32">{
                        if index &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov4" title="32">b := data[index]
                        index++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov4" title="24">{
                                break</span>
                        }
                }
                <span class="cov4" title="24">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                switch fieldNum </span>{
                <span class="cov2" title="3">case 1:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
                        }</span>
                        <span class="cov2" title="3">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="4">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="4">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">s := string(data[index:postIndex])
                        m.Product = &amp;s
                        index = postIndex</span>
                <span class="cov2" title="3">case 2:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ClientIP", wireType)
                        }</span>
                        <span class="cov2" title="3">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="3">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="3">b := data[index]
                                index++
                                byteLen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + byteLen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">m.ClientIP = append(m.ClientIP, data[index:postIndex]...)
                        index = postIndex</span>
                <span class="cov2" title="3">case 3:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field BaiduID", wireType)
                        }</span>
                        <span class="cov2" title="3">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="3">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="3">b := data[index]
                                index++
                                byteLen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + byteLen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">m.BaiduID = append(m.BaiduID, data[index:postIndex]...)
                        index = postIndex</span>
                <span class="cov2" title="3">case 5:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Logid", wireType)
                        }</span>
                        <span class="cov2" title="3">var v uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov3" title="15">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov3" title="15">b := data[index]
                                index++
                                v |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">m.Logid = &amp;v</span>
                <span class="cov1" title="2">case 6:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Ua", wireType)
                        }</span>
                        <span class="cov1" title="2">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov1" title="2">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov1" title="2">b := data[index]
                                index++
                                byteLen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov1" title="2">{
                                        break</span>
                                }
                        }
                        <span class="cov1" title="2">postIndex := index + byteLen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov1" title="2">m.Ua = append(m.Ua, data[index:postIndex]...)
                        index = postIndex</span>
                <span class="cov1" title="2">case 7:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field IpCookie", wireType)
                        }</span>
                        <span class="cov1" title="2">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov1" title="2">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov1" title="2">b := data[index]
                                index++
                                byteLen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov1" title="2">{
                                        break</span>
                                }
                        }
                        <span class="cov1" title="2">postIndex := index + byteLen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov1" title="2">m.IpCookie = append(m.IpCookie, data[index:postIndex]...)
                        index = postIndex</span>
                <span class="cov3" title="8">default:
                        var sizeOfWire int
                        for </span><span class="cov3" title="16">{
                                sizeOfWire++
                                wire &gt;&gt;= 7
                                if wire == 0 </span><span class="cov3" title="8">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="8">index -= sizeOfWire
                        skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov3" title="8">if (index + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="8">m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
                        index += skippy</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}
func (m *DictResponse) Unmarshal(data []byte) error <span class="cov2" title="3">{
        l := len(data)
        index := 0
        for index &lt; l </span><span class="cov5" title="60">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov5" title="66">{
                        if index &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov5" title="66">b := data[index]
                        index++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov5" title="60">{
                                break</span>
                        }
                }
                <span class="cov5" title="60">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                switch fieldNum </span>{
                <span class="cov2" title="3">case 1:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
                        }</span>
                        <span class="cov2" title="3">var v DictResponse_ResponseCode
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="3">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="3">b := data[index]
                                index++
                                v |= (DictResponse_ResponseCode(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">m.Code = &amp;v</span>
                <span class="cov2" title="3">case 2:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
                        }</span>
                        <span class="cov2" title="3">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="5">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="5">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">s := string(data[index:postIndex])
                        m.Message = &amp;s
                        index = postIndex</span>
                <span class="cov2" title="6">case 3:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TagsClientIP", wireType)
                        }</span>
                        <span class="cov2" title="6">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov3" title="12">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov3" title="12">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="6">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="6">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="6">m.TagsClientIP = append(m.TagsClientIP, string(data[index:postIndex]))
                        index = postIndex</span>
                <span class="cov3" title="9">case 4:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TagsBaiduID", wireType)
                        }</span>
                        <span class="cov3" title="9">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov3" title="13">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov3" title="13">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov3" title="9">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="9">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="9">m.TagsBaiduID = append(m.TagsBaiduID, string(data[index:postIndex]))
                        index = postIndex</span>
                <span class="cov3" title="16">case 5:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TagsUa", wireType)
                        }</span>
                        <span class="cov3" title="16">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov4" title="25">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov4" title="25">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov3" title="16">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="16">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="16">m.TagsUa = append(m.TagsUa, string(data[index:postIndex]))
                        index = postIndex</span>
                <span class="cov3" title="17">case 6:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TagsIpCookie", wireType)
                        }</span>
                        <span class="cov3" title="17">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov4" title="25">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov4" title="25">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov3" title="17">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="17">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="17">m.TagsIpCookie = append(m.TagsIpCookie, string(data[index:postIndex]))
                        index = postIndex</span>
                <span class="cov2" title="6">default:
                        var sizeOfWire int
                        for </span><span class="cov3" title="12">{
                                sizeOfWire++
                                wire &gt;&gt;= 7
                                if wire == 0 </span><span class="cov2" title="6">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="6">index -= sizeOfWire
                        skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="6">if (index + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="6">m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
                        index += skippy</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}
func (this *DictRequest) String() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings.Join([]string{`&amp;DictRequest{`,
                `Product:` + valueToStringBfeDictGogo(this.Product) + `,`,
                `ClientIP:` + valueToStringBfeDictGogo(this.ClientIP) + `,`,
                `BaiduID:` + valueToStringBfeDictGogo(this.BaiduID) + `,`,
                `Logid:` + valueToStringBfeDictGogo(this.Logid) + `,`,
                `Ua:` + valueToStringBfeDictGogo(this.Ua) + `,`,
                `IpCookie:` + valueToStringBfeDictGogo(this.IpCookie) + `,`,
                `XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
                `}`,
        }, "")
        return s</span>
}
func (this *DictResponse) String() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings.Join([]string{`&amp;DictResponse{`,
                `Code:` + valueToStringBfeDictGogo(this.Code) + `,`,
                `Message:` + valueToStringBfeDictGogo(this.Message) + `,`,
                `TagsClientIP:` + fmt1.Sprintf("%v", this.TagsClientIP) + `,`,
                `TagsBaiduID:` + fmt1.Sprintf("%v", this.TagsBaiduID) + `,`,
                `TagsUa:` + fmt1.Sprintf("%v", this.TagsUa) + `,`,
                `TagsIpCookie:` + fmt1.Sprintf("%v", this.TagsIpCookie) + `,`,
                `XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
                `}`,
        }, "")
        return s</span>
}
func valueToStringBfeDictGogo(v interface{}) string <span class="cov3" title="16">{
        rv := reflect.ValueOf(v)
        if rv.IsNil() </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov3" title="16">pv := reflect.Indirect(rv).Interface()
        return fmt1.Sprintf("*%v", pv)</span>
}
func (m *DictRequest) Size() (n int) <span class="cov2" title="7">{
        var l int
        _ = l
        if m.Product != nil </span><span class="cov2" title="7">{
                l = len(*m.Product)
                n += 1 + l + sovBfeDictGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.ClientIP != nil </span><span class="cov2" title="7">{
                l = len(m.ClientIP)
                n += 1 + l + sovBfeDictGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.BaiduID != nil </span><span class="cov2" title="7">{
                l = len(m.BaiduID)
                n += 1 + l + sovBfeDictGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.Logid != nil </span><span class="cov2" title="7">{
                n += 1 + sovBfeDictGogo(uint64(*m.Logid))
        }</span>
        <span class="cov2" title="7">if m.Ua != nil </span><span class="cov1" title="2">{
                l = len(m.Ua)
                n += 1 + l + sovBfeDictGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.IpCookie != nil </span><span class="cov2" title="6">{
                l = len(m.IpCookie)
                n += 1 + l + sovBfeDictGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.XXX_unrecognized != nil </span><span class="cov2" title="3">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="7">return n</span>
}
func (m *DictResponse) Size() (n int) <span class="cov2" title="7">{
        var l int
        _ = l
        if m.Code != nil </span><span class="cov2" title="7">{
                n += 1 + sovBfeDictGogo(uint64(*m.Code))
        }</span>
        <span class="cov2" title="7">if m.Message != nil </span><span class="cov2" title="3">{
                l = len(*m.Message)
                n += 1 + l + sovBfeDictGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if len(m.TagsClientIP) &gt; 0 </span><span class="cov1" title="2">{
                for _, s := range m.TagsClientIP </span><span class="cov2" title="6">{
                        l = len(s)
                        n += 1 + l + sovBfeDictGogo(uint64(l))
                }</span>
        }
        <span class="cov2" title="7">if len(m.TagsBaiduID) &gt; 0 </span><span class="cov1" title="1">{
                for _, s := range m.TagsBaiduID </span><span class="cov3" title="9">{
                        l = len(s)
                        n += 1 + l + sovBfeDictGogo(uint64(l))
                }</span>
        }
        <span class="cov2" title="7">if len(m.TagsUa) &gt; 0 </span><span class="cov2" title="7">{
                for _, s := range m.TagsUa </span><span class="cov4" title="28">{
                        l = len(s)
                        n += 1 + l + sovBfeDictGogo(uint64(l))
                }</span>
        }
        <span class="cov2" title="7">if len(m.TagsIpCookie) &gt; 0 </span><span class="cov2" title="7">{
                for _, s := range m.TagsIpCookie </span><span class="cov4" title="25">{
                        l = len(s)
                        n += 1 + l + sovBfeDictGogo(uint64(l))
                }</span>
        }
        <span class="cov2" title="7">if m.XXX_unrecognized != nil </span><span class="cov1" title="2">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="7">return n</span>
}

func sovBfeDictGogo(x uint64) (n int) <span class="cov5" title="114">{
        for </span><span class="cov6" title="180">{
                n++
                x &gt;&gt;= 7
                if x == 0 </span><span class="cov5" title="114">{
                        break</span>
                }
        }
        <span class="cov5" title="114">return n</span>
}
func sozBfeDictGogo(x uint64) (n int) <span class="cov0" title="0">{
        return sovBfeDictGogo(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func NewPopulatedDictRequest(r randyBfeDictGogo, easy bool) *DictRequest <span class="cov3" title="9">{
        this := &amp;DictRequest{}
        v1 := randStringBfeDictGogo(r)
        this.Product = &amp;v1
        if r.Intn(10) != 0 </span><span class="cov3" title="8">{
                v2 := r.Intn(100)
                this.ClientIP = make([]byte, v2)
                for i := 0; i &lt; v2; i++ </span><span class="cov6" title="385">{
                        this.ClientIP[i] = byte(r.Intn(256))
                }</span>
        }
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov3" title="9">{
                v3 := r.Intn(100)
                this.BaiduID = make([]byte, v3)
                for i := 0; i &lt; v3; i++ </span><span class="cov6" title="285">{
                        this.BaiduID[i] = byte(r.Intn(256))
                }</span>
        }
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov3" title="9">{
                v4 := uint64(r.Uint32())
                this.Logid = &amp;v4
        }</span>
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov2" title="6">{
                v5 := r.Intn(100)
                this.Ua = make([]byte, v5)
                for i := 0; i &lt; v5; i++ </span><span class="cov6" title="324">{
                        this.Ua[i] = byte(r.Intn(256))
                }</span>
        }
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov2" title="6">{
                v6 := r.Intn(100)
                this.IpCookie = make([]byte, v6)
                for i := 0; i &lt; v6; i++ </span><span class="cov6" title="340">{
                        this.IpCookie[i] = byte(r.Intn(256))
                }</span>
        }
        <span class="cov3" title="9">if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov2" title="5">{
                this.XXX_unrecognized = randUnrecognizedBfeDictGogo(r, 8)
        }</span>
        <span class="cov3" title="9">return this</span>
}

func NewPopulatedDictResponse(r randyBfeDictGogo, easy bool) *DictResponse <span class="cov3" title="9">{
        this := &amp;DictResponse{}
        v7 := DictResponse_ResponseCode([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
        this.Code = &amp;v7
        if r.Intn(10) != 0 </span><span class="cov3" title="8">{
                v8 := randStringBfeDictGogo(r)
                this.Message = &amp;v8
        }</span>
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov3" title="9">{
                v9 := r.Intn(10)
                this.TagsClientIP = make([]string, v9)
                for i := 0; i &lt; v9; i++ </span><span class="cov4" title="32">{
                        this.TagsClientIP[i] = randStringBfeDictGogo(r)
                }</span>
        }
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov2" title="7">{
                v10 := r.Intn(10)
                this.TagsBaiduID = make([]string, v10)
                for i := 0; i &lt; v10; i++ </span><span class="cov4" title="41">{
                        this.TagsBaiduID[i] = randStringBfeDictGogo(r)
                }</span>
        }
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov3" title="9">{
                v11 := r.Intn(10)
                this.TagsUa = make([]string, v11)
                for i := 0; i &lt; v11; i++ </span><span class="cov4" title="45">{
                        this.TagsUa[i] = randStringBfeDictGogo(r)
                }</span>
        }
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov3" title="9">{
                v12 := r.Intn(10)
                this.TagsIpCookie = make([]string, v12)
                for i := 0; i &lt; v12; i++ </span><span class="cov4" title="42">{
                        this.TagsIpCookie[i] = randStringBfeDictGogo(r)
                }</span>
        }
        <span class="cov3" title="9">if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov2" title="4">{
                this.XXX_unrecognized = randUnrecognizedBfeDictGogo(r, 7)
        }</span>
        <span class="cov3" title="9">return this</span>
}

type randyBfeDictGogo interface {
        Float32() float32
        Float64() float64
        Int63() int64
        Int31() int32
        Uint32() uint32
        Intn(n int) int
}

func randUTF8RuneBfeDictGogo(r randyBfeDictGogo) rune <span class="cov10" title="8927">{
        res := rune(r.Uint32() % 1112064)
        if 55296 &lt;= res </span><span class="cov9" title="8477">{
                res += 2047
        }</span>
        <span class="cov10" title="8927">return res</span>
}
func randStringBfeDictGogo(r randyBfeDictGogo) string <span class="cov6" title="177">{
        v13 := r.Intn(100)
        tmps := make([]rune, v13)
        for i := 0; i &lt; v13; i++ </span><span class="cov10" title="8927">{
                tmps[i] = randUTF8RuneBfeDictGogo(r)
        }</span>
        <span class="cov6" title="177">return string(tmps)</span>
}
func randUnrecognizedBfeDictGogo(r randyBfeDictGogo, maxFieldNumber int) (data []byte) <span class="cov3" title="9">{
        l := r.Intn(5)
        for i := 0; i &lt; l; i++ </span><span class="cov4" title="25">{
                wire := r.Intn(4)
                if wire == 3 </span><span class="cov2" title="3">{
                        wire = 5
                }</span>
                <span class="cov4" title="25">fieldNumber := maxFieldNumber + r.Intn(100)
                data = randFieldBfeDictGogo(data, r, fieldNumber, wire)</span>
        }
        <span class="cov3" title="9">return data</span>
}
func randFieldBfeDictGogo(data []byte, r randyBfeDictGogo, fieldNumber int, wire int) []byte <span class="cov4" title="25">{
        key := uint32(fieldNumber)&lt;&lt;3 | uint32(wire)
        switch wire </span>{
        <span class="cov3" title="12">case 0:
                data = encodeVarintPopulateBfeDictGogo(data, uint64(key))
                v14 := r.Int63()
                if r.Intn(2) == 0 </span><span class="cov2" title="6">{
                        v14 *= -1
                }</span>
                <span class="cov3" title="12">data = encodeVarintPopulateBfeDictGogo(data, uint64(v14))</span>
        <span class="cov2" title="5">case 1:
                data = encodeVarintPopulateBfeDictGogo(data, uint64(key))
                data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))</span>
        <span class="cov2" title="5">case 2:
                data = encodeVarintPopulateBfeDictGogo(data, uint64(key))
                ll := r.Intn(100)
                data = encodeVarintPopulateBfeDictGogo(data, uint64(ll))
                for j := 0; j &lt; ll; j++ </span><span class="cov5" title="148">{
                        data = append(data, byte(r.Intn(256)))
                }</span>
        <span class="cov2" title="3">default:
                data = encodeVarintPopulateBfeDictGogo(data, uint64(key))
                data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))</span>
        }
        <span class="cov4" title="25">return data</span>
}
func encodeVarintPopulateBfeDictGogo(data []byte, v uint64) []byte <span class="cov4" title="42">{
        for v &gt;= 1&lt;&lt;7 </span><span class="cov5" title="126">{
                data = append(data, uint8(uint64(v)&amp;0x7f|0x80))
                v &gt;&gt;= 7
        }</span>
        <span class="cov4" title="42">data = append(data, uint8(v))
        return data</span>
}
func (m *DictRequest) Marshal() (data []byte, err error) <span class="cov2" title="5">{
        size := m.Size()
        data = make([]byte, size)
        n, err := m.MarshalTo(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="5">return data[:n], nil</span>
}

func (m *DictRequest) MarshalTo(data []byte) (n int, err error) <span class="cov2" title="6">{
        var i int
        _ = i
        var l int
        _ = l
        if m.Product != nil </span><span class="cov2" title="6">{
                data[i] = 0xa
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(len(*m.Product)))
                i += copy(data[i:], *m.Product)
        }</span>
        <span class="cov2" title="6">if m.ClientIP != nil </span><span class="cov2" title="6">{
                data[i] = 0x12
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(len(m.ClientIP)))
                i += copy(data[i:], m.ClientIP)
        }</span>
        <span class="cov2" title="6">if m.BaiduID != nil </span><span class="cov2" title="6">{
                data[i] = 0x1a
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(len(m.BaiduID)))
                i += copy(data[i:], m.BaiduID)
        }</span>
        <span class="cov2" title="6">if m.Logid != nil </span><span class="cov2" title="6">{
                data[i] = 0x28
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(*m.Logid))
        }</span>
        <span class="cov2" title="6">if m.Ua != nil </span><span class="cov1" title="2">{
                data[i] = 0x32
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(len(m.Ua)))
                i += copy(data[i:], m.Ua)
        }</span>
        <span class="cov2" title="6">if m.IpCookie != nil </span><span class="cov2" title="5">{
                data[i] = 0x3a
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(len(m.IpCookie)))
                i += copy(data[i:], m.IpCookie)
        }</span>
        <span class="cov2" title="6">if m.XXX_unrecognized != nil </span><span class="cov2" title="3">{
                i += copy(data[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return i, nil</span>
}
func (m *DictResponse) Marshal() (data []byte, err error) <span class="cov2" title="5">{
        size := m.Size()
        data = make([]byte, size)
        n, err := m.MarshalTo(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="5">return data[:n], nil</span>
}

func (m *DictResponse) MarshalTo(data []byte) (n int, err error) <span class="cov2" title="6">{
        var i int
        _ = i
        var l int
        _ = l
        if m.Code != nil </span><span class="cov2" title="6">{
                data[i] = 0x8
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(*m.Code))
        }</span>
        <span class="cov2" title="6">if m.Message != nil </span><span class="cov2" title="3">{
                data[i] = 0x12
                i++
                i = encodeVarintBfeDictGogo(data, i, uint64(len(*m.Message)))
                i += copy(data[i:], *m.Message)
        }</span>
        <span class="cov2" title="6">if len(m.TagsClientIP) &gt; 0 </span><span class="cov1" title="2">{
                for _, s := range m.TagsClientIP </span><span class="cov2" title="6">{
                        data[i] = 0x1a
                        i++
                        l = len(s)
                        for l &gt;= 1&lt;&lt;7 </span><span class="cov2" title="6">{
                                data[i] = uint8(uint64(l)&amp;0x7f | 0x80)
                                l &gt;&gt;= 7
                                i++
                        }</span>
                        <span class="cov2" title="6">data[i] = uint8(l)
                        i++
                        i += copy(data[i:], s)</span>
                }
        }
        <span class="cov2" title="6">if len(m.TagsBaiduID) &gt; 0 </span><span class="cov1" title="1">{
                for _, s := range m.TagsBaiduID </span><span class="cov3" title="9">{
                        data[i] = 0x22
                        i++
                        l = len(s)
                        for l &gt;= 1&lt;&lt;7 </span><span class="cov2" title="4">{
                                data[i] = uint8(uint64(l)&amp;0x7f | 0x80)
                                l &gt;&gt;= 7
                                i++
                        }</span>
                        <span class="cov3" title="9">data[i] = uint8(l)
                        i++
                        i += copy(data[i:], s)</span>
                }
        }
        <span class="cov2" title="6">if len(m.TagsUa) &gt; 0 </span><span class="cov2" title="6">{
                for _, s := range m.TagsUa </span><span class="cov4" title="25">{
                        data[i] = 0x2a
                        i++
                        l = len(s)
                        for l &gt;= 1&lt;&lt;7 </span><span class="cov3" title="12">{
                                data[i] = uint8(uint64(l)&amp;0x7f | 0x80)
                                l &gt;&gt;= 7
                                i++
                        }</span>
                        <span class="cov4" title="25">data[i] = uint8(l)
                        i++
                        i += copy(data[i:], s)</span>
                }
        }
        <span class="cov2" title="6">if len(m.TagsIpCookie) &gt; 0 </span><span class="cov2" title="6">{
                for _, s := range m.TagsIpCookie </span><span class="cov4" title="23">{
                        data[i] = 0x32
                        i++
                        l = len(s)
                        for l &gt;= 1&lt;&lt;7 </span><span class="cov3" title="8">{
                                data[i] = uint8(uint64(l)&amp;0x7f | 0x80)
                                l &gt;&gt;= 7
                                i++
                        }</span>
                        <span class="cov4" title="23">data[i] = uint8(l)
                        i++
                        i += copy(data[i:], s)</span>
                }
        }
        <span class="cov2" title="6">if m.XXX_unrecognized != nil </span><span class="cov1" title="2">{
                i += copy(data[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return i, nil</span>
}
func encodeFixed64BfeDictGogo(data []byte, offset int, v uint64) int <span class="cov0" title="0">{
        data[offset] = uint8(v)
        data[offset+1] = uint8(v &gt;&gt; 8)
        data[offset+2] = uint8(v &gt;&gt; 16)
        data[offset+3] = uint8(v &gt;&gt; 24)
        data[offset+4] = uint8(v &gt;&gt; 32)
        data[offset+5] = uint8(v &gt;&gt; 40)
        data[offset+6] = uint8(v &gt;&gt; 48)
        data[offset+7] = uint8(v &gt;&gt; 56)
        return offset + 8
}</span>
func encodeFixed32BfeDictGogo(data []byte, offset int, v uint32) int <span class="cov0" title="0">{
        data[offset] = uint8(v)
        data[offset+1] = uint8(v &gt;&gt; 8)
        data[offset+2] = uint8(v &gt;&gt; 16)
        data[offset+3] = uint8(v &gt;&gt; 24)
        return offset + 4
}</span>
func encodeVarintBfeDictGogo(data []byte, offset int, v uint64) int <span class="cov4" title="40">{
        for v &gt;= 1&lt;&lt;7 </span><span class="cov4" title="30">{
                data[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov4" title="40">data[offset] = uint8(v)
        return offset + 1</span>
}
func (this *DictRequest) GoString() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings1.Join([]string{`&amp;dict_pb.DictRequest{` + `Product:` + valueToGoStringBfeDictGogo(this.Product, "string"), `ClientIP:` + valueToGoStringBfeDictGogo(this.ClientIP, "byte"), `BaiduID:` + valueToGoStringBfeDictGogo(this.BaiduID, "byte"), `Logid:` + valueToGoStringBfeDictGogo(this.Logid, "uint64"), `Ua:` + valueToGoStringBfeDictGogo(this.Ua, "byte"), `IpCookie:` + valueToGoStringBfeDictGogo(this.IpCookie, "byte"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
        return s</span>
}
func (this *DictResponse) GoString() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings1.Join([]string{`&amp;dict_pb.DictResponse{` + `Code:` + valueToGoStringBfeDictGogo(this.Code, "dict_pb.DictResponse_ResponseCode"), `Message:` + valueToGoStringBfeDictGogo(this.Message, "string"), `TagsClientIP:` + fmt2.Sprintf("%#v", this.TagsClientIP), `TagsBaiduID:` + fmt2.Sprintf("%#v", this.TagsBaiduID), `TagsUa:` + fmt2.Sprintf("%#v", this.TagsUa), `TagsIpCookie:` + fmt2.Sprintf("%#v", this.TagsIpCookie), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
        return s</span>
}
func valueToGoStringBfeDictGogo(v interface{}, typ string) string <span class="cov3" title="16">{
        rv := reflect1.ValueOf(v)
        if rv.IsNil() </span><span class="cov1" title="2">{
                return "nil"
        }</span>
        <span class="cov3" title="14">pv := reflect1.Indirect(rv).Interface()
        return fmt2.Sprintf("func(v %v) *%v { return &amp;v } ( %#v )", typ, typ, pv)</span>
}
func extensionToGoStringBfeDictGogo(e map[int32]code_google_com_p_gogoprotobuf_proto1.Extension) string <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov0" title="0">s := "map[int32]proto.Extension{"
        keys := make([]int, 0, len(e))
        for k := range e </span><span class="cov0" title="0">{
                keys = append(keys, int(k))
        }</span>
        <span class="cov0" title="0">sort.Ints(keys)
        ss := []string{}
        for _, k := range keys </span><span class="cov0" title="0">{
                ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
        }</span>
        <span class="cov0" title="0">s += strings1.Join(ss, ",") + "}"
        return s</span>
}
func (this *DictRequest) VerboseEqual(that interface{}) error <span class="cov2" title="6">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that == nil &amp;&amp; this != nil")</span>
        }

        <span class="cov2" title="6">that1, ok := that.(*DictRequest)
        if !ok </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is not of type *DictRequest")
        }</span>
        <span class="cov2" title="6">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that is type *DictRequest but is nil &amp;&amp; this != nil")</span>
        } <span class="cov2" title="6">else if this == nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is type *DictRequestbut is not nil &amp;&amp; this == nil")
        }</span>
        <span class="cov2" title="6">if this.Product != nil &amp;&amp; that1.Product != nil </span><span class="cov2" title="6">{
                if *this.Product != *that1.Product </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Product this(%v) Not Equal that(%v)", *this.Product, *that1.Product)
                }</span>
        } <span class="cov0" title="0">else if this.Product != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Product == nil &amp;&amp; that.Product != nil")
        }</span> <span class="cov0" title="0">else if that1.Product != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Product this(%v) Not Equal that(%v)", this.Product, that1.Product)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.ClientIP, that1.ClientIP) </span><span class="cov0" title="0">{
                return fmt3.Errorf("ClientIP this(%v) Not Equal that(%v)", this.ClientIP, that1.ClientIP)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.BaiduID, that1.BaiduID) </span><span class="cov0" title="0">{
                return fmt3.Errorf("BaiduID this(%v) Not Equal that(%v)", this.BaiduID, that1.BaiduID)
        }</span>
        <span class="cov2" title="6">if this.Logid != nil &amp;&amp; that1.Logid != nil </span><span class="cov2" title="6">{
                if *this.Logid != *that1.Logid </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Logid this(%v) Not Equal that(%v)", *this.Logid, *that1.Logid)
                }</span>
        } <span class="cov0" title="0">else if this.Logid != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Logid == nil &amp;&amp; that.Logid != nil")
        }</span> <span class="cov0" title="0">else if that1.Logid != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Logid this(%v) Not Equal that(%v)", this.Logid, that1.Logid)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.Ua, that1.Ua) </span><span class="cov0" title="0">{
                return fmt3.Errorf("Ua this(%v) Not Equal that(%v)", this.Ua, that1.Ua)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.IpCookie, that1.IpCookie) </span><span class="cov0" title="0">{
                return fmt3.Errorf("IpCookie this(%v) Not Equal that(%v)", this.IpCookie, that1.IpCookie)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return nil</span>
}
func (this *DictRequest) Equal(that interface{}) bool <span class="cov2" title="5">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov2" title="5">that1, ok := that.(*DictRequest)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov2" title="5">else if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Product != nil &amp;&amp; that1.Product != nil </span><span class="cov2" title="5">{
                if *this.Product != *that1.Product </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Product != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Product != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.ClientIP, that1.ClientIP) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.BaiduID, that1.BaiduID) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Logid != nil &amp;&amp; that1.Logid != nil </span><span class="cov2" title="5">{
                if *this.Logid != *that1.Logid </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Logid != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Logid != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.Ua, that1.Ua) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.IpCookie, that1.IpCookie) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">return true</span>
}
func (this *DictResponse) VerboseEqual(that interface{}) error <span class="cov2" title="6">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that == nil &amp;&amp; this != nil")</span>
        }

        <span class="cov2" title="6">that1, ok := that.(*DictResponse)
        if !ok </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is not of type *DictResponse")
        }</span>
        <span class="cov2" title="6">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that is type *DictResponse but is nil &amp;&amp; this != nil")</span>
        } <span class="cov2" title="6">else if this == nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is type *DictResponsebut is not nil &amp;&amp; this == nil")
        }</span>
        <span class="cov2" title="6">if this.Code != nil &amp;&amp; that1.Code != nil </span><span class="cov2" title="6">{
                if *this.Code != *that1.Code </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Code this(%v) Not Equal that(%v)", *this.Code, *that1.Code)
                }</span>
        } <span class="cov0" title="0">else if this.Code != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Code == nil &amp;&amp; that.Code != nil")
        }</span> <span class="cov0" title="0">else if that1.Code != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
        }</span>
        <span class="cov2" title="6">if this.Message != nil &amp;&amp; that1.Message != nil </span><span class="cov2" title="6">{
                if *this.Message != *that1.Message </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Message this(%v) Not Equal that(%v)", *this.Message, *that1.Message)
                }</span>
        } <span class="cov0" title="0">else if this.Message != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Message == nil &amp;&amp; that.Message != nil")
        }</span> <span class="cov0" title="0">else if that1.Message != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
        }</span>
        <span class="cov2" title="6">if len(this.TagsClientIP) != len(that1.TagsClientIP) </span><span class="cov0" title="0">{
                return fmt3.Errorf("TagsClientIP this(%v) Not Equal that(%v)", len(this.TagsClientIP), len(that1.TagsClientIP))
        }</span>
        <span class="cov2" title="6">for i := range this.TagsClientIP </span><span class="cov3" title="18">{
                if this.TagsClientIP[i] != that1.TagsClientIP[i] </span><span class="cov0" title="0">{
                        return fmt3.Errorf("TagsClientIP this[%v](%v) Not Equal that[%v](%v)", i, this.TagsClientIP[i], i, that1.TagsClientIP[i])
                }</span>
        }
        <span class="cov2" title="6">if len(this.TagsBaiduID) != len(that1.TagsBaiduID) </span><span class="cov0" title="0">{
                return fmt3.Errorf("TagsBaiduID this(%v) Not Equal that(%v)", len(this.TagsBaiduID), len(that1.TagsBaiduID))
        }</span>
        <span class="cov2" title="6">for i := range this.TagsBaiduID </span><span class="cov4" title="30">{
                if this.TagsBaiduID[i] != that1.TagsBaiduID[i] </span><span class="cov0" title="0">{
                        return fmt3.Errorf("TagsBaiduID this[%v](%v) Not Equal that[%v](%v)", i, this.TagsBaiduID[i], i, that1.TagsBaiduID[i])
                }</span>
        }
        <span class="cov2" title="6">if len(this.TagsUa) != len(that1.TagsUa) </span><span class="cov0" title="0">{
                return fmt3.Errorf("TagsUa this(%v) Not Equal that(%v)", len(this.TagsUa), len(that1.TagsUa))
        }</span>
        <span class="cov2" title="6">for i := range this.TagsUa </span><span class="cov4" title="36">{
                if this.TagsUa[i] != that1.TagsUa[i] </span><span class="cov0" title="0">{
                        return fmt3.Errorf("TagsUa this[%v](%v) Not Equal that[%v](%v)", i, this.TagsUa[i], i, that1.TagsUa[i])
                }</span>
        }
        <span class="cov2" title="6">if len(this.TagsIpCookie) != len(that1.TagsIpCookie) </span><span class="cov0" title="0">{
                return fmt3.Errorf("TagsIpCookie this(%v) Not Equal that(%v)", len(this.TagsIpCookie), len(that1.TagsIpCookie))
        }</span>
        <span class="cov2" title="6">for i := range this.TagsIpCookie </span><span class="cov4" title="34">{
                if this.TagsIpCookie[i] != that1.TagsIpCookie[i] </span><span class="cov0" title="0">{
                        return fmt3.Errorf("TagsIpCookie this[%v](%v) Not Equal that[%v](%v)", i, this.TagsIpCookie[i], i, that1.TagsIpCookie[i])
                }</span>
        }
        <span class="cov2" title="6">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return nil</span>
}
func (this *DictResponse) Equal(that interface{}) bool <span class="cov2" title="5">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov2" title="5">that1, ok := that.(*DictResponse)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov2" title="5">else if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Code != nil &amp;&amp; that1.Code != nil </span><span class="cov2" title="5">{
                if *this.Code != *that1.Code </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Code != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Code != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Message != nil &amp;&amp; that1.Message != nil </span><span class="cov2" title="5">{
                if *this.Message != *that1.Message </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Message != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Message != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if len(this.TagsClientIP) != len(that1.TagsClientIP) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">for i := range this.TagsClientIP </span><span class="cov3" title="15">{
                if this.TagsClientIP[i] != that1.TagsClientIP[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov2" title="5">if len(this.TagsBaiduID) != len(that1.TagsBaiduID) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">for i := range this.TagsBaiduID </span><span class="cov4" title="30">{
                if this.TagsBaiduID[i] != that1.TagsBaiduID[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov2" title="5">if len(this.TagsUa) != len(that1.TagsUa) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">for i := range this.TagsUa </span><span class="cov4" title="30">{
                if this.TagsUa[i] != that1.TagsUa[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov2" title="5">if len(this.TagsIpCookie) != len(that1.TagsIpCookie) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">for i := range this.TagsIpCookie </span><span class="cov4" title="31">{
                if this.TagsIpCookie[i] != that1.TagsIpCookie[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov2" title="5">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/* dict_rule_load.go - load config of product rules from configuration file */
/*
modification history
--------------------
2015/10/20, by geng chao, create
*/
/*
DESCRIPTION
*/

package mod_dict_client

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

import (

    "www.baidu.com/golang-lib/log"
)

import (
    "bfe_basic/condition"
)

/*
* parse rules.data configuration file
* conf format:
* {
*     "Config": {
*        "wise": [
*             "cond": "xxx"
*          ],
*          "xxx":[]
*      },
*      "Version": "1234"
* }
 */

/* load config of rules from file

   Returns:
        (RuleConf, error)
*/

type RuleFile struct {
    Cond     *string
}
type RuleFileList []RuleFile
type DictRulesFile map[string]*RuleFileList // product name =&gt; list of product rules List
type DictRuleConfFile struct {
    Version *string
    Config  *DictRulesFile
}

type Rule struct {
    Cond      condition.Condition // condition for dict-client filter
}
type RuleList []Rule
type ProductRules map[string]*RuleList
type DictRuleConf struct {
    Version string       // version of the config
    Config  ProductRules // product rules
}

func ruleConvert(ruleFile RuleFile) (*Rule, error) <span class="cov10" title="4">{
    rule := new(Rule)
    cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov0" title="0">{
        return rule, err
    }</span>
    <span class="cov10" title="4">rule.Cond = cond
    return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov10" title="4">{
    ruleList := new(RuleList)
    *ruleList = make([]Rule, 0)

    if(ruleFileList == nil) </span><span class="cov0" title="0">{
        return ruleList, nil
    }</span>
    <span class="cov10" title="4">for _, ruleFile := range *ruleFileList </span><span class="cov10" title="4">{
        rule, err := ruleConvert(ruleFile)
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>

        <span class="cov10" title="4">*ruleList = append(*ruleList, *rule)</span> 
    }
    <span class="cov10" title="4">return ruleList, nil</span>
}

// check Rule
func ruleCheck(conf RuleFile) error <span class="cov10" title="4">{
    // check Cond
    if conf.Cond == nil </span><span class="cov0" title="0">{
        return errors.New("error: not write Condition")
    }</span>
    <span class="cov10" title="4">return nil</span>
}

// check RuleList
func ruleListCheck(conf *RuleFileList) error <span class="cov10" title="4">{
    for index, rule := range *conf </span><span class="cov10" title="4">{
        err := ruleCheck(rule)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("RuleListCheck:%d, %s", index, err.Error())
        }</span>
    }
    <span class="cov10" title="4">return nil</span>
}

// check Rules
func rulesFileCheck(conf *DictRulesFile) error <span class="cov5" title="2">{
    for product, ruleList := range *conf </span><span class="cov10" title="4">{
        if ruleList == nil || len(*ruleList) == 0 </span><span class="cov0" title="0">{
            if openDebug </span><span class="cov0" title="0">{
                log.Logger.Debug("rulesFileCheck(): ruleList is empty")
            }</span>
            <span class="cov0" title="0">continue</span>
        }
        <span class="cov10" title="4">err := ruleListCheck(ruleList)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
        }</span>
    }
    <span class="cov5" title="2">return nil</span>
}

// validate config Files
func ruleConfCheck(conf *DictRuleConfFile) error <span class="cov5" title="2">{
    var err error

    // check Version
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>
    // check Config
    <span class="cov5" title="2">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>
    <span class="cov5" title="2">err = rulesFileCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Config:%s", err.Error())
    }</span>

    <span class="cov5" title="2">return nil</span>
}

func RulesConfLoad(filename string) (DictRuleConf, error) <span class="cov5" title="2">{
    var dictCfg DictRuleConf

    ruleList := new(RuleList)
    /* open the file    */
    file, err := os.Open(filename)
    if err != nil </span><span class="cov0" title="0">{
        return dictCfg, err
    }</span>
    <span class="cov5" title="2">defer file.Close()
    /* decode the file  */
    decoder := json.NewDecoder(file)
    var config DictRuleConfFile
    if err = decoder.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
        return dictCfg, err
    }</span>

    // check Rules config
    <span class="cov5" title="2">if err = ruleConfCheck(&amp;config); err != nil </span><span class="cov0" title="0">{
        return dictCfg, err
    }</span>

    // convert config
    <span class="cov5" title="2">dictCfg.Version = *config.Version
    dictCfg.Config = make(ProductRules)

    for product, rulesFileList := range *config.Config </span><span class="cov10" title="4">{
        ruleList, err = ruleListConvert(rulesFileList)
        if err != nil </span><span class="cov0" title="0">{
            return dictCfg, err
        }</span>
        <span class="cov10" title="4">dictCfg.Config[product] = ruleList</span>
    }

    <span class="cov5" title="2">return dictCfg, nil</span>
}</pre>
		
		<pre class="file" id="file81" style="display: none">/* mod_dict_client.go - module for adding tags to request */
/*
modification history
--------------------
2014/8/11, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_dict_client

import (
    "crypto/md5"
    "encoding/json"
    "fmt"
    "net/url"
    "strings"
    "time"
)

import (
    "www.baidu.com/golang-lib/delay_counter"
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/remote"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
    "bfe_modules/mod_dict_client/dict_pb"
)

// setting for DelayCounter
const (
    DELAY_COUNTER_INTERVAL      = 60    // interval for moving current to past (in s)
    DELAY_COUNTER_BUCKET_SIZE   = 1     // size of delay counter bucket (in ms)
    DELAY_COUNTER_BUCKET_NUM    = 10    // number of delay counter bucket
)

// const for headers values
const HEADER_USER_AGENT = "User-Agent"

var (
    openDebug = false
)

// key for counter of mod_dict_client
var COUNTER_KEYS = []string {
    "REQ_TOTAL",            // total requests send to dict server
    "REQ_CALL_ERR",         // requests call error (send fail, timeout, etc)
    "CALL_RESPONSE_OK",     // requests proc success by dict server
    "CALL_RESPONSE_ERR",    // requests proc failure by dict server
}

type ModuleDictClient struct {
    name      string                     // name of module
    state     *module_state2.State       // module state
    delay     *delay_counter.DelayRecent // for monitor internel delay

    conf      *ConfModDictClient         // dict config
    client    remote.IClient             // dict client
    ruleTable *ProductRuleTable          // table for product rules
}

func NewModuleDictClient() *ModuleDictClient <span class="cov10" title="3">{
    m := new(ModuleDictClient)
    m.name = "mod_dict_client"

    m.state = new(module_state2.State)
    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_DIC_CLIENT)

    m.delay = new(delay_counter.DelayRecent)
    m.delay.Init(DELAY_COUNTER_INTERVAL, DELAY_COUNTER_BUCKET_SIZE, DELAY_COUNTER_BUCKET_NUM)
    m.delay.SetNoahKeyPrefix(bfe_basic.NOAH_MOD_DICT_DELAY)

    m.ruleTable = NewProductRuleTable()
    return m
}</span>

func (m *ModuleDictClient) Name() string <span class="cov1" title="1">{
    return m.name
}</span>

func (m *ModuleDictClient) Attr() map[string]interface{} <span class="cov1" title="1">{
    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name           : bfe_basic.MON_TYPE_STATE,
        m.name + ".delay": bfe_basic.MON_TYPE_DELAY_RECENT,
    }
    // reload items
    reloadEntries := []string{
        m.name + ".product_rule_table",
    }
    return map[string]interface{} {
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
        bfe_basic.MON_ATTR_RELOAD:  reloadEntries,
    }
}</span>

// init dict client
func (m *ModuleDictClient) initDictClient() error <span class="cov0" title="0">{
    cfg := m.conf.DictClient
    m.client = remote.NewClient(cfg.Network, cfg.Address,
                                    time.Duration(cfg.ConnectTimeout) * time.Millisecond,
                                    cfg.Concurrency, nil, cfg.PendingNum)
    return nil
}</span>

// loadRulesConf is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleDictClient) loadRulesConf(query url.Values) error <span class="cov0" title="0">{
    // get reload file path
    path := query.Get("path")
    if path == "" </span><span class="cov0" title="0">{
        // use default
        path = m.conf.CondRules.Path
    }</span>

    <span class="cov0" title="0">dictConf, err := RulesConfLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadRulesConf(%s):%s", path, err)
    }</span>

    <span class="cov0" title="0">m.ruleTable.Update(dictConf)
    
    return nil</span>
}

func getUaMd5Value(request *bfe_basic.Request) []byte <span class="cov1" title="1">{
    httpReq := request.HttpRequest

    // get user agent
    userAgent := httpReq.Header.Get(HEADER_USER_AGENT)
    if len(userAgent) != 0 </span><span class="cov0" title="0">{
        // parse ua
        uaMd5 := fmt.Sprintf("%x", md5.Sum([]byte(userAgent)))
        uaValue := []byte(uaMd5)
        return uaValue
    }</span> <span class="cov1" title="1">else {
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("getUaMd5Value: Not get Request User Agent")
        }</span>
        <span class="cov1" title="1">return nil</span>
    }
}

func getIpCookieMd5Value(request *bfe_basic.Request) []byte <span class="cov1" title="1">{
    var baiduId string

    // get client ip
    clientIp := request.RemoteAddr.IP.String()

    if request.Baiduid == "" </span><span class="cov1" title="1">{
        baiduId = "-"
    }</span> <span class="cov0" title="0">else {
        baiduId = request.Baiduid
    }</span>

    <span class="cov1" title="1">Key := strings.Join([]string{clientIp, baiduId}, ":")
    if len(Key) != 0 </span><span class="cov1" title="1">{

        IpCookieMd5 := fmt.Sprintf("%x", md5.Sum([]byte(Key)))
        IpCookieValue := []byte(IpCookieMd5)
        return IpCookieValue
    }</span> <span class="cov0" title="0">else {
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("getIpCookieMd5Value: Not get Request ClienIp:Baiduid")
        }</span>
        <span class="cov0" title="0">return nil</span>
    }
}

// prepare dict request
func (m *ModuleDictClient) prepareDictRequest(request *bfe_basic.Request) (
                                              *dict_pb.DictRequest) <span class="cov1" title="1">{
    req := new(dict_pb.DictRequest)

    // product 
    req.Product = &amp;request.Route.Product

    // client ip
    req.ClientIP = request.RemoteAddr.IP.To4()
    
    //baiduID
    req.BaiduID = request.BaiduidHex
    if req.BaiduID == nil </span><span class="cov1" title="1">{
        req.BaiduID = make([]byte, 0)   // not check baiduid
    }</span>

    //ua
    <span class="cov1" title="1">req.Ua = getUaMd5Value(request)
    if req.Ua == nil </span><span class="cov1" title="1">{
        req.Ua = make([]byte, 0)   // not check ua
    }</span>

    //ip cookie
    <span class="cov1" title="1">req.IpCookie = getIpCookieMd5Value(request)
    if req.IpCookie == nil </span><span class="cov0" title="0">{
        req.IpCookie = make([]byte, 0)   // not check ua
    }</span>
    <span class="cov1" title="1">return req</span>
}

// process dict response
func (m *ModuleDictClient) processDictResponse(request *bfe_basic.Request,
                                               dictResp *dict_pb.DictResponse) <span class="cov1" title="1">{
    // add tags to orginal request
    if (*dictResp.Code == dict_pb.DictResponse_OK) </span><span class="cov1" title="1">{
        request.Tags.IPTags = dictResp.TagsClientIP
        request.Tags.BaiduIDTags = dictResp.TagsBaiduID
        request.Tags.UserAgentTags = dictResp.TagsUa
        request.Tags.IPCookieTags = dictResp.TagsIpCookie
        
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s: add tags to request(ip: %v, baidid: %v, UA: %v, IPCookie: %v)",
                             m.name, request.Tags.IPTags, request.Tags.BaiduIDTags, request.Tags.UserAgentTags, request.Tags.IPCookieTags)
        }</span>
        <span class="cov1" title="1">m.state.Inc("CALL_RESPONSE_OK", 1)</span>
    } <span class="cov0" title="0">else {
        err := fmt.Errorf("%s:request error: %d %s", m.name, *dictResp.Code, dictResp.Code.String())
        request.Tags.Error = err
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s: %s", m.name, err.Error())
        }</span>
        <span class="cov0" title="0">m.state.Inc("CALL_RESPONSE_ERR", 1)</span>
    }
}

func (m *ModuleDictClient) dictProcess(request *bfe_basic.Request) <span class="cov0" title="0">{
    // create dict request
    dictReq := m.prepareDictRequest(request)
    m.state.Inc("REQ_TOTAL", 1)

    // request dict server
    dictResp := new(dict_pb.DictResponse)
    duration := time.Duration(m.conf.DictClient.ConnectTimeout) * time.Millisecond
    err := m.client.Call(dictReq, dictResp, duration)
    // process dict response
    if err == nil </span><span class="cov0" title="0">{
        m.processDictResponse(request, dictResp)
    }</span> <span class="cov0" title="0">else {
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s: request dict server error: %s", m.name, err.Error())
        }</span>
        <span class="cov0" title="0">m.state.Inc("REQ_CALL_ERR", 1)</span>
    }
}

// dict handler
func (m *ModuleDictClient) dictHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
    if openDebug </span><span class="cov0" title="0">{
        log.Logger.Debug("%s: process request (ip=%s, baiduid=%s)", 
                         m.name, request.RemoteAddr.IP, request.Baiduid)
    }</span>
    <span class="cov0" title="0">procStart := time.Now()

    // find rules for given product info
    rules := m.ruleTable.Search(request.Route.Product)
    if rules == nil </span><span class="cov0" title="0">{ // no rules found
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("no dict rules for %s , just pass", request.Route.Product)
        }</span>
        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON, nil</span>
    }

    <span class="cov0" title="0">if len(*rules) == 0 </span><span class="cov0" title="0">{
        m.dictProcess(request)
    }</span> <span class="cov0" title="0">else {
        for _, rule := range *rules </span><span class="cov0" title="0">{
            // rule condition is satisfied ?
            if rule.Cond.Match(request) </span><span class="cov0" title="0">{
                m.dictProcess(request)
                break</span>
            }
        }
    }
    
    <span class="cov0" title="0">m.delay.AddBySub(procStart, time.Now())

    return bfe_module.BFE_HANDLER_GOON, nil</span>
}

func (m *ModuleDictClient) getState(query url.Values) ([]byte, error) <span class="cov1" title="1">{
    state := m.state.GetAll()

    // get param for format
    format := query.Get("format")
    if len(format) == 0 </span><span class="cov1" title="1">{
        // default format is json
        format = "json"
    }</span>

    <span class="cov1" title="1">var buff []byte
    var err error

    switch format </span>{
        <span class="cov1" title="1">case "json":
            buff, err = json.Marshal(state)</span>
        <span class="cov0" title="0">case "noah":
            buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }    
    <span class="cov1" title="1">return buff, err</span>
}

func (m *ModuleDictClient) getDelay(query url.Values) ([]byte, error) <span class="cov1" title="1">{
    delay := m.delay.Get()

    // get param for format
    format := query.Get("format")
    if len(format) == 0 </span><span class="cov1" title="1">{
        // default format is json
        format = "json"
    }</span>

    <span class="cov1" title="1">var buff []byte
    var err error

    switch format </span>{
        <span class="cov1" title="1">case "json":
            buff, err = delay.GetJson()</span>
        <span class="cov0" title="0">case "noah":
            buff = delay.GetNoah()</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }    
    <span class="cov1" title="1">return buff, err</span>
}

// all monitor handlers
func (m *ModuleDictClient) monitorHandlers() map[string]interface{} <span class="cov1" title="1">{
    handlers := map[string]interface{} {
        m.name            : m.getState,
        m.name + ".delay" : m.getDelay,
    }
    return handlers
}</span>

// all reload handlers
func (m *ModuleDictClient) reloadHandlers() map[string]interface{} <span class="cov0" title="0">{
    handlers := map[string]interface{}{
        m.name + ".product_rule_table": m.loadRulesConf,
    }
    return handlers
}</span>

func (m *ModuleDictClient) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                                cr string) error <span class="cov0" title="0">{
    var err error
    var conf *ConfModDictClient

    // load config
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">openDebug = conf.Log.OpenDebug

    // init dict client
    m.conf = conf
    m.initDictClient()

    // load conf data
    err = m.loadRulesConf(nil)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): loadRulesConf err %s", m.name, err.Error())
    }</span>

    // register handler
    <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.dictHandler)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.dictHandler): %s", m.name, err.Error())
    }</span>

    // register web handler for monitor
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>
    // register web handler for reload
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
    }</span>
    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/* product_rule_table.go - table for storing product rules   */
/*
modification history
--------------------
2015/10/26, by  Geng Chao, create
*/
/*
DESCRIPTION
*/
package mod_dict_client

import (
    "sync"
)

type ProductRuleTable struct {
    lock    sync.RWMutex
    version string
    rules   ProductRules
}

func NewProductRuleTable() *ProductRuleTable <span class="cov10" title="4">{
    t := new(ProductRuleTable)
    t.rules = make(ProductRules)
    return t
}</span>

// update
func (t *ProductRuleTable) Update(conf DictRuleConf) <span class="cov1" title="1">{
    t.lock.Lock()
    t.version = conf.Version
    t.rules = conf.Config
    t.lock.Unlock()
}</span>

/* According to the product name, Search for product rules

   Returns:
        (*RuleList, nil), if succeed
        (nil, error), if fail
*/
func (t *ProductRuleTable) Search(product string) (*RuleList) <span class="cov8" title="3">{
    t.lock.RLock()
    //  find rules for given product name
    rules := t.rules[product]
    t.lock.RUnlock()
    return rules
}</pre>
		
		<pre class="file" id="file83" style="display: none">/* action.go - action for headers */
/*
modification history
--------------------
2015/4/28, by Xiong Zongtao, created.
2015/10/16, by Xiong Zongtao, modified.
        -add response header action
*/
/*
DESCRIPTION
*/
package mod_header

import (
    "errors"
    "fmt"
        "strings"
)

import (
        "bfe_basic"
    "bfe_http"
)

type ActionFile struct {
    Cmd         *string                 // command of action
    Params      []string
}

type Action struct {
    Cmd         string      // command of action
    Params      []string    // params of action
}

type ActionFileList []ActionFile

// check ActionFile
func ActionFileCheck(conf ActionFile) error <span class="cov9" title="60">{
    var paramsLenCheck int
    
    // check command
    if conf.Cmd == nil </span><span class="cov0" title="0">{
        return errors.New("no Cmd")
    }</span>

    // validate command, and get how many params should exist for each command
    <span class="cov9" title="60">switch *conf.Cmd </span>{
        <span class="cov8" title="38">case "REQ_HEADER_SET", 
             "REQ_HEADER_ADD", 
             "RSP_HEADER_SET", 
             "RSP_HEADER_ADD" :
        // header and value
            paramsLenCheck = 2</span>
        <span class="cov7" title="22">case "REQ_HEADER_DEL", 
             "RSP_HEADER_DEL" :
        // header 
            paramsLenCheck = 1</span>
        <span class="cov0" title="0">default:
            return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
    }

    // check params
    <span class="cov9" title="60">if conf.Params == nil </span><span class="cov0" title="0">{
        return errors.New("no Params")
    }</span>

    <span class="cov9" title="60">if paramsLenCheck &gt; 0 </span><span class="cov9" title="60">{
        paramsLen := len(conf.Params)
        if paramsLen != paramsLenCheck </span><span class="cov1" title="1">{
            return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, paramsLen)
        }</span>
    }

        <span class="cov9" title="59">for _, p := range conf.Params </span><span class="cov10" title="96">{
                if len(p) == 0 </span><span class="cov0" title="0">{
                        return errors.New("empty Params")
                }</span>
        }

    <span class="cov9" title="59">return nil</span>
}

// check ActionFileList
func ActionFileListCheck(conf *ActionFileList) error <span class="cov9" title="58">{    
    for index, action := range *conf </span><span class="cov9" title="60">{
        err := ActionFileCheck(action)
        if err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("ActionFileList:%d, %s", index, err.Error())
        }</span>        
    }

    <span class="cov8" title="57">return nil</span>
}

func preProcessParams(param string) (string, error) <span class="cov8" title="39">{
        /* second param has three schema:
         * bfe_vip:   no '%' prefix
     * %bfe_vip:  has '%' prefix
     * %%bfe_vip: has '%%' prefix
         * here, we only process second schema, such as %bfe_vip
         * other two, return directly
     */

        //header value variable 
        if strings.HasPrefix(param, "%") &amp;&amp; !strings.HasPrefix(param, "%%") </span><span class="cov0" title="0">{
                varHeaderVal := strings.ToLower(param)
                if _, found := headerVar[varHeaderVal[1:]]; found </span><span class="cov0" title="0">{
                        return varHeaderVal, nil
                }</span> <span class="cov0" title="0">else {
                        // not valid header value variable 
                        err := fmt.Errorf("command's second param is not valid: %s", param)
                        return param, err
                }</span>
        }
        
        <span class="cov8" title="39">return param, nil</span>
}

func getHeaderValue(req *bfe_basic.Request, action Action) string <span class="cov7" title="30">{
        if len(action.Params) &lt;= 1 </span><span class="cov6" title="16">{
                return ""
        }</span>

        <span class="cov6" title="14">param := action.Params[1]
        if strings.HasPrefix(param, "%") </span><span class="cov0" title="0">{ 
                param = param[1:]
                if handler, found := headerVar[param]; found </span><span class="cov0" title="0">{
                        return handler(req)
                }</span>
        }

        <span class="cov6" title="14">return param</span>
}

func actionConvert(actionFile ActionFile) (Action, error) <span class="cov9" title="62">{
    action := Action{}    

    action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params

        if len(actionFile.Params) &gt; 1 </span><span class="cov8" title="39">{
                var err error
            action.Params[1], err = preProcessParams(actionFile.Params[1])
                if err != nil </span><span class="cov0" title="0">{
                        return action, err
                }</span>
        }

    <span class="cov9" title="62">return action, nil</span>
}

func actionsConvert(actionFiles ActionFileList) ([]Action, error) <span class="cov9" title="58">{
    actions := make([]Action, 0)
    
    for _, actionFile := range actionFiles </span><span class="cov9" title="62">{
        action, err := actionConvert(actionFile)
                if err != nil </span><span class="cov0" title="0">{
                        return actions, err
                }</span>
        <span class="cov9" title="62">actions = append(actions, action)</span>
    }
    
    <span class="cov9" title="58">return actions, nil</span>
}

// do actions to request
func HeaderActionDo(h *bfe_http.Header, cmd string, headerName string, value string) <span class="cov7" title="30">{
    switch cmd </span>{
        // insert or modify
        <span class="cov5" title="12">case "HEADER_SET":
            headerSet(h, headerName, value)</span>
        // append    
        <span class="cov2" title="2">case "HEADER_ADD":
            headerAdd(h, headerName,value)</span>
        // delete    
        <span class="cov6" title="16">case "HEADER_DEL":
            headerDel(h, headerName)</span>
    }
}

func getHeader(req *bfe_basic.Request, headerType int) (h *bfe_http.Header) <span class="cov8" title="46">{
        switch headerType </span>{
                <span class="cov8" title="46">case REQ_HEADER:
                        h = &amp;req.HttpRequest.Header</span>
                <span class="cov0" title="0">case RSP_HEADER:
                        h = &amp;req.HttpResponse.Header</span>        
        }
        
        <span class="cov8" title="46">return h</span>
}

// do actions to request
func HeaderActionsDo(req *bfe_basic.Request, headerType int, actions []Action) <span class="cov7" title="28">{
    for _, action := range actions </span><span class="cov7" title="30">{
                h := getHeader(req, headerType)
                value := getHeaderValue(req, action)
                // trim action.Cmd prefix REQ_ and RSP_
        HeaderActionDo(h, action.Cmd[4:], action.Params[0], value)
    }</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/* action_header.go - actions to set/add/delete/header */
/*
modification history
--------------------
2015/4/28, by Xiong Zongtao, created.
*/
/*
DESCRIPTION
*/
package mod_header


import (
    "bfe_http"
)

/* insert or modify existing header
 */
func headerSet(h *bfe_http.Header, key string, value string) <span class="cov9" title="12">{
    h.Set(key, value)
}</span>


/* append #value to existing header
 * or insert a new one
 */
func headerAdd(h *bfe_http.Header, key string, value string) <span class="cov3" title="2">{
    h.Add(key, value)
}</span>

/* delete header specified by #key
 * user defined headers can't be deleted
 */
func headerDel(h *bfe_http.Header, key string) <span class="cov10" title="16">{
    h.Del(key)
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">/* action_header_var.go - get header value dynamic generated*/
/*
modification history
--------------------
2015/9/22, by Xiong Zongtao, created.
*/
/*
DESCRIPTION
*/
package mod_header

import (
    "bfe_basic"
)

type HeaderValueHandler func (req *bfe_basic.Request) string

var headerVar map[string]HeaderValueHandler

func initVarHeader() <span class="cov10" title="6">{
        headerVar = make(map[string]HeaderValueHandler)

        headerVar["bfe_cluster"]  = getBfeCluster
        headerVar["bfe_vip"]      = getBfeVip
}</span>

func getBfeCluster(req *bfe_basic.Request) string <span class="cov0" title="0">{
        return req.Route.ClusterName
}</span>

func getBfeVip(req *bfe_basic.Request) string <span class="cov0" title="0">{
        if req.Session.Vip != nil </span><span class="cov0" title="0">{
                return req.Session.Vip.String()
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/* conf_mod_header.go - config for mod_header */
/*
modification history
--------------------
2015/4/29, by Xiong Zongtao, created.
*/
/*
DESCRIPTION
*/
package mod_header

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfModHeader struct {
    Basic struct {
        DataPath    string  // path of config data (rewrite)
    }

    Log struct {
        OpenDebug bool
    }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModHeader, error) <span class="cov10" title="8">{
    var err error
    var cfg ConfModHeader

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_header
    <span class="cov10" title="8">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="8">return &amp;cfg, nil</span>
}


func (cfg *ConfModHeader) Check(confRoot string) error <span class="cov10" title="8">{
    return ConfModHeaderCheck(cfg, confRoot)
}</span>

func ConfModHeaderCheck(cfg *ConfModHeader, confRoot string) error <span class="cov10" title="8">{
    if cfg.Basic.DataPath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModHeader.DataPath not set, use default value")
        cfg.Basic.DataPath = "mod_header/mod_header.data"
    }</span>
    
    <span class="cov10" title="8">cfg.Basic.DataPath = conf_path.ConfPathProc(cfg.Basic.DataPath, confRoot)
    return nil</span>
}

</pre>
		
		<pre class="file" id="file87" style="display: none">/* header_conf_load.go - load header config from json file  */
/*
modification history
--------------------
2015/4/29, by Xiong Zongtao, created.
*/
/*
DESCRIPTION
*/
package mod_header

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
        "strings"
)

import (
    "bfe_basic/condition"
)

type HeaderRuleFile struct {
    Cond        *string         // condition for header
    Actions     *ActionFileList // list of actions
    Last        *bool           // if true, not to check the next rule in the list if
                                // the condition is satisfied
}

type HeaderRule struct {
    Cond        condition.Condition     // condition for header
    Actions     []Action    // list of actions
    Last        bool        // if true, not to check the next rule in the list if
                            // the condition is satisfied
}

type RuleFileList []HeaderRuleFile
type RuleList     []HeaderRule

type ProductRulesFile map[string]*RuleFileList  // product =&gt; list of header rules
type ProductRules     map[string][]*RuleList      // product =&gt; list of header rules

type HeaderConfFile struct {
    Version     *string             // version of the config
    Config      *ProductRulesFile
}

type HeaderConf struct {
    Version     string          // version of the config
    Config      ProductRules    // product rules for header
}

// attrs in header rules
var attrsMust = []string {"HostTags", "PathTags", "QueryTags", "CookieTags", 
                          "HostRules","PathRules", "QueryRules"}

// check ReWriteRule
func HeaderRuleCheck(conf HeaderRuleFile) error <span class="cov10" title="56">{
    var err error
    
    // check Cond      
    if conf.Cond == nil </span><span class="cov0" title="0">{
        return errors.New("no Cond")
    }</span>

    // check Actions
    <span class="cov10" title="56">if conf.Actions == nil </span><span class="cov0" title="0">{
        return errors.New("no Actions")
    }</span>

    <span class="cov10" title="56">err = ActionFileListCheck(conf.Actions)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Actions:%s", err.Error())
    }</span>

    // check Last
    <span class="cov10" title="56">if conf.Last == nil </span><span class="cov0" title="0">{
        return errors.New("no Last")
    }</span>

    <span class="cov10" title="56">return nil</span>
}

// check RuleList
func RuleListCheck(conf *RuleFileList) error <span class="cov8" title="28">{    
    for index, rule := range *conf </span><span class="cov10" title="56">{
        err := HeaderRuleCheck(rule)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("HeaderRule:%d, %s", index, err.Error())
        }</span>        
    }

    <span class="cov8" title="28">return nil</span>
}

// check ProductRules
func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov5" title="7">{    
    for product, ruleList := range *conf </span><span class="cov8" title="28">{
        if ruleList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no RuleList for product:%s", product)
        }</span>
        
        <span class="cov8" title="28">err := RuleListCheck(ruleList)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
        }</span>        
    }

    <span class="cov5" title="7">return nil</span>
}

// check HeaderConf
func HeaderConfCheck(conf HeaderConfFile) error <span class="cov5" title="7">{
    var err error
    
    // check Version      
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    // check Config
    <span class="cov5" title="7">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    <span class="cov5" title="7">err = ProductRulesCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Config:%s", err.Error())
    }</span>

    <span class="cov5" title="7">return nil</span>
}

func ruleConvert(ruleFile HeaderRuleFile) (HeaderRule, error) <span class="cov10" title="56">{
    rule := HeaderRule{}

    if ruleFile.Cond == nil </span><span class="cov0" title="0">{
        return rule, fmt.Errorf("cond not set")
    }</span>
    <span class="cov10" title="56">cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov0" title="0">{
        return rule, err
    }</span>

    <span class="cov10" title="56">rule.Cond = cond
    rule.Actions, err = actionsConvert(*ruleFile.Actions)
        if err != nil </span><span class="cov0" title="0">{
                return rule, err
        }</span>
    <span class="cov10" title="56">rule.Last = *ruleFile.Last

    return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="28">{
    ruleList := new(RuleList)
    *ruleList = make([]HeaderRule, 0)

    for _, ruleFile := range *ruleFileList </span><span class="cov10" title="56">{
        rule, err := ruleConvert(ruleFile)
        if err != nil </span><span class="cov0" title="0">{
            return ruleList, err
        }</span>
        <span class="cov10" title="56">*ruleList = append(*ruleList, rule)</span>
    }

    <span class="cov8" title="28">return ruleList, nil</span>
}

// classify rules to request's and response's
func classifyRules(ruleList *RuleList) []*RuleList <span class="cov8" title="28">{
        ruleLists := make([]*RuleList, 2)

    reqRuleList := new(RuleList)
    rspRuleList := new(RuleList)
    *reqRuleList = make([]HeaderRule, 0)
    *rspRuleList = make([]HeaderRule, 0)

        for _, r := range *ruleList </span><span class="cov10" title="56">{
                reqRule := new(HeaderRule)
                rspRule := new(HeaderRule)

                for _, a := range r.Actions </span><span class="cov10" title="56">{
                        reqRule.Cond = r.Cond
                        rspRule.Cond = r.Cond
                        if strings.HasPrefix(a.Cmd, "REQ_") </span><span class="cov10" title="56">{
                                reqRule.Actions = append(reqRule.Actions, a)
                        }</span> <span class="cov0" title="0">else if strings.HasPrefix(a.Cmd, "RSP_") </span><span class="cov0" title="0">{
                                rspRule.Actions = append(rspRule.Actions, a)
                        }</span>
                }

                <span class="cov10" title="56">*reqRuleList = append(*reqRuleList, *reqRule)
                *rspRuleList = append(*rspRuleList, *rspRule)</span>
        }
        
        <span class="cov8" title="28">ruleLists[0] = reqRuleList        
        ruleLists[1] = rspRuleList

        return ruleLists</span>
}

/* load config of header from file  
   
   Returns:
        (HeaderConf, error)
*/
func HeaderConfLoad(filename string) (HeaderConf, error) <span class="cov5" title="8">{  
    var conf HeaderConf
    var err error
      
    /* open the file    */
    file, err1 := os.Open(filename)
    
    if err1 != nil </span><span class="cov1" title="1">{
        return conf, err1
    }</span>
    
    /* decode the file  */
    <span class="cov5" title="7">decoder := json.NewDecoder(file)
    
    var config HeaderConfFile
    err = decoder.Decode(&amp;config)    
    file.Close()
    
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // check config
    <span class="cov5" title="7">err = HeaderConfCheck(config)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    /* convert config   */
    <span class="cov5" title="7">conf.Version = *config.Version
    conf.Config = make(ProductRules)
    
    for product, ruleFileList := range *config.Config </span><span class="cov8" title="28">{        
        ruleList, err := ruleListConvert(ruleFileList)
        if err != nil </span><span class="cov0" title="0">{
            return conf, err
        }</span>

                <span class="cov8" title="28">conf.Config[product] = classifyRules(ruleList)</span>
    }

    <span class="cov5" title="7">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">/*header_table.go - table for storing header rules   */
/*
modification history
--------------------
2015/4/29, by Xiong Zongtao, created.
*/
/*
DESCRIPTION
*/
package mod_header

import (
    "fmt"
    "sync"
)

type HeaderTable struct {
    lock            sync.Mutex
    version         string
    productRules    ProductRules
}

func NewHeaderTable() *HeaderTable <span class="cov7" title="7">{
    t := new(HeaderTable)
    t.productRules = make(ProductRules)
    return t
}</span>

// update
func (t *HeaderTable) Update(conf HeaderConf) <span class="cov6" title="6">{
    t.lock.Lock()
    
    t.version = conf.Version
    t.productRules = conf.Config

    t.lock.Unlock()
}</span>

/* Search for header rules
 
   Returns:
        (*RuleList, nil), if succeed
        (nil, error), if fail
*/
func (t *HeaderTable) Search(product string) ([]*RuleList, error)<span class="cov10" title="16">{
    t.lock.Lock()   
    //  find rules for given product
    rules, ok := t.productRules[product]
    t.lock.Unlock()
    
    if ok </span><span class="cov10" title="16">{    
        return rules, nil
    }</span> <span class="cov0" title="0">else {
        return nil, fmt.Errorf("no header rules for %s", product)
    }</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">/* mod_header.go - module for header    */
/*
modification history
--------------------
2015/4/28, by Xiong Zongtao, created.
2015/8/31, by Xiong Zongtao, modified.
        -add global product for global configuration
*/
/*
DESCRIPTION
* THIS module insert/modify/append/delete request headers according
* to conditions specified by users before it is transfered to
* backends
*/
package mod_header

import (
        "fmt"
        "net/url"
)

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
)

const (
        REQ_HEADER=0
        RSP_HEADER=1
)

var (
        openDebug = false
)

const (
        GLOBAL_PRODUCT = "global"
)

type ModuleHeader struct {
        name       string       // name of module
        configPath string       // path of config file
        ruleTable  *HeaderTable // table of header rules
}

func NewModuleHeader() *ModuleHeader <span class="cov5" title="7">{
        m := new(ModuleHeader)
        m.name = "mod_header"
        m.ruleTable = NewHeaderTable()
        return m
}</span>

func (m *ModuleHeader) Name() string <span class="cov1" title="1">{
        return m.name
}</span>

func (m *ModuleHeader) Attr() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                bfe_basic.MON_ATTR_RELOAD: []string{m.name}, // reload items
        }
}</span>

// load from config file for mod-header
// loadConfData is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleHeader) loadConfData(query url.Values) error <span class="cov5" title="6">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov5" title="6">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov5" title="6">conf, err := HeaderConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in HeaderConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov5" title="6">m.ruleTable.Update(conf)

        return nil</span>
}

// do rewrite to http request header, with given rewrite rules
func DoHeader(req *bfe_basic.Request, headerType int, ruleList *RuleList) <span class="cov7" title="16">{
        for _, rule := range *ruleList </span><span class="cov10" title="48">{
                // rule condition is satisfied ?
                if rule.Cond.Match(req) </span><span class="cov8" title="27">{
                        // do actions of the rule
                        HeaderActionsDo(req, headerType, rule.Actions)

                        // flag of last is true?
                        if rule.Last </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
}

// apply product rules to header
func (m *ModuleHeader) applyProductRule(request *bfe_basic.Request, headerType int, product string) <span class="cov7" title="16">{
        // find rules for given product
        rules, err := m.ruleTable.Search(product)
        h := getHeader(request, headerType)

        if err == nil </span><span class="cov7" title="16">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:before:headers=%s", m.name, *h)
                }</span>

                // do rewrite to request, according to rules
                <span class="cov7" title="16">DoHeader(request, headerType, rules[headerType])

                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:after:headers=%s", m.name, *h)
                }</span>
        }
}

// handler for header
func (m *ModuleHeader) reqHeaderHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov5" title="8">{
        // apply global rule first
        m.applyProductRule(request, REQ_HEADER, GLOBAL_PRODUCT)
        
        // product specific rule will overwirte global rule for HEADER_SET action
        m.applyProductRule(request, REQ_HEADER, request.Route.Product)

        return bfe_module.BFE_HANDLER_GOON, nil
}</span>


// add bfe-cluster header for testing
func (m *ModuleHeader) rspHeaderHandler(request *bfe_basic.Request, res *bfe_http.Response) int <span class="cov0" title="0">{
        // apply global rule first
        m.applyProductRule(request, RSP_HEADER, GLOBAL_PRODUCT)
        
        // product specific rule will overwirte global rule for HEADER_SET action
        m.applyProductRule(request, RSP_HEADER, request.Route.Product)

        return bfe_module.BFE_HANDLER_GOON
}</span>

func (m *ModuleHeader) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov5" title="6">{
        var err error
        var conf *ConfModHeader

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov5" title="6">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleHeader) init(cfg *ConfModHeader, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov5" title="6">{
        openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath
        
        // init variable header value handler
        initVarHeader()        

        // load from config file to rule table
        if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov5" title="6">err := cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.reqHeaderHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.headerHandler): %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov5" title="6">err = cbs.AddFilter(bfe_module.HANDLE_READ_BACKEND, m.rspHeaderHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.respHeaderHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov5" title="6">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov5" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">/* conf_mod_header_defence.go - config for mod_header_defence */
/*
modification history
--------------------
2014/11/21, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_header_defence

import (
    "errors"
)

import (
    "code.google.com/p/gcfg"
        "www.baidu.com/golang-lib/conf_path"
)

type ConfModHeaderDefence struct {
    Basic struct {
        DataPath string // products which enbale header defence
    }

    Log struct {
        OpenDebug bool
    }
}

func (conf *ConfModHeaderDefence) Check() error <span class="cov10" title="3">{
    if conf.Basic.DataPath == "" </span><span class="cov0" title="0">{
        return errors.New("ConfModHeaderDefence datapath not set")
    }</span>

    <span class="cov10" title="3">return nil</span>
}

func ConfLoad(path, cr string) (*ConfModHeaderDefence, error) <span class="cov6" title="2">{
    var err error
    var conf ConfModHeaderDefence

    // read config from file
    if err = gcfg.ReadFileInto(&amp;conf, path); err != nil </span><span class="cov0" title="0">{
        return &amp;conf, err
    }</span>

    // check conf of mod_header_defence
    <span class="cov6" title="2">err = conf.Check()
    if err != nil </span><span class="cov0" title="0">{
        return &amp;conf, err
    }</span>

    <span class="cov6" title="2">conf.Basic.DataPath = conf_path.ConfPathProc(conf.Basic.DataPath, cr)

    return &amp;conf, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">/* mod_header_defence.go - module for judging 360 User Agent by headers */
/*
modification history
--------------------
2014/11/19, by Sijie Yang, create
*/
/*
DESCRIPTION
    clone of mod_header_defence in bfe
*/
package mod_header_defence

import (
    "encoding/json"
    "fmt"
    "net/url"
    "strings"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
    "bfe_util"
)

// const for headers and values
const HEADER_USER_AGENT = "User-Agent"
const HEADER_DEFENCE    = "bfe-atk"
const VALUE_NORMAL      = "NORMAL_BROWSER"
const VALUE_ABNORMAL    = "ABNORMAL_BROWSER"

var (
    openDebug = false
)

// user agent whitelist
var UserAgentWhitelist = []string {
    "LBBROWSER",
    "SE 2.X MetaSr",
    "BIDUBrowser",
    "TaoBrowser",
    "Maxthon",
}

// headers in abnormal order
var AbnormalHeadersOrder = []string{
    "Host",
    "Connection",
    "User-Agent",
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Charset",
    "Cookie",
}

// keys for counter of mod_header_defence
var CounterKeys = []string {
    "REQ_TOTAL",                // total requests
    "REQ_TO_CHECK",             // requests to check
    "REQ_FROM_NORMAL_BROWSER",  // requests from normal browsers
    "REQ_FROM_ABNORMAL_BROWSER",// requests from abnormal browsers
    "REQ_WITHOUT_USER_AGENT",   // requests without user agent header
    "REQ_UA_IN_WHITELIST",      // requests from browsers in whitelist
    "REQ_WITH_NORMAL_HEADERS",  // requests with normal headers
}

type ModuleHeaderDefence struct {
    name string                 // module name
    state *module_state2.State  // module state

    dataPath string             // path to header defence data path
    products map[string]bool    // products which enable header defence
}

func NewModuleHeaderDefence() *ModuleHeaderDefence <span class="cov4" title="8">{
    m := new(ModuleHeaderDefence)
    m.name = "mod_header_defence"

    m.state = new(module_state2.State)
    m.state.Init()
    m.state.CountersInit(CounterKeys)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_HEADER_DEFENCE)
    m.products = make(map[string]bool)

    return m
}</span>

func (m *ModuleHeaderDefence) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

// return module attributions
func (m *ModuleHeaderDefence) Attr() map[string]interface{} <span class="cov1" title="1">{
    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
    }

    // reload items
    reloadEntries := []string {m.name}

    return map[string]interface{} {
        bfe_basic.MON_ATTR_MONITOR: monitorEntries, // monitor items
        bfe_basic.MON_ATTR_RELOAD : reloadEntries,  // reload items
    }
}</span>

// loadProducts is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleHeaderDefence) loadProducts(query url.Values) error <span class="cov1" title="1">{
    path := query.Get("path")
    if path == "" </span><span class="cov1" title="1">{
        path = m.dataPath
    }</span>

    <span class="cov1" title="1">products := new([]string)
    if err := bfe_util.LoadJsonFile(path, &amp;products); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // init products which enable header defence
    <span class="cov1" title="1">productsConf := make(map[string]bool)
    for _, product := range(*products) </span><span class="cov2" title="2">{
        productsConf[product] = true
    }</span>
    <span class="cov1" title="1">m.products = productsConf
    return nil</span>

}

// load config from file
func (m *ModuleHeaderDefence) LoadConf(confPath string, cr string) error <span class="cov1" title="1">{
    conf, err := ConfLoad(confPath, cr)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>

    <span class="cov1" title="1">openDebug = conf.Log.OpenDebug
    m.dataPath = conf.Basic.DataPath

    return m.loadProducts(nil)</span>
}

// check whether `product` enable defence or not
func (m *ModuleHeaderDefence) isProductEnableDefence(product string) bool <span class="cov2" title="2">{
    return m.products[product]
}</span>

// header defence process
func (m *ModuleHeaderDefence) doHeaderDefence(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov2" title="2">{
    m.state.Inc("REQ_TOTAL", 1)
    if !m.isProductEnableDefence(req.Route.Product) </span><span class="cov1" title="1">{
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s: Skip header defence (proudct: %s)", m.name, req.Route.Product)
        }</span>
        <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON, nil</span>
    }

    <span class="cov1" title="1">m.state.Inc("REQ_TO_CHECK", 1)
    if m.judgeUserAgent360(req) </span><span class="cov0" title="0">{
        req.HttpRequest.Header.Add(HEADER_DEFENCE, VALUE_ABNORMAL)
        m.state.Inc("REQ_FROM_ABNORMAL_BROWSER", 1)
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s: Request from abnormal browser", m.name)
        }</span>
    } <span class="cov1" title="1">else {
        req.HttpRequest.Header.Add(HEADER_DEFENCE, VALUE_NORMAL)
        m.state.Inc("REQ_FROM_NORMAL_BROWSER", 1)
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s: Request from normal browser", m.name)
        }</span>
    }
    <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON, nil</span>
}

// check whether user agent is '360' or not
func (m *ModuleHeaderDefence) judgeUserAgent360(request *bfe_basic.Request) bool <span class="cov4" title="8">{
    req := request.HttpRequest

    // user agent not provide
    userAgent := req.Header.Get(HEADER_USER_AGENT)
    if (len(userAgent) == 0) </span><span class="cov2" title="2">{
        m.state.Inc("REQ_WITHOUT_USER_AGENT", 1)
        return false
    }</span>
    <span class="cov4" title="6">if openDebug </span><span class="cov0" title="0">{
        log.Logger.Debug("%s: Request User Agent: %s", m.name, userAgent)
    }</span>

    // user agent in whitelist
    <span class="cov4" title="6">for i := 0; i &lt; len(UserAgentWhitelist); i ++ </span><span class="cov7" title="27">{
        if strings.Contains(userAgent, UserAgentWhitelist[i]) </span><span class="cov2" title="2">{
            m.state.Inc("REQ_UA_IN_WHITELIST", 1)
            return false
        }</span>
    }

    // request with normal headers
    <span class="cov3" title="4">if !matchAbnormalHeadersOrder(req.HeaderKeys) </span><span class="cov2" title="2">{
        m.state.Inc("REQ_WITH_NORMAL_HEADERS", 1)
        return false
    }</span>

    <span class="cov2" title="2">return true</span>
}

/* matchAbnormalHeadersOrder - match abnormal headers order
 * 
 * Params:
 *     headerKeys: keys of header in orginal order
 *
 * Return:
 *     true: if the order of keys in `AbnormalHeadersOrder` 
             match that of headerKeys
 *     false: if not
 */
func matchAbnormalHeadersOrder(headerKeys []string) bool <span class="cov3" title="4">{
    var prevPos, nextPos int

    prevPos = indexOfSlice(headerKeys, AbnormalHeadersOrder[0])
    for i := 1; i &lt; len(AbnormalHeadersOrder); i ++ </span><span class="cov6" title="24">{
        nextPos = indexOfSlice(headerKeys, AbnormalHeadersOrder[i])
        if nextPos &lt; prevPos </span><span class="cov2" title="2">{ // compare order of two adjacent header keys
            return false
        }</span>
        <span class="cov6" title="22">prevPos = nextPos</span>
    }
    <span class="cov2" title="2">return true</span>
}

// return index of element in slice
func indexOfSlice(elems []string, elem string) int <span class="cov7" title="28">{
    for i := 0; i &lt; len(elems); i ++ </span><span class="cov10" title="123">{
        if elem == elems[i] </span><span class="cov7" title="27">{
            return i
        }</span>
    }
    <span class="cov1" title="1">return -1</span>
}

func (m *ModuleHeaderDefence) getState(query url.Values) ([]byte, error) <span class="cov1" title="1">{
    state := m.state.GetAll()

    // get param for format
    format := query.Get("format")
    if len(format) == 0 </span><span class="cov1" title="1">{
        format = "json"
    }</span>

    <span class="cov1" title="1">var buff []byte
    var err error

    switch format </span>{
        <span class="cov1" title="1">case "json":
            buff, err = json.Marshal(state)</span>
        <span class="cov0" title="0">case "noah":
            buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }
    <span class="cov1" title="1">return buff, err</span>
}

// all monitor handlers
func (m *ModuleHeaderDefence) monitorHandlers() map[string]interface{} <span class="cov0" title="0">{
    handlers := map[string]interface{} {
        m.name  : m.getState,
    }
    return handlers
}</span>

// all relaod handlers
func (m *ModuleHeaderDefence) reloadHandlers() map[string]interface{} <span class="cov0" title="0">{
    handlers := map[string]interface{} {
        m.name  : m.loadProducts,
    }
    return handlers
}</span>

func (m *ModuleHeaderDefence) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                                   cr string) error <span class="cov0" title="0">{
    var err error

    // load config
    if err = m.LoadConf(bfe_module.ModConfPath(cr, m.name), cr); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // register handler
    <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.doHeaderDefence)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.doHeaderDefence): %s", m.name, err.Error())
    }</span>

    // register web handler for monitor
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>

    // register web handler for reload
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/* base64.go - base64 decode algorithm   */
/*
modification history
--------------------
2015/7/22, by Taochunhua, create
*/
/*
DESCRIPTION
    The base64 used in baidu is different from public base64 algorithm. The algorithm in this file
is copied from : https://svn.baidu.com/op/oped/noah/trunk/bfe/bfe-nginx/https/src/http/modules/thirdparty_module/https_identify_ngx_module/https_base64.cpp
*/
package mod_host_delegation

/*
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const char psBase64Val[] = {(char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char)63, (char) -1, (char) -1, (char)1, (char)2, (char)3, (char)4, (char)5, (char)58, (char)59, (char)60, (char)61, (char)62, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1, (char)6, (char)7, (char)8, (char)9, (char)10, (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20, (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30, (char)31, (char) -1, (char) -1, (char) -1, (char) -1, (char)0, (char) -1, (char)32, (char)33, (char)34, (char)35, (char)36, (char)37, (char)38, (char)39, (char)40, (char)41, (char)42, (char)43, (char)44, (char)45, (char)46, (char)47, (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char) -1, (char) -1, (char) -1, (char) -1, (char) -1};
static const char LOW[] = {0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F};

int bc_base64_dec(char* out, int outlen, const char* in, int inlen)
{   
    int l, n, i;

    if (NULL == in || NULL == out || inlen &lt; 0 || (inlen == 1 &amp;&amp; *in != 0) || (inlen * 6) % 8 &gt;= 6)
    {
        // Invalid basetext or length
        return -1;
    }

    for (i = 0; i &lt; inlen; i++)
    {
        if (*(in + i) &gt; 127 || psBase64Val[(char) * (in + i)] == (char) -1)
        {
            // Invalid base codes
            return -1;
        }
    }

    //*outlen = inlen * 6 / 8;
    l = inlen * 6 / 8;
    if (l &gt; outlen)
    {
        return -1;
    }

    //memset(out, 0, (size_t)(outlen + 1));
    // out memory has already set to 0
    n = 0;
    
    while (l-- &gt; 0 &amp;&amp; inlen &gt; 0)
    {
        if (n &gt; 0)
        {
            *out |= (psBase64Val[(char) * in] &amp; LOW[n]) &lt;&lt; (8 - n);
            in++;
            inlen--;
        }

        n = 8 - n;

        if (n &gt;= 6)
        {
            *out |= psBase64Val[(char) * in] &lt;&lt; (n - 6);
            n -= 6;
            in++;
            inlen--;
        }

        if (n &gt; 0)
        {
            *out |= psBase64Val[(char) * in] &gt;&gt; (6 - n);
            n = 6 - n;
        }

        out++;
    }

    return 0;
}
*/
import "C"
import "unsafe"

func base64_dec(s string) []byte <span class="cov10" title="120">{
    size := len(s) * 6 / 8
    if size ==</span><span class="cov0" title="0"> 0 {
        return nil
  </span>  }
    
 <span class="cov10" title="120">   cs := C.CString(s)
    buff := make([]byte, size, size)
    
    if C.bc_base64_dec((*C.char)(unsafe.Pointer(&amp;buff[0])), C.int(size), cs, C.int(len(s))) != 0 {
        C.free(unsafe.Pointer(cs))
        return nil
    }
    
    C.free(unsafe.Pointer(cs))
     
    return buff
}
</pre>
		
		<pre class="file" id="file93" style="display: none">/* conf_mod_host_delegation.go - config for mod_host_delegation   */
/*
modification history
--------------------
2015/7/16, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package mod_host_delegation

import (
    "errors"
)

import (
    "code.google.com/p/gcfg"
)

type PathConf struct {
    DecryptKeyPath          string
    DelegationsPath         string
    DomainDictPath          string
}

type ConfModHostDelegation struct {
    PathConfig        PathConf
}


/* load config from config file    */
func ConfLoad(filePath string) (PathConf, error) <span class="cov8" title="1">{
    var err error
    var cfg ConfModHostDelegation

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return cfg.PathConfig, err
    }</span>

    // check conf of mod_access
    <span class="cov8" title="1">err = cfg.Check()
    if err != nil </span><span class="cov0" title="0">{
        return cfg.PathConfig, err
    }</span>

    <span class="cov8" title="1">return cfg.PathConfig, nil</span>
}

func (cfg *ConfModHostDelegation) Check() error <span class="cov8" title="1">{
    return ConfModHostDelegationCheck(&amp;cfg.PathConfig)
}</span>

func ConfModHostDelegationCheck(path *PathConf) error <span class="cov8" title="1">{
    if path.DecryptKeyPath == "" </span><span class="cov0" title="0">{
        return errors.New("DecryptKeyPath empty")
    }</span>
    
    <span class="cov8" title="1">if path.DelegationsPath == "" </span><span class="cov0" title="0">{
        return errors.New("DelegationsPath empty")
    }</span>
    
    <span class="cov8" title="1">if path.DomainDictPath == "" </span><span class="cov0" title="0">{
        return errors.New("DomainDictPath empty")
    }</span>
    
    <span class="cov8" title="1">return nil</span>
}

</pre>
		
		<pre class="file" id="file94" style="display: none">/* domain_dict.go - dictionary for domain info */
/*
modification history
--------------------
2015/07/15, by Taochunhua, create
*/
/*
DESCRIPTION
*/

package mod_host_delegation

import (
    "bufio"
    "bytes"
    //"crypto/md5"
    "fmt"
    "io/ioutil"
    "os"
    "strconv"
    "strings"
    "sync"
    "time"
)

const (
    DICT_SIZE_LIMIT = 1024 * 1024 * 10  // 10 MB limit for this dict
    DICT_ENTRY_COL_N = 6                // how many colomns in an entry
    DICT_LINE_LIMIT  = 100000           // line limit for this dict
)

type DictEnry  struct {
    Emergence       int
    UrlPrefix       string
    Type            string  // "D" - dynamic; "S" - static
    ThirdPartyReq   int
    WhiteList       string
}

type DomainDict struct {
    signature   string      // md5 signature
    table       map[string]DictEnry
    timestamp   time.Time
    lock        sync.RWMutex
}

func NewEntry(items []string) (*DictEnry, error) <span class="cov10" title="240">{
    var err error
    entry := new(DictEnry)
    
    entry.Emergence, err = strconv.Atoi(items[0])
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("entry Emergence: %s", err.Error())
    }</span>
    
    <span class="cov10" title="240">entry.UrlPrefix = items[2]
    
    entry.Type = items[3]
    if entry.Type != "S" &amp;&amp; entry.Type != "D" </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("entry dynamic/static type: %s", entry.Type)
    }</span>
    
    <span class="cov10" title="240">entry.ThirdPartyReq, err = strconv.Atoi(items[4])
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("entry ThirdPartyReq: %s", err.Error())
    }</span>
    
    <span class="cov10" title="240">entry.WhiteList = items[5]
    
    return entry, err</span>
}

func NewDomainDict() *DomainDict <span class="cov2" title="2">{
    dict := new(DomainDict)
    dict.table = make(map[string]DictEnry)
    
    return dict
}</span>

// load dict from file
func (d *DomainDict) Load(path string) error <span class="cov2" title="2">{
    info, err := os.Stat(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Load() os.Stat(): %s", err.Error())
    }</span>
    
    <span class="cov2" title="2">size := info.Size()
    // this dict is relatively small, should not be too big
    if size &gt;= DICT_SIZE_LIMIT </span><span class="cov0" title="0">{
        return fmt.Errorf("domain dict too big: %d", size)
    }</span>
    
    <span class="cov2" title="2">data, err := ioutil.ReadFile(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Load() ioutil.ReadFile(): %s", err.Error())
    }</span>
    
    <span class="cov2" title="2">reader := bytes.NewReader(data)
    scanner := bufio.NewScanner(reader)
    if scanner.Scan() == false </span><span class="cov0" title="0">{
        // file formate error
        return fmt.Errorf("domain dict formate error")
    }</span>
    
    // first line is signature
    <span class="cov2" title="2">signature := scanner.Text()
    
    table := make(map[string]DictEnry)
    lineCounter := 0
    
    for scanner.Scan() </span><span class="cov10" title="240">{
        // get text line
        entryLine := scanner.Text()
        
        // parse
        items := strings.Split(entryLine, " ")
        if len(items) != DICT_ENTRY_COL_N </span><span class="cov0" title="0">{
            return fmt.Errorf("domain dict entry formate error")
        }</span>
        
        // create entry
        <span class="cov10" title="240">entry, err := NewEntry(items)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("NewEntry: %s", err.Error())
        }</span>
        
        // add into table
        <span class="cov10" title="240">table[items[1]] = *entry
        
        // check line limit
        lineCounter += 1
        if lineCounter &gt;= DICT_LINE_LIMIT </span><span class="cov0" title="0">{
            return fmt.Errorf("domain dict too many lines")
        }</span>
    }
    
    // check signature
    
    
    // update 
    <span class="cov2" title="2">d.Update(signature, table)
    
    return nil</span>
}

func (d *DomainDict) Update(signature string, table map[string]DictEnry) <span class="cov2" title="2">{
    d.lock.Lock()
    
    d.signature = signature
    d.table = table
    d.timestamp = time.Now()
    
    d.lock.Unlock()
}</span>

func (d *DomainDict) Find(domain string) (*DictEnry, error) <span class="cov2" title="2">{
    var entryPtr *DictEnry
    var err error
    
    d.lock.RLock()
    
    if entry, ok := d.table[domain]; ok </span><span class="cov1" title="1">{
        entryPtr = &amp;entry
        err = nil
    }</span> <span class="cov1" title="1">else {
        entryPtr = nil
        err = fmt.Errorf("no such domain: %s", domain)
    }</span>
    
    <span class="cov2" title="2">d.lock.RUnlock()
    
    return entryPtr, err</span>
}

func (d *DomainDict) Size() int <span class="cov1" title="1">{
    d.lock.RLock()
    size := len(d.table)
    d.lock.RUnlock()
    
    return size
}</span>

func (d *DomainDict) UpdateTime() time.Time <span class="cov1" title="1">{
    d.lock.RLock()
    ts := d.timestamp
    d.lock.RUnlock()
    
    return ts
}</span>

func (d *DomainDict) Signature() string <span class="cov2" title="2">{
    d.lock.RLock()
    signature := d.signature
    d.lock.RUnlock()
    
    return signature
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">/* delegation_table.go - table for innocent domains */
/*
modification history
--------------------
2015/07/15, by Taochunhua, create
*/
/*
DESCRIPTION
*/

package mod_host_delegation

import (
    "bufio"
    "bytes"
    "fmt"
    "io/ioutil"
    "os"
    "time"
    "sync"
)

const (
    DOMAIN_SIZE_LIMIT = 1024 * 1024 * 10  // 10 MB limit for domain file
    INNO_DOMAIN_LINE_LIMIT = 100000       // line limit for this table
)


type DelegationTable struct {
    domainSet   map[string]int      // this map is used as a set, value is useless
    timeStamp   time.Time
    lock        sync.RWMutex
}

func NewInnoDomainTable() *DelegationTable <span class="cov2" title="2">{
    t := new(DelegationTable)
    t.domainSet = make(map[string]int)
    
    return t
}</span>

// load domain list from file
func (t *DelegationTable) Load(path string) error <span class="cov2" title="2">{
    info, err := os.Stat(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Load() os.Stat(): %s", err.Error())
    }</span>
    
    <span class="cov2" title="2">size := info.Size()
    // this file is relatively small, should not be too big
    if size &gt;= DOMAIN_SIZE_LIMIT </span><span class="cov0" title="0">{
        return fmt.Errorf("domain list too big: %d", size)
    }</span>
    
    <span class="cov2" title="2">data, err := ioutil.ReadFile(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Load() ioutil.ReadFile(): %s", err.Error())
    }</span>
    
    <span class="cov2" title="2">reader := bytes.NewReader(data)
    scanner := bufio.NewScanner(reader)
    
    domains := make([]string, 0)
    lineCounter := 0
    
    for scanner.Scan() </span><span class="cov10" title="286">{
        // get text line
        domain := scanner.Text()
        // add into list
        domains = append(domains, domain)
        
        // check line limit
        lineCounter += 1
        if lineCounter &gt;= INNO_DOMAIN_LINE_LIMIT </span><span class="cov0" title="0">{
            return fmt.Errorf("inno domain too many lines")
        }</span>
    }
    
    // update
    <span class="cov2" title="2">t.Update(domains)
    
    return nil</span>
}

func (t *DelegationTable) Update(hostnames []string) <span class="cov2" title="2">{
    newSet := make(map[string]int)
    for _, host := range hostnames </span><span class="cov10" title="286">{
        newSet[host] = 1
    }</span>
    
    <span class="cov2" title="2">t.lock.Lock()
    
    t.domainSet = newSet
    t.timeStamp = time.Now()
    
    t.lock.Unlock()</span>
}

func (t *DelegationTable) Check(hostname string) bool <span class="cov2" title="3">{
    var found bool
    
    t.lock.RLock()
    _, found = t.domainSet[hostname]
    t.lock.RUnlock()
    
    return found
}</span>

func (t *DelegationTable) UpdateTime() time.Time <span class="cov1" title="1">{
    t.lock.RLock()
    ts := t.timeStamp
    t.lock.RUnlock()
    
    return ts
}</span>

func (t *DelegationTable) Size() int <span class="cov1" title="1">{
    t.lock.RLock()
    size := len(t.domainSet)
    t.lock.RUnlock()
    
    return size
}</pre>
		
		<pre class="file" id="file96" style="display: none">/* key_list.go - keys for decrypt */
/*
modification history
--------------------
2015/07/15, by Taochunhua, create
*/
/*
DESCRIPTION
*/

package mod_host_delegation

import (
    "bufio"
    "bytes"
    "fmt"
    "io/ioutil"
    "os"
    "sync"
    "time"
)

const (
    KEYLIST_SIZE_LIMIT = 1024 * 1024 * 1  // 1 MB limit for key file
    KEYLIST_LINE_LIMIT = 1000             // line limit for this key file
)

type KeyList  struct {
    keys        [][]byte
    timestamp   time.Time
    lock        sync.RWMutex
}

func NewKeyList() *KeyList <span class="cov4" title="2">{
    keylist := new(KeyList)
    keylist.keys = make([][]byte, 0)
    
    return keylist
}</span>


// load key list from file
func (l *KeyList) Load(path string) error <span class="cov4" title="2">{
    info, err := os.Stat(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Load() os.Stat(): %s", err.Error())
    }</span>
    
    <span class="cov4" title="2">size := info.Size()
    // this file is relatively small, should not be too big
    if size &gt;= KEYLIST_SIZE_LIMIT </span><span class="cov0" title="0">{
        return fmt.Errorf("key list too big: %d", size)
    }</span>
    
    <span class="cov4" title="2">data, err := ioutil.ReadFile(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Load() ioutil.ReadFile(): %s", err.Error())
    }</span>
    
    <span class="cov4" title="2">reader := bytes.NewReader(data)
    scanner := bufio.NewScanner(reader)
    
    keys := make([][]byte, 0)
    lineCounter := 0
    
    for scanner.Scan() </span><span class="cov10" title="6">{
        // get text line
        keyText := scanner.Text()
        // convert to bytes
        buff := bytes.NewBufferString(keyText)
        key := buff.Bytes()
        // add into list
        keys = append(keys, key)
        
        // check line limit
        lineCounter += 1
        if lineCounter &gt;= KEYLIST_LINE_LIMIT </span><span class="cov0" title="0">{
            return fmt.Errorf("key list too many lines")
        }</span>
    }
    
    // check size
    <span class="cov4" title="2">if len(keys) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("key file is empty")
    }</span>
    
    // update
    <span class="cov4" title="2">l.Update(keys)
    
    return nil</span>
}

func (l *KeyList) Update(keys [][]byte) <span class="cov4" title="2">{
    l.lock.Lock()

    l.keys = keys
    l.timestamp = time.Now()
    
    l.lock.Unlock()
}</span>

func (l *KeyList) Get() [][]byte <span class="cov4" title="2">{
    var keys [][]byte
    
    l.lock.RLock()
    keys = l.keys
    l.lock.RUnlock()
    
    return keys
}</span>

func (l *KeyList) Size() int <span class="cov4" title="2">{
    l.lock.RLock()
    n := len(l.keys)
    l.lock.RUnlock()
    
    return n
}</span>

func (l *KeyList) UpdateTime() time.Time <span class="cov1" title="1">{
    l.lock.RLock()
    ts := l.timestamp
    l.lock.RUnlock()
    
    return ts
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">/* mod_host_delegation.go - module hostname proxy decryption */
/*
modification history
--------------------
2015/07/15, by Taochunhua, create
*/
/*
DESCRIPTION
*/

package mod_host_delegation

import (
    "crypto/rc4"
    "encoding/json"
    "fmt"
    "net/url"
    "path"
    "strings"
)

import (
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
)

const (
    DIFF_COUNTER_INTERVAL = 20
)

type ModHostDelegation struct {
    name             string                     // name of module
    
    delegationTable *DelegationTable            // innocent domain table
    domainDict      *DomainDict                 // domain dict
    keys            *KeyList                    // decrypt keys
    configRoot      string                      // default configRoot
    
    state       *module_state2.State       // module state
    stateDiff   module_state2.CounterSlice // diff counter of moudle state
}

// remove ":port" in hostname
func hostnameStrip(hostname string) string <span class="cov0" title="0">{
    return strings.Split(hostname, ":")[0]
}</span>

func NewModHostDelegation() *ModHostDelegation <span class="cov1" title="1">{
    m := new(ModHostDelegation)
    m.name = "mod_host_delegation"

    m.state = new(module_state2.State)
    m.state.Init()
    m.stateDiff.Init(m.state, DIFF_COUNTER_INTERVAL)

    m.delegationTable = NewInnoDomainTable()
    m.domainDict = NewDomainDict()
    m.keys = NewKeyList()
    
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_HOST_DELEGATE)
    m.stateDiff.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_HOST_DELEGATE_DIFF)

    return m
}</span>

func (m *ModHostDelegation) InitTables(conf PathConf, moduleConfig string) error <span class="cov1" title="1">{
    var err error
    err = m.delegationTable.Load(path.Join(moduleConfig, conf.DelegationsPath))
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    
    <span class="cov1" title="1">err = m.domainDict.Load(path.Join(moduleConfig, conf.DomainDictPath))
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    
    <span class="cov1" title="1">err = m.keys.Load(path.Join(moduleConfig, conf.DecryptKeyPath))
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    
    // set state for monitor
    <span class="cov1" title="1">m.setState()
    
    return nil</span>
}

// set data info in state monitor
func (m *ModHostDelegation) setState() <span class="cov1" title="1">{
    info := fmt.Sprintf("%v", m.keys.UpdateTime())
    m.state.Set("KEY_LIST_UPDATE_TIME", info)
    
    m.state.SetNum("KEY_LIST_SIZE", int64(m.keys.Size()))
    
    info = fmt.Sprintf("%v", m.delegationTable.UpdateTime())
    m.state.Set("DELEGATION_TABLE_UPDATE_TIME", info)
    
    m.state.SetNum("DELEGATION_TABLE_SIZE", int64(m.delegationTable.Size()))
    
    info = fmt.Sprintf("%v", m.domainDict.UpdateTime())
    m.state.Set("DOMAIN_DICT_UPDATE_TIME", info)
    
    info = fmt.Sprintf("%v", m.domainDict.Signature())
    m.state.Set("DOMAIN_DICT_SIGNATURE", info)
    
    m.state.SetNum("DOMAIN_DICT_SIZE", int64(m.domainDict.Size()))
}</span>

func (m *ModHostDelegation) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModHostDelegation) Attr() map[string]interface{} <span class="cov0" title="0">{
    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name : bfe_basic.MON_TYPE_STATE,
        m.name + ".diff" : bfe_basic.MON_TYPE_COUNTER_SLICE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,  //  monitor items
        bfe_basic.MON_ATTR_RELOAD: []string{m.name}, // reload items
    }
}</span>

func (m *ModHostDelegation) getState(query url.Values) ([]byte, error) <span class="cov0" title="0">{
    state := m.state.GetAll()
    
    // get param for format
    format := query.Get("format")
    if len(format) == 0 </span><span class="cov0" title="0">{
        // default format is json
        format = "json"
    }</span>

    <span class="cov0" title="0">var buff []byte
    var err error

    switch format </span>{
        <span class="cov0" title="0">case "json":
            buff, err = json.Marshal(state)</span>
        <span class="cov0" title="0">case "noah":
            buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }    
    <span class="cov0" title="0">return buff, err</span>
}

func (m *ModHostDelegation) getStateDiff(query url.Values) ([]byte, error) <span class="cov0" title="0">{
    stateDiff := m.stateDiff.Get()
    
    // get param for format
    format := query.Get("format")
    if len(format) == 0 </span><span class="cov0" title="0">{
        // default format is json
        format = "json"
    }</span>

    <span class="cov0" title="0">var buff []byte
    var err error

    switch format </span>{
        <span class="cov0" title="0">case "json":
            buff, err = json.Marshal(stateDiff)</span>
        <span class="cov0" title="0">case "noah":
            buff = stateDiff.NoahString()</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }    
    <span class="cov0" title="0">return buff, err</span>
}

// register web monitor handlers
func (m *ModHostDelegation) monitorHandlers() map[string]interface{} <span class="cov0" title="0">{
    handlers := map[string]interface{} {
        m.name               : m.getState,
        m.name + ".diff"     : m.getStateDiff,
    }

    return handlers
}</span>

// reload data
// loadConfData is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModHostDelegation) loadConfData(query url.Values) error <span class="cov0" title="0">{
    var conf PathConf
    var err error
    
    // using default file path
    confPath := bfe_module.ModConfPath(m.configRoot, m.name)

    // load conf data
    if conf, err = ConfLoad(confPath); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
    }</span>
    
    <span class="cov0" title="0">moduleConfPath := path.Join(m.configRoot, m.name)
    
    // init data
    err = m.InitTables(conf, moduleConfPath)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): InitTables(): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return nil</span>
}

func (m *ModHostDelegation) Init(cbs *bfe_module.BfeCallbacks,
                                 whs *web_monitor.WebHandlers, cr string) error <span class="cov0" title="0">{
    var err error
    var conf PathConf
    
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
    }</span>
    
    <span class="cov0" title="0">moduleConfPath := path.Join(cr, m.name)
    
    // init data
    err = m.InitTables(conf, moduleConfPath)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): InitTables(): %s", m.name, err.Error())
    }</span>
    
    // set config Root
    <span class="cov0" title="0">m.configRoot = cr

    // register handler
    err = cbs.AddFilter(bfe_module.HANDLE_BEFORE_LOCATION, m.removeDelegation)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.removeDelegation): %s", m.name, err.Error())
    }</span>

    // register web handlers for monitor
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>
    
    // register web handler for reload
    <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfData)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return nil</span>
}

// module call backs
// handler for remove hostname delegations
func (m *ModHostDelegation) removeDelegation(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
    // service only for https
    if !req.Session.IsHttps </span><span class="cov0" title="0">{
        return bfe_module.BFE_HANDLER_GOON, nil
    }</span>
    
    // get hostname
    <span class="cov0" title="0">hostname := hostnameStrip(req.HttpRequest.Host)
    
    // check if hostname in delegation hosts
    if !m.delegationTable.Check(hostname) </span><span class="cov0" title="0">{
        // this hostname is not a delegation host
        return bfe_module.BFE_HANDLER_GOON, nil
    }</span>
    
    // decrypt
    <span class="cov0" title="0">path := req.HttpRequest.URL.Path
    tokens := strings.SplitN(path, "/", 3)
    if len(tokens) &lt; 2 </span><span class="cov0" title="0">{
        // error in path
        m.state.Inc("PATH_ERROR", 1)
        return bfe_module.BFE_HANDLER_FINISH, nil
    }</span>
    
    <span class="cov0" title="0">allKeys := m.keys.Get()
    find := false
    var entry *DictEnry
    var rawHostname string
    var err error
    
    // try keys one by one
    for _, key := range allKeys </span><span class="cov0" title="0">{
        rawHostname, err = m.decrypt(tokens[1], key)
        if err != nil </span><span class="cov0" title="0">{
            m.state.Inc("DECRYPT_ERROR", 1)
            continue</span>
        }
        
        // check if decrypted hostname in domain dict
        <span class="cov0" title="0">entry, err = m.domainDict.Find(rawHostname)
        if err != nil </span><span class="cov0" title="0">{
            // no such host, reject
            m.state.Inc("HOSTNAME_NOT_IN_DICT", 1)
            continue</span>
        } <span class="cov0" title="0">else {
            // get it
            find = true
            break</span>
        }
    }
    
    <span class="cov0" title="0">if !find </span><span class="cov0" title="0">{
        m.state.Inc("FIND_NOT_HOST", 1)
        return bfe_module.BFE_HANDLER_FINISH, nil
    }</span>
    
    // process for domain dict items
    <span class="cov0" title="0">m.process(entry, req)
        
    // remove delelation host
    req.HttpRequest.Host = rawHostname
    req.HttpRequest.URL.Path = "/" + tokens[2]
    
    return bfe_module.BFE_HANDLER_GOON, nil</span>
}

func (m *ModHostDelegation) process(entry *DictEnry, req *bfe_basic.Request) <span class="cov0" title="0">{
    // check if set dynamic
    if entry.Type == "D" </span><span class="cov0" title="0">{
        // set Cache-Control=no-cache, ssl_dynamic_header=D
        req.HttpRequest.Header.Set("Cache-Control", "no-cache")
        req.HttpRequest.Header.Set("ssl_dynamic_header", "D")
    }</span> <span class="cov0" title="0">else {
        // set ssl_dynamic_header=S
        req.HttpRequest.Header.Set("ssl_dynamic_header", "S")
    }</span>
    
    // check if set ThirdPartyReq
    <span class="cov0" title="0">if entry.ThirdPartyReq &gt; 0 </span><span class="cov0" title="0">{
        // set ssl_third_flag=1
        req.HttpRequest.Header.Set("ssl_third_flag", "1")
    }</span> <span class="cov0" title="0">else {
        // set ssl_third_flag=0
        req.HttpRequest.Header.Set("ssl_third_flag", "0")
    }</span>
    
    // set ssl_baidu_innocent
    <span class="cov0" title="0">req.HttpRequest.Header.Set("ssl_baidu_innocent", entry.WhiteList)
    
    // check if Emergence
    if entry.Emergence &gt; 0 </span><span class="cov0" title="0">{
        // check if match url prefix
        if strings.HasPrefix(req.HttpRequest.RequestURI, entry.UrlPrefix) </span><span class="cov0" title="0">{
            // set Cache-Control=no-cache, ssl_dynamic_header=D
            req.HttpRequest.Header.Set("Cache-Control", "no-cache")
            req.HttpRequest.Header.Set("ssl_dynamic_header", "D")
        }</span>
    }
}

func (m *ModHostDelegation) decrypt(host string, key []byte) (string, error) <span class="cov10" title="120">{
    data := base64_dec(host)
    if data == nil </span><span class="cov0" title="0">{
        return "", fmt.Errorf("base64 decode failed")
    }</span>
    
    <span class="cov10" title="120">rawHost := make([]byte, len(data))
    
    c, err := rc4.NewCipher(key)
    if err != nil </span><span class="cov0" title="0">{
        return "", fmt.Errorf("NewCipher() failed: %s", err.Error())
    }</span>
    
    <span class="cov10" title="120">c.XORKeyStream(rawHost, data)
    return string(rawHost), nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/* mod_http_retcode.go - module for service http return code statistics  */
/*
modification history
--------------------
2014/12/08, by Taochunhua, create
*/
/*
DESCRIPTION
*/

package mod_http_retcode

import (
        "encoding/json"
        "fmt"
        "net/url"
)

import (
        "www.baidu.com/golang-lib/module_state2"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
)

const (
        DIFF_COUNTER_INTERVAL = 20
)

type ModuleHttpRetcode struct {
        name string // name of module

        state     *module_state2.State       // module state
        stateDiff module_state2.CounterSlice // diff counter of moudle state
}

func NewModuleHttpRetcode() *ModuleHttpRetcode <span class="cov10" title="2">{
        m := new(ModuleHttpRetcode)
        m.name = "mod_http_retcode"

        m.state = new(module_state2.State)
        m.state.Init()
        m.stateDiff.Init(m.state, DIFF_COUNTER_INTERVAL)

        m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_HTTP_RETCODE)
        m.stateDiff.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_HTTP_RETCODE_DIFF)

        return m
}</span>

func (m *ModuleHttpRetcode) Name() string <span class="cov1" title="1">{
        return m.name
}</span>

func (m *ModuleHttpRetcode) Attr() map[string]interface{} <span class="cov1" title="1">{
        // monitor items (item name, item type)
        monitorEntries := map[string]string{
                m.name:           bfe_basic.MON_TYPE_STATE,
                m.name + ".diff": bfe_basic.MON_TYPE_COUNTER_SLICE,
        }

        return map[string]interface{}{
                bfe_basic.MON_ATTR_MONITOR: monitorEntries,
        }
}</span>

func (m *ModuleHttpRetcode) getState(query url.Values) ([]byte, error) <span class="cov1" title="1">{
        state := m.state.GetAll()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov1" title="1">var buff []byte
        var err error

        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(state)</span>
        <span class="cov1" title="1">case "noah":
                buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov1" title="1">return buff, err</span>
}

func (m *ModuleHttpRetcode) getStateDiff(query url.Values) ([]byte, error) <span class="cov1" title="1">{
        stateDiff := m.stateDiff.Get()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov1" title="1">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov1" title="1">var buff []byte
        var err error

        switch format </span>{
        <span class="cov1" title="1">case "json":
                buff, err = json.Marshal(stateDiff)</span>
        <span class="cov0" title="0">case "noah":
                buff = stateDiff.NoahString()</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov1" title="1">return buff, err</span>
}

// register web monitor handlers
func (m *ModuleHttpRetcode) monitorHandlers() map[string]interface{} <span class="cov1" title="1">{
        handlers := map[string]interface{}{
                m.name:           m.getState,
                m.name + ".diff": m.getStateDiff,
        }

        return handlers
}</span>

func (m *ModuleHttpRetcode) Init(cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers, cr string) error <span class="cov1" title="1">{
        var err error

        // register handler
        err = cbs.AddFilter(bfe_module.HANDLE_REQUEST_FINISH, m.requestFinish)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.requestFinish): %s", m.name, err.Error())
        }</span>

        // register web handlers for monitor
        <span class="cov1" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// module call backs
// handler for finish http request
func (m *ModuleHttpRetcode) requestFinish(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov10" title="2">{
        // product
        cluster := req.Backend.ClusterName
        retCode := 0

        if cluster == "" </span><span class="cov10" title="2">{
                cluster = "Empty"
        }</span>

        // return code
        <span class="cov10" title="2">if req.HttpResponse == nil </span><span class="cov0" title="0">{
                if req.BfeStatusCode == 0 </span><span class="cov0" title="0">{
                        return bfe_module.BFE_HANDLER_GOON
                }</span>

                <span class="cov0" title="0">retCode = req.BfeStatusCode
                cluster = fmt.Sprintf("BFE_%s", cluster)</span>
        } <span class="cov10" title="2">else {
                retCode = req.HttpResponse.StatusCode
        }</span>

        <span class="cov10" title="2">codeSuffix := fmt.Sprintf("%dXX", retCode/100)

        // cluster_baike_200
        key := fmt.Sprintf("%s_%d", cluster, retCode)
        m.state.Inc(key, 1)

        // ALL_200
        allKey := fmt.Sprintf("ALL_%d", retCode)
        m.state.Inc(allKey, 1)

        // cluster_baike_2xx
        key = fmt.Sprintf("%s_%s", cluster, codeSuffix)
        m.state.Inc(key, 1)

        // ALL_2xx
        allKey = fmt.Sprintf("ALL_%s", codeSuffix)
        m.state.Inc(allKey, 1)

        return bfe_module.BFE_HANDLER_GOON</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">/* conf_mod_http_sign.go - config for mod_http_sign */
/*
modification history
--------------------
2015/3/25, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_http_sign

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfModHttpSign struct {
    Basic struct {
        ProductRulePath string  // path of product sign rule data
        SignConfPath    string  // path of sign conf data
    }

    Log struct {
        OpenDebug bool          //  whether open debug
    }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModHttpSign, error) <span class="cov10" title="4">{
    var cfg ConfModHttpSign
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_http_sign
    <span class="cov10" title="4">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="4">return &amp;cfg, nil</span>
}

func (cfg *ConfModHttpSign) Check(confRoot string) error <span class="cov10" title="4">{
    return ConfModHttpSignCheck(cfg, confRoot)
}</span>

func ConfModHttpSignCheck(cfg *ConfModHttpSign, confRoot string) error <span class="cov10" title="4">{
    if cfg.Basic.ProductRulePath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModHttpSign.ProductRulePath not set, use default value")
        cfg.Basic.ProductRulePath = "mod_http_sign/sign_rule.data"
    }</span>
    <span class="cov10" title="4">cfg.Basic.ProductRulePath = conf_path.ConfPathProc(cfg.Basic.ProductRulePath, confRoot)

    if cfg.Basic.SignConfPath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModHttpSign.SignConfPath not set, use default value")
        cfg.Basic.SignConfPath = "mod_http_sign/sign_conf.data"
    }</span>
    <span class="cov10" title="4">cfg.Basic.SignConfPath = conf_path.ConfPathProc(cfg.Basic.SignConfPath, confRoot)

    return nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">/* mod_http_sign.go - module for add signature to response */
/*
modification history
--------------------
2015/3/25, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_http_sign

import (
    "crypto/md5"
    "fmt"
    "net/url"
    "sync"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
)

var (
    openDebug = false
)

// key for counter of mod_http_sign
var COUNTER_KEYS = []string{
    "REQ_TOTAL",            // all request in
    "REQ_FROM_HTTPS",       // request from https connection
    "REQ_FROM_HTTP",        // request from http connection
    "REQ_TO_CHECK",         // request to check
    "RESP_SIGN",            // response to sign
}

type ModuleHttpSign struct {
    name            string               // name of module
    state           *module_state2.State // module state

    productRulePath string               // path of sign rule data file
    signConfPath    string               // path of sign conf file

    ruleTable       *ProductRuleTable    // table for product block rules
    signSalt        string               // salt for signature
    lock            sync.RWMutex
}

func NewModuleHttpSign() *ModuleHttpSign <span class="cov6" title="2">{
    m := new(ModuleHttpSign)
    m.name = "mod_http_sign"
    m.state = new(module_state2.State)
  
    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_HTTP_SIGN)
    
    m.ruleTable = NewProductRuleTable()
    return m
}</span>

func (m *ModuleHttpSign) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModuleHttpSign) Attr() map[string]interface{} <span class="cov1" title="1">{
    // reload items
    reloadEntries := []string {
        m.name + ".product_rule_table",
        m.name + ".sign_conf",
    }

    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD : reloadEntries,
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>

// load product rule from config file
// loadProductRuleConf is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to loaded
//          if query["path"] is not set, use default path
func (m *ModuleHttpSign) loadProductRuleConf(query url.Values) error <span class="cov6" title="2">{
    // get path
    path := query.Get("path")
    if path == "" </span><span class="cov6" title="2">{
        // use default
        path = m.productRulePath
    }</span>

    // load file
    <span class="cov6" title="2">conf, err := ProductRuleConfLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in ProductRuleConfLoad(%s):%s", path, err)
    }</span>

    <span class="cov6" title="2">m.ruleTable.Update(conf)
    return nil</span>
}

// load sign conf from config file
func (m *ModuleHttpSign) loadSignConf(query url.Values) error <span class="cov6" title="2">{
    // get path
    path := query.Get("path")
    if path == "" </span><span class="cov6" title="2">{
        // use default
        path = m.signConfPath
    }</span>

    // load file
    <span class="cov6" title="2">conf, err := SignConfLoad(path)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in ProductRuleConfLoad(%s):%s", path, err)
    }</span>

    <span class="cov6" title="2">m.updateSignSalt(conf.Config.SignSalt)
    return nil</span>
}

// handler for checking whether we should sign response
func (m *ModuleHttpSign) signHandler(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov6" title="2">{
    if openDebug </span><span class="cov6" title="2">{
        log.Logger.Debug("%s check request", m.name)
    }</span>
    <span class="cov6" title="2">m.state.Inc("REQ_TOTAL", 1)

    // skip request from https connection
    if req.Session.IsHttps </span><span class="cov0" title="0">{
        m.state.Inc("REQ_FROM_HTTPS", 1)
        return bfe_module.BFE_HANDLER_GOON
    }</span>
    <span class="cov6" title="2">m.state.Inc("REQ_FROM_HTTP", 1)

    // find rules for given request
    rules, err := m.ruleTable.Search(req.Route.Product)
    if err != nil </span><span class="cov1" title="1">{ // no rules found
        if openDebug </span><span class="cov1" title="1">{
            log.Logger.Debug("%s product %s not found, just pass", 
                             m.name, req.Route.Product)
        }</span>
        <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON</span>
    }

    // check rules for given request
    <span class="cov1" title="1">m.state.Inc("REQ_TO_CHECK", 1)
    for _, rule := range *rules </span><span class="cov1" title="1">{
        if openDebug </span><span class="cov1" title="1">{
            log.Logger.Debug("%s process rule: %v", m.name, rule)
        }</span>
        // rule condition is satisfied ?
        <span class="cov1" title="1">if rule.Cond.Match(req) </span><span class="cov1" title="1">{
            m.state.Inc("RESP_SIGN", 1)
            // should add signature to response for this request
            res.Signer = m
            if openDebug </span><span class="cov1" title="1">{
                log.Logger.Debug("%s match rule: %v, should sign", m.name, rule)
            }</span>
            <span class="cov1" title="1">break</span>
        }
    }

    <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON</span>
}

// calculate signature 
func (m *ModuleHttpSign) CalcSign(feature string) string <span class="cov0" title="0">{
    salt := m.getSignSalt()
    msg := fmt.Sprintf("%s%s", feature, salt)
    sign := md5.Sum([]byte(msg))
    if openDebug </span><span class="cov0" title="0">{ 
        log.Logger.Debug("feature[%s], salt[%s] msg[%s], sign[%s]", feature, salt, msg, fmt.Sprintf("%x", sign))
    }</span>

    <span class="cov0" title="0">return fmt.Sprintf("%x", sign)</span>
}

func (m *ModuleHttpSign) updateSignSalt(salt string) <span class="cov6" title="2">{
    m.lock.Lock()
    m.signSalt = salt
    m.lock.Unlock()
}</span>

func (m *ModuleHttpSign) getSignSalt() string <span class="cov0" title="0">{
    m.lock.RLock()
    salt := m.signSalt
    m.lock.RUnlock()
    return salt
}</span>

func (m *ModuleHttpSign) getState() *module_state2.StateData <span class="cov1" title="1">{
    return m.state.GetAll()
}</span>

// all monitor handlers
func (m *ModuleHttpSign) monitorHandlers() map[string]interface{} <span class="cov10" title="3">{
    handlers := map[string]interface{} {
        m.name  : web_monitor.CreateStateDataHandler(m.getState),
    }
    return handlers
}</span>

// all reload handlers
func (m *ModuleHttpSign) reloadHandlers() map[string]interface{} <span class="cov10" title="3">{
    handlers := map[string]interface{} {
        m.name + ".product_rule_table"  : m.loadProductRuleConf,
        m.name + ".sign_conf"           : m.loadSignConf,
    }
    return handlers
}</span>

func (m *ModuleHttpSign) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                           cr string) error <span class="cov6" title="2">{
    var conf *ConfModHttpSign
    var err error

    // load module config
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>

    <span class="cov6" title="2">m.productRulePath = conf.Basic.ProductRulePath
    m.signConfPath = conf.Basic.SignConfPath
    openDebug = conf.Log.OpenDebug

    // load conf data
    if err = m.loadProductRuleConf(nil); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: loadProductRuleConf() err %s", m.name, err.Error())
    }</span>
    <span class="cov6" title="2">if err = m.loadSignConf(nil); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: loadSignConf() err %s", m.name, err.Error())
    }</span>

    // register handler
    <span class="cov6" title="2">err = cbs.AddFilter(bfe_module.HANDLE_READ_BACKEND, m.signHandler)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.signHandler): %s", m.name, err.Error())
    }</span>

    // register web handler for monitor
    <span class="cov6" title="2">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>

    // register web handler for reload
    <span class="cov6" title="2">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
    }</span>

    <span class="cov6" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/* product_rule_load.go - load sign rule config from json file */
/*
modification history
--------------------
2015/3/26, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_http_sign

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

import (
    "bfe_basic/condition"
)

type signRuleFile struct {
    Cond   *string     // condition for sign
}

type signRule struct {
    Cond   condition.Condition // condition for sign
}

type signRuleFileList []signRuleFile
type signRuleList []signRule

type ProductRulesFile map[string]*signRuleFileList // product =&gt; list of sign rules
type ProductRules map[string]*signRuleList

type productRuleConfFile struct {
    Version *string // version of the config
    Config  *ProductRulesFile
}

type productRuleConf struct {
    Version string       // version of the config
    Config  ProductRules // product rules for sign
}

// check signRule
func signRuleCheck(conf signRuleFile) error <span class="cov7" title="4">{
    // check Cond
    if conf.Cond == nil </span><span class="cov0" title="0">{
        return errors.New("no Cond")
    }</span>

    <span class="cov7" title="4">return nil</span>
}

// check signRuleList
func signRuleListCheck(conf *signRuleFileList) error <span class="cov10" title="8">{
    for index, rule := range *conf </span><span class="cov7" title="4">{
        err := signRuleCheck(rule)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("signRule:%d, %s", index, err.Error())
        }</span>
    }

    <span class="cov10" title="8">return nil</span>
}

// check ProductRules
func productRulesCheck(conf *ProductRulesFile) error <span class="cov7" title="4">{
    for product, ruleList := range *conf </span><span class="cov10" title="8">{
        if ruleList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no signRuleList for product:%s", product)
        }</span>

        <span class="cov10" title="8">err := signRuleListCheck(ruleList)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
        }</span>
    }

    <span class="cov7" title="4">return nil</span>
}

// check productRuleConf
func productRuleConfCheck(conf productRuleConfFile) error <span class="cov7" title="4">{
    var err error

    // check Version
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    // check Config
    <span class="cov7" title="4">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    <span class="cov7" title="4">err = productRulesCheck(conf.Config)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Config:%s", err.Error())
    }</span>

    <span class="cov7" title="4">return nil</span>
}

func ruleConvert(ruleFile signRuleFile) (signRule, error) <span class="cov7" title="4">{
    rule := signRule{}

    cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov1" title="1">{
        return rule, err
    }</span>
    <span class="cov5" title="3">rule.Cond = cond
    return rule, nil</span>
}

func ruleListConvert(ruleFileList *signRuleFileList) (*signRuleList, error) <span class="cov9" title="7">{
    ruleList := new(signRuleList)
    *ruleList = make([]signRule, 0)

    for _, ruleFile := range *ruleFileList </span><span class="cov7" title="4">{
        rule, err := ruleConvert(ruleFile)
        if err != nil </span><span class="cov1" title="1">{
            return nil, err
        }</span>
        <span class="cov5" title="3">*ruleList = append(*ruleList, rule)</span>
    }

    <span class="cov8" title="6">return ruleList, nil</span>
}

/* load sign rule config from file

   Returns:
        (productRuleConf, error)
*/
func ProductRuleConfLoad(filename string) (productRuleConf, error) <span class="cov7" title="4">{
    var conf productRuleConf
    var err error

    // open the file
    file, err := os.Open(filename)
    defer file.Close()
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // decode the file
    <span class="cov7" title="4">decoder := json.NewDecoder(file)
    var config productRuleConfFile
    err = decoder.Decode(&amp;config)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // check config
    <span class="cov7" title="4">err = productRuleConfCheck(config)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // convert config
    <span class="cov7" title="4">conf.Version = *config.Version
    conf.Config = make(ProductRules)
    for product, ruleFileList := range *config.Config </span><span class="cov9" title="7">{
        ruleList, err := ruleListConvert(ruleFileList)
        if err != nil </span><span class="cov1" title="1">{
            return conf, err
        }</span>
        <span class="cov8" title="6">conf.Config[product] = ruleList</span>
    }

    <span class="cov5" title="3">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/* product_rule_table.go - table for storing product sign rules   */
/*
modification history
--------------------
2015/3/26, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_http_sign

import (
    "fmt"
    "sync"
)

type ProductRuleTable struct {
    lock            sync.Mutex
    version         string
    productRules    ProductRules
}

func NewProductRuleTable() *ProductRuleTable <span class="cov10" title="2">{
    t := new(ProductRuleTable)
    t.productRules = make(ProductRules)
    return t
}</span>

// update
func (t *ProductRuleTable) Update(conf productRuleConf) <span class="cov10" title="2">{
    t.lock.Lock()
    t.version = conf.Version
    t.productRules = conf.Config
    t.lock.Unlock()
}</span>

/* Search for sign rules
 
   Returns:
        (*RuleList, nil), if succeed
        (nil, error), if fail
*/
func (t *ProductRuleTable) Search(product string) (*signRuleList, error)<span class="cov10" title="2">{
    t.lock.Lock()
    //  find rules for given product
    rules, ok := t.productRules[product]
    t.lock.Unlock()

    if ok </span><span class="cov1" title="1">{
        return rules, nil
    }</span> <span class="cov1" title="1">else {
        return nil, fmt.Errorf("no sign rules for %s", product)
    }</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">/* sign_conf_load.go - load sign config from json file */
/*
modification history
--------------------
2015/3/26, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_http_sign

import (
    "encoding/json"
    "fmt"
    "os"
)

// signature config
type SignConf struct {
    Version string      // version of the config

    Config  struct {
        SignSalt string // salt for signature
    }
}

// check productRuleConf
func SignConfCheck(conf SignConf) error <span class="cov10" title="2">{
    // check Version
    if len(conf.Version) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no Version")
    }</span>

    // check Config
    <span class="cov10" title="2">if len(conf.Config.SignSalt) == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("no SignSalt")
    }</span>

    <span class="cov10" title="2">return nil</span>
}

/* load sign rule config from file

   Returns:
        (productRuleConf, error)
*/
func SignConfLoad(filename string) (SignConf, error) <span class="cov10" title="2">{
    var conf SignConf

    // open the file
    file, err := os.Open(filename)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>
    <span class="cov10" title="2">defer file.Close()

    // decode the file
    decoder := json.NewDecoder(file)
    err = decoder.Decode(&amp;conf)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // check config
    <span class="cov10" title="2">err = SignConfCheck(conf)
    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    <span class="cov10" title="2">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">/* logid.go - create unified log id */
/*
modification history
--------------------
2014/9/9, by Taochunhua, create
*/
/*
DESCRIPTION
    The following c codes are copied from c edition bfe. 
    Some details are modified.

    calculate_log_id(): 
      see file https://svn.baidu.com/op/oped/noah/trunk/bfe/bfe/core/untr_log.c
    others: 
      see file https://svn.baidu.com/op/oped/noah/trunk/bfe/bfe/util/util.c
*/
package mod_logid

/*
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef unsigned long uint64_t;
typedef unsigned int uint32_t;

static uint32_t Mod_Prime_List_1[256] = {
256,     65536,         3,       768,    196608,         9,      2304,    589824,
 27,      6912,   1769472,        81,     20736,   5308416,       243,     62208,
15925248,       729,    186624,  14221318,      2187,    559872,   9109528,      6561,
1679616,  10551371,     19683,   5038848,  14876900,     59049,  15116544,  11076274,
177147,  11795206,  16451609,    531441,   1831192,  15800401,   1594323,   5493576,
13846777,   4782969,  16480728,   7985905,  14348907,  15887758,   7180502,   9492295,
14108848,   4764293,  11699672,   8772118,  14292879,   1544590,   9539141,   9324211,
4633770,  11840210,  11195420,  13901310,   1966204,     31834,   8149504,   5898612,
95502,   7671299,    918623,    286506,   6236684,   2755869,    859518,   1932839,
8267607,   2578554,   5798517,   8025608,   7735662,    618338,   7299611,   6429773,
1855014,   5121620,   2512106,   5565042,  15364860,   7536318,  16695126,  12540154,
5831741,  16530952,   4066036,    718010,  16038430,  12198108,   2154030,  14560864,
3039898,   6462090,  10128166,   9119694,   2609057,  13607285,  10581869,   7827171,
7267429,  14968394,   6704300,   5025074,  11350756,   3335687,  15075222,    497842,
10007061,  11671240,   1493526,  13243970,   1459294,   4480578,   6177484,   4377882,
13441734,   1755239,  13133646,   6770776,   5265717,   5846512,   3535115,  15797151,
762323,  10605345,  13837027,   2286969,  15038822,   7956655,   6860907,  11562040,
7092752,   3805508,   1131694,   4501043,  11416524,   3395082,  13503129,    695146,
10185246,   6954961,   2085438,  13778525,   4087670,   6256314,   7781149,  12263010,
1991729,   6566234,   3234604,   5975187,   2921489,   9703812,   1148348,   8764467,
12334223,   3445044,   9516188,   3448243,  10335132,  11771351,  10344729,  14228183,
1759627,  14256974,   9130123,   5278881,   9216496,  10613156,  15836643,  10872275,
15062255,  13955503,  15839612,  11632339,   8312083,  13964410,   1342591,   8159036,
8338804,   4027773,   7699895,   8239199,  12083319,   6322472,   7940384,   2695531,
2190203,   7043939,   8086593,   6570609,   4354604,   7482566,   2934614,  13063812,
5670485,   8803842,   5637010,    234242,   9634313,    133817,    702726,  12125726,
401451,   2108178,   2822752,   1204353,   6324534,   8468256,   3613059,   2196389,
8627555,  10839177,   6589167,   9105452,  15740318,   2990288,  10539143,  13666528,
8970864,  14840216,   7445158,  10135379,  10966222,   5558261,  13628924,  16121453,
16674783,   7332346,  14809933,  16469923,   5219825,  10875373,  15855343,  15659475,
15848906,  14011603,  13423999,  13992292,   8480383,   6717571,   8422450,   8663936,
3375500,   8490137,   9214595,  10126500,   8693198,  10866572,  13602287,   9302381
};

static uint32_t Mod_Prime_List_2[256] = {
15824477,   7761153,   7145686,    580925,  14499208,   4036269,   9875725,  11605750,
1507777,    115335,  12748561,   8855010,   1960695,  15399149,  16317578,  16554616,
10127548,   8963642,  12993288,   4396326,   1387123,   2782309,   7628746,   6803892,
13744855,  12248289,  15002970,  15558948,   6894525,   3392505,  12844131,  16543731,
7340988,    246640,  12808243,   7356403,   4192880,  16413743,   7618458,   4170164,
10598447,  12073393,   3783992,  12401609,   3921293,  13996267,   9500965,  16330384,
3055753,  10521614,   9181344,   1616204,  11095448,   5088057,  10698269,   4073427,
2610974,  14098583,   2139463,  10832160,   4795125,   2816473,  16374730,  14408329,
14325643,   9935226,  10060807,   8655145,   1126852,   3261729,  12919873,   2379285,
5117796,   1534254,   6893447,   3116537,   9305119,  16525405,   2649532,   7192232,
12496701,  11487646,   4827551,  11117529,  10740793,  14959571,   4448804,  14821491,
2654722,   8520872,    307362,  11575876,  10637232,   5225154,  12240703,  13060954,
4941623,   6765563,   3932631,    121596,  14351377,  16523130,   2067132,   9092623,
12458026,   1586846,   3579800,  10460054,  10199183,  10525003,  10048928,   5614121,
11153061,   3059786,  11554062,   5052848,   1684765,  11869865,   2012421,  11863806,
461317,    656759,    358314,   7842389,  11164903,   6091338,  15880220,   5254162,
2889552,   1528556,   5434759,  15567986,   9208253,   8504908,  12997777,   5545510,
10365844,   2858622,  10387675,   8447358,  15042176,   8818485,   9387494,   4059007,
15696653,   8592607,   1894323,  15185116,  11856727,  15426292,   6488987,    237971,
10588979,   9649585,   4045507,  12240653,  13048154,   1664823,   6764713,   3715031,
11524792,  14336927,  12823930,  11372275,   8846973,  16680422,   8779486,  16180949,
15131990,  15033670,   6640949,   5585845,   3914405,  12232939,  11073370,  16213288,
6633575,   3698101,   7190712,  12107581,  12536120,   4801711,   4502489,  11787652,
14520291,   9433517,  15840895,  11964161,   9374998,    860031,   2064349,   8380175,
14620527,   1539535,   8245383,  13668173,   9394896,   5953919,  14255354,   8718441,
553429,   7460232,  13995905,   9408293,   9383551,   3049599,   8946190,   8525576,
1511586,   1090439,  10717200,   8919763,   1760264,  14420410,    641180,  13147289,
10266184,  10900060,   5400326,   6753138,    751831,   7919547,  14140152,  12781127,
414707,   5501798,  15952771,   7050019,   9644571,   2761923,   2409930,  12962916,
13398293,   7414412,   2265985,   9667394,   8604611,   4967347,  13350907,  12060795,
558904,   8861832,   3707127,   9501368,  16433552,  12689562,  10528465,  10935200,
14396166,  11211915,   1349211,   9854036,   6053366,   6159388,  16523821,   2244028
};

unsigned int getsign_24_1(char* str)
{
    int i = 0;
    unsigned int itemp = 0;

    while(str[i] != 0)
    {
        //% PRIME_USED_24
        itemp = ((unsigned char)(str[i]) * Mod_Prime_List_1[0xFF &amp; (i++)] + itemp); 
    }
    
    return itemp;
}

unsigned int getsign_24_2(char* str)
{
    int i=0;
    unsigned int itemp = 0;

    while (str[i]!=0)
    {
        //% PRIME_USED_24;
        itemp = ((unsigned char)(str[i])*Mod_Prime_List_2[0xFF &amp; (i++)]+itemp);
    }
    
    return itemp;
}

void bfe_creat_sign_f64(char* psrc, int slen, uint32_t* sign1, uint32_t * sign2)
{
    *sign1=0;
    *sign2=0;
    
    if(slen &lt;= 4)
    {
        memcpy(sign1, psrc, slen);
        return;
    }
    else 
    {
        if(slen&lt;=8)
        {
            memcpy(sign1, psrc, 4);
            memcpy(sign2, psrc+4, slen-4);
            return;
        }
        else
        {
            (*sign1) = getsign_24_1(psrc);
            (*sign2) = getsign_24_2(psrc);
            return;
        }
    }

    // should not comes to here
    return;
}

uint64_t calculate_log_id(int fd, char* client_ip, char* local_ip,
                          int pid, uint64_t sec, uint64_t usec)
{
    char connected_string[128] = {0};
    uint32_t connected_string_size = sizeof(connected_string);
    
    snprintf(connected_string, connected_string_size, "%s/%s %ld %ld %d %d",
             client_ip, local_ip, sec, usec, fd, pid);
    
    uint32_t high_int = 0;
    uint32_t low_int = 0;
    bfe_creat_sign_f64(connected_string, connected_string_size, &amp;high_int, &amp;low_int);
    
    uint64_t log_id = (uint64_t)(((uint64_t)(high_int) &lt;&lt; 32) | (uint64_t)(low_int));
    
    return log_id;
}
*/
import "C"      // this line must be seperated

import (
    "net"
    "unsafe"
)

import (
    "bfe_basic"
    "bfe_tls"
)

/*
 * calcLogId():
 *    calculate a new log id.
 * parameters:
 *     fd - socket fd
 *     clientIp - client ip
 *     localIp  - local bfe server ip
 *     pid      - bfe process pid
 *     sec      - seconds return from time.Unix()
 *     usec     - micro seconds
 * return:
 *     an unsigned int64 id
 */
func calcLogId(fd int, clientIp string, localIp string,
                 pid int, sec int64, u<span class="cov10" title="1005">sec int) uint64 {
    pClientIp := C.CString(clientIp)
    pLocalIP := C.CString(localIp)
    id := C.calculate_log_id(C.int(fd), pClientIp, pLocalIP,
                            C.int(pid), C.ulong(sec), C.ulong(usec))
    C.free(unsafe.Pointer(pClientIp))
    C.free(unsafe.Pointer(pLocalIP))

    return uint64(id)
}</span>

// get fd
func fdGet(req *bfe_basic.Request) int <span class="cov9" title="1003">{
    c := req.Connection 
    if tlsConn, ok := req.Connection.(*bfe_tls.Conn); </span><span class="cov0" title="0">ok {
        c = tlsConn.GetNetConn()
  </span>  }
 <span class="cov9" title="1003">   return net.GetTcpSocketFd(c.(*net.TCPCon</span>n))
}
</pre>
		
		<pre class="file" id="file105" style="display: none">/* mod_logid.go - module for bfe unified log id generation */
/*
modification history
--------------------
2014/9/9, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package mod_logid

import (
    "encoding/json"
    "fmt"
    "net"
    "os"
    "strconv"
    "time"
)

import (
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
)

type ModuleLogId struct {
    name  string               // name of module
    state module_state2.State  // module state
}

// key of counter
var COUNTER_KEYS = []string{
    "NO_LOGID_FROM_UPPER_BFE",   // counter for no logid cases
                                 // when requests come from trusted ip
    "LOGID_CONVERT_FAILED",      // counter for old logid convert error
}

func NewModuleLogId() *ModuleLogId <span class="cov1" title="2">{
    m := new(ModuleLogId)
    m.name = "mod_logid"
    
    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_LOGID)
    
    return m
}</span>

func (m *ModuleLogId) Name() string <span class="cov1" title="1">{
    return m.name
}</span>

func (m *ModuleLogId) Attr() map[string]interface{} <span class="cov1" title="1">{
    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>

func (m *ModuleLogId) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                           cr string) error <span class="cov0" title="0">{
    // register handler
    err := cbs.AddFilter(bfe_module.HANDLE_BEFORE_LOCATION, m.beforeLocation)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.beforeLocation): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.afterLocation)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.afterLocation): %s", m.name, err.Error())
    }</span>
    
    // register web handler
    <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_MONITOR, m.name, m.getJsonState)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandler(m.getJsonState): %s", m.name, err.Error())
    }</span>
    
    <span class="cov0" title="0">return nil</span>
}

// handler for before-location
func (m *ModuleLogId) beforeLocation(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov2" title="3">{
    // check if request comes from trusted ip
    if req.Session.IsTrustIP </span><span class="cov1" title="2">{
        // check if there is BFE_LOGID in Header
        oldLogid := req.HttpRequest.Header.Get("Bfe_logid")
        
        // keep logid unchanged, if possible
        if oldLogid != "" </span><span class="cov1" title="1">{
            id , err :=  strconv.ParseUint(oldLogid, 10, 64)
            if err == nil </span><span class="cov1" title="1">{
                req.LogId = id
                return bfe_module.BFE_HANDLER_GOON, nil
            }</span> <span class="cov0" title="0">else {
                // strconv.ParseUint() failed.
                m.state.Inc("LOGID_CONVERT_FAILED", 1)
                
                // calculate a new log id
                req.LogId = reqBfeLogIdCalc(req)
                return bfe_module.BFE_HANDLER_GOON, nil
            }</span>
        } <span class="cov1" title="1">else {
            // trust ip, should has a logid
            m.state.Inc("NO_LOGID_FROM_UPPER_BFE", 1)
            
            // calculate a new log id
            req.LogId = reqBfeLogIdCalc(req)
            return bfe_module.BFE_HANDLER_GOON, nil
        }</span>
    }
    
    // request comes from none-trusted ip
    // calculate a new log id
    <span class="cov1" title="1">req.LogId = reqBfeLogIdCalc(req)
    return bfe_module.BFE_HANDLER_GOON, nil</span>
}

// handler for after-location
func (m *ModuleLogId) afterLocation(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
    id := fmt.Sprintf("%d", req.LogId)
    req.HttpRequest.Header.Set("Bfe_logid", id)
    
    return bfe_module.BFE_HANDLER_GOON, nil
}</span>

// calculate new log id
func reqBfeLogIdCalc(req *bfe_basic.Request) uint64 <span class="cov10" title="1002">{
    fd := fdGet(req)
    pid := os.Getpid()
    t := time.Now()
    sec := t.Unix()
    usec := t.Nanosecond() / 1000
    
    removeIp := req.RemoteAddr.IP.String()
    localIp := req.Connection.LocalAddr().(*net.TCPAddr).IP.String()
    return calcLogId(fd, removeIp, localIp, pid, sec, usec)
}</span>

// for web monitor
func (m *ModuleLogId) getJsonState() ([]byte, error) <span class="cov1" title="1">{
    state := m.state.GetAll()
    return json.Marshal(state)
}</span>

</pre>
		
		<pre class="file" id="file106" style="display: none">/* basic_type.go - basic type for mod_prison */
/*
modification history
--------------------
2014/12/17, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_prison

import (
    "www.baidu.com/golang-lib/log"
)

import (
    "sync/atomic"
    "time"
)

// prison type
const (
    IP      = 1
    BAIDUID = 2
)

// default size for dict
const (
    DEFAULT_USER_DICT_SIZE   = 60000
    DEFAULT_PRISON_DICT_SIZE = 20000
)

// signature
type Sign [16]byte

// user stat info
type User struct {
    count     int32 // value of stat counter
    startTime int64 // timestamp when start count
}

func NewUser() *User <span class="cov7" title="4">{
    user := new(User)
    user.count = 1
    user.startTime = time.Now().Unix()
    return user
}</span>

/* incAndCheck - increase count and check whether excess threshold 
 *
 * Params:
 *     - checkPeroid: check peroid
 *     - threshold  : count threshold
 *
 * Return:
 *     - status: true if excess threshold, false if not
 */
func (u *User) incAndCheck(checkPeriod int64, threshold int32) bool <span class="cov10" title="6">{
    // check timestamp first
    now := time.Now().Unix()
    if u.startTime + checkPeriod &lt; now </span><span class="cov4" title="2">{ // reset count
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("incAndCheck(): reset count(startTime %d, checkPeriod %d, now %d)",
                             u.startTime, checkPeriod, now)
        }</span>
        <span class="cov4" title="2">u.reset()</span>
    }

    // increase counter
    <span class="cov10" title="6">count := atomic.AddInt32(&amp;u.count, 1)
    if openDebug </span><span class="cov0" title="0">{
        log.Logger.Debug("incAndCheck(): count %d, threshod %d (startTime %d, checkPeriod %d)",
                         count, threshold, u.startTime, checkPeriod)
    }</span>

    // check threshold
    <span class="cov10" title="6">return count &gt; threshold</span>
}

// reset counter of user
func (u *User) reset() <span class="cov7" title="4">{
    atomic.StoreInt32(&amp;u.count, 0)
    u.startTime = time.Now().Unix()
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">/* conf_mod_prison.go - config for mod_prison */
/*
modification history
--------------------
2014/12/17, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package mod_prison

import (
    "fmt"
)

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/log"
)

type PrisonConf struct {
    CheckPeriod int64        // period for checking (secs)
    Threshold   int32        // count limit in check period
    StayPeriod  int64        // peroid for staying in PRISON state (secs)
}

type ConfModPrison struct {
    PrisonIP      PrisonConf // config for ip prison
    PrisonBaiduID PrisonConf // config for baiduid prison

    Dict struct {            // config for dict size
        UserDictSize   int
        PrisonDictSize int
    }

    Log struct {
        OpenDebug bool       //  whether open debug
    }
}

/* load config from config file */
func ConfLoad(filePath string, confRoot string) (*ConfModPrison, error) <span class="cov7" title="6">{
    var cfg ConfModPrison
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_block
    <span class="cov7" title="6">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov7" title="6">return &amp;cfg, nil</span>
}

func (cfg *ConfModPrison) Check(confRoot string) error <span class="cov7" title="6">{
    return ConfModPrisonCheck(cfg, confRoot)
}</span>

func ConfModPrisonCheck(cfg *ConfModPrison, confRoot string) error <span class="cov7" title="6">{
    if err := checkPrisonConf(cfg.PrisonIP); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov7" title="6">if err := checkPrisonConf(cfg.PrisonBaiduID); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov7" title="6">if cfg.Dict.UserDictSize &lt;= 0 </span><span class="cov1" title="1">{
        log.Logger.Warn("Dict.UserDictSize not set, use default value")
        cfg.Dict.UserDictSize = DEFAULT_USER_DICT_SIZE
    }</span>
    <span class="cov7" title="6">if cfg.Dict.PrisonDictSize &lt;= 0 </span><span class="cov1" title="1">{
        log.Logger.Warn("Dict.PrisonDictSize not set, use default value")
        cfg.Dict.PrisonDictSize = DEFAULT_PRISON_DICT_SIZE
    }</span>
    <span class="cov7" title="6">return nil</span>
}

func checkPrisonConf(conf PrisonConf) error <span class="cov10" title="12">{
    if conf.Threshold &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("Wrong config value for Threshod: %s", conf.Threshold )
    }</span>
    <span class="cov10" title="12">if conf.CheckPeriod &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("Wrong config value for CheckPeriod: %s", conf.CheckPeriod)
    }</span>
    <span class="cov10" title="12">if conf.StayPeriod &lt;= 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("Wrong config value for StayPeriod: %s", conf.StayPeriod)
    }</span>
    <span class="cov10" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">/* mod_prison.go - module for request prison */
/*
modification history
--------------------
2014/12/17, by Sijie Yang, create
*/
/*
DESCRIPTION
    A simplified version of mod_prison in bfe
*/
package mod_prison

import (
    "crypto/md5"
    "encoding/json"
    "fmt"
    "net/url"
    "time"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/lru_cache"
    "www.baidu.com/golang-lib/module_state2"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
)

var (
    openDebug = false
)

// key for counter of mod_prison
var COUNTER_KEYS = []string {
    "REQ_TOTAL",            // all request in
    "REQ_PRISON_IP",        // request prisoned by ip
    "REQ_PRISON_BAIDUID",   // request prisoned by baiduid
    "REQ_ACCEPT",           // request accepted
    "REQ_WITHOUT_BAIDUID",  // request without baiduid
    "REQ_UNSET_CLIENTADDR", // request not intital orginal clientip
}

type ModulePrison struct {
    name       string               // name of module
    state      *module_state2.State // module state
    conf       *ConfModPrison       // config for prison

    userDict   *lru_cache.LRUCache  // user stat info (sign -&gt; User)
    prisonDict *lru_cache.LRUCache  // prison info (sign -&gt; freetime)
}

func NewModulePrison() *ModulePrison <span class="cov5" title="5">{
    m := new(ModulePrison)
    m.name = "mod_prison"
    m.state = new(module_state2.State)

    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_PRISON)

    return m
}</span>

func (m *ModulePrison) createDict(userDictSize int, prisonDictSize int) <span class="cov5" title="4">{
    m.userDict = lru_cache.NewLRUCache(userDictSize)
    m.prisonDict = lru_cache.NewLRUCache(prisonDictSize)
}</span>

func (m *ModulePrison) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModulePrison) Attr() map[string]interface{} <span class="cov1" title="1">{
    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name: bfe_basic.MON_TYPE_STATE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>

// handler for doing request prison
func (m *ModulePrison) prisonAfterLocHandler(request *bfe_basic.Request) (
                                             int, *bfe_http.Response) <span class="cov8" title="11">{
    m.state.Inc("REQ_TOTAL", 1)
    if openDebug </span><span class="cov0" title="0">{
        log.Logger.Debug("%s check request", m.name)
    }</span>

    // check baiduid
    <span class="cov8" title="11">baiduIDSign := m.getBaiduIDSign(request)
    if m.processPrison(baiduIDSign, &amp;m.conf.PrisonBaiduID) </span><span class="cov1" title="1">{
        request.ErrCode = bfe_basic.ERR_PRISON
        m.state.Inc("REQ_PRISON_BAIDUID", 1)
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s prison request by baiduID (sign:%2x)", m.name, baiduIDSign)
        }</span>
        <span class="cov1" title="1">return bfe_module.BFE_HANDLER_FINISH, nil</span>
    }

    // check client ip
    <span class="cov7" title="10">clientIPSign := m.getClientIPSign(request)
    if m.processPrison(clientIPSign, &amp;m.conf.PrisonIP) </span><span class="cov1" title="1">{
        request.ErrCode = bfe_basic.ERR_PRISON
        m.state.Inc("REQ_PRISON_IP", 1)
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s prison request by clientIP (sign:%2x)", m.name, clientIPSign)
        }</span>
        <span class="cov1" title="1">return bfe_module.BFE_HANDLER_FINISH, nil</span>
    }

    <span class="cov7" title="9">m.state.Inc("REQ_ACCEPT", 1)
    if openDebug </span><span class="cov0" title="0">{
        log.Logger.Debug("%s accept request (baiduid sign: %2x, clientip sign: %2x)", 
                         m.name, baiduIDSign, clientIPSign)
    }</span>
    <span class="cov7" title="9">return bfe_module.BFE_HANDLER_GOON, nil</span>
}

// whether prison request with signature 'sign' or not
func (m *ModulePrison) processPrison(sign *Sign, conf *PrisonConf) bool <span class="cov10" title="21">{
    // skip request without valid signature
    if sign == nil </span><span class="cov8" title="11">{
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s ignore nil signature", m.name)
        }</span>
        <span class="cov8" title="11">return false</span>
    }

    // update counter for request with signature 'sign'
    <span class="cov7" title="10">m.recordUser(sign, conf)

    // check whether we should delay request with signature 'sign'
    result := m.shouldDeny(sign)
    return result</span>
}

// record user access
func (m *ModulePrison) recordUser(sign *Sign, conf *PrisonConf) <span class="cov7" title="10">{
    // get counter for request with signature 'sgin' from user dict, 
    value, ok := m.userDict.Get(*sign)
    if !ok </span><span class="cov5" title="4">{
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s add user record for signature: %2x", m.name, sign)
        }</span>
        // insert new counter if not found
        <span class="cov5" title="4">m.userDict.Add(*sign, NewUser())
        return</span>
    }
    <span class="cov6" title="6">user := value.(*User)

    // increase counter for request with signature 'sign'.
    // if counter excess threshold during check period, 
    // add a prison record for 'sign' to prison dict
    if user.incAndCheck(conf.CheckPeriod, conf.Threshold) </span><span class="cov3" title="2">{
        // add to prison dict
        freeTime := conf.StayPeriod + time.Now().Unix() // prison expire time
        m.prisonDict.Add(*sign, freeTime)

        // reset counter
        user.reset()

        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s reset count and add prison record for signature: %2x",
                             m.name, sign)
        }</span>
    }
}

// check whether we should deny request with signature 'sign'
func (m *ModulePrison) shouldDeny(sign *Sign) bool <span class="cov7" title="10">{
    // find prison record for 'sign'
    freeTime, ok := m.prisonDict.Get(*sign)
    if !ok </span><span class="cov6" title="6">{
        return false
    }</span>

    // check prison expire time
    <span class="cov5" title="4">if time.Now().Unix() &lt; freeTime.(int64) </span><span class="cov3" title="2">{
        // should deny if not expired
        return true
    }</span> <span class="cov3" title="2">else {
        // remove prison record if expried
        m.prisonDict.Del(*sign)
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s remove prison record for signature: %2x", m.name, sign)
        }</span>
        <span class="cov3" title="2">return false</span>
    }
}

// get signature of clientip
func (m *ModulePrison) getClientIPSign(request *bfe_basic.Request) *Sign <span class="cov7" title="10">{
    if request.ClientAddr == nil </span><span class="cov6" title="6">{
        m.state.Inc("REQ_UNSET_CLIENTADDR", 1)
        return nil
    }</span>
    <span class="cov5" title="4">sign := Sign(md5.Sum(request.ClientAddr.IP))
    return &amp;sign</span>
}

// get signature of baiduid
func (m *ModulePrison) getBaiduIDSign(request *bfe_basic.Request) *Sign <span class="cov8" title="11">{
    if request.BaiduidHex == nil </span><span class="cov5" title="5">{
        m.state.Inc("REQ_WITHOUT_BAIDUID", 1)
        return nil
    }</span>
    <span class="cov6" title="6">sign := Sign(md5.Sum(request.BaiduidHex))
    return &amp;sign</span>
}

func (m *ModulePrison) getState(query url.Values) ([]byte, error) <span class="cov1" title="1">{
    // get items count in prisonDict/userDict
    var prisonCount, userCount = 0, 0
    if m.prisonDict != nil </span><span class="cov0" title="0">{
        prisonCount = m.prisonDict.Len()
    }</span>
    <span class="cov1" title="1">if m.userDict != nil </span><span class="cov0" title="0">{
        userCount = m.userDict.Len()
    }</span>
    <span class="cov1" title="1">m.state.SetNum("COUNT_PRISON_DICT", int64(prisonCount))
    m.state.SetNum("COUNT_USER_DICT", int64(userCount))
    state := m.state.GetAll()

    // get param for format
    format := query.Get("format")
    if len(format) == 0 </span><span class="cov1" title="1">{
        // default format is json
        format = "json"
    }</span>

    <span class="cov1" title="1">var buff []byte
    var err error

    switch format </span>{
        <span class="cov1" title="1">case "json":
            buff, err = json.Marshal(state)</span>
        <span class="cov0" title="0">case "noah":
            buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }
    <span class="cov1" title="1">return buff, err</span>
}

// all monitor handlers
func (m *ModulePrison) monitorHandlers() map[string]interface{} <span class="cov1" title="1">{
    handlers := map[string]interface{} {
        m.name  : m.getState,
    }
    return handlers
}</span>

func (m *ModulePrison) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                            cr string) error <span class="cov5" title="4">{
    var conf *ConfModPrison
    var err error

    // load module config
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>
    <span class="cov5" title="4">m.conf = conf

    // initialize user dict and prison dict
    m.createDict(conf.Dict.UserDictSize, conf.Dict.PrisonDictSize)

    openDebug = conf.Log.OpenDebug

    // register handler for prison
    err = cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.prisonAfterLocHandler)
    if err != nil </span><span class="cov5" title="4">{
        return fmt.Errorf("%s.Init(): AddFilter(m.prisonHandler): %s", m.name, err.Error())
    }</span>

    // register web handler for monitor
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">/* action.go - action for redirect   */
/*
modification history
--------------------
2014/7/30, by Sijie YANG, create
2015/7/9,  by Xiong Zongtao, modify
        -add action SCHEME_SET
*/
/*
DESCRIPTION
*/
package mod_redirect

import (
        "errors"
        "fmt"
        "strings"
)

import (
        "bfe_basic"
)

type ActionFile struct {
        Cmd    *string  // command of action
        Params []string // params of action
}

type Action struct {
        Cmd    string   // command of action
        Params []string // params of action
}

type ActionFileList []ActionFile

// exclusive action set
var EXCLUSIVE_ACTIONS = map[string]interface{}{
        "SCHEME_SET"    : nil,
        "URL_SET"       : nil,
        "URL_FROM_QUERY": nil,
        "URL_PREFIX_ADD": nil}

// check ActionFile
func ActionFileCheck(conf ActionFile) error <span class="cov10" title="2">{
        var paramsLenCheck int

        // check command
        if conf.Cmd == nil </span><span class="cov0" title="0">{
                return errors.New("no Cmd")
        }</span>

        // validate command, and get how many params should exist for each command
        <span class="cov10" title="2">switch *conf.Cmd </span>{
        // commands for url
        <span class="cov10" title="2">case "URL_SET", "URL_FROM_QUERY", "URL_PREFIX_ADD", "SCHEME_SET":
                paramsLenCheck = 1</span>
        <span class="cov0" title="0">default:
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        // check params
        <span class="cov10" title="2">if conf.Params == nil </span><span class="cov0" title="0">{
                return errors.New("no Params")
        }</span>

        <span class="cov10" title="2">if paramsLenCheck != -1 </span><span class="cov10" title="2">{
                paramsLen := len(conf.Params)
                if paramsLenCheck != paramsLen </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, paramsLen)
                }</span>
        }
        
        // currently only http|https scheme supported.
        <span class="cov10" title="2">if *conf.Cmd == "SCHEME_SET" </span><span class="cov0" title="0">{
                scheme := strings.ToLower(conf.Params[0])
                if scheme != "http" &amp;&amp; scheme != "https" </span><span class="cov0" title="0">{
                        return fmt.Errorf("scheme %s invalid, only http|https supported now", conf.Params[0])        
                }</span>
                <span class="cov0" title="0">conf.Params[0] = scheme</span>
        }

        <span class="cov10" title="2">return nil</span>
}

// check ActionFileList
func ActionFileListCheck(conf *ActionFileList) error <span class="cov10" title="2">{
        if len(*conf) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("ActionFileList: currently only support exclusive action!")
        }</span>

        <span class="cov10" title="2">for index, action := range *conf </span><span class="cov10" title="2">{
                err := ActionFileCheck(action)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ActionFileList:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov10" title="2">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov10" title="2">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params
        return action
}</span>

func actionsConvert(actionFiles ActionFileList) []Action <span class="cov10" title="2">{
        actions := make([]Action, 0)

        for _, actionFile := range actionFiles </span><span class="cov10" title="2">{
                action := actionConvert(actionFile)
                actions = append(actions, action)
        }</span>

        <span class="cov10" title="2">return actions</span>
}

// do exclusive action to request
func redirectExclusiveActionDo(req *bfe_basic.Request, action Action) <span class="cov1" title="1">{
        switch action.Cmd </span>{
        <span class="cov0" title="0">case "SCHEME_SET":
                reqSchemeSet(req, action.Params[0])</span>
        // for url
        <span class="cov1" title="1">case "URL_SET":
                reqUrlSet(req, action.Params[0])</span>
        <span class="cov0" title="0">case "URL_FROM_QUERY":
                reqUrlFromQuery(req, action.Params[0])</span>
        <span class="cov0" title="0">case "URL_PREFIX_ADD":
                reqUrlPrefixAdd(req, action.Params[0])</span>
        }
}

// check if exclusive action
func checkExclusiveAction(actions []Action) bool <span class="cov1" title="1">{
        if len(actions) != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">action := actions[0]
        _, ok := EXCLUSIVE_ACTIONS[action.Cmd]
        return ok</span>
}

// do actions to request
func redirectActionsDo(req *bfe_basic.Request, actions []Action) <span class="cov1" title="1">{
        // for exclusive action
        if checkExclusiveAction(actions) </span><span class="cov1" title="1">{
                redirectExclusiveActionDo(req, actions[0])
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">/* action_url.go - action to url for redirect  */
/*
modification history
--------------------
2014/7/30, by Sijie YANG, create
2015/7/9,  by Xiong Zongtao, modify
        -add function reqSchemeSet
*/
/*
DESCRIPTION
*/
package mod_redirect

import (
        "bfe_basic"
)

// set redirect url
func reqUrlSet(req *bfe_basic.Request, url string) <span class="cov10" title="2">{
        req.Redirect.Url = url
}</span>

// set redirect url to value of given field in query
// e.g., url "http://service?url=(.*)" =&gt; "$1",
func reqUrlFromQuery(req *bfe_basic.Request, key string) <span class="cov1" title="1">{
        if req.Query == nil </span><span class="cov1" title="1">{
                req.Query = req.HttpRequest.URL.Query()
        }</span>

        <span class="cov1" title="1">req.Redirect.Url = req.Query.Get(key)</span>
}

// specify redirect url by adding prefix to orginal uri(path+query)
// e.g., url  "/(.*)" =&gt; "link$1",
func reqUrlPrefixAdd(req *bfe_basic.Request, prefix string) <span class="cov1" title="1">{
        rawUrl := req.HttpRequest.URL
        uri := rawUrl.RequestURI()
        req.Redirect.Url = prefix + uri
}</span>

// specify redirect url to absolute one with scheme user defined
// e.g., url  scheme://host/path, usually scheme is https
func reqSchemeSet(req *bfe_basic.Request, scheme string) <span class="cov1" title="1">{
        rawUrl := req.HttpRequest.URL
        uri := rawUrl.RequestURI()

        host := rawUrl.Host
        if host == "" </span><span class="cov0" title="0">{
                host = req.HttpRequest.Host
        }</span>

        <span class="cov1" title="1">req.Redirect.Url = scheme + "://" + host + uri</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">/* conf_mod_redirect.go - config for mod_redirect */
/*
modification history
--------------------
2014/7/31, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_redirect

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfModRedirect struct {
    Basic struct {
        DataPath    string  // path of config data (redirect)
    }

    Log struct {
        OpenDebug bool
    }
}


/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModRedirect, error) <span class="cov10" title="3">{
    var cfg ConfModRedirect
    var err error

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_redirect
    <span class="cov10" title="3">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="3">return &amp;cfg, nil</span>
}

func (cfg *ConfModRedirect) Check(confRoot string) error <span class="cov10" title="3">{
    return ConfModRedirectCheck(cfg, confRoot)
}</span>

func ConfModRedirectCheck(cfg *ConfModRedirect, confRoot string) error <span class="cov10" title="3">{
    if cfg.Basic.DataPath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModRedirect.DataPath not set, use default value")
        cfg.Basic.DataPath = "mod_redirect/redirect.data"
    }</span> 
    
    <span class="cov10" title="3">cfg.Basic.DataPath = conf_path.ConfPathProc(cfg.Basic.DataPath, confRoot)    
    return nil</span>
}

</pre>
		
		<pre class="file" id="file112" style="display: none">/* mod_redirect.go - module for making redirect    */
/*
modification history
--------------------
2014/7/30, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_redirect

import (
    "fmt"
    "net/url"
)

import (
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_http"
    "bfe_module"
)

var (
    openDebug = false
)

type ModuleRedirect struct {
    name       string         // name of module
    configPath string         // path of config file
    ruleTable  *RedirectTable // table of redirect rules
}

func NewModuleRedirect() *ModuleRedirect <span class="cov1" title="1">{
    m := new(ModuleRedirect)
    m.name = "mod_redirect"
    m.ruleTable = NewRedirectTable()
    return m
}</span>

func (m *ModuleRedirect) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModuleRedirect) Attr() map[string]interface{} <span class="cov0" title="0">{
    return map[string]interface{}{
        bfe_basic.MON_ATTR_RELOAD: []string{m.name}, // reload items
    }
}</span>

// load from config file for mod-redirect
// loadConfData is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleRedirect) loadConfData(query url.Values) error <span class="cov1" title="1">{
    // get file path
    path := query.Get("path")
    if path == "" </span><span class="cov1" title="1">{
        // use default
        path = m.configPath
    }</span>

    // load from config file
    <span class="cov1" title="1">conf, err := redirectConfLoad(path)

    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in redirectConfLoad(%s):%s", path, err.Error())
    }</span>

    // update to rule table
    <span class="cov1" title="1">m.ruleTable.Update(conf)

    return nil</span>
}

// set redirect code
func redirectCodeSet(req *bfe_basic.Request, code int) <span class="cov1" title="1">{
    req.Redirect.Code = code
}</span>

// do redirect to http request, with given redirect rules
func prepareReqRedirect(req *bfe_basic.Request, rules *RuleList) bool <span class="cov1" title="1">{
    for _, rule := range *rules </span><span class="cov1" title="1">{
        // rule condition is satisfied ?
        if rule.Cond.Match(req) </span><span class="cov1" title="1">{
            // do actions of the rule
            redirectActionsDo(req, rule.Actions)
            redirectCodeSet(req, rule.Status)

            // finish redirect rules process
            return true
        }</span>
    }
    <span class="cov0" title="0">return false</span>
}

// handler for doing redirect
func (m *ModuleRedirect) redirectHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov10" title="2">{
    // find redirect rules for given request
    rules, err := m.ruleTable.Search(request.Route.Product)

    if err == nil </span><span class="cov1" title="1">{
        if openDebug </span><span class="cov0" title="0">{
            log.Logger.Debug("%s:before:host=%s, path=%s, query=%s, rules=",
                m.name,
                request.HttpRequest.Host, request.HttpRequest.URL.Path,
                request.HttpRequest.URL.RawQuery, rules)
        }</span>

        // redirect rules process
        <span class="cov1" title="1">needRedirect := prepareReqRedirect(request, rules)

        if openDebug </span><span class="cov0" title="0">{
            if needRedirect </span><span class="cov0" title="0">{
                log.Logger.Debug("%s:after:redirectUrl=%s, redirectCode=%d",
                    m.name, request.Redirect.Url, request.Redirect.Code)
            }</span> <span class="cov0" title="0">else {
                log.Logger.Debug("%s:after:not need redirect", m.name)
            }</span>
        }

        <span class="cov1" title="1">if needRedirect </span><span class="cov1" title="1">{
            return bfe_module.BFE_HANDLER_REDIRECT, nil
        }</span>
    }
    <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON, nil</span>
}

func (m *ModuleRedirect) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
    cr string) error <span class="cov1" title="1">{
    var err error
    var conf *ConfModRedirect

    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: cond load err %s", m.name, err.Error())
    }</span>

    <span class="cov1" title="1">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleRedirect) init(cfg *ConfModRedirect, cbs *bfe_module.BfeCallbacks,
    whs *web_monitor.WebHandlers) error <span class="cov1" title="1">{
    openDebug = cfg.Log.OpenDebug

    m.configPath = cfg.Basic.DataPath

    // load from config file to rule table
    if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadConfData(): %s", err.Error())
    }</span>

    // register handler
    <span class="cov1" title="1">err := cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.redirectHandler)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.redirectHandler): %s", m.name, err.Error())
    }</span>

    // register web handler for reload
    <span class="cov1" title="1">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfData)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
    }</span>

    <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">/* redirect_conf_load.go - load redirect config from json file  */
/*
modification history
--------------------
2014/7/30, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_redirect

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

import (
    "bfe_basic/condition"
)

type redirectRuleFile struct {
    Cond    *string         // condition for redirect
    Actions *ActionFileList // list of actions
    Status  *int            // redirect code
}

type redirectRule struct {
    Cond    condition.Condition // condition for redirect
    Actions []Action            // list of actions
    Status  int                 // redirect code
}

type RuleFileList []redirectRuleFile
type RuleList []redirectRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of redirect rules
type ProductRules map[string]*RuleList         // product =&gt; list of redirect rules

type redirectConfFile struct {
    Version *string // version of the config
    Config  *ProductRulesFile
}

type redirectConf struct {
    Version string       // version of the config
    Config  ProductRules // product rules for redirect
}

// check redirectRule
func redirectRuleCheck(conf redirectRuleFile) error <span class="cov7" title="3">{
    var err error

    // check Cond
    if conf.Cond == nil </span><span class="cov1" title="1">{
        return errors.New("no Cond")
    }</span>

    // check Actions
    <span class="cov4" title="2">if conf.Actions == nil || len(*conf.Actions) == 0 </span><span class="cov0" title="0">{
        return errors.New("no Actions")
    }</span>

    <span class="cov4" title="2">err = ActionFileListCheck(conf.Actions)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Actions:%s", err.Error())
    }</span>

    // check redirect code
    <span class="cov4" title="2">if *conf.Status == 0 </span><span class="cov0" title="0">{
        return fmt.Errorf("Status: redirect code not provided")
    }</span>

    <span class="cov4" title="2">return nil</span>
}

// check RuleList
func RuleListCheck(conf *RuleFileList) error <span class="cov10" title="5">{
    for index, rule := range *conf </span><span class="cov7" title="3">{
        err := redirectRuleCheck(rule)
        if err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("redirectRule:%d, %s", index, err.Error())
        }</span>
    }

    <span class="cov8" title="4">return nil</span>
}

// check ProductRules
func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov7" title="3">{
    for product, ruleList := range *conf </span><span class="cov10" title="5">{
        if ruleList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no RuleList for product:%s", product)
        }</span>

        <span class="cov10" title="5">err := RuleListCheck(ruleList)
        if err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
        }</span>
    }

    <span class="cov4" title="2">return nil</span>
}

// check redirectConf
func redirectConfCheck(conf redirectConfFile) error <span class="cov7" title="3">{
    var err error

    // check Version
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    // check Config
    <span class="cov7" title="3">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    <span class="cov7" title="3">err = ProductRulesCheck(conf.Config)
    if err != nil </span><span class="cov1" title="1">{
        return fmt.Errorf("Config:%s", err.Error())
    }</span>

    <span class="cov4" title="2">return nil</span>
}

func ruleConvert(ruleFile redirectRuleFile) (redirectRule, error) <span class="cov4" title="2">{
    rule := redirectRule{}

    cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov0" title="0">{
        return rule, err
    }</span>
    <span class="cov4" title="2">rule.Cond = cond

    rule.Actions = actionsConvert(*ruleFile.Actions)
    rule.Status = *ruleFile.Status
    return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="4">{
    ruleList := new(RuleList)
    *ruleList = make([]redirectRule, 0)

    for _, ruleFile := range *ruleFileList </span><span class="cov4" title="2">{
        rule, err := ruleConvert(ruleFile)
        if err != nil </span><span class="cov0" title="0">{
            return ruleList, err
        }</span>
        <span class="cov4" title="2">*ruleList = append(*ruleList, rule)</span>
    }

    <span class="cov8" title="4">return ruleList, nil</span>
}

/* load config of redirect from file

   Returns:
        (redirectConf, error)
*/
func redirectConfLoad(filename string) (redirectConf, error) <span class="cov7" title="3">{
    var conf redirectConf
    var err error

    /* open the file    */
    file, err1 := os.Open(filename)

    if err1 != nil </span><span class="cov0" title="0">{
        return conf, err1
    }</span>

    /* decode the file  */
    <span class="cov7" title="3">decoder := json.NewDecoder(file)

    var config redirectConfFile
    err = decoder.Decode(&amp;config)
    file.Close()

    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // check config
    <span class="cov7" title="3">err = redirectConfCheck(config)
    if err != nil </span><span class="cov1" title="1">{
        return conf, err
    }</span>

    /* convert config   */
    <span class="cov4" title="2">conf.Version = *config.Version
    conf.Config = make(ProductRules)

    for product, ruleFileList := range *config.Config </span><span class="cov8" title="4">{
        ruleList, err := ruleListConvert(ruleFileList)
        if err != nil </span><span class="cov0" title="0">{
            return conf, err
        }</span>
        <span class="cov8" title="4">conf.Config[product] = ruleList</span>
    }

    <span class="cov4" title="2">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">/* redirect_table.go - table for storing redirect rules   */
/*
modification history
--------------------
2014/7/30, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package mod_redirect

import (
    "fmt"
    "sync"
)

type RedirectTable struct {
    lock            sync.Mutex
    version         string
    productRules    ProductRules
}

func NewRedirectTable() *RedirectTable <span class="cov1" title="1">{
    t := new(RedirectTable)
    t.productRules = make(ProductRules)
    return t
}</span>

// update
func (t *RedirectTable) Update(conf redirectConf) <span class="cov1" title="1">{
    t.lock.Lock()
    
    t.version = conf.Version
    t.productRules = conf.Config

    t.lock.Unlock()
}</span>

/* Search for redirect rules
 
   Returns:
        (*RuleList, nil), if succeed
        (nil, error), if fail
*/
func (t *RedirectTable) Search(product string) (*RuleList, error)<span class="cov10" title="2">{
    t.lock.Lock()   
    //  find rules for given product
    rules, ok := t.productRules[product]
    t.lock.Unlock()
    
    if ok </span><span class="cov1" title="1">{    
        return rules, nil
    }</span> <span class="cov1" title="1">else {
        return nil, fmt.Errorf("no redirect rules for %s", product)
    }</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">/* action.go - action for rewrite   */
/*
modification history
--------------------
2014/7/24, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
        "errors"
        "fmt"
)

import (
        "bfe_basic"
)

type ActionFile struct {
        Cmd    *string  // command of action
        Params []string // params of action
}

type Action struct {
        Cmd    string   // command of action
        Params []string // params of action
}

type ActionFileList []ActionFile

// check ActionFile
func ActionFileCheck(conf ActionFile) error <span class="cov6" title="5">{
        var paramsLenCheck int

        // check command
        if conf.Cmd == nil </span><span class="cov1" title="1">{
                return errors.New("no Cmd")
        }</span>

        // validate command, and get how many params should exist for each command
        <span class="cov5" title="4">switch *conf.Cmd </span>{
        // commands or host
        <span class="cov5" title="4">case "HOST_SET":
                paramsLenCheck = 1</span>
        // commands for path
        <span class="cov0" title="0">case "PATH_SET", "PATH_PREFIX_ADD", "PATH_PREFIX_TRIM":
                paramsLenCheck = 1</span>
        // commands for query
        <span class="cov0" title="0">case "QUERY_ADD", "QUERY_RENAME":
                paramsLenCheck = 2</span>
        <span class="cov0" title="0">case "QUERY_DEL", "QUERY_DEL_ALL_EXCEPT":
                paramsLenCheck = -1</span> // any is OK
        <span class="cov0" title="0">default:
                return fmt.Errorf("invalid cmd:%s", *conf.Cmd)</span>
        }

        // check params
        <span class="cov5" title="4">if conf.Params == nil </span><span class="cov3" title="2">{
                return errors.New("no Params")
        }</span>

        <span class="cov3" title="2">if paramsLenCheck != -1 </span><span class="cov3" title="2">{
                paramsLen := len(conf.Params)

                if *conf.Cmd == "QUERY_ADD" </span><span class="cov0" title="0">{
                        // len(params) should be multiply of 2
                        if !((paramsLen%2 == 0) &amp;&amp; (paramsLen &gt;= 2)) </span><span class="cov0" title="0">{
                                return fmt.Errorf("num of params should be 2x, now:%d]", paramsLen)
                        }</span>
                }

                <span class="cov3" title="2">if paramsLen != paramsLenCheck </span><span class="cov0" title="0">{
                        return fmt.Errorf("num of params:[ok:%d, now:%d]", paramsLenCheck, paramsLen)
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// check ActionFileList
func ActionFileListCheck(conf *ActionFileList) error <span class="cov3" title="2">{
        for index, action := range *conf </span><span class="cov3" title="2">{
                err := ActionFileCheck(action)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ActionFileList:%d, %s", index, err.Error())
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

func actionConvert(actionFile ActionFile) Action <span class="cov4" title="3">{
        action := Action{}
        action.Cmd = *actionFile.Cmd
        action.Params = actionFile.Params
        return action
}</span>

func actionsConvert(actionFiles ActionFileList) []Action <span class="cov3" title="2">{
        actions := make([]Action, 0)

        for _, actionFile := range actionFiles </span><span class="cov3" title="2">{
                action := actionConvert(actionFile)
                actions = append(actions, action)
        }</span>

        <span class="cov3" title="2">return actions</span>
}

// do actions to request
func reWriteActionDo(req *bfe_basic.Request, action Action) <span class="cov10" title="13">{
        switch action.Cmd </span>{
        // for host
        <span class="cov3" title="2">case "HOST_SET":
                reqHostSet(req, action.Params[0])</span>
        // for path
        <span class="cov3" title="2">case "PATH_SET":
                reqPathSet(req, action.Params[0])</span>
        <span class="cov1" title="1">case "PATH_PREFIX_ADD":
                reqPathPrefixAdd(req, action.Params[0])</span>
        <span class="cov1" title="1">case "PATH_PREFIX_TRIM":
                reqPathPrefixTrim(req, action.Params[0])</span>
        // for query
        <span class="cov3" title="2">case "QUERY_ADD":
                reqQueryAdd(req, action.Params)</span>
        <span class="cov3" title="2">case "QUERY_RENAME":
                reqQueryRename(req, action.Params[0], action.Params[1])</span>
        <span class="cov1" title="1">case "QUERY_DEL":
                reqQueryDel(req, action.Params)</span>
        <span class="cov3" title="2">case "QUERY_DEL_ALL_EXCEPT":
                reqQueryDelAllExcept(req, action.Params)</span>
        }
}

// do actions to request
func reWriteActionsDo(req *bfe_basic.Request, actions []Action) <span class="cov1" title="1">{
        for _, action := range actions </span><span class="cov6" title="5">{
                reWriteActionDo(req, action)
        }</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">/* action_host.go - action to host for rewrite  */
/*
modification history
--------------------
2014/7/25, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
    "bfe_basic"
)

// set hostname to request
func reqHostSet(req *bfe_basic.Request, hostname string) <span class="cov10" title="2">{
    httpReq := req.HttpRequest
    httpReq.Host = hostname
}</pre>
		
		<pre class="file" id="file117" style="display: none">/* action_path.go - action to path for rewrite  */
/*
modification history
--------------------
2014/7/25, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
    "path"
    "strings"
)

import (
    "bfe_basic"
)

// set path to request
func reqPathSet(req *bfe_basic.Request, path string) <span class="cov10" title="2">{
    httpReq := req.HttpRequest
    httpReq.URL.Path = path
}</span>

// add prefix to path
// e.g., path  "/(.*)" =&gt; "/link?$1",
func reqPathPrefixAdd(req *bfe_basic.Request, prefix string) <span class="cov1" title="1">{
    httpReq := req.HttpRequest    
    pathStr := httpReq.URL.Path
    // remove "/" from path
    pathStr = strings.TrimPrefix(pathStr, "/")
    // add prefix to path
    pathStr = prefix + pathStr
    // add "/" to path
    pathStr = path.Join("/", pathStr)
    // set new path
    httpReq.URL.Path = pathStr
}</span>

// trim prefix of path
// e.g., path "/service/shortcut/(.*)" =&gt; "/$1",
func reqPathPrefixTrim(req *bfe_basic.Request, prefix string) <span class="cov1" title="1">{
    httpReq := req.HttpRequest
    pathStr := httpReq.URL.Path
    // trim prefix from path
    pathStr = strings.TrimPrefix(pathStr, prefix)
    // add "/" to prefix
    pathStr = path.Join("/", pathStr)
    // set new path
    httpReq.URL.Path = pathStr    
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">/* action_query.go - action to query for rewrite    */
/*
modification history
--------------------
2014/7/25, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
        "fmt"
        "net/url"
        "strings"
)

import (
        "bfe_basic"
)

// parse the query
func queryParse(req *bfe_basic.Request) url.Values <span class="cov8" title="7">{
        // re-use req.Query
        if req.Query == nil </span><span class="cov7" title="5">{
                req.Query = req.HttpRequest.URL.Query()
        }</span>

        <span class="cov8" title="7">return req.Query</span>
}

// dump queries to string, e.g., key1=value1&amp;key2=value2
func queryDump(queries url.Values) string <span class="cov8" title="7">{
        strs := make([]string, 0)

        for key, values := range queries </span><span class="cov9" title="10">{
                for _, value := range values </span><span class="cov10" title="11">{
                        str := fmt.Sprintf("%s=%s", key, value)
                        strs = append(strs, str)
                }</span>
        }

        <span class="cov8" title="7">return strings.Join(strs, "&amp;")</span>
}

// add some number of (key, value) to query
func reqQueryAdd(req *bfe_basic.Request, params []string) <span class="cov3" title="2">{
        // parse the query
        queries := queryParse(req)

        // get number of pairs
        pairNum := len(params) / 2

        // add (key, value) to queries
        for i := 0; i &lt; pairNum; i++ </span><span class="cov5" title="3">{
                key := params[2*i]
                value := params[2*i+1]

                // try to get value of given key
                oldValue := queries.Get(key)

                if oldValue == "" </span><span class="cov5" title="3">{
                        // key not exist, use Set()
                        queries.Set(key, value)
                }</span> <span class="cov0" title="0">else {
                        // key exist, use Add()
                        queries.Add(key, value)
                }</span>
        }

        // dump queries to URL.RawQuery
        <span class="cov3" title="2">req.HttpRequest.URL.RawQuery = queryDump(queries)</span>
}

// renanme query key from old name to new name
func reqQueryRename(req *bfe_basic.Request, oldName string, newName string) <span class="cov3" title="2">{
        // parse the query
        queries := queryParse(req)

        // renanme query key from old name to new name
        values, ok := queries[oldName]
        if ok </span><span class="cov3" title="2">{
                queries.Del(oldName)
                queries[newName] = values
        }</span>

        // dump queries to URL.RawQuery
        <span class="cov3" title="2">req.HttpRequest.URL.RawQuery = queryDump(queries)</span>
}

// delete some keys from query
func reqQueryDel(req *bfe_basic.Request, keys []string) <span class="cov1" title="1">{
        // parse the query
        queries := queryParse(req)

        // delete some keys from queries
        for _, key := range keys </span><span class="cov3" title="2">{
                queries.Del(key)
        }</span>

        // dump queries to URL.RawQuery
        <span class="cov1" title="1">req.HttpRequest.URL.RawQuery = queryDump(queries)</span>
}

// delete all keys from query, except some keys
func reqQueryDelAllExcept(req *bfe_basic.Request, keys []string) <span class="cov3" title="2">{
        // parse the query
        queries := queryParse(req)

        // prepare map for keys
        keysMap := make(map[string]bool)
        for _, key := range keys </span><span class="cov3" title="2">{
                keysMap[key] = true
        }</span>

        // delete some keys from queries, except keys in keysMap
        <span class="cov3" title="2">for key, _ := range queries </span><span class="cov7" title="6">{
                _, ok := keysMap[key]

                if !ok </span><span class="cov6" title="4">{
                        queries.Del(key)
                }</span>
        }

        // dump queries to URL.RawQuery
        <span class="cov3" title="2">req.HttpRequest.URL.RawQuery = queryDump(queries)</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">/* conf_mod_rewrite.go - config for mod_rewrite */
/*
modification history
--------------------
2014/7/25, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
    "code.google.com/p/gcfg"
    "www.baidu.com/golang-lib/conf_path"
    "www.baidu.com/golang-lib/log"
)

type ConfModReWrite struct {
    Basic struct {
        DataPath    string  // path of config data (rewrite)
    }

    Log struct {
        OpenDebug bool
    }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModReWrite, error) <span class="cov10" title="2">{
    var err error
    var cfg ConfModReWrite

    // read config from file
    err = gcfg.ReadFileInto(&amp;cfg, filePath)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    // check conf of mod_rewrite
    <span class="cov10" title="2">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

    <span class="cov10" title="2">return &amp;cfg, nil</span>
}


func (cfg *ConfModReWrite) Check(confRoot string) error <span class="cov10" title="2">{
    return ConfModReWriteCheck(cfg, confRoot)
}</span>

func ConfModReWriteCheck(cfg *ConfModReWrite, confRoot string) error <span class="cov10" title="2">{
    if cfg.Basic.DataPath == "" </span><span class="cov1" title="1">{
        log.Logger.Warn("ModReWrite.DataPath not set, use default value")
        cfg.Basic.DataPath = "mod_rewrite/rewrite.data"
    }</span>
    
    <span class="cov10" title="2">cfg.Basic.DataPath = conf_path.ConfPathProc(cfg.Basic.DataPath, confRoot)
    return nil</span>
}

</pre>
		
		<pre class="file" id="file120" style="display: none">/* mod_rewrite.go - module for marking rewrite    */
/*
modification history
--------------------
2014/7/23, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
        "fmt"
        "net/url"
)

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
)

var (
        openDebug = false
)

type ModuleReWrite struct {
        name       string        // name of module
        configPath string        // path of config file
        ruleTable  *ReWriteTable // table of rewrite rules
}

func NewModuleReWrite() *ModuleReWrite <span class="cov0" title="0">{
        m := new(ModuleReWrite)
        m.name = "mod_rewrite"
        m.ruleTable = NewReWriteTable()
        return m
}</span>

func (m *ModuleReWrite) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleReWrite) Attr() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                bfe_basic.MON_ATTR_RELOAD: []string{m.name}, // reload items
        }
}</span>

// load from config file for mod-rewrite
// loadConfData is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleReWrite) loadConfData(query url.Values) error <span class="cov0" title="0">{
        // get file path
        path := query.Get("path")
        if path == "" </span><span class="cov0" title="0">{
                // use default
                path = m.configPath
        }</span>

        // load from config file
        <span class="cov0" title="0">conf, err := ReWriteConfLoad(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in ReWriteConfLoad(%s):%s", path, err.Error())
        }</span>

        // update to rule table
        <span class="cov0" title="0">m.ruleTable.Update(conf)

        return nil</span>
}

// do rewrite to http request, with given rewrite rules
func ReqReWrite(req *bfe_basic.Request, rules *RuleList) <span class="cov0" title="0">{
        for _, rule := range *rules </span><span class="cov0" title="0">{
                // rule condition is satisfied ?
                if rule.Cond.Match(req) </span><span class="cov0" title="0">{
                        // do actions of the rule
                        reWriteActionsDo(req, rule.Actions)

                        // flag of last is true?
                        if rule.Last </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
}

// handler for doing rewrite
func (m *ModuleReWrite) rewriteHandler(request *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov0" title="0">{
        // find rewrite rules for given request
        rules, err := m.ruleTable.Search(request.Route.Product)

        if err == nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:before:host=%s, path=%s, query=%s, rules=", m.name,
                                request.HttpRequest.Host, request.HttpRequest.URL.Path,
                                request.HttpRequest.URL.RawQuery, rules)
                }</span>

                // do rewrite to request, according to rules
                <span class="cov0" title="0">ReqReWrite(request, rules)

                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s:after:host=%s, path=%s, query=%s", m.name,
                                request.HttpRequest.Host, request.HttpRequest.URL.Path,
                                request.HttpRequest.URL.RawQuery)
                }</span>
        }

        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON, nil</span>
}

func (m *ModuleReWrite) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov0" title="0">{
        var err error
        var conf *ConfModReWrite

        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleReWrite) init(cfg *ConfModReWrite, cbs *bfe_module.BfeCallbacks,
        whs *web_monitor.WebHandlers) error <span class="cov0" title="0">{
        openDebug = cfg.Log.OpenDebug

        m.configPath = cfg.Basic.DataPath

        // load from config file to rule table
        if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("err in loadConfData(): %s", err.Error())
        }</span>

        // register handler
        <span class="cov0" title="0">err := cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.rewriteHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.rewriteHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for reload
        <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">/* rewrite_conf_load.go - load rewrite config from json file  */
/*
modification history
--------------------
2014/7/23, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
    "encoding/json"
    "errors"
    "fmt"
    "os"
)

import (
    "bfe_basic/condition"
)

type ReWriteRuleFile struct {
    Cond    *string         // condition for rewrite
    Actions *ActionFileList // list of actions
    Last    *bool           // if true, not to check the next rule in the list if
    // the condition is satisfied
}

type ReWriteRule struct {
    Cond    condition.Condition // condition for rewrite
    Actions []Action            // list of actions
    Last    bool                // if true, not to check the next rule in the list if
    // the condition is satisfied
}

type RuleFileList []ReWriteRuleFile
type RuleList []ReWriteRule

type ProductRulesFile map[string]*RuleFileList // product =&gt; list of rewrite rules
type ProductRules map[string]*RuleList         // product =&gt; list of rewrite rules

type ReWriteConfFile struct {
    Version *string // version of the config
    Config  *ProductRulesFile
}

type ReWriteConf struct {
    Version string       // version of the config
    Config  ProductRules // product rules for rewrite
}

// check ReWriteRule
func ReWriteRuleCheck(conf ReWriteRuleFile) error <span class="cov7" title="3">{
    var err error

    // check Cond
    if conf.Cond == nil </span><span class="cov1" title="1">{
        return errors.New("no Cond")
    }</span>

    // check Actions
    <span class="cov4" title="2">if conf.Actions == nil </span><span class="cov0" title="0">{
        return errors.New("no Actions")
    }</span>

    <span class="cov4" title="2">err = ActionFileListCheck(conf.Actions)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("Actions:%s", err.Error())
    }</span>

    // check Last
    <span class="cov4" title="2">if conf.Last == nil </span><span class="cov0" title="0">{
        return errors.New("no Last")
    }</span>

    <span class="cov4" title="2">return nil</span>
}

// check RuleList
func RuleListCheck(conf *RuleFileList) error <span class="cov10" title="5">{
    for index, rule := range *conf </span><span class="cov7" title="3">{
        err := ReWriteRuleCheck(rule)
        if err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("ReWriteRule:%d, %s", index, err.Error())
        }</span>
    }

    <span class="cov8" title="4">return nil</span>
}

// check ProductRules
func ProductRulesCheck(conf *ProductRulesFile) error <span class="cov7" title="3">{
    for product, ruleList := range *conf </span><span class="cov10" title="5">{
        if ruleList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no RuleList for product:%s", product)
        }</span>

        <span class="cov10" title="5">err := RuleListCheck(ruleList)
        if err != nil </span><span class="cov1" title="1">{
            return fmt.Errorf("ProductRules:%s, %s", product, err.Error())
        }</span>
    }

    <span class="cov4" title="2">return nil</span>
}

// check ReWriteConf
func ReWriteConfCheck(conf ReWriteConfFile) error <span class="cov7" title="3">{
    var err error

    // check Version
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>

    // check Config
    <span class="cov7" title="3">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    <span class="cov7" title="3">err = ProductRulesCheck(conf.Config)
    if err != nil </span><span class="cov1" title="1">{
        return fmt.Errorf("Config:%s", err.Error())
    }</span>

    <span class="cov4" title="2">return nil</span>
}

func ruleConvert(ruleFile ReWriteRuleFile) (ReWriteRule, error) <span class="cov4" title="2">{
    rule := ReWriteRule{}

    if ruleFile.Cond == nil </span><span class="cov0" title="0">{
        return rule, fmt.Errorf("cond not set")
    }</span>
    <span class="cov4" title="2">cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov0" title="0">{
        return rule, err
    }</span>
    <span class="cov4" title="2">rule.Cond = cond

    rule.Actions = actionsConvert(*ruleFile.Actions)
    rule.Last = *ruleFile.Last
    return rule, nil</span>
}

func ruleListConvert(ruleFileList *RuleFileList) (*RuleList, error) <span class="cov8" title="4">{
    ruleList := new(RuleList)
    *ruleList = make([]ReWriteRule, 0)

    for _, ruleFile := range *ruleFileList </span><span class="cov4" title="2">{
        rule, err := ruleConvert(ruleFile)
        if err != nil </span><span class="cov0" title="0">{
            return ruleList, err
        }</span>
        <span class="cov4" title="2">*ruleList = append(*ruleList, rule)</span>
    }

    <span class="cov8" title="4">return ruleList, nil</span>
}

/* load config of rewrite from file

   Returns:
        (ReWriteConf, error)
*/
func ReWriteConfLoad(filename string) (ReWriteConf, error) <span class="cov7" title="3">{
    var conf ReWriteConf
    var err error

    /* open the file    */
    file, err1 := os.Open(filename)

    if err1 != nil </span><span class="cov0" title="0">{
        return conf, err1
    }</span>

    /* decode the file  */
    <span class="cov7" title="3">decoder := json.NewDecoder(file)

    var config ReWriteConfFile
    err = decoder.Decode(&amp;config)
    file.Close()

    if err != nil </span><span class="cov0" title="0">{
        return conf, err
    }</span>

    // check config
    <span class="cov7" title="3">err = ReWriteConfCheck(config)
    if err != nil </span><span class="cov1" title="1">{
        return conf, err
    }</span>

    /* convert config   */
    <span class="cov4" title="2">conf.Version = *config.Version
    conf.Config = make(ProductRules)

    for product, ruleFileList := range *config.Config </span><span class="cov8" title="4">{
        ruleList, err := ruleListConvert(ruleFileList)
        if err != nil </span><span class="cov0" title="0">{
            return conf, err
        }</span>
        <span class="cov8" title="4">conf.Config[product] = ruleList</span>
    }

    <span class="cov4" title="2">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">/* rewrite_table.go - table for storing rewrite rules   */
/*
modification history
--------------------
2014/7/24, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_rewrite

import (
    "fmt"
    "sync"
)

type ReWriteTable struct {
    lock            sync.Mutex
    version         string
    productRules    ProductRules
}

func NewReWriteTable() *ReWriteTable <span class="cov8" title="1">{
    t := new(ReWriteTable)
    t.productRules = make(ProductRules)
    return t
}</span>

// update
func (t *ReWriteTable) Update(conf ReWriteConf) <span class="cov8" title="1">{
    t.lock.Lock()
    
    t.version = conf.Version
    t.productRules = conf.Config

    t.lock.Unlock()
}</span>

/* Search for rewrite rules
 
   Returns:
        (*RuleList, nil), if succeed
        (nil, error), if fail
*/
func (t *ReWriteTable) Search(product string) (*RuleList, error)<span class="cov8" title="1">{
    t.lock.Lock()   
    //  find rules for given product
    rules, ok := t.productRules[product]
    t.lock.Unlock()
    
    if ok </span><span class="cov8" title="1">{    
        return rules, nil
    }</span> <span class="cov0" title="0">else {
        return nil, fmt.Errorf("no rewrite rules for %s", product)
    }</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">/* conf_mod_tcp_wise.go - configuration for mod_tcp_wise  */
/*
modification history
--------------------
2015/9/1, by niexiaohui, create
*/
/*
DESCRIPTION
*/

package mod_tcp_wise

import (
        "code.google.com/p/gcfg"
        "www.baidu.com/golang-lib/conf_path"
        "www.baidu.com/golang-lib/log"
)

type ConfModTcpWise struct {
        Basic struct {
                RulePath      string // tcp wise config file path
                CwndTablePath string // cwnd table file path
        }

        Log struct {
                OpenDebug bool
        }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModTcpWise, error) <span class="cov7" title="3">{
        var err error
        var cfg ConfModTcpWise

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_block
        <span class="cov7" title="3">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>
        <span class="cov7" title="3">return &amp;cfg, nil</span>
}

func (cfg *ConfModTcpWise) Check(confRoot string) error <span class="cov10" title="5">{
        if cfg.Basic.RulePath == "" </span><span class="cov1" title="1">{
                log.Logger.Warn("ModTcpWise.RulePath not set, use default value: mod_tcp_wise/tcp_wise_rule.data")
                cfg.Basic.RulePath = "mod_tcp_wise/tcp_wise_rule.data"
        }</span>

        <span class="cov10" title="5">if cfg.Basic.CwndTablePath == "" </span><span class="cov1" title="1">{
                log.Logger.Warn("ModTcpWise.CwndTablePath not set, use default value: mod_tcp_wise/cwnd_table.data")
                cfg.Basic.CwndTablePath = "mod_tcp_wise/cwnd_table.data"
        }</span>

        <span class="cov10" title="5">cfg.Basic.RulePath = conf_path.ConfPathProc(cfg.Basic.RulePath, confRoot)
        cfg.Basic.CwndTablePath = conf_path.ConfPathProc(cfg.Basic.CwndTablePath, confRoot)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">/* cwnd_table_load.go - load cwnd table for mod_tcp_wise  */
/*
modification history
--------------------
2015/9/1, by niexiaohui, create
*/
/*
DESCRIPTION
*/
package mod_tcp_wise

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "sync"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
        "bfe_util"
)

type CwndTable struct {
        lock           sync.RWMutex
        version        string
        cwndTableValue map[string]int
}

func NewCwndTable() *CwndTable <span class="cov8" title="23">{
        t := new(CwndTable)
        t.version = ""
        t.cwndTableValue = make(map[string]int)
        return t
}</span>

//update
func (t *CwndTable) Update(ct CwndTable) <span class="cov4" title="5">{
        t.lock.Lock()
        t.version = ct.version
        t.cwndTableValue = ct.cwndTableValue
        t.lock.Unlock()
    log.Logger.Info("CwndTable.Update(): cwnd table updated")
}</span>

// get initial cwnd(icw) by ip
func (t *CwndTable) QueryICW(ip string) (int, error) <span class="cov5" title="6">{
    items := strings.Split(ip, ".")
    if len(items) != 4 </span><span class="cov2" title="2">{
        return -1, fmt.Errorf("QueryICW(%s): ip formate is err", ip)
    }</span>
    <span class="cov4" title="4">t.lock.RLock()
    table := t.cwndTableValue
    t.lock.RUnlock()
    // query icw, now we use default IP prefix len = 24, is will be optimized in the future
    ipPrefix := items[0] + "." + items[1] + "." + items[2] + ".0" 
    if cwnd, ok := table[ipPrefix]; ok </span><span class="cov2" title="2">{
        return cwnd, nil
    }</span>
    // not found
    <span class="cov2" title="2">return -1, nil</span>
}

/* check cwnd table config

   Returns:
           (ip prefix, icw, error)
*/
func checkConfig(line string) (string, int, error) <span class="cov8" title="25">{
    var ipPrefix string
    var icw int
    /*  parse config
        items[0] is ip prefix name
        items[1] is ip prefix length
        items[2] is icw
        Now we do not use items[1], here we let ip prefix length = 24. It will be optimized in the future
    */
    items := strings.Split(line, ",")
    if len(items) != 3 </span><span class="cov0" title="0">{
        return ipPrefix, icw, fmt.Errorf("err config: %s, line should be 3 column", line)
    }</span>

    <span class="cov8" title="25">ipPrefix = items[0]
    // ip prefix format should be *.*.*.*
    ipItems := strings.Split(ipPrefix, ".")
    if len(ipItems) != 4 </span><span class="cov5" title="7">{
        return ipPrefix, icw, fmt.Errorf("err config: %s, ip err", line)
    }</span>

    <span class="cov8" title="18">icw, err := strconv.Atoi(items[2])
    // icw must be int and &gt; 0
    if err != nil || icw &lt; 1 </span><span class="cov2" title="2">{
        return ipPrefix, icw, fmt.Errorf("err config: %s, icw should &gt; 0", line)
    }</span>

    <span class="cov7" title="16">return ipPrefix, icw, nil</span>
}

func (t *CwndTable) CwndTableLoad(path string) (CwndTable, error) <span class="cov6" title="9">{
        var ct CwndTable
        var err error

        version, err := bfe_util.GetVersion(path)
        if err != nil </span><span class="cov1" title="1">{
        return ct, fmt.Errorf("CwndTableLoad(): err %s", err.Error())
        }</span>

        <span class="cov6" title="8">if version == "" </span><span class="cov0" title="0">{
        return ct, fmt.Errorf("CwndTableLoad(): err first line")
        }</span>
        // if version do not change, cwnd table do not load cwndTableValue
        <span class="cov6" title="8">if t.version == version </span><span class="cov2" title="2">{
        log.Logger.Info("CwndTableLoad(): New cwnd table's version does not change, cwnd table kept the same.")
                return *t, nil
        }</span>
        // load new cwnd table
        <span class="cov5" title="6">ct.version = version
        ct.cwndTableValue = make(map[string]int)
        // open the file
        fr, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return ct, fmt.Errorf("CwndTableLoad() err %s", err.Error())
        }</span>
        <span class="cov5" title="6">defer fr.Close()
        buf := bufio.NewReader(fr)
        for </span><span class="cov10" title="39">{
                line, err := buf.ReadString('\n')
                if err != nil </span><span class="cov5" title="6">{
                        if err == io.EOF </span><span class="cov5" title="6">{
                                break</span>
                        }
                        <span class="cov0" title="0">return ct, err</span>
                }
                <span class="cov9" title="33">line = strings.TrimSpace(line)
                if strings.Contains(line, "#") </span><span class="cov7" title="12">{
                        continue</span>
                }
        // check config format
        <span class="cov8" title="21">ipPrefix, icw, err := checkConfig(line) 
        if err != nil </span><span class="cov5" title="6">{
            log.Logger.Warn("CwndTableLoad(): err config: %s", err)
            continue</span>
        }
        // add ipPrefix -&gt; icw
        <span class="cov7" title="15">if _, ok := ct.cwndTableValue[ipPrefix]; !ok </span><span class="cov7" title="15">{
            ct.cwndTableValue[ipPrefix] = icw
        }</span>
        }
    // Unless at the bfe start time, cwnd table length can not be 0
    <span class="cov5" title="6">if len(ct.cwndTableValue) == 0 &amp;&amp; len(t.cwndTableValue) != 0 </span><span class="cov2" title="2">{
        return ct, fmt.Errorf("CwndTableLoad(%s) : new cwnd table is empty, err cwnd table file")
    }</span>
        <span class="cov4" title="4">return ct, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">/* conf_mod_tcp_wise.go - get tcp flow data and configure the initial cwnd   */
/*
modification history
--------------------
2015/9/1, by niexiaohui, create
*/
/*
DESCRIPTION
*/
package mod_tcp_wise

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "net/url"
        "unsafe"
)

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/module_state2"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_module"
        "bfe_util"
)

var (
        openDebug = false
)

// key for counter of mod_block
var COUNTER_KEYS = []string{
        "TCP_WISE_INFO_NUM",     // get tcp wise info data
        "QUERY_SUCESS_NUM",      // find cwnd in cwnd table
        "SESSION_NUM",           // session num
        "SET_CWND_ERR_NUM",      // set initial err number
        "GET_TCP_WISE_INFO_ERR", // get tcp wise info err number
}

type ModuleTcpWise struct {
        name            string
        state           *module_state2.State // module state

        rulePath        string       // rule file path
        cwndTablePath   string       // cwnd table path

    tcpWiseRule     *TcpWiseRule // basic rule for tcp wise
        cwndTable       *CwndTable   // cwnd table

    isBigEndian     bool         // the endian of this machine
    kernelCwnd      uint32       // kernel default cwnd
    supportTcpWise  bool         // support tcp wise or not
}

func NewModuleTcpWise() *ModuleTcpWise <span class="cov10" title="20">{
        m := new(ModuleTcpWise)
        m.name = "mod_tcp_wise"
        m.tcpWiseRule = NewTcpWiseRule()
        m.cwndTable = NewCwndTable()
        m.isBigEndian = bfe_util.IsBigEndian()

        m.state = new(module_state2.State)
        m.state.Init()
        m.state.CountersInit(COUNTER_KEYS)
        m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_TCP_WISE)

        return m
}</span>

func (m *ModuleTcpWise) Name() string <span class="cov0" title="0">{
        return m.name
}</span>

func (m *ModuleTcpWise) Attr() map[string]interface{} <span class="cov0" title="0">{
        // reload items
        reloadEntries := []string{
                m.name + ".rule_conf",
                m.name + ".cwnd_table",
        }

        // monitor items (item name, item type)
        monitorEntries := map[string]string{
                m.name: bfe_basic.MON_TYPE_STATE,
        }

        return map[string]interface{}{
                bfe_basic.MON_ATTR_RELOAD:  reloadEntries,
                bfe_basic.MON_ATTR_MONITOR: monitorEntries,
        }
}</span>

// all reload handlers
func (m *ModuleTcpWise) reloadHandlers() map[string]interface{} <span class="cov1" title="1">{
        handlers := map[string]interface{}{
                m.name + ".rule_conf":  m.loadConfData,
                m.name + ".cwnd_table": m.loadCwndTable,
        }
        return handlers
}</span>

// load all the configuration
func (m *ModuleTcpWise) loadConfData(query url.Values) error <span class="cov5" title="5">{
        path := query.Get("path")
        if path == "" </span><span class="cov5" title="4">{
                // use old path
                path = m.rulePath
        }</span>
        //load conf
        <span class="cov5" title="5">conf, err := TcpWiseRuleConfLoad(path)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("%s.loadConfData():%s", m.name, err.Error())
        }</span>
        <span class="cov5" title="4">m.tcpWiseRule.Update(conf)

        // check function state
        if m.supportTcpWise </span><span class="cov3" title="2">{
                if m.tcpWiseRule.GetTcpWiseFunction() </span><span class="cov3" title="2">{
                        m.state.Set("TCP_WISE_FUNCTION", "true")
                }</span> <span class="cov0" title="0">else {
                        m.state.Set("TCP_WISE_FUNCTION", "false")
                }</span>
                <span class="cov3" title="2">if m.tcpWiseRule.GetTcpDataFunction() </span><span class="cov3" title="2">{
                        m.state.Set("TCP_DATA_FUNCTION", "true")
                }</span> <span class="cov0" title="0">else {
                        m.state.Set("TCP_DATA_FUNCTION", "false")
                }</span>
        } <span class="cov3" title="2">else {
                // if machine not support tcp wise 
                if m.tcpWiseRule.GetTcpWiseFunction() </span><span class="cov1" title="1">{
                        m.state.Set("TCP_WISE_FUNCTION", "false")
                        m.tcpWiseRule.SetTcpWiseFunction(false)
                        log.Logger.Warn("%s.loadConfData(): machine do not support TCP WISE, shut down TcpWiseFunction", m.name)
                }</span> 
                <span class="cov3" title="2">if m.tcpWiseRule.GetTcpDataFunction() </span><span class="cov1" title="1">{
                        m.state.Set("TCP_DATA_FUNCTION", "false")
                        m.tcpWiseRule.SetTcpDataFunction(false)
                        log.Logger.Warn("%s.loadConfData(): machine do not support TCP WISE, shut down TcpDataFunction", m.name)
                }</span>
        }
        <span class="cov5" title="4">return nil</span>
}

// load cwnd table data
func (m *ModuleTcpWise) loadCwndTable(query url.Values) error <span class="cov6" title="6">{
        path := query.Get("path")
        if path == "" </span><span class="cov3" title="2">{
                //use old path
                path = m.cwndTablePath
        }</span>
        <span class="cov6" title="6">items, err := m.cwndTable.CwndTableLoad(path)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("%s.loadCwndTable():%s", m.name, err.Error())
        }</span>
        <span class="cov5" title="4">m.cwndTable.Update(items)
        return nil</span>
}

// query initial cwnd by ip
func (m *ModuleTcpWise) queryCwndByIP(srcip string) int <span class="cov4" title="3">{
    defaultCwnd := m.tcpWiseRule.GetDefaultCwnd()
        cwnd, err := m.cwndTable.QueryICW(srcip)
        if err != nil </span><span class="cov1" title="1">{
        log.Logger.Error("%s.queryCwndByIP(): %s ", m.name, err )
                return defaultCwnd
        }</span>

    <span class="cov3" title="2">if cwnd != -1 </span><span class="cov1" title="1">{
        m.state.Inc("QUERY_SUCESS_NUM", 1)
                return cwnd
        }</span>
        <span class="cov1" title="1">return defaultCwnd</span>
}

//query initial cwnd by ip and tell kernel
func (m *ModuleTcpWise) modifyCwndHandler(session *bfe_basic.Session) int <span class="cov4" title="3">{
        m.state.Inc("SESSION_NUM", 1)

        if session.FlowInfo == nil </span><span class="cov4" title="3">{
                session.FlowInfo = new(bfe_basic.TcpFlowInfo)
        }</span>

        // tcp wise not work, return
        <span class="cov4" title="3">function := m.tcpWiseRule.GetTcpWiseFunction()
        if !function </span><span class="cov4" title="3">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("TcpWiseFunction is false, using DefaultCwnd")
                }</span>
                <span class="cov4" title="3">session.FlowInfo.InitialCwnd = m.kernelCwnd
                return bfe_module.BFE_HANDLER_GOON</span>
        }

        // tcp wise works, query and modify icw
        <span class="cov0" title="0">clientIP := session.RemoteAddr.IP.String()
        icw := m.queryCwndByIP(clientIP)
        session.FlowInfo.InitialCwnd = uint32(icw)
        
        //get net fd
        conn := session.Connection
        fd, err := bfe_util.GetConnFd(conn)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("%s.modifyCwndHandler(): GetConnFd(): %s", m.name, err.Error())
                return bfe_module.BFE_HANDLER_GOON
        }</span>

        // tell kernel initial icw
        <span class="cov0" title="0">err = bfe_util.SetFdCwnd(fd, icw)
        if err != nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s.modifyCwndHandler(): SetFdCwnd(): %s", m.name, err.Error())
                }</span>
                <span class="cov0" title="0">m.state.Inc("SET_CWND_ERR_NUM", 1)</span>
        }
    <span class="cov0" title="0">if openDebug </span><span class="cov0" title="0">{
        // check changing icw success or not
        kernelIcw, err := bfe_util.GetFdCwnd(fd)
        if err != nil </span><span class="cov0" title="0">{
            log.Logger.Debug("%s.modifyCwndHandler(): GetFdCwnd(): %s", m.name, err.Error())
        }</span>
        <span class="cov0" title="0">if kernelIcw != uint32(icw) </span><span class="cov0" title="0">{
            log.Logger.Debug("%s.modifyCwndHandler(): Set ICW failed.", m.name)
        }</span>
    }
        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON</span>
}

func (m *ModuleTcpWise) collectTcpWiseInfo(session *bfe_basic.Session) error <span class="cov1" title="1">{
        // if session's tcp_wise_info num &lt;= MaxTcpWiseInfoNum, collect it, otherwise abandon it
        tcpResponseLen := len(session.FlowInfo.AllTcpWiseInfo)
        if tcpResponseLen &gt; m.tcpWiseRule.tcpWiseRuleConf.MaxTcpWiseInfoNum </span><span class="cov0" title="0">{
                return nil
        }</span>

    <span class="cov1" title="1">tcpWiseInfo := new(bfe_basic.TcpWiseInfo)
        tcpWiseInfoLen := int(unsafe.Sizeof(*tcpWiseInfo))
        uint32Data := make([]uint32, tcpWiseInfoLen/4)
        conn := session.Connection
        fd, err := bfe_util.GetConnFd(conn)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("collectTcpWiseInfo(): %s", err.Error())
        }</span>
        // get tcp wise info from kernel
        <span class="cov0" title="0">data, err := bfe_util.GetTcpWiseInfo(fd, tcpWiseInfoLen)
        if err != nil </span><span class="cov0" title="0">{
                m.state.Inc("GET_TCP_WISE_INFO_ERR", 1)
                return fmt.Errorf("collectTcpWiseInfo(): GetTcpWiseInfo(): %s", err.Error())
        }</span>
        <span class="cov0" title="0">if m.isBigEndian </span><span class="cov0" title="0">{
                err = binary.Read(bytes.NewReader(data), binary.BigEndian, &amp;uint32Data)
        }</span> <span class="cov0" title="0">else {
                err = binary.Read(bytes.NewReader(data), binary.LittleEndian, &amp;uint32Data)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("collectTcpWiseInfo(): binary.Read: %s", err.Error())
        }</span>

        <span class="cov0" title="0">tcpWiseInfo.TransDataSize = uint32Data[0]
        tcpWiseInfo.TotalRetrans = uint32Data[1]
        tcpWiseInfo.TotalTrans = uint32Data[2]
        tcpWiseInfo.LastTimeOut = uint32Data[3]
        tcpWiseInfo.Mss = uint32Data[4]
        tcpWiseInfo.Latency = uint32Data[5]
        tcpWiseInfo.Rtt = uint32Data[6]
        tcpWiseInfo.Rttvar = uint32Data[7]
        tcpWiseInfo.ClientInitRwnd = uint32Data[8]
        tcpWiseInfo.ClientMaxRwnd = uint32Data[9]
        tcpWiseInfo.AvgCwnd = uint32Data[10]

        session.FlowInfo.AllTcpWiseInfo = append(session.FlowInfo.AllTcpWiseInfo, tcpWiseInfo)
        // session num monitor
        m.state.Inc("TCP_WISE_INFO_NUM", 1)
        return nil</span>
}

//write tcp wise info for every response
func (m *ModuleTcpWise) getTcpWiseInfoBeforeSendHandler(req *bfe_basic.Request, res *bfe_http.Response) int <span class="cov1" title="1">{
        // not collect tcp data, return
        function := m.tcpWiseRule.GetTcpDataFunction()
        if !function </span><span class="cov1" title="1">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("TcpDataFunction is false, do not collect Tcp Wise Info")
                }</span>
                <span class="cov1" title="1">return bfe_module.BFE_HANDLER_GOON</span>
        }
        // collect tcp data
        <span class="cov0" title="0">session := req.Session
        err := m.collectTcpWiseInfo(session)
        if err != nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s.getTcpWiseInfoBeforeSendHandler(): %s", m.name, err.Error())
                }</span>
        }
        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON</span>
}

//write tcp wise info for every response
func (m *ModuleTcpWise) getTcpWiseInfoBeforeCloseHandler(session *bfe_basic.Session) int <span class="cov0" title="0">{
        // not collect tcp data, return
        function := m.tcpWiseRule.GetTcpDataFunction()
        if !function </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("TcpDataFunction is false, do not collect Tcp Wise Info")
                }</span>
                <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON</span>
        }
        // collect tcp data
        <span class="cov0" title="0">err := m.collectTcpWiseInfo(session)
        if err != nil </span><span class="cov0" title="0">{
                if openDebug </span><span class="cov0" title="0">{
                        log.Logger.Debug("%s.getTcpWiseInfoBeforeCloseHandler(): %s", m.name, err.Error())
                }</span>
        }
        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON</span>
}

func (m *ModuleTcpWise) getState(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        state := m.state.GetAll()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(state)</span>
        <span class="cov0" title="0">case "noah":
                buff = state.NoahString()</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// all monitor handlers
func (m *ModuleTcpWise) monitorHandlers() map[string]interface{} <span class="cov1" title="1">{
        handlers := map[string]interface{}{
                m.name: m.getState,
        }
        return handlers
}</span>

func (m *ModuleTcpWise) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
        cr string) error <span class="cov1" title="1">{
        var conf *ConfModTcpWise
        var err error

        // load module config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
        }</span>
        <span class="cov1" title="1">m.rulePath = conf.Basic.RulePath
        m.cwndTablePath = conf.Basic.CwndTablePath
        m.kernelCwnd, err = bfe_util.GetKernelCwnd()
        // if err, kernelCwnd would be 0
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("%s: get kernel initial cwnd err: %s", m.name, err.Error())
        }</span> <span class="cov1" title="1">else {
                log.Logger.Info("%s: get kernel initial cwnd = %d", m.name, m.kernelCwnd)
        }</span>
        <span class="cov1" title="1">openDebug = conf.Log.OpenDebug

        // check kernel support TCP WISE 
        support, err := bfe_util.SupportTcpWise()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: SupportTcpWise err %s", m.name, err.Error())
        }</span>
        <span class="cov1" title="1">if !support </span><span class="cov1" title="1">{
                // kernel do not support TCP WISE
                log.Logger.Warn("%s: kernel do not support TCP WISE", m.name)
                m.state.Set("SUPPORT_TCP_WISE", "false")
                m.supportTcpWise = false
        }</span> <span class="cov0" title="0">else {
                // kernel support TCP WISE
                log.Logger.Info("%s: kernel support TCP WISE", m.name)
                m.state.Set("SUPPORT_TCP_WISE", "true")
                m.supportTcpWise = true
        }</span>

        // load tcp wise conf data
        <span class="cov1" title="1">if err = m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadConfData() err: %s", m.name, err.Error())
        }</span>

        // load cwnd table
        <span class="cov1" title="1">if err = m.loadCwndTable(nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: loadCwndTable() err %s", m.name, err.Error())
        }</span>
        
        //register handler
        <span class="cov1" title="1">err = cbs.AddFilter(bfe_module.HANDLE_ACCEPT, m.modifyCwndHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.modifyCwndHandler): %s", m.name, err.Error())
        }</span>

        <span class="cov1" title="1">err = cbs.AddFilter(bfe_module.HANDLE_READ_BACKEND, m.getTcpWiseInfoBeforeSendHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.getTcpWiseInfoBeforeSendHandler): %s", m.name, err.Error())
        }</span>

        <span class="cov1" title="1">err = cbs.AddFilter(bfe_module.HANDLE_FINISH, m.getTcpWiseInfoBeforeCloseHandler)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): AddFilter(m.getTcpWiseInfoBeforeCloseHandler): %s", m.name, err.Error())
        }</span>

        // register web handler for monitor
        <span class="cov1" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init():RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
        }</span>

        // register web handler for reload Cwnd table
        <span class="cov1" title="1">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">/* tcp_wise_rule.go - load rule for mod_tcp_wise  */
/*
modification history
--------------------
2015/10/1, by niexiaohui, create
*/
/*
DESCRIPTION
*/
package mod_tcp_wise

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"
)

import (
    "www.baidu.com/golang-lib/log"
)

const (
        MAX_TCP_WISE_INFO_NUM = 100
)

type TcpWiseRule struct {
        lock            sync.RWMutex
        tcpWiseRuleConf *TcpWiseRuleConf
}

type TcpWiseRuleConf struct {
        DefaultCwnd       int    // default initial cwnd
        MaxTcpWiseInfoNum int    // max tcp wise info stored in session.FlowInfo
    TcpDataFunction   bool   // collect data function, false means it does not collect tcp wise info into session
        TcpWiseFunction   bool   // tcp wise function, false means it does not modify the initial cwnd
        Version           string // config version
}

func NewTcpWiseRule() *TcpWiseRule <span class="cov10" title="21">{
        t := new(TcpWiseRule)
        t.tcpWiseRuleConf = new(TcpWiseRuleConf)
        return t
}</span>

// get default cwnd 
func (t *TcpWiseRule) GetDefaultCwnd() int <span class="cov5" title="4">{
    t.lock.Lock()
    defer t.lock.Unlock()
    return t.tcpWiseRuleConf.DefaultCwnd
}</span>

// get tcp wise function
func (t *TcpWiseRule) GetTcpWiseFunction() bool <span class="cov7" title="8">{
   t.lock.Lock()
   defer t.lock.Unlock()
   return t.tcpWiseRuleConf.TcpWiseFunction
}</span>

// set tcp wise function
func (t *TcpWiseRule) SetTcpWiseFunction(function bool) <span class="cov3" title="2">{
        t.lock.Lock()
    t.tcpWiseRuleConf.TcpWiseFunction = function
    t.lock.Unlock()
}</span>

// get tcp data function
func (t *TcpWiseRule) GetTcpDataFunction() bool <span class="cov6" title="6">{
   t.lock.Lock()
   defer t.lock.Unlock()
   return t.tcpWiseRuleConf.TcpDataFunction
}</span>

// set tcp data function
func (t *TcpWiseRule) SetTcpDataFunction(function bool) <span class="cov3" title="2">{
        t.lock.Lock()
    t.tcpWiseRuleConf.TcpDataFunction = function
    t.lock.Unlock()
}</span> 

// update
func (t *TcpWiseRule) Update(cfg TcpWiseRuleConf) <span class="cov5" title="5">{
        t.lock.Lock()
        t.tcpWiseRuleConf = &amp;cfg
        t.lock.Unlock()
    log.Logger.Info("TcpWiseRule.Update(): tcp wise conf updated")
}</span>

// check TcpWiseRuleConf
func tcpWiseRuleConfCheck(cfg TcpWiseRuleConf) error <span class="cov7" title="9">{
        //check DefaultCwnd
        if cfg.DefaultCwnd &lt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("ModTcpWise.TcpWiseRuleConf.DefaultCwnd is illegal should &gt; 1")
        }</span>

        //check MaxTcpWiseInfoNum
        <span class="cov7" title="8">if cfg.MaxTcpWiseInfoNum &lt; 1 || cfg.MaxTcpWiseInfoNum &gt; MAX_TCP_WISE_INFO_NUM </span><span class="cov3" title="2">{
                return fmt.Errorf("ModTcpWise.TcpWiseRuleConf.MaxTcpWiseInfoNum is illegal, legal range is [1, %d]", MAX_TCP_WISE_INFO_NUM)
        }</span>

        //check version
        <span class="cov6" title="6">if cfg.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ModTcpWise.TcpWiseRuleConf.Version is empty.")
        }</span>

        <span class="cov6" title="6">return nil</span>
}

/* load tcp wise rule config from file

   Returns:
        (TcpWiseRuleConf, error)
*/
func TcpWiseRuleConfLoad(filename string) (TcpWiseRuleConf, error) <span class="cov6" title="6">{
        var conf TcpWiseRuleConf
        var err error

        //open the file
        file, err := os.Open(filename)
        if err != nil </span><span class="cov1" title="1">{
                return conf, err
        }</span>
        <span class="cov5" title="5">defer file.Close()

        // decode the file
        decoder := json.NewDecoder(file)
        err = decoder.Decode(&amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        // check config
        <span class="cov5" title="5">err = tcpWiseRuleConfCheck(conf)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>
        <span class="cov5" title="5">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">/* conf_mod_trust_clientip.go - config for mod_trust_clientip   */
/*
modification history
--------------------
2014/7/8, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_trust_clientip

import (
        "code.google.com/p/gcfg"
        "www.baidu.com/golang-lib/conf_path"
        "www.baidu.com/golang-lib/log"
)

type ConfModTrustClientIP struct {
        Basic struct {
                DataPath string // path of config data (trust-ip)
        }

    Log struct {
        OpenDebug bool
    }
}

/* load config from config file    */
func ConfLoad(filePath string, confRoot string) (*ConfModTrustClientIP, error) <span class="cov10" title="2">{
        var cfg ConfModTrustClientIP
        var err error

        // read config from file
        err = gcfg.ReadFileInto(&amp;cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        // check conf of mod_trust_clientip
        <span class="cov10" title="2">err = cfg.Check(confRoot)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

        <span class="cov10" title="2">return &amp;cfg, nil</span>
}

func (cfg *ConfModTrustClientIP) Check(confRoot string) error <span class="cov10" title="2">{
        return ConfModTrustClientIPCheck(cfg, confRoot)
}</span>

func ConfModTrustClientIPCheck(cfg *ConfModTrustClientIP, confRoot string) error <span class="cov10" title="2">{
        if cfg.Basic.DataPath == "" </span><span class="cov1" title="1">{
                log.Logger.Warn("ModTrustClientIP.DataPath not set, use default value")
                cfg.Basic.DataPath = "mod_trust_clientip/trust_client_ip.data"
        }</span>

    <span class="cov10" title="2">cfg.Basic.DataPath = conf_path.ConfPathProc(cfg.Basic.DataPath, confRoot)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">/* mod_trust_clientip.go - module for marking trust-client-ip in session    */
/*
modification history
--------------------
2014/7/8, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_trust_clientip

import (
    "bytes"
    "fmt"
    "net/url"
)

import (
    "www.baidu.com/golang-lib/ipdict"
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/web_monitor"
)

import (
    "bfe_basic"
    "bfe_module"
)

var (
    openDebug = false
)

type ModuleTrustClientIP struct {
    name        string          // name of module
    configPath  string          // path of config file    
    trustTable  *ipdict.IPTable // table for storing trust-ip
}

func NewModuleTrustClientIP() *ModuleTrustClientIP <span class="cov1" title="1">{
    m := new(ModuleTrustClientIP)
    m.name = "mod_trust_clientip"
    return m
}</span>

func (m *ModuleTrustClientIP) Name() string <span class="cov0" title="0">{
    return m.name
}</span>

func (m *ModuleTrustClientIP) Attr() map[string]interface{} <span class="cov0" title="0">{
    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD: []string {m.name}, // reload items
    }
}</span>

// convert TrustIPConf to ipdict.IPItems
func ipItemsMake(conf TrustIPConf) (*ipdict.IPItems, error) <span class="cov1" title="1">{
    ipItems, err := ipdict.NewIPItems(conf.SingleIPNum, conf.PairIPNum)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">for src, addrScopeList := range conf.Config </span><span class="cov8" title="3">{
        for index, AddrScope := range *addrScopeList </span><span class="cov10" title="4">{
            // Insert start &amp; end ip into ipItems
            ret := bytes.Compare(AddrScope.Begin, AddrScope.End)    
            if ret == 0 </span><span class="cov0" title="0">{
                // startip == endip
                err = ipItems.InsertSingle(AddrScope.Begin) 
            }</span> <span class="cov10" title="4">else {
                // startip != endip
                err = ipItems.InsertPair(AddrScope.Begin, AddrScope.End)
            }</span>

            <span class="cov10" title="4">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ipItemsMake():[%s, %d], err:[%s]", src, index, err.Error())
            }</span>
        }
    }

    // Load succ, sort dict
    <span class="cov1" title="1">ipItems.Sort()
    ipItems.Version = conf.Version

    return ipItems, nil</span>
}

// load from config file to trust-table
// loadConfData is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleTrustClientIP) loadConfData(query url.Values) error <span class="cov1" title="1">{
    // get file path
    path := query.Get("path")
    if path == "" </span><span class="cov1" title="1">{
        // use default
        path = m.configPath
    }</span>

    // load from config file
    <span class="cov1" title="1">conf, err := TrustIPConfLoad(path)

    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in TrustIPConfLoad(%s):%s", path, err.Error())
    }</span>

    <span class="cov1" title="1">items, err2 := ipItemsMake(conf)
    if err2 != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in ipItemsMake():%s", err.Error())
    }</span>

    // update to trust-table
    <span class="cov1" title="1">m.trustTable.Update(items)

    return nil</span>
}

// handler for accept
func (m *ModuleTrustClientIP) acceptHandler(session *bfe_basic.Session) int <span class="cov8" title="3">{    
    trusted := m.trustTable.Search(session.RemoteAddr.IP)    
    session.IsTrustIP = trusted
    
    if openDebug </span><span class="cov0" title="0">{
        log.Logger.Debug("mod_trust_clientip:src ip = %s, trusted=%s", 
                         session.RemoteAddr.IP, session.IsTrustIP)
    }</span>
    
    <span class="cov8" title="3">return bfe_module.BFE_HANDLER_GOON</span>
}

func (m *ModuleTrustClientIP) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                                   cr string) error <span class="cov0" title="0">{
    var err error    
    var conf *ConfModTrustClientIP
    
    confPath := bfe_module.ModConfPath(cr, m.name)
    if conf, err = ConfLoad(confPath, cr); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s: conf load err %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return m.init(conf, cbs, whs)</span>
}

func (m *ModuleTrustClientIP) init(cfg *ConfModTrustClientIP, cbs *bfe_module.BfeCallbacks,
                                   whs *web_monitor.WebHandlers) error <span class="cov0" title="0">{   
    m.configPath = cfg.Basic.DataPath

    // set debug switch
    openDebug = cfg.Log.OpenDebug

    // initialize trust-table
    m.trustTable = ipdict.NewIPTable()
    
    // load from config file to trust-table
    if err := m.loadConfData(nil); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("err in loadConfData(): %s", err.Error())
    }</span>
    
    // register handler
    // for accept
    <span class="cov0" title="0">err := cbs.AddFilter(bfe_module.HANDLE_ACCEPT, m.acceptHandler)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): AddFilter(m.acceptHandler): %s", m.name, err.Error())
    }</span>

    // register web handler for reload
    <span class="cov0" title="0">err = whs.RegisterHandler(web_monitor.WEB_HANDLE_RELOAD, m.name, m.loadConfData)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandler(m.loadConfData): %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">/* trustip_conf_load.go - load trust-ip config from json file  */
/*
modification history
--------------------
2014/7/8, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package mod_trust_clientip

import (
    "encoding/json"
    "errors"
    "fmt"
    "net"
    "os"
)

import (
    "www.baidu.com/golang-lib/net_util"
)

// structure of trust-ip config
// {"Version":"1234", 
//  "Config":{"cdn":[{"begin":"119.75.215.0", "end":"119.75.215.255"},
//                   {"begin":"122.70.136.0", "end":"122.70.136.255"}], 
//            "tieba nj":[{"begin":"10.208.133.52", "end":"10.208.133.55"},
//                       ]
//           }
//
type AddrScopeFile struct {
    Begin   *string     // start, e.g,. 119.75.215.0
    End     *string     // end, e.g., 119.75.215.255
}

type AddrScope struct {
    Begin   net.IP  // start
    End     net.IP  // end
}

type AddrScopeFileList []AddrScopeFile
type AddrScopeList []AddrScope

type SrcScopeMapFile map[string]*AddrScopeFileList  // source =&gt; list of addr scope
type SrcScopeMap     map[string]*AddrScopeList      // source =&gt; list of addr scope

type TrustIPConfFile struct {
    Version     *string     // version of the config
    SingleIPNum int
    PairIPNum   int
    Config      *SrcScopeMapFile
}

type TrustIPConf struct {
    Version     string      // version of the config
    SingleIPNum int
    PairIPNum   int
    Config      SrcScopeMap
}

func AddrScopeListCheck(conf *AddrScopeFileList) error <span class="cov8" title="8">{
    for index, scope := range *conf </span><span class="cov10" title="11">{
        // the check for ip address format will be done in convert function
        if scope.Begin == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%d:no start", index)
        }</span>
        
        <span class="cov10" title="11">if scope.End == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%d:no end", index)
        }</span>        
    }
    <span class="cov8" title="8">return nil</span>
}

// check TrustIPConf
func TrustIPConfCheck(conf TrustIPConfFile) error <span class="cov5" title="3">{
    if conf.Version == nil </span><span class="cov0" title="0">{
        return errors.New("no Version")
    }</span>
    
    // check SingleIPNum/PairIPNum 
    <span class="cov5" title="3">if conf.SingleIPNum &lt; 0 || conf.PairIPNum &lt; 0 </span><span class="cov0" title="0">{
        return errors.New("SingleIPNum/PairIPNum &lt; 0")  
    }</span>
    
    <span class="cov5" title="3">if conf.Config == nil </span><span class="cov0" title="0">{
        return errors.New("no Config")
    }</span>

    // check config for each source
    <span class="cov5" title="3">for src, scopeList := range *conf.Config </span><span class="cov8" title="8">{
        if scopeList == nil </span><span class="cov0" title="0">{
            return fmt.Errorf("no conf for src:%s", src)
        }</span>
        
        <span class="cov8" title="8">err := AddrScopeListCheck(scopeList)
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("src %s:%s", src, err.Error())
        }</span>
    }
    
    <span class="cov5" title="3">return nil</span>    
}

/* load config of trust-ip from file  
   
   Returns:
        (TrustIPConf, error)
*/
func TrustIPConfLoad(filename string) (TrustIPConf, error) <span class="cov5" title="3">{  
    var conf TrustIPConf
      
    /* open the file    */
    file, err1 := os.Open(filename)
    
    if err1 != nil </span><span class="cov0" title="0">{
        return conf, err1
    }</span>
    
    /* decode the file  */
    <span class="cov5" title="3">decoder := json.NewDecoder(file)
    
    config := TrustIPConfFile{SingleIPNum:-1, PairIPNum:-1}
    err2 := decoder.Decode(&amp;config)    
    file.Close()
    
    if err2 != nil </span><span class="cov0" title="0">{
        return conf, err2
    }</span>

    // check config
    <span class="cov5" title="3">err3 := TrustIPConfCheck(config)
    if err3 != nil </span><span class="cov0" title="0">{
        return conf, err3
    }</span>

    /* convert config   */
    <span class="cov5" title="3">conf.Version = *config.Version
    conf.SingleIPNum = config.SingleIPNum
    conf.PairIPNum = config.PairIPNum
    conf.Config = make(SrcScopeMap)
    
    for src, scopeListFile := range *config.Config </span><span class="cov8" title="8">{
        scopeList := new(AddrScopeList)
        *scopeList = make([]AddrScope, 0)
        
        for index, scopeFile := range *scopeListFile </span><span class="cov10" title="11">{
            var startAddr, endAddr net.IP
            
            if startAddr = net_util.ParseIPv4(*scopeFile.Begin); startAddr == nil </span><span class="cov0" title="0">{
                return conf, fmt.Errorf("%d:illegal begin:%s", index, *scopeFile.Begin)
            }</span>

            <span class="cov10" title="11">if endAddr = net_util.ParseIPv4(*scopeFile.End); endAddr == nil </span><span class="cov1" title="1">{
                return conf, fmt.Errorf("%d:illegal end:%s", index, *scopeFile.End)
            }</span>
            
            <span class="cov9" title="10">scope := AddrScope{}
            scope.Begin = startAddr
            scope.End = endAddr

            *scopeList = append(*scopeList, scope)</span>
        }
        
        <span class="cov8" title="7">conf.Config[src] = scopeList</span>
    }

    <span class="cov3" title="2">return conf, nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">/* conf_mod_waf_client.go - basic config for mod_waf_client   */
/*
modification history
--------------------
2014/7/9, by Weiwei02, create
*/
/*
DESCRIPTION
*/
package mod_waf_client

import (
        "errors"
)

import (
        "code.google.com/p/gcfg"
        "www.baidu.com/golang-lib/conf_path"
        "www.baidu.com/golang-lib/log"
)

// default config value if key missing or value out of range
const (
        DEFAULT_CONCURRENCY = 8
        DEFAULT_TIMEOUT     = 1000
        DEFAULT_PENDINGNUM  = 5000 // 
)

type ConfModWafClient struct {
        WafRule struct {
        ConfPath string // configure file path
    }

    WafClient struct {
            // waf client related
            Network     string
            Addr        string
            ConnectTimeout     int  // connect timeout in millisecond
            Concurrency int
            PendingNum  int
    }

        // waf block log
    WafLog struct {
        Network string
        LogServerAddr string
    }

    Log struct {
        OpenDebug bool
    }
}

func ConfLoad(path string, confRoot string) (*ConfModWafClient, error) <span class="cov0" title="0">{
    var err error
        var cfg ConfModWafClient

    // read config from file
        if err = gcfg.ReadFileInto(&amp;cfg, path); err != nil </span><span class="cov0" title="0">{
                return &amp;cfg, err
        }</span>

    // check conf of mod_waf_client
    <span class="cov0" title="0">err = cfg.Check(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return &amp;cfg, err
    }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// check also fix some configure value
func (cfg *ConfModWafClient) Check(confRoot string) error <span class="cov0" title="0">{
    // check conf of WafRule
        if cfg.WafRule.ConfPath == "" </span><span class="cov0" title="0">{
                log.Logger.Error("ModWafClient.WafRuleConfPath not set")
                return errors.New("ModWafClient.WafRuleConfPath not set")
        }</span>
        
    <span class="cov0" title="0">cfg.WafRule.ConfPath = conf_path.ConfPathProc(cfg.WafRule.ConfPath, confRoot)        
        
    // check conf of WafClient
        if cfg.WafClient.Network == "" || cfg.WafClient.Addr == "" </span><span class="cov0" title="0">{
                log.Logger.Error("ModWafClient.Network ModWaf.Addr not set")
                return errors.New("ModWafClient.Network ModWaf.Addr not set")
        }</span>

        <span class="cov0" title="0">if cfg.WafClient.PendingNum &gt; 10000 || cfg.WafClient.PendingNum &lt;= 0 </span><span class="cov0" title="0">{
                log.Logger.Error("ModWafClient.PendingNum not in (0, 10000]")
                return errors.New("pendingNum is not in (0, 10000)")
        }</span>

        <span class="cov0" title="0">if cfg.WafClient.Concurrency &lt;= 0 </span><span class="cov0" title="0">{
                log.Logger.Warn("ModWafClient.Concurrency &lt;=0, use default value %d", DEFAULT_CONCURRENCY)
                cfg.WafClient.Concurrency = DEFAULT_CONCURRENCY
        }</span>

        <span class="cov0" title="0">if cfg.WafClient.ConnectTimeout &lt;= 0 </span><span class="cov0" title="0">{
                log.Logger.Warn("ModWafClient.ConnectTimeout &lt;=0, use default value %d", DEFAULT_TIMEOUT)
                cfg.WafClient.ConnectTimeout = DEFAULT_TIMEOUT
        }</span>

    <span class="cov0" title="0">if cfg.WafLog.Network != "unixgram" &amp;&amp; cfg.WafLog.Network != "upd" </span><span class="cov0" title="0">{
        return errors.New("cfg.WafLog.Network config error")
    }</span>

    <span class="cov0" title="0">if cfg.WafLog.LogServerAddr == "" </span><span class="cov0" title="0">{
        return errors.New("cfg.WafLog.LogServerAddr not set")
    }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">/* mod_waf_client.go - module for waf check  */
/*
modification history
--------------------
2014/7/3, by Weiwei, create
2014/11/4, by Li Bingyi, add delay counter
*/
/*
DESCRIPTION
*/

package mod_waf_client

import (
        "encoding/binary"
        "encoding/json"
        "fmt"
        "time"
    "net/url"
)

import (
        "code.google.com/p/log4go"
        "www.baidu.com/golang-lib/access_log"
        "www.baidu.com/golang-lib/delay_counter"
        "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
        "www.baidu.com/golang-lib/remote"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
    bfe_access_pb "bfe_modules/mod_access_pb/bfe_access_pb"
        "bfe_basic"
        "bfe_http"
        "bfe_module"
        "bfe_modules/mod_waf_client/waf_pb"

)

const (
        // currently must be &lt;= 4096, since httpRequest's body's buffer size is default set to 4096
        // if waf need more than 4096bytes body, httpRequst's Body's buffer size should also adjust
        MAX_BODY_SIZE = 4096
)

const (
    DELAY_STAT_INTERVAL = 20    // delay stat interval
    DELAY_BUCKET_SIZE   = 1     // delay bucket size
    DELAY_BUCKET_NUM    = 20   // delay bucket num
)

const (
    DIFF_COUNTER_INTERVAL = 20
)

const (
    REQ_CHECK_ONLY   = "CheckOnly"
    REQ_NO_CHECK     = "NoCheck"
    REQ_FORBIDDEN    = "WaitResponse.Forbidden"
    REQ_OK           = "WaitResponse.Pass.Ok"
    REQ_TIMEOUT      = "WaitResponse.Pass.Timeout"
    REQ_OTHER        = "WaitResponse.Pass.Other"
    Services         = "Services"
)

var (
    openDebug = false
)

var COUNTER_KEYS = []string {
    REQ_CHECK_ONLY,
    REQ_NO_CHECK,
    REQ_FORBIDDEN,
    REQ_OK,
    REQ_TIMEOUT,
    REQ_OTHER,
}

type ModuleWafClient struct {
    name         string                     // name of module
        conf         *ConfModWafClient
        path         string                     // waf rule data path
        wafClient    remote.IClient             // communicate with waf-server
        wafRuleTable *WafRuleTable              // data table for waf acl
    status       wafStatus                  // enable waf or not
        logger       log4go.Logger              // logger to log block request

    delay           delay_counter.DelayRecent  // delay counter for request of wait response type
    delayPeekBody   delay_counter.DelayRecent  // delay counter for peek at most 4k body
    state        *module_state2.State       // module state
    stateDiff    module_state2.CounterSlice // diff counter of moudle state
}

func NewModuleWafClient() *ModuleWafClient <span class="cov10" title="5">{
        m := new(ModuleWafClient)
        m.name = "mod_waf_client"
        m.wafRuleTable = NewWafRuleTable()

    m.delay.Init(DELAY_STAT_INTERVAL, DELAY_BUCKET_SIZE, DELAY_BUCKET_NUM)
    m.delayPeekBody.Init(DELAY_STAT_INTERVAL, DELAY_BUCKET_SIZE, DELAY_BUCKET_NUM)
    
    m.state = new(module_state2.State)
    m.state.Init()
    m.state.CountersInit(COUNTER_KEYS)
    m.stateDiff.Init(m.state, DIFF_COUNTER_INTERVAL)

    m.delayPeekBody.Init(DELAY_STAT_INTERVAL, DELAY_BUCKET_SIZE, DELAY_BUCKET_NUM)

    m.delay.SetNoahKeyPrefix(bfe_basic.NOAH_MOD_WAF_DELAY)
    m.delayPeekBody.SetNoahKeyPrefix(bfe_basic.NOAH_MOD_WAF_PEEK_DELAY)
    m.state.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_WAF)
    m.stateDiff.SetNoahKeyPrefix(bfe_basic.NOAH_SD_MOD_WAF_DIFF)

        return m
}</span>

func (m *ModuleWafClient) Name() string <span class="cov1" title="1">{
        return m.name
}</span>

func (m *ModuleWafClient) getState() ([]byte, error) <span class="cov1" title="1">{
    // set pending call counter
    if m.wafClient != nil </span><span class="cov1" title="1">{
        c, ok := m.wafClient.(*remote.Client)
        if ok </span><span class="cov0" title="0">{
            pendingCallNum := c.PendingCallNum()
            for i := 0; i &lt; len(pendingCallNum); i++ </span><span class="cov0" title="0">{
                m.state.SetNum("PendingCalls.Call" + fmt.Sprintf("%d", i), int64(pendingCallNum[i]))
            }</span>
        }
    }

    <span class="cov1" title="1">if m.status.isEnable() </span><span class="cov1" title="1">{
        m.state.SetNum("Enable", int64(1))
    }</span> <span class="cov0" title="0">else {
        m.state.SetNum("Enable", int64(0))
    }</span>

    <span class="cov1" title="1">state := m.state.GetAll()
    return json.Marshal(state)</span>
}

func (m *ModuleWafClient) getStateDiff() ([]byte, error) <span class="cov1" title="1">{
    stateDiff := m.stateDiff.Get()
    return json.Marshal(stateDiff)
}</span>

func (m *ModuleWafClient) Attr() map[string]interface{} <span class="cov1" title="1">{
    // reload items
    reloadEntries := []string {
        m.name,
        m.name + ".status",
    }

    // monitor items (item name, item type)
    monitorEntries := map[string]string {
        m.name : bfe_basic.MON_TYPE_STATE,
        m.name + ".delay": bfe_basic.MON_TYPE_DELAY_RECENT,
        m.name + ".delay_peek_body": bfe_basic.MON_TYPE_DELAY_RECENT,
        m.name + ".diff" : bfe_basic.MON_TYPE_COUNTER_SLICE,
    }

    return map[string]interface{} {
        bfe_basic.MON_ATTR_RELOAD : reloadEntries,
        bfe_basic.MON_ATTR_MONITOR: monitorEntries,
    }
}</span>

// register web monitor handlers
func (m *ModuleWafClient) monitorHandlers() map[string]interface{} <span class="cov1" title="1">{
    handlers := map[string]interface{} {
        m.name               : m.getState,
        m.name + ".diff"     : m.getStateDiff,
        m.name + ".delay"    : m.delay.GetJson,
        m.name + ".delay_peek_body"   : m.delayPeekBody.GetJson,
    }

    return handlers
}</span>

// register web reload handlers
func (m *ModuleWafClient) reloadHandlers() map[string]interface{} <span class="cov1" title="1">{
    handlers := map[string]interface{} {
        m.name               : m.loadRules,
        m.name + ".status"   : m.updateStatus,
    }

    return handlers
}</span>

// updateStatus is a registered reload callback
// params:
//   - query: url query, query["enable"] is status to update
func (m *ModuleWafClient) updateStatus(query url.Values) error <span class="cov4" title="2">{
    // get status to update
    status := query.Get("enable")
    if status == "yes" </span><span class="cov1" title="1">{
        m.status.update(true)
    }</span> <span class="cov1" title="1">else if status == "no"</span><span class="cov1" title="1">{
        m.status.update(false)
    }</span> <span class="cov0" title="0">else {
        return fmt.Errorf("updateStatus(): get param 'enable' failed")
    }</span>

    <span class="cov4" title="2">return nil</span>
}

func (m *ModuleWafClient) Init(cbs *bfe_module.BfeCallbacks, whs *web_monitor.WebHandlers,
                               cr string) error <span class="cov0" title="0">{
        var err error

        // parse config
        confPath := bfe_module.ModConfPath(cr, m.name)
        if err = m.LoadConfig(confPath, cr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): ParseConfig %s", m.name, err.Error())
        }</span>

    // set debug switch
    <span class="cov0" title="0">openDebug = m.conf.Log.OpenDebug
    // enable waf default
    m.status.update(true)

        // create waf client
        wafClientConf := m.conf.WafClient
        m.wafClient = remote.NewClient(wafClientConf.Network, wafClientConf.Addr,
                time.Duration(wafClientConf.ConnectTimeout) * time.Millisecond,
                wafClientConf.Concurrency, nil, wafClientConf.PendingNum)

        // create logger
        wafLogConf := m.conf.WafLog
    m.logger, err = access_log.LoggerInitWithSvr("go-bfe", "waf_client",
        wafLogConf.Network, wafLogConf.LogServerAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.Init(): init logger err %s", m.name, err.Error())
        }</span>

        // register handler
        <span class="cov0" title="0">err = cbs.AddFilter(bfe_module.HANDLE_AFTER_LOCATION, m.wafHandler) // for after location
        if err != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%s.Init(): AddFilter(m.wafHandler): %s", m.name, err.Error())
        }</span>

    // register web handlers for reload
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_RELOAD, m.reloadHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandlers(m.reloadHandlers): %s", m.name, err.Error())
    }</span>

    // register web handlers for monitor
    <span class="cov0" title="0">err = web_monitor.RegisterHandlers(whs, web_monitor.WEB_HANDLE_MONITOR, m.monitorHandlers())
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s.Init(): RegisterHandlers(m.monitorHandlers): %s", m.name, err.Error())
    }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *ModuleWafClient) getRequestWafAction(req *bfe_basic.Request) *Action <span class="cov10" title="5">{
        return m.wafRuleTable.GetRequestWafAction(req)
}</span>

// generate header for remote call
func genRequestHeader(conf *Action, request *bfe_http.Request) []*waf_pb.WafRequest_Request_Header <span class="cov1" title="1">{
        var headers []*waf_pb.WafRequest_Request_Header

        for k, vs := range request.Header </span><span class="cov0" title="0">{
                if k == "COOKIE" &amp;&amp; !conf.IsNeedCookie </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">copyK := k
                for _, v := range vs </span><span class="cov0" title="0">{
                        copyV := v
                        headers = append(headers, &amp;waf_pb.WafRequest_Request_Header{Key: &amp;copyK, Value: &amp;copyV})
                }</span>
        }

    <span class="cov1" title="1">hostKey := "Host"
    hostValue := request.Host
    // add host key:value
    headers = append(headers, &amp;waf_pb.WafRequest_Request_Header{Key: &amp;hostKey, Value: &amp;hostValue})

        return headers</span>
}

type Peeker interface {
        Peek(n int) ([]byte, error)
}

// generate request for remote call
func (m *ModuleWafClient) genRemoteRequest(conf *Action, req *bfe_basic.Request) *waf_pb.WafRequest <span class="cov1" title="1">{
        httpRequest := req.HttpRequest
        wafRequest := new(waf_pb.WafRequest)

        wafRequest.Service = &amp;req.Route.Product
        wafRequest.Signature = &amp;conf.RuleSign
        clientIp := binary.LittleEndian.Uint32(req.RemoteAddr.IP.To4())
        wafRequest.Clientip = &amp;clientIp

        wafReqRequest := new(waf_pb.WafRequest_Request)
        wafReqRequest.Uri = &amp;httpRequest.RequestURI

    if httpRequest.ProtoMajor == 1 &amp;&amp; httpRequest.ProtoMinor == 0 </span><span class="cov0" title="0">{
        wafReqRequest.Version = waf_pb.WafRequest_Request_HTTP_1_0.Enum()
    }</span> <span class="cov1" title="1">else {
        wafReqRequest.Version = waf_pb.WafRequest_Request_HTTP_1_1.Enum()
    }</span>


        <span class="cov1" title="1">wafReqRequest.Method = waf_pb.WafRequest_Request_GET.Enum()
        if req.HttpRequest.Method == "POST" </span><span class="cov0" title="0">{
                wafReqRequest.Method = waf_pb.WafRequest_Request_POST.Enum()
        }</span>

        <span class="cov1" title="1">wafReqRequest.Headers = genRequestHeader(conf, httpRequest)

        // set body
        if conf.IsNeedBody &amp;&amp; httpRequest.Method == "POST" &amp;&amp; httpRequest.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                // set when request is not chunk (ContentLength &gt; 0) and method is Post
                peekN := httpRequest.ContentLength
                if peekN &gt; MAX_BODY_SIZE </span><span class="cov0" title="0">{
                        peekN = MAX_BODY_SIZE
                }</span>

                <span class="cov0" title="0">if p, ok := httpRequest.Body.(Peeker); ok </span><span class="cov0" title="0">{
            t := time.Now()
                        b, err := p.Peek(int(peekN))
            if err == nil </span><span class="cov0" title="0">{
                                wafReqRequest.Body = b
                        }</span> <span class="cov0" title="0">else {
                log.Logger.Info("mod waf:peek body err %s", err)
            }</span>

            <span class="cov0" title="0">m.delayPeekBody.AddBySub(t, time.Now())</span>
                }
        }
        <span class="cov1" title="1">wafRequest.Req = wafReqRequest

        return wafRequest</span>
}

// increase related err counter when remote call returns err
func (m *ModuleWafClient) updateErrInfo(req *bfe_basic.Request, service string, err error) <span class="cov4" title="2">{
    switch err.Error() </span>{
    <span class="cov1" title="1">case remote.ErrTimeout.Error():
        m.state.Inc(Services + "." + service + "." + REQ_TIMEOUT, 1)
        m.state.Inc(REQ_TIMEOUT, 1)
        setWafStatus(req, (int)(bfe_access_pb.WafStatus_Timeout))</span>
    <span class="cov1" title="1">default:
        m.state.Inc(Services + "." + service + "." + REQ_OTHER, 1)
        m.state.Inc(REQ_OTHER, 1)
        setWafStatus(req, (int)(bfe_access_pb.WafStatus_Error))
        log.Logger.Warn("waf service call err [%s]", err)</span>
    }
}

// set waf spent time
func setWafSpentTime(req *bfe_basic.Request, start time.Time, end time.Time) <span class="cov1" title="1">{
    req.Stat.WafSpentTime = end.Sub(start).Nanoseconds() / 1000000
}</span>

// set waf status
func setWafStatus(req *bfe_basic.Request, status int) <span class="cov10" title="5">{
    req.Stat.WafStatus = status
}</span>

// module call backs
// handler for finish http request
func (m *ModuleWafClient) wafHandler(req *bfe_basic.Request) (int, *bfe_http.Response) <span class="cov7" title="3">{
    conf := m.getRequestWafAction(req)
        // no waf check
        if conf == nil </span><span class="cov4" title="2">{
        if openDebug </span><span class="cov0" title="0">{
                    log.Logger.Debug("no waf check rule found")
        }</span>
        <span class="cov4" title="2">setWafStatus(req, (int)(bfe_access_pb.WafStatus_NoCheck))
                return bfe_module.BFE_HANDLER_GOON, nil</span>
        }

    // waf check disable, set related status and return
    <span class="cov1" title="1">if !m.status.isEnable() </span><span class="cov0" title="0">{
        switch conf.Stratege </span>{
        <span class="cov0" title="0">case CHECK_ONLY, WAIT_RESPONSE:
            setWafStatus(req, (int)(bfe_access_pb.WafStatus_Downgrade))</span>
        <span class="cov0" title="0">default:
            setWafStatus(req, (int)(bfe_access_pb.WafStatus_NoCheck))</span>
        }

        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON, nil</span>
    }

    // get service name
    <span class="cov1" title="1">service := req.Route.Product
        // generate waf pb data
        remoteReq := m.genRemoteRequest(conf, req)

        // communicate with waf server
        switch conf.Stratege </span>{
        <span class="cov0" title="0">case CHECK_ONLY:
        m.state.Inc(REQ_CHECK_ONLY, 1)
        m.state.Inc(Services + "." + service + "." + REQ_CHECK_ONLY, 1)
        if openDebug </span><span class="cov0" title="0">{
                    log.Logger.Debug("waf check only")
        }</span>

        <span class="cov0" title="0">setWafStatus(req, (int)(bfe_access_pb.WafStatus_CheckOnly))
                m.wafClient.GoNoReturn(remoteReq)</span>
        <span class="cov1" title="1">case WAIT_RESPONSE:
        var startTime, endTime time.Time
        startTime = time.Now()

        if openDebug </span><span class="cov0" title="0">{
                    log.Logger.Debug("waf block mode")
        }</span>

                <span class="cov1" title="1">response := new(waf_pb.WafResponse)
                err := m.wafClient.Call(remoteReq, response, conf.ReadWriteTimeout)
                if err != nil </span><span class="cov0" title="0">{
            // delay count for err waf request
            endTime = time.Now()
            m.updateErrInfo(req, service, err)
            m.delay.AddBySub(startTime, time.Now())
            setWafSpentTime(req, startTime, endTime)
                        break</span>
                }

                <span class="cov1" title="1">if *response.Code == waf_pb.WafResponse_FORBIDDEN </span><span class="cov1" title="1">{
            // delay count for forbidden request
            endTime = time.Now()
            m.delay.AddBySub(startTime, time.Now())
            m.state.Inc(REQ_FORBIDDEN, 1)
            m.state.Inc(Services + "." + service + "." + REQ_FORBIDDEN, 1)
                        m.logger.Info("waf forbidden [%s]", req.HttpRequest.URL)
            setWafSpentTime(req, startTime, endTime)
            setWafStatus(req, (int)(bfe_access_pb.WafStatus_Forbidden))
                        return bfe_module.BFE_HANDLER_FINISH, nil
                }</span>

        // delay count for request that passed waf check
        <span class="cov0" title="0">endTime = time.Now()
        m.delay.AddBySub(startTime, endTime)
        m.state.Inc(REQ_OK, 1)
        m.state.Inc(Services + "." + service + "." + REQ_OK, 1)
        setWafSpentTime(req, startTime, endTime)
        setWafStatus(req, (int)(bfe_access_pb.WafStatus_Pass))</span>
    <span class="cov0" title="0">default:
        m.state.Inc(REQ_NO_CHECK, 1)
        m.state.Inc(Services + "." + service + "." + REQ_NO_CHECK, 1)
        setWafStatus(req, (int)(bfe_access_pb.WafStatus_NoCheck))</span>
        }

        <span class="cov0" title="0">return bfe_module.BFE_HANDLER_GOON, nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">/* waf_client_config_load.go - load configure, including basic conf, waf rule data   */
/*
modification history
--------------------
2014/7/9, by Weiwei02, create
*/
/*
DESCRIPTION
*/
package mod_waf_client

import (
    "fmt"
    "net/url"
    "time"
)

import (
    "www.baidu.com/golang-lib/log"
)

import (
    "bfe_basic/condition"
    "bfe_util"
)

// for load json conf
type ActionFile struct {
    Stratege     *int // check or block
    RuleSign     *string
    IsNeedCookie *bool
    IsNeedBody   *bool
    // max time to wait for server response, used when stratage is WAIT_RESPONSE
    ReadWriteTimeout *int
}

// for load json waf rule file
type WafRuleFile struct {
    Cond   *string     // condition for waf rule
    Action *ActionFile // action
}

type WafRulesFile []*WafRuleFile
type ProductWafRules map[string]WafRules // service -&gt; WafRules

type WafConfFile struct {
    Version *string // version of the config
    Config  *ProductWafRulesFile
}

func (w *WafConfFile) Check() error <span class="cov8" title="3">{
    if err := bfe_util.CheckNilField(*w, false); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // check ProductWafFile
    <span class="cov8" title="3">for name, wafRules := range *w.Config </span><span class="cov10" title="4">{
        for i, rule := range wafRules </span><span class="cov10" title="4">{
            if err := rule.Check(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("waf config check, [%s] [%d] [%s]", name, i, err.Error())
            }</span>
        }
    }

    <span class="cov8" title="3">return nil</span>
}

func (w *WafRuleFile) Check() error <span class="cov10" title="4">{
    if err := bfe_util.CheckNilField(*w, false); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov10" title="4">if err := w.Action.Check(); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov10" title="4">return nil</span>
}

func (af *ActionFile) Check() error <span class="cov10" title="4">{
    if err := bfe_util.CheckNilField(*af, false); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov10" title="4">if *af.Stratege &lt; 0 || *af.Stratege &gt; 2 </span><span class="cov0" title="0">{
        return fmt.Errorf("Action conf stratage %d not [0, 2]", af.Stratege)
    }</span>

    <span class="cov10" title="4">return nil</span>
}

func ruleConvert(ruleFile *WafRuleFile) (*WafRule, error) <span class="cov10" title="4">{
    rule := &amp;WafRule{}

    if ruleFile.Cond == nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("cond not set")
    }</span>

    <span class="cov10" title="4">cond, err := condition.Build(*ruleFile.Cond)
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Warn("build waf rule condition failed %s", err)
        return nil, err
    }</span>
    <span class="cov10" title="4">rule.Cond = cond

    rule.Action = actionConvert(ruleFile.Action)
    return rule, nil</span>
}

func wafRulesConvert(productRules *ProductWafRulesFile) (ProductWafRules, error) <span class="cov8" title="3">{
    productWafRules := make(ProductWafRules)

    for name, rules := range *productRules </span><span class="cov10" title="4">{
        var newWafRules []*WafRule

        for _, rule := range rules </span><span class="cov10" title="4">{
            wafRule, err := ruleConvert(rule)
            if err != nil </span><span class="cov0" title="0">{
                return nil, err
            }</span>
            <span class="cov10" title="4">newWafRules = append(newWafRules, wafRule)</span>
        }

        <span class="cov10" title="4">productWafRules[name] = newWafRules</span>
    }

    <span class="cov8" title="3">return productWafRules, nil</span>
}

func actionConvert(af *ActionFile) *Action <span class="cov10" title="4">{
    return &amp;Action{
        Stratege:         *af.Stratege,
        RuleSign:         *af.RuleSign,
        IsNeedCookie:     *af.IsNeedCookie,
        IsNeedBody:       *af.IsNeedBody,
        ReadWriteTimeout: time.Duration(*af.ReadWriteTimeout) * time.Millisecond,
    }
}</span>

// load configure from conf file
func (m *ModuleWafClient) LoadConfig(confPath string, confRoot string) error <span class="cov0" title="0">{
    conf, err := ConfLoad(confPath, confRoot)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("%s conf load error %s", m.name, err.Error())
    }</span>

    <span class="cov0" title="0">m.conf = conf
    m.path = conf.WafRule.ConfPath

    if err := m.loadRules(nil); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov0" title="0">return nil</span>
}

// loadRules is a registered reload callback
// params:
//   - query: url query, query["path"] is the file need to load
//          if query["path"] is not set, use default path
func (m *ModuleWafClient) loadRules(query url.Values) error <span class="cov8" title="3">{
    // get file path
    path := query.Get("path")
    if path == "" </span><span class="cov8" title="3">{
        //use default
        path = m.path
    }</span>

    <span class="cov8" title="3">err := m.wafRuleTable.loadRules(path)
    if err == nil </span><span class="cov8" title="3">{
        m.state.Set("Version", m.wafRuleTable.version)
    }</span>

    <span class="cov8" title="3">return err</span>
}

type WafRuleConf struct {
    wafConfFile WafConfFile
}

// reload_trigger adaptor interface
func (conf *WafRuleConf) LoadAndCheck(path string) (string, error) <span class="cov8" title="3">{
    // load conf from file
    if err := bfe_util.LoadJsonFile(path, &amp;conf.wafConfFile); err != nil </span><span class="cov0" title="0">{
        return "", fmt.Errorf("load json file %s fail %s", path, err.Error())
    }</span>

    // check conf file
    <span class="cov8" title="3">if err := conf.wafConfFile.Check(); err != nil </span><span class="cov0" title="0">{
        return "", err
    }</span>

    <span class="cov8" title="3">return *conf.wafConfFile.Version, nil</span>
}

func (w *WafRuleTable) loadRules(path string) error <span class="cov8" title="3">{
    _, err := w.wafRuleConf.LoadAndCheck(path)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // convert to WafRule struct
    <span class="cov8" title="3">productWafRules, err := wafRulesConvert(w.wafRuleConf.wafConfFile.Config)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov8" title="3">w.Update(*w.wafRuleConf.wafConfFile.Version, productWafRules)

    return nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">/* waf_client_status.go - support waf status operation  */
/*
modification history
--------------------
2014/12/23, by Li Bingyi, create
*/
/*
DESCRIPTION
*/
package mod_waf_client

import (
    "sync"
)

type wafStatus struct {
    lock    sync.Mutex
    enable  bool
}

// check waf is enable or disable
func (ws *wafStatus) isEnable() bool <span class="cov10" title="3">{
    ws.lock.Lock()
    status := ws.enable
    ws.lock.Unlock()

    return status
}</span>

// update status
func (ws *wafStatus) update(status bool) <span class="cov10" title="3">{
    ws.lock.Lock()
    ws.enable = status
    ws.lock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">// Code generated by protoc-gen-gogo.
// source: bfe_waf_gogo.proto
// DO NOT EDIT!

/*
        Package waf_pb is a generated protocol buffer package.

        It is generated from these files:
                bfe_waf_gogo.proto

        It has these top-level messages:
                WafRequest
                WafResponse
*/
package waf_pb

import proto "code.google.com/p/gogoprotobuf/proto"
import math "math"

// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"

import io "io"
import fmt "fmt"
import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"

import fmt1 "fmt"
import strings "strings"
import reflect "reflect"

import fmt2 "fmt"
import strings1 "strings"
import code_google_com_p_gogoprotobuf_proto1 "code.google.com/p/gogoprotobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect1 "reflect"

import fmt3 "fmt"
import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type WafRequest_Request_Method int32

const (
        WafRequest_Request_GET    WafRequest_Request_Method = 0
        WafRequest_Request_POST   WafRequest_Request_Method = 1
        WafRequest_Request_PUT    WafRequest_Request_Method = 2
        WafRequest_Request_DELETE WafRequest_Request_Method = 3
)

var WafRequest_Request_Method_name = map[int32]string{
        0: "GET",
        1: "POST",
        2: "PUT",
        3: "DELETE",
}
var WafRequest_Request_Method_value = map[string]int32{
        "GET":    0,
        "POST":   1,
        "PUT":    2,
        "DELETE": 3,
}

func (x WafRequest_Request_Method) Enum() *WafRequest_Request_Method <span class="cov0" title="0">{
        p := new(WafRequest_Request_Method)
        *p = x
        return p
}</span>
func (x WafRequest_Request_Method) String() string <span class="cov2" title="4">{
        return proto.EnumName(WafRequest_Request_Method_name, int32(x))
}</span>
func (x *WafRequest_Request_Method) UnmarshalJSON(data []byte) error <span class="cov1" title="2">{
        value, err := proto.UnmarshalJSONEnum(WafRequest_Request_Method_value, data, "WafRequest_Request_Method")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="2">*x = WafRequest_Request_Method(value)
        return nil</span>
}

type WafRequest_Request_Version int32

const (
        WafRequest_Request_HTTP_1_0 WafRequest_Request_Version = 0
        WafRequest_Request_HTTP_1_1 WafRequest_Request_Version = 1
)

var WafRequest_Request_Version_name = map[int32]string{
        0: "HTTP_1_0",
        1: "HTTP_1_1",
}
var WafRequest_Request_Version_value = map[string]int32{
        "HTTP_1_0": 0,
        "HTTP_1_1": 1,
}

func (x WafRequest_Request_Version) Enum() *WafRequest_Request_Version <span class="cov0" title="0">{
        p := new(WafRequest_Request_Version)
        *p = x
        return p
}</span>
func (x WafRequest_Request_Version) String() string <span class="cov2" title="4">{
        return proto.EnumName(WafRequest_Request_Version_name, int32(x))
}</span>
func (x *WafRequest_Request_Version) UnmarshalJSON(data []byte) error <span class="cov1" title="2">{
        value, err := proto.UnmarshalJSONEnum(WafRequest_Request_Version_value, data, "WafRequest_Request_Version")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="2">*x = WafRequest_Request_Version(value)
        return nil</span>
}

type WafResponse_ResponseCode int32

const (
        WafResponse_OK        WafResponse_ResponseCode = 0
        WafResponse_FORBIDDEN WafResponse_ResponseCode = 1
)

var WafResponse_ResponseCode_name = map[int32]string{
        0: "OK",
        1: "FORBIDDEN",
}
var WafResponse_ResponseCode_value = map[string]int32{
        "OK":        0,
        "FORBIDDEN": 1,
}

func (x WafResponse_ResponseCode) Enum() *WafResponse_ResponseCode <span class="cov0" title="0">{
        p := new(WafResponse_ResponseCode)
        *p = x
        return p
}</span>
func (x WafResponse_ResponseCode) String() string <span class="cov1" title="2">{
        return proto.EnumName(WafResponse_ResponseCode_name, int32(x))
}</span>
func (x *WafResponse_ResponseCode) UnmarshalJSON(data []byte) error <span class="cov1" title="1">{
        value, err := proto.UnmarshalJSONEnum(WafResponse_ResponseCode_value, data, "WafResponse_ResponseCode")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">*x = WafResponse_ResponseCode(value)
        return nil</span>
}

type WafRequest struct {
        Service          *string             `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
        Signature        *string             `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
        Req              *WafRequest_Request `protobuf:"bytes,3,req,name=req" json:"req,omitempty"`
        Clientip         *uint32             `protobuf:"varint,4,req,name=clientip" json:"clientip,omitempty"`
        Logid            *uint64             `protobuf:"varint,5,opt,name=logid" json:"logid,omitempty"`
        XXX_unrecognized []byte              `json:"-"`
}

func (m *WafRequest) Reset()      <span class="cov2" title="5">{ *m = WafRequest{} }</span>
func (*WafRequest) ProtoMessage() <span class="cov0" title="0">{}</span>

func (m *WafRequest) GetService() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Service != nil </span><span class="cov0" title="0">{
                return *m.Service
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WafRequest) GetSignature() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Signature != nil </span><span class="cov0" title="0">{
                return *m.Signature
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WafRequest) GetReq() *WafRequest_Request <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Req
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *WafRequest) GetClientip() uint32 <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Clientip != nil </span><span class="cov0" title="0">{
                return *m.Clientip
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *WafRequest) GetLogid() uint64 <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Logid != nil </span><span class="cov0" title="0">{
                return *m.Logid
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type WafRequest_Request struct {
        Method           *WafRequest_Request_Method   `protobuf:"varint,1,req,name=method,enum=waf_pb.WafRequest_Request_Method,def=0" json:"method,omitempty"`
        Version          *WafRequest_Request_Version  `protobuf:"varint,2,req,name=version,enum=waf_pb.WafRequest_Request_Version,def=1" json:"version,omitempty"`
        Uri              *string                      `protobuf:"bytes,3,req,name=uri" json:"uri,omitempty"`
        Headers          []*WafRequest_Request_Header `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty"`
        Body             []byte                       `protobuf:"bytes,5,opt,name=body" json:"body,omitempty"`
        XXX_unrecognized []byte                       `json:"-"`
}

func (m *WafRequest_Request) Reset()      <span class="cov2" title="5">{ *m = WafRequest_Request{} }</span>
func (*WafRequest_Request) ProtoMessage() <span class="cov0" title="0">{}</span>

const Default_WafRequest_Request_Method WafRequest_Request_Method = WafRequest_Request_GET
const Default_WafRequest_Request_Version WafRequest_Request_Version = WafRequest_Request_HTTP_1_1

func (m *WafRequest_Request) GetMethod() WafRequest_Request_Method <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Method != nil </span><span class="cov0" title="0">{
                return *m.Method
        }</span>
        <span class="cov0" title="0">return Default_WafRequest_Request_Method</span>
}

func (m *WafRequest_Request) GetVersion() WafRequest_Request_Version <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Version != nil </span><span class="cov0" title="0">{
                return *m.Version
        }</span>
        <span class="cov0" title="0">return Default_WafRequest_Request_Version</span>
}

func (m *WafRequest_Request) GetUri() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Uri != nil </span><span class="cov0" title="0">{
                return *m.Uri
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WafRequest_Request) GetHeaders() []*WafRequest_Request_Header <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *WafRequest_Request) GetBody() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Body
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type WafRequest_Request_Header struct {
        Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
        Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
        XXX_unrecognized []byte  `json:"-"`
}

func (m *WafRequest_Request_Header) Reset()      <span class="cov2" title="5">{ *m = WafRequest_Request_Header{} }</span>
func (*WafRequest_Request_Header) ProtoMessage() <span class="cov0" title="0">{}</span>

func (m *WafRequest_Request_Header) GetKey() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Key != nil </span><span class="cov0" title="0">{
                return *m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WafRequest_Request_Header) GetValue() string <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Value != nil </span><span class="cov0" title="0">{
                return *m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type WafResponse struct {
        Code             *WafResponse_ResponseCode `protobuf:"varint,1,req,name=code,enum=waf_pb.WafResponse_ResponseCode,def=0" json:"code,omitempty"`
        XXX_unrecognized []byte                    `json:"-"`
}

func (m *WafResponse) Reset()      <span class="cov2" title="5">{ *m = WafResponse{} }</span>
func (*WafResponse) ProtoMessage() <span class="cov0" title="0">{}</span>

const Default_WafResponse_Code WafResponse_ResponseCode = WafResponse_OK

func (m *WafResponse) GetCode() WafResponse_ResponseCode <span class="cov0" title="0">{
        if m != nil &amp;&amp; m.Code != nil </span><span class="cov0" title="0">{
                return *m.Code
        }</span>
        <span class="cov0" title="0">return Default_WafResponse_Code</span>
}

func init() <span class="cov1" title="1">{
        proto.RegisterEnum("waf_pb.WafRequest_Request_Method", WafRequest_Request_Method_name, WafRequest_Request_Method_value)
        proto.RegisterEnum("waf_pb.WafRequest_Request_Version", WafRequest_Request_Version_name, WafRequest_Request_Version_value)
        proto.RegisterEnum("waf_pb.WafResponse_ResponseCode", WafResponse_ResponseCode_name, WafResponse_ResponseCode_value)
}</span>
func (m *WafRequest) Unmarshal(data []byte) error <span class="cov2" title="3">{
        l := len(data)
        index := 0
        for index &lt; l </span><span class="cov3" title="19">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov4" title="23">{
                        if index &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov4" title="23">b := data[index]
                        index++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov3" title="19">{
                                break</span>
                        }
                }
                <span class="cov3" title="19">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                switch fieldNum </span>{
                <span class="cov2" title="3">case 1:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
                        }</span>
                        <span class="cov2" title="3">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="4">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="4">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">s := string(data[index:postIndex])
                        m.Service = &amp;s
                        index = postIndex</span>
                <span class="cov2" title="3">case 2:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
                        }</span>
                        <span class="cov2" title="3">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="6">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="6">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">s := string(data[index:postIndex])
                        m.Signature = &amp;s
                        index = postIndex</span>
                <span class="cov2" title="3">case 3:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
                        }</span>
                        <span class="cov2" title="3">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="6">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="6">b := data[index]
                                index++
                                msglen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">postIndex := index + msglen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">if m.Req == nil </span><span class="cov2" title="3">{
                                m.Req = &amp;WafRequest_Request{}
                        }</span>
                        <span class="cov2" title="3">if err := m.Req.Unmarshal(data[index:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="3">index = postIndex</span>
                <span class="cov2" title="3">case 4:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Clientip", wireType)
                        }</span>
                        <span class="cov2" title="3">var v uint32
                        for shift := uint(0); ; shift += 7 </span><span class="cov3" title="15">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov3" title="15">b := data[index]
                                index++
                                v |= (uint32(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">m.Clientip = &amp;v</span>
                <span class="cov2" title="3">case 5:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Logid", wireType)
                        }</span>
                        <span class="cov2" title="3">var v uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov3" title="15">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov3" title="15">b := data[index]
                                index++
                                v |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">m.Logid = &amp;v</span>
                <span class="cov2" title="4">default:
                        var sizeOfWire int
                        for </span><span class="cov3" title="8">{
                                sizeOfWire++
                                wire &gt;&gt;= 7
                                if wire == 0 </span><span class="cov2" title="4">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="4">index -= sizeOfWire
                        skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="4">if (index + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="4">m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
                        index += skippy</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}
func (m *WafRequest_Request) Unmarshal(data []byte) error <span class="cov2" title="6">{
        l := len(data)
        index := 0
        for index &lt; l </span><span class="cov4" title="41">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov4" title="43">{
                        if index &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov4" title="43">b := data[index]
                        index++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov4" title="41">{
                                break</span>
                        }
                }
                <span class="cov4" title="41">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                switch fieldNum </span>{
                <span class="cov2" title="6">case 1:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
                        }</span>
                        <span class="cov2" title="6">var v WafRequest_Request_Method
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="6">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="6">b := data[index]
                                index++
                                v |= (WafRequest_Request_Method(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="6">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="6">m.Method = &amp;v</span>
                <span class="cov2" title="6">case 2:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov2" title="6">var v WafRequest_Request_Version
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="6">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="6">b := data[index]
                                index++
                                v |= (WafRequest_Request_Version(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="6">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="6">m.Version = &amp;v</span>
                <span class="cov2" title="6">case 3:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
                        }</span>
                        <span class="cov2" title="6">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov3" title="9">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov3" title="9">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="6">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="6">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="6">s := string(data[index:postIndex])
                        m.Uri = &amp;s
                        index = postIndex</span>
                <span class="cov3" title="14">case 4:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
                        }</span>
                        <span class="cov3" title="14">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov4" title="27">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov4" title="27">b := data[index]
                                index++
                                msglen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov3" title="14">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="14">postIndex := index + msglen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="14">m.Headers = append(m.Headers, &amp;WafRequest_Request_Header{})
                        m.Headers[len(m.Headers)-1].Unmarshal(data[index:postIndex])
                        index = postIndex</span>
                <span class="cov2" title="6">case 5:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
                        }</span>
                        <span class="cov2" title="6">var byteLen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="6">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="6">b := data[index]
                                index++
                                byteLen |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="6">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="6">postIndex := index + byteLen
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="6">m.Body = append(m.Body, data[index:postIndex]...)
                        index = postIndex</span>
                <span class="cov2" title="3">default:
                        var sizeOfWire int
                        for </span><span class="cov2" title="5">{
                                sizeOfWire++
                                wire &gt;&gt;= 7
                                if wire == 0 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">index -= sizeOfWire
                        skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="3">if (index + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="3">m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
                        index += skippy</span>
                }
        }
        <span class="cov2" title="6">return nil</span>
}
func (m *WafRequest_Request_Header) Unmarshal(data []byte) error <span class="cov3" title="17">{
        l := len(data)
        index := 0
        for index &lt; l </span><span class="cov5" title="62">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov5" title="89">{
                        if index &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov5" title="89">b := data[index]
                        index++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov5" title="62">{
                                break</span>
                        }
                }
                <span class="cov5" title="62">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                switch fieldNum </span>{
                <span class="cov3" title="15">case 1:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
                        }</span>
                        <span class="cov3" title="15">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov4" title="24">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov4" title="24">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov3" title="15">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="15">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="15">s := string(data[index:postIndex])
                        m.Key = &amp;s
                        index = postIndex</span>
                <span class="cov3" title="15">case 2:
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }</span>
                        <span class="cov3" title="15">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov4" title="25">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov4" title="25">b := data[index]
                                index++
                                stringLen |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov3" title="15">{
                                        break</span>
                                }
                        }
                        <span class="cov3" title="15">postIndex := index + int(stringLen)
                        if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="15">s := string(data[index:postIndex])
                        m.Value = &amp;s
                        index = postIndex</span>
                <span class="cov4" title="32">default:
                        var sizeOfWire int
                        for </span><span class="cov5" title="59">{
                                sizeOfWire++
                                wire &gt;&gt;= 7
                                if wire == 0 </span><span class="cov4" title="32">{
                                        break</span>
                                }
                        }
                        <span class="cov4" title="32">index -= sizeOfWire
                        skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov4" title="32">if (index + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov4" title="32">m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
                        index += skippy</span>
                }
        }
        <span class="cov3" title="17">return nil</span>
}
func (m *WafResponse) Unmarshal(data []byte) error <span class="cov2" title="3">{
        l := len(data)
        index := 0
        for index &lt; l </span><span class="cov2" title="7">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov3" title="8">{
                        if index &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov3" title="8">b := data[index]
                        index++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov2" title="7">{
                                break</span>
                        }
                }
                <span class="cov2" title="7">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                switch fieldNum </span>{
                <span class="cov2" title="3">case 1:
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
                        }</span>
                        <span class="cov2" title="3">var v WafResponse_ResponseCode
                        for shift := uint(0); ; shift += 7 </span><span class="cov2" title="3">{
                                if index &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov2" title="3">b := data[index]
                                index++
                                v |= (WafResponse_ResponseCode(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov2" title="3">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="3">m.Code = &amp;v</span>
                <span class="cov2" title="4">default:
                        var sizeOfWire int
                        for </span><span class="cov2" title="5">{
                                sizeOfWire++
                                wire &gt;&gt;= 7
                                if wire == 0 </span><span class="cov2" title="4">{
                                        break</span>
                                }
                        }
                        <span class="cov2" title="4">index -= sizeOfWire
                        skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov2" title="4">if (index + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov2" title="4">m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
                        index += skippy</span>
                }
        }
        <span class="cov2" title="3">return nil</span>
}
func (this *WafRequest) String() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings.Join([]string{`&amp;WafRequest{`,
                `Service:` + valueToStringBfeWafGogo(this.Service) + `,`,
                `Signature:` + valueToStringBfeWafGogo(this.Signature) + `,`,
                `Req:` + strings.Replace(fmt1.Sprintf("%v", this.Req), "WafRequest_Request", "WafRequest_Request", 1) + `,`,
                `Clientip:` + valueToStringBfeWafGogo(this.Clientip) + `,`,
                `Logid:` + valueToStringBfeWafGogo(this.Logid) + `,`,
                `XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
                `}`,
        }, "")
        return s</span>
}
func (this *WafRequest_Request) String() string <span class="cov2" title="4">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov2" title="4">s := strings.Join([]string{`&amp;WafRequest_Request{`,
                `Method:` + valueToStringBfeWafGogo(this.Method) + `,`,
                `Version:` + valueToStringBfeWafGogo(this.Version) + `,`,
                `Uri:` + valueToStringBfeWafGogo(this.Uri) + `,`,
                `Headers:` + strings.Replace(fmt1.Sprintf("%v", this.Headers), "WafRequest_Request_Header", "WafRequest_Request_Header", 1) + `,`,
                `Body:` + valueToStringBfeWafGogo(this.Body) + `,`,
                `XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
                `}`,
        }, "")
        return s</span>
}
func (this *WafRequest_Request_Header) String() string <span class="cov3" title="20">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov3" title="20">s := strings.Join([]string{`&amp;WafRequest_Request_Header{`,
                `Key:` + valueToStringBfeWafGogo(this.Key) + `,`,
                `Value:` + valueToStringBfeWafGogo(this.Value) + `,`,
                `XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
                `}`,
        }, "")
        return s</span>
}
func (this *WafResponse) String() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings.Join([]string{`&amp;WafResponse{`,
                `Code:` + valueToStringBfeWafGogo(this.Code) + `,`,
                `XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
                `}`,
        }, "")
        return s</span>
}
func valueToStringBfeWafGogo(v interface{}) string <span class="cov5" title="66">{
        rv := reflect.ValueOf(v)
        if rv.IsNil() </span><span class="cov3" title="8">{
                return "nil"
        }</span>
        <span class="cov5" title="58">pv := reflect.Indirect(rv).Interface()
        return fmt1.Sprintf("*%v", pv)</span>
}
func (m *WafRequest) Size() (n int) <span class="cov2" title="7">{
        var l int
        _ = l
        if m.Service != nil </span><span class="cov2" title="7">{
                l = len(*m.Service)
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.Signature != nil </span><span class="cov2" title="7">{
                l = len(*m.Signature)
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.Req != nil </span><span class="cov2" title="7">{
                l = m.Req.Size()
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov2" title="7">if m.Clientip != nil </span><span class="cov2" title="7">{
                n += 1 + sovBfeWafGogo(uint64(*m.Clientip))
        }</span>
        <span class="cov2" title="7">if m.Logid != nil </span><span class="cov2" title="7">{
                n += 1 + sovBfeWafGogo(uint64(*m.Logid))
        }</span>
        <span class="cov2" title="7">if m.XXX_unrecognized != nil </span><span class="cov1" title="1">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="7">return n</span>
}
func (m *WafRequest_Request) Size() (n int) <span class="cov3" title="20">{
        var l int
        _ = l
        if m.Method != nil </span><span class="cov3" title="20">{
                n += 1 + sovBfeWafGogo(uint64(*m.Method))
        }</span>
        <span class="cov3" title="20">if m.Version != nil </span><span class="cov3" title="20">{
                n += 1 + sovBfeWafGogo(uint64(*m.Version))
        }</span>
        <span class="cov3" title="20">if m.Uri != nil </span><span class="cov3" title="20">{
                l = len(*m.Uri)
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov3" title="20">if len(m.Headers) &gt; 0 </span><span class="cov3" title="15">{
                for _, e := range m.Headers </span><span class="cov4" title="27">{
                        l = e.Size()
                        n += 1 + l + sovBfeWafGogo(uint64(l))
                }</span>
        }
        <span class="cov3" title="20">if m.Body != nil </span><span class="cov3" title="20">{
                l = len(m.Body)
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov3" title="20">if m.XXX_unrecognized != nil </span><span class="cov2" title="4">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov3" title="20">return n</span>
}
func (m *WafRequest_Request_Header) Size() (n int) <span class="cov4" title="51">{
        var l int
        _ = l
        if m.Key != nil </span><span class="cov4" title="47">{
                l = len(*m.Key)
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov4" title="51">if m.Value != nil </span><span class="cov4" title="46">{
                l = len(*m.Value)
                n += 1 + l + sovBfeWafGogo(uint64(l))
        }</span>
        <span class="cov4" title="51">if m.XXX_unrecognized != nil </span><span class="cov4" title="29">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov4" title="51">return n</span>
}
func (m *WafResponse) Size() (n int) <span class="cov2" title="7">{
        var l int
        _ = l
        if m.Code != nil </span><span class="cov2" title="7">{
                n += 1 + sovBfeWafGogo(uint64(*m.Code))
        }</span>
        <span class="cov2" title="7">if m.XXX_unrecognized != nil </span><span class="cov1" title="2">{
                n += len(m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="7">return n</span>
}

func sovBfeWafGogo(x uint64) (n int) <span class="cov6" title="242">{
        for </span><span class="cov7" title="411">{
                n++
                x &gt;&gt;= 7
                if x == 0 </span><span class="cov6" title="242">{
                        break</span>
                }
        }
        <span class="cov6" title="242">return n</span>
}
func sozBfeWafGogo(x uint64) (n int) <span class="cov0" title="0">{
        return sovBfeWafGogo(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func NewPopulatedWafRequest(r randyBfeWafGogo, easy bool) *WafRequest <span class="cov3" title="9">{
        this := &amp;WafRequest{}
        if r.Intn(10) != 0 </span><span class="cov2" title="6">{
                v1 := randStringBfeWafGogo(r)
                this.Service = &amp;v1
        }</span>
        <span class="cov3" title="9">if r.Intn(10) != 0 </span><span class="cov3" title="9">{
                v2 := randStringBfeWafGogo(r)
                this.Signature = &amp;v2
        }</span>
        <span class="cov3" title="9">this.Req = NewPopulatedWafRequest_Request(r, easy)
        v3 := r.Uint32()
        this.Clientip = &amp;v3
        if r.Intn(10) != 0 </span><span class="cov3" title="8">{
                v4 := uint64(r.Uint32())
                this.Logid = &amp;v4
        }</span>
        <span class="cov3" title="9">if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov2" title="5">{
                this.XXX_unrecognized = randUnrecognizedBfeWafGogo(r, 6)
        }</span>
        <span class="cov3" title="9">return this</span>
}

func NewPopulatedWafRequest_Request(r randyBfeWafGogo, easy bool) *WafRequest_Request <span class="cov3" title="18">{
        this := &amp;WafRequest_Request{}
        v5 := WafRequest_Request_Method([]int32{0, 1, 2, 3}[r.Intn(4)])
        this.Method = &amp;v5
        v6 := WafRequest_Request_Version([]int32{0, 1}[r.Intn(2)])
        this.Version = &amp;v6
        v7 := randStringBfeWafGogo(r)
        this.Uri = &amp;v7
        if r.Intn(10) != 0 </span><span class="cov3" title="16">{
                v8 := r.Intn(10)
                this.Headers = make([]*WafRequest_Request_Header, v8)
                for i := 0; i &lt; v8; i++ </span><span class="cov5" title="65">{
                        this.Headers[i] = NewPopulatedWafRequest_Request_Header(r, easy)
                }</span>
        }
        <span class="cov3" title="18">if r.Intn(10) != 0 </span><span class="cov3" title="17">{
                v9 := r.Intn(100)
                this.Body = make([]byte, v9)
                for i := 0; i &lt; v9; i++ </span><span class="cov7" title="887">{
                        this.Body[i] = byte(r.Intn(256))
                }</span>
        }
        <span class="cov3" title="18">if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov2" title="7">{
                this.XXX_unrecognized = randUnrecognizedBfeWafGogo(r, 6)
        }</span>
        <span class="cov3" title="18">return this</span>
}

func NewPopulatedWafRequest_Request_Header(r randyBfeWafGogo, easy bool) *WafRequest_Request_Header <span class="cov5" title="74">{
        this := &amp;WafRequest_Request_Header{}
        if r.Intn(10) != 0 </span><span class="cov5" title="67">{
                v10 := randStringBfeWafGogo(r)
                this.Key = &amp;v10
        }</span>
        <span class="cov5" title="74">if r.Intn(10) != 0 </span><span class="cov5" title="67">{
                v11 := randStringBfeWafGogo(r)
                this.Value = &amp;v11
        }</span>
        <span class="cov5" title="74">if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov4" title="32">{
                this.XXX_unrecognized = randUnrecognizedBfeWafGogo(r, 3)
        }</span>
        <span class="cov5" title="74">return this</span>
}

func NewPopulatedWafResponse(r randyBfeWafGogo, easy bool) *WafResponse <span class="cov3" title="9">{
        this := &amp;WafResponse{}
        v12 := WafResponse_ResponseCode([]int32{0, 1}[r.Intn(2)])
        this.Code = &amp;v12
        if !easy &amp;&amp; r.Intn(10) != 0 </span><span class="cov2" title="5">{
                this.XXX_unrecognized = randUnrecognizedBfeWafGogo(r, 2)
        }</span>
        <span class="cov3" title="9">return this</span>
}

type randyBfeWafGogo interface {
        Float32() float32
        Float64() float64
        Int63() int64
        Int31() int32
        Uint32() uint32
        Intn(n int) int
}

func randUTF8RuneBfeWafGogo(r randyBfeWafGogo) rune <span class="cov10" title="8277">{
        res := rune(r.Uint32() % 1112064)
        if 55296 &lt;= res </span><span class="cov9" title="7876">{
                res += 2047
        }</span>
        <span class="cov10" title="8277">return res</span>
}
func randStringBfeWafGogo(r randyBfeWafGogo) string <span class="cov6" title="167">{
        v13 := r.Intn(100)
        tmps := make([]rune, v13)
        for i := 0; i &lt; v13; i++ </span><span class="cov10" title="8277">{
                tmps[i] = randUTF8RuneBfeWafGogo(r)
        }</span>
        <span class="cov6" title="167">return string(tmps)</span>
}
func randUnrecognizedBfeWafGogo(r randyBfeWafGogo, maxFieldNumber int) (data []byte) <span class="cov4" title="49">{
        l := r.Intn(5)
        for i := 0; i &lt; l; i++ </span><span class="cov5" title="85">{
                wire := r.Intn(4)
                if wire == 3 </span><span class="cov4" title="22">{
                        wire = 5
                }</span>
                <span class="cov5" title="85">fieldNumber := maxFieldNumber + r.Intn(100)
                data = randFieldBfeWafGogo(data, r, fieldNumber, wire)</span>
        }
        <span class="cov4" title="49">return data</span>
}
func randFieldBfeWafGogo(data []byte, r randyBfeWafGogo, fieldNumber int, wire int) []byte <span class="cov5" title="85">{
        key := uint32(fieldNumber)&lt;&lt;3 | uint32(wire)
        switch wire </span>{
        <span class="cov3" title="17">case 0:
                data = encodeVarintPopulateBfeWafGogo(data, uint64(key))
                v14 := r.Int63()
                if r.Intn(2) == 0 </span><span class="cov2" title="6">{
                        v14 *= -1
                }</span>
                <span class="cov3" title="17">data = encodeVarintPopulateBfeWafGogo(data, uint64(v14))</span>
        <span class="cov4" title="24">case 1:
                data = encodeVarintPopulateBfeWafGogo(data, uint64(key))
                data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))</span>
        <span class="cov4" title="22">case 2:
                data = encodeVarintPopulateBfeWafGogo(data, uint64(key))
                ll := r.Intn(100)
                data = encodeVarintPopulateBfeWafGogo(data, uint64(ll))
                for j := 0; j &lt; ll; j++ </span><span class="cov7" title="1110">{
                        data = append(data, byte(r.Intn(256)))
                }</span>
        <span class="cov4" title="22">default:
                data = encodeVarintPopulateBfeWafGogo(data, uint64(key))
                data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))</span>
        }
        <span class="cov5" title="85">return data</span>
}
func encodeVarintPopulateBfeWafGogo(data []byte, v uint64) []byte <span class="cov5" title="124">{
        for v &gt;= 1&lt;&lt;7 </span><span class="cov6" title="214">{
                data = append(data, uint8(uint64(v)&amp;0x7f|0x80))
                v &gt;&gt;= 7
        }</span>
        <span class="cov5" title="124">data = append(data, uint8(v))
        return data</span>
}
func (m *WafRequest) Marshal() (data []byte, err error) <span class="cov2" title="5">{
        size := m.Size()
        data = make([]byte, size)
        n, err := m.MarshalTo(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="5">return data[:n], nil</span>
}

func (m *WafRequest) MarshalTo(data []byte) (n int, err error) <span class="cov2" title="6">{
        var i int
        _ = i
        var l int
        _ = l
        if m.Service != nil </span><span class="cov2" title="6">{
                data[i] = 0xa
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(len(*m.Service)))
                i += copy(data[i:], *m.Service)
        }</span>
        <span class="cov2" title="6">if m.Signature != nil </span><span class="cov2" title="6">{
                data[i] = 0x12
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(len(*m.Signature)))
                i += copy(data[i:], *m.Signature)
        }</span>
        <span class="cov2" title="6">if m.Req != nil </span><span class="cov2" title="6">{
                data[i] = 0x1a
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(m.Req.Size()))
                n1, err := m.Req.MarshalTo(data[i:])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov2" title="6">i += n1</span>
        }
        <span class="cov2" title="6">if m.Clientip != nil </span><span class="cov2" title="6">{
                data[i] = 0x20
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(*m.Clientip))
        }</span>
        <span class="cov2" title="6">if m.Logid != nil </span><span class="cov2" title="6">{
                data[i] = 0x28
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(*m.Logid))
        }</span>
        <span class="cov2" title="6">if m.XXX_unrecognized != nil </span><span class="cov1" title="1">{
                i += copy(data[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return i, nil</span>
}
func (m *WafRequest_Request) Marshal() (data []byte, err error) <span class="cov2" title="5">{
        size := m.Size()
        data = make([]byte, size)
        n, err := m.MarshalTo(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="5">return data[:n], nil</span>
}

func (m *WafRequest_Request) MarshalTo(data []byte) (n int, err error) <span class="cov3" title="12">{
        var i int
        _ = i
        var l int
        _ = l
        if m.Method != nil </span><span class="cov3" title="12">{
                data[i] = 0x8
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(*m.Method))
        }</span>
        <span class="cov3" title="12">if m.Version != nil </span><span class="cov3" title="12">{
                data[i] = 0x10
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(*m.Version))
        }</span>
        <span class="cov3" title="12">if m.Uri != nil </span><span class="cov3" title="12">{
                data[i] = 0x1a
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(len(*m.Uri)))
                i += copy(data[i:], *m.Uri)
        }</span>
        <span class="cov3" title="12">if len(m.Headers) &gt; 0 </span><span class="cov3" title="8">{
                for _, msg := range m.Headers </span><span class="cov3" title="17">{
                        data[i] = 0x22
                        i++
                        i = encodeVarintBfeWafGogo(data, i, uint64(msg.Size()))
                        n, err := msg.MarshalTo(data[i:])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov3" title="17">i += n</span>
                }
        }
        <span class="cov3" title="12">if m.Body != nil </span><span class="cov3" title="12">{
                data[i] = 0x2a
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(len(m.Body)))
                i += copy(data[i:], m.Body)
        }</span>
        <span class="cov3" title="12">if m.XXX_unrecognized != nil </span><span class="cov2" title="3">{
                i += copy(data[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov3" title="12">return i, nil</span>
}
func (m *WafRequest_Request_Header) Marshal() (data []byte, err error) <span class="cov2" title="5">{
        size := m.Size()
        data = make([]byte, size)
        n, err := m.MarshalTo(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="5">return data[:n], nil</span>
}

func (m *WafRequest_Request_Header) MarshalTo(data []byte) (n int, err error) <span class="cov4" title="23">{
        var i int
        _ = i
        var l int
        _ = l
        if m.Key != nil </span><span class="cov4" title="21">{
                data[i] = 0xa
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(len(*m.Key)))
                i += copy(data[i:], *m.Key)
        }</span>
        <span class="cov4" title="23">if m.Value != nil </span><span class="cov4" title="21">{
                data[i] = 0x12
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(len(*m.Value)))
                i += copy(data[i:], *m.Value)
        }</span>
        <span class="cov4" title="23">if m.XXX_unrecognized != nil </span><span class="cov3" title="13">{
                i += copy(data[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov4" title="23">return i, nil</span>
}
func (m *WafResponse) Marshal() (data []byte, err error) <span class="cov2" title="5">{
        size := m.Size()
        data = make([]byte, size)
        n, err := m.MarshalTo(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="5">return data[:n], nil</span>
}

func (m *WafResponse) MarshalTo(data []byte) (n int, err error) <span class="cov2" title="6">{
        var i int
        _ = i
        var l int
        _ = l
        if m.Code != nil </span><span class="cov2" title="6">{
                data[i] = 0x8
                i++
                i = encodeVarintBfeWafGogo(data, i, uint64(*m.Code))
        }</span>
        <span class="cov2" title="6">if m.XXX_unrecognized != nil </span><span class="cov1" title="2">{
                i += copy(data[i:], m.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return i, nil</span>
}
func encodeFixed64BfeWafGogo(data []byte, offset int, v uint64) int <span class="cov0" title="0">{
        data[offset] = uint8(v)
        data[offset+1] = uint8(v &gt;&gt; 8)
        data[offset+2] = uint8(v &gt;&gt; 16)
        data[offset+3] = uint8(v &gt;&gt; 24)
        data[offset+4] = uint8(v &gt;&gt; 32)
        data[offset+5] = uint8(v &gt;&gt; 40)
        data[offset+6] = uint8(v &gt;&gt; 48)
        data[offset+7] = uint8(v &gt;&gt; 56)
        return offset + 8
}</span>
func encodeFixed32BfeWafGogo(data []byte, offset int, v uint32) int <span class="cov0" title="0">{
        data[offset] = uint8(v)
        data[offset+1] = uint8(v &gt;&gt; 8)
        data[offset+2] = uint8(v &gt;&gt; 16)
        data[offset+3] = uint8(v &gt;&gt; 24)
        return offset + 4
}</span>
func encodeVarintBfeWafGogo(data []byte, offset int, v uint64) int <span class="cov5" title="143">{
        for v &gt;= 1&lt;&lt;7 </span><span class="cov5" title="108">{
                data[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov5" title="143">data[offset] = uint8(v)
        return offset + 1</span>
}
func (this *WafRequest) GoString() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings1.Join([]string{`&amp;waf_pb.WafRequest{` + `Service:` + valueToGoStringBfeWafGogo(this.Service, "string"), `Signature:` + valueToGoStringBfeWafGogo(this.Signature, "string"), `Req:` + fmt2.Sprintf("%#v", this.Req), `Clientip:` + valueToGoStringBfeWafGogo(this.Clientip, "uint32"), `Logid:` + valueToGoStringBfeWafGogo(this.Logid, "uint64"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
        return s</span>
}
func (this *WafRequest_Request) GoString() string <span class="cov2" title="4">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov2" title="4">s := strings1.Join([]string{`&amp;waf_pb.WafRequest_Request{` + `Method:` + valueToGoStringBfeWafGogo(this.Method, "waf_pb.WafRequest_Request_Method"), `Version:` + valueToGoStringBfeWafGogo(this.Version, "waf_pb.WafRequest_Request_Version"), `Uri:` + valueToGoStringBfeWafGogo(this.Uri, "string"), `Headers:` + fmt2.Sprintf("%#v", this.Headers), `Body:` + valueToGoStringBfeWafGogo(this.Body, "byte"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
        return s</span>
}
func (this *WafRequest_Request_Header) GoString() string <span class="cov3" title="14">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov3" title="14">s := strings1.Join([]string{`&amp;waf_pb.WafRequest_Request_Header{` + `Key:` + valueToGoStringBfeWafGogo(this.Key, "string"), `Value:` + valueToGoStringBfeWafGogo(this.Value, "string"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
        return s</span>
}
func (this *WafResponse) GoString() string <span class="cov1" title="2">{
        if this == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov1" title="2">s := strings1.Join([]string{`&amp;waf_pb.WafResponse{` + `Code:` + valueToGoStringBfeWafGogo(this.Code, "waf_pb.WafResponse_ResponseCode"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
        return s</span>
}
func valueToGoStringBfeWafGogo(v interface{}, typ string) string <span class="cov4" title="54">{
        rv := reflect1.ValueOf(v)
        if rv.IsNil() </span><span class="cov1" title="2">{
                return "nil"
        }</span>
        <span class="cov4" title="52">pv := reflect1.Indirect(rv).Interface()
        return fmt2.Sprintf("func(v %v) *%v { return &amp;v } ( %#v )", typ, typ, pv)</span>
}
func extensionToGoStringBfeWafGogo(e map[int32]code_google_com_p_gogoprotobuf_proto1.Extension) string <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov0" title="0">s := "map[int32]proto.Extension{"
        keys := make([]int, 0, len(e))
        for k := range e </span><span class="cov0" title="0">{
                keys = append(keys, int(k))
        }</span>
        <span class="cov0" title="0">sort.Ints(keys)
        ss := []string{}
        for _, k := range keys </span><span class="cov0" title="0">{
                ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
        }</span>
        <span class="cov0" title="0">s += strings1.Join(ss, ",") + "}"
        return s</span>
}
func (this *WafRequest) VerboseEqual(that interface{}) error <span class="cov2" title="6">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that == nil &amp;&amp; this != nil")</span>
        }

        <span class="cov2" title="6">that1, ok := that.(*WafRequest)
        if !ok </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is not of type *WafRequest")
        }</span>
        <span class="cov2" title="6">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that is type *WafRequest but is nil &amp;&amp; this != nil")</span>
        } <span class="cov2" title="6">else if this == nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is type *WafRequestbut is not nil &amp;&amp; this == nil")
        }</span>
        <span class="cov2" title="6">if this.Service != nil &amp;&amp; that1.Service != nil </span><span class="cov2" title="4">{
                if *this.Service != *that1.Service </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Service this(%v) Not Equal that(%v)", *this.Service, *that1.Service)
                }</span>
        } <span class="cov1" title="2">else if this.Service != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Service == nil &amp;&amp; that.Service != nil")
        }</span> <span class="cov1" title="2">else if that1.Service != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Service this(%v) Not Equal that(%v)", this.Service, that1.Service)
        }</span>
        <span class="cov2" title="6">if this.Signature != nil &amp;&amp; that1.Signature != nil </span><span class="cov2" title="6">{
                if *this.Signature != *that1.Signature </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Signature this(%v) Not Equal that(%v)", *this.Signature, *that1.Signature)
                }</span>
        } <span class="cov0" title="0">else if this.Signature != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Signature == nil &amp;&amp; that.Signature != nil")
        }</span> <span class="cov0" title="0">else if that1.Signature != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
        }</span>
        <span class="cov2" title="6">if !this.Req.Equal(that1.Req) </span><span class="cov0" title="0">{
                return fmt3.Errorf("Req this(%v) Not Equal that(%v)", this.Req, that1.Req)
        }</span>
        <span class="cov2" title="6">if this.Clientip != nil &amp;&amp; that1.Clientip != nil </span><span class="cov2" title="6">{
                if *this.Clientip != *that1.Clientip </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Clientip this(%v) Not Equal that(%v)", *this.Clientip, *that1.Clientip)
                }</span>
        } <span class="cov0" title="0">else if this.Clientip != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Clientip == nil &amp;&amp; that.Clientip != nil")
        }</span> <span class="cov0" title="0">else if that1.Clientip != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Clientip this(%v) Not Equal that(%v)", this.Clientip, that1.Clientip)
        }</span>
        <span class="cov2" title="6">if this.Logid != nil &amp;&amp; that1.Logid != nil </span><span class="cov2" title="5">{
                if *this.Logid != *that1.Logid </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Logid this(%v) Not Equal that(%v)", *this.Logid, *that1.Logid)
                }</span>
        } <span class="cov1" title="1">else if this.Logid != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Logid == nil &amp;&amp; that.Logid != nil")
        }</span> <span class="cov1" title="1">else if that1.Logid != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Logid this(%v) Not Equal that(%v)", this.Logid, that1.Logid)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return nil</span>
}
func (this *WafRequest) Equal(that interface{}) bool <span class="cov2" title="5">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov2" title="5">that1, ok := that.(*WafRequest)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov2" title="5">else if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Service != nil &amp;&amp; that1.Service != nil </span><span class="cov2" title="3">{
                if *this.Service != *that1.Service </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov1" title="2">else if this.Service != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov1" title="2">else if that1.Service != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Signature != nil &amp;&amp; that1.Signature != nil </span><span class="cov2" title="5">{
                if *this.Signature != *that1.Signature </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Signature != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Signature != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !this.Req.Equal(that1.Req) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Clientip != nil &amp;&amp; that1.Clientip != nil </span><span class="cov2" title="5">{
                if *this.Clientip != *that1.Clientip </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Clientip != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Clientip != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Logid != nil &amp;&amp; that1.Logid != nil </span><span class="cov2" title="4">{
                if *this.Logid != *that1.Logid </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov1" title="1">else if this.Logid != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov1" title="1">else if that1.Logid != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">return true</span>
}
func (this *WafRequest_Request) VerboseEqual(that interface{}) error <span class="cov2" title="6">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that == nil &amp;&amp; this != nil")</span>
        }

        <span class="cov2" title="6">that1, ok := that.(*WafRequest_Request)
        if !ok </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is not of type *WafRequest_Request")
        }</span>
        <span class="cov2" title="6">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that is type *WafRequest_Request but is nil &amp;&amp; this != nil")</span>
        } <span class="cov2" title="6">else if this == nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is type *WafRequest_Requestbut is not nil &amp;&amp; this == nil")
        }</span>
        <span class="cov2" title="6">if this.Method != nil &amp;&amp; that1.Method != nil </span><span class="cov2" title="6">{
                if *this.Method != *that1.Method </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Method this(%v) Not Equal that(%v)", *this.Method, *that1.Method)
                }</span>
        } <span class="cov0" title="0">else if this.Method != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Method == nil &amp;&amp; that.Method != nil")
        }</span> <span class="cov0" title="0">else if that1.Method != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Method this(%v) Not Equal that(%v)", this.Method, that1.Method)
        }</span>
        <span class="cov2" title="6">if this.Version != nil &amp;&amp; that1.Version != nil </span><span class="cov2" title="6">{
                if *this.Version != *that1.Version </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Version this(%v) Not Equal that(%v)", *this.Version, *that1.Version)
                }</span>
        } <span class="cov0" title="0">else if this.Version != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Version == nil &amp;&amp; that.Version != nil")
        }</span> <span class="cov0" title="0">else if that1.Version != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
        }</span>
        <span class="cov2" title="6">if this.Uri != nil &amp;&amp; that1.Uri != nil </span><span class="cov2" title="6">{
                if *this.Uri != *that1.Uri </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Uri this(%v) Not Equal that(%v)", *this.Uri, *that1.Uri)
                }</span>
        } <span class="cov0" title="0">else if this.Uri != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Uri == nil &amp;&amp; that.Uri != nil")
        }</span> <span class="cov0" title="0">else if that1.Uri != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Uri this(%v) Not Equal that(%v)", this.Uri, that1.Uri)
        }</span>
        <span class="cov2" title="6">if len(this.Headers) != len(that1.Headers) </span><span class="cov0" title="0">{
                return fmt3.Errorf("Headers this(%v) Not Equal that(%v)", len(this.Headers), len(that1.Headers))
        }</span>
        <span class="cov2" title="6">for i := range this.Headers </span><span class="cov4" title="29">{
                if !this.Headers[i].Equal(that1.Headers[i]) </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Headers this[%v](%v) Not Equal that[%v](%v)", i, this.Headers[i], i, that1.Headers[i])
                }</span>
        }
        <span class="cov2" title="6">if !bytes.Equal(this.Body, that1.Body) </span><span class="cov0" title="0">{
                return fmt3.Errorf("Body this(%v) Not Equal that(%v)", this.Body, that1.Body)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return nil</span>
}
func (this *WafRequest_Request) Equal(that interface{}) bool <span class="cov3" title="16">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov3" title="16">that1, ok := that.(*WafRequest_Request)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov3" title="16">else if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">if this.Method != nil &amp;&amp; that1.Method != nil </span><span class="cov3" title="16">{
                if *this.Method != *that1.Method </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Method != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Method != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">if this.Version != nil &amp;&amp; that1.Version != nil </span><span class="cov3" title="16">{
                if *this.Version != *that1.Version </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Version != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Version != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">if this.Uri != nil &amp;&amp; that1.Uri != nil </span><span class="cov3" title="16">{
                if *this.Uri != *that1.Uri </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Uri != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Uri != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">if len(this.Headers) != len(that1.Headers) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">for i := range this.Headers </span><span class="cov5" title="65">{
                if !this.Headers[i].Equal(that1.Headers[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov3" title="16">if !bytes.Equal(this.Body, that1.Body) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="16">return true</span>
}
func (this *WafRequest_Request_Header) VerboseEqual(that interface{}) error <span class="cov2" title="6">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that == nil &amp;&amp; this != nil")</span>
        }

        <span class="cov2" title="6">that1, ok := that.(*WafRequest_Request_Header)
        if !ok </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is not of type *WafRequest_Request_Header")
        }</span>
        <span class="cov2" title="6">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that is type *WafRequest_Request_Header but is nil &amp;&amp; this != nil")</span>
        } <span class="cov2" title="6">else if this == nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is type *WafRequest_Request_Headerbut is not nil &amp;&amp; this == nil")
        }</span>
        <span class="cov2" title="6">if this.Key != nil &amp;&amp; that1.Key != nil </span><span class="cov2" title="6">{
                if *this.Key != *that1.Key </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Key this(%v) Not Equal that(%v)", *this.Key, *that1.Key)
                }</span>
        } <span class="cov0" title="0">else if this.Key != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Key == nil &amp;&amp; that.Key != nil")
        }</span> <span class="cov0" title="0">else if that1.Key != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Key this(%v) Not Equal that(%v)", this.Key, that1.Key)
        }</span>
        <span class="cov2" title="6">if this.Value != nil &amp;&amp; that1.Value != nil </span><span class="cov2" title="5">{
                if *this.Value != *that1.Value </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
                }</span>
        } <span class="cov1" title="1">else if this.Value != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Value == nil &amp;&amp; that.Value != nil")
        }</span> <span class="cov1" title="1">else if that1.Value != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return nil</span>
}
func (this *WafRequest_Request_Header) Equal(that interface{}) bool <span class="cov5" title="99">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov5" title="99">that1, ok := that.(*WafRequest_Request_Header)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="99">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov5" title="99">else if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="99">if this.Key != nil &amp;&amp; that1.Key != nil </span><span class="cov5" title="92">{
                if *this.Key != *that1.Key </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov2" title="7">else if this.Key != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov2" title="7">else if that1.Key != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="99">if this.Value != nil &amp;&amp; that1.Value != nil </span><span class="cov5" title="89">{
                if *this.Value != *that1.Value </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov3" title="10">else if this.Value != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov3" title="10">else if that1.Value != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="99">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="99">return true</span>
}
func (this *WafResponse) VerboseEqual(that interface{}) error <span class="cov2" title="6">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that == nil &amp;&amp; this != nil")</span>
        }

        <span class="cov2" title="6">that1, ok := that.(*WafResponse)
        if !ok </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is not of type *WafResponse")
        }</span>
        <span class="cov2" title="6">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt3.Errorf("that is type *WafResponse but is nil &amp;&amp; this != nil")</span>
        } <span class="cov2" title="6">else if this == nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("that is type *WafResponsebut is not nil &amp;&amp; this == nil")
        }</span>
        <span class="cov2" title="6">if this.Code != nil &amp;&amp; that1.Code != nil </span><span class="cov2" title="6">{
                if *this.Code != *that1.Code </span><span class="cov0" title="0">{
                        return fmt3.Errorf("Code this(%v) Not Equal that(%v)", *this.Code, *that1.Code)
                }</span>
        } <span class="cov0" title="0">else if this.Code != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("this.Code == nil &amp;&amp; that.Code != nil")
        }</span> <span class="cov0" title="0">else if that1.Code != nil </span><span class="cov0" title="0">{
                return fmt3.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
        }</span>
        <span class="cov2" title="6">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
        }</span>
        <span class="cov2" title="6">return nil</span>
}
func (this *WafResponse) Equal(that interface{}) bool <span class="cov2" title="5">{
        if that == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov2" title="5">that1, ok := that.(*WafResponse)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if that1 == nil </span><span class="cov0" title="0">{
                if this == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        } <span class="cov2" title="5">else if this == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if this.Code != nil &amp;&amp; that1.Code != nil </span><span class="cov2" title="5">{
                if *this.Code != *that1.Code </span><span class="cov0" title="0">{
                        return false
                }</span>
        } <span class="cov0" title="0">else if this.Code != nil </span><span class="cov0" title="0">{
                return false
        }</span> <span class="cov0" title="0">else if that1.Code != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">/* waf_rule_table.go - waf rule table, for waf check conditions and actions   */
/*
modification history
--------------------
2014/8/7, by Weiwei02, create
*/
/*
DESCRIPTION
*/
package mod_waf_client

import (
        "sync"
)

import (
        "bfe_basic"
        "bfe_basic/condition"
)

// condition, action
type WafRule struct {
        Cond   condition.Condition
        Action *Action
}

type WafRules []*WafRule                         // list of WafRule
type ProductWafRulesFile map[string]WafRulesFile // service to file waf rules

type WafRuleTable struct {
        lock        sync.Mutex
        version     string
        rules       ProductWafRules // service -&gt; waf configure
        wafRuleConf WafRuleConf     // provide LoadAndCheck interface
}

func NewWafRuleTable() *WafRuleTable <span class="cov10" title="5">{
        w := new(WafRuleTable)
        w.rules = make(ProductWafRules)

        return w
}</span>

func (w *WafRuleTable) Update(version string, newRules ProductWafRules) <span class="cov7" title="3">{
        w.lock.Lock()
        w.version = version
        w.rules = newRules
        w.lock.Unlock()
}</span>

func (w *WafRuleTable) GetRequestWafAction(req *bfe_basic.Request) *Action <span class="cov10" title="5">{
        w.lock.Lock()
        defer w.lock.Unlock()

        productName := req.Route.Product
        if rules, ok := w.rules[productName]; ok </span><span class="cov7" title="3">{
                for _, rule := range rules </span><span class="cov7" title="3">{
                        if rule.Cond.Match(req) </span><span class="cov4" title="2">{
                                return rule.Action
                        }</span>
                }
        }

        <span class="cov7" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">/* aggre_handler.go - handlers for aggregating state data */
/*
modification history
--------------------
2014/10/8, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package bfe_monitor_proxy

import (
    "bytes"
    "encoding/json"
    "fmt"
    "strconv"
)

import (
    "www.baidu.com/golang-lib/delay_counter"
    "www.baidu.com/golang-lib/module_state2"
)

// function prototype for aggregating state data
type StateDataHandlerType func([][]byte, string) ([]byte, error)

var stateDataHandlerMap = map[string]StateDataHandlerType {
    "CounterSlice": processCounterDiff, // handler for aggregating data of type 'CounterDiff'
    "DelayRecent": processDelayOutput,  // handler for aggregating data of type 'DelayOutput'
    "State": processStateData,          // handler for aggregating data of type 'StateData'
}

// get state data handler by type
func GetStateDataHandler(stateType string) StateDataHandlerType <span class="cov7" title="5">{
    if handler, ok := stateDataHandlerMap[stateType]; ok </span><span class="cov5" title="3">{
        return handler
    }</span>
    <span class="cov3" title="2">return defaultHandler</span>
}

// check whether stateType is registered or not 
func IsRegisterStateType(stateType string) bool <span class="cov7" title="5">{
    _, ok := stateDataHandlerMap[stateType]
    return ok
}</span>

// default handler for aggregating data of unknown type
func defaultHandler(stateData [][]byte, format string) ([]byte, error) <span class="cov3" title="2">{
    var err error 

    // aggregate data of unknown type
    switch format </span>{
    <span class="cov1" title="1">case "json":
        var result = make(map[string]interface{})
        for i := 0; i &lt; len(stateData); i ++ </span><span class="cov3" title="2">{
            var item interface{}
            if err = json.Unmarshal(stateData[i], &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("json.Unmarshal():%d:%s", i, err.Error())
            }</span>
            <span class="cov3" title="2">result[strconv.Itoa(i)] = item</span> // (child index, orginal json data)
        }
        <span class="cov1" title="1">return json.Marshal(result)</span>

    <span class="cov1" title="1">case "noah":
        var result bytes.Buffer
        for i := 0; i &lt; len(stateData); i ++ </span><span class="cov3" title="2">{
            lines := bytes.Split(stateData[i], []byte("\n"))
            for _, line := range(lines[:len(lines)-1]) </span><span class="cov10" title="10">{
                row := fmt.Sprintf("%d_%s\n", i, line) // &lt;child index&gt;_&lt;noah record&gt;
                result.WriteString(row)
            }</span>
        }
        <span class="cov1" title="1">return result.Bytes(), nil</span>

    <span class="cov0" title="0">default:
        return nil, fmt.Errorf("format not support: %s", format)</span>
    }
}

func processCounterDiff(stateData [][]byte, format string) ([]byte, error) <span class="cov1" title="1">{
    var result *module_state2.CounterDiff

    // aggregate counter diff
    for i := 0; i &lt; len(stateData); i ++ </span><span class="cov3" title="2">{
        cd := new(module_state2.CounterDiff)
        if err := json.Unmarshal(stateData[i], cd); err != nil </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("json.Unmarshal():%d:%s", i, err.Error())
        }</span>
        <span class="cov3" title="2">if i == 0 </span><span class="cov1" title="1">{
            result = cd
            continue</span>
        }
        <span class="cov1" title="1">result.Diff.Sum(cd.Diff)

        // Note. use lastest *LastTime* for result
        if result.LastTime &lt; cd.LastTime </span><span class="cov0" title="0">{
            result.LastTime = cd.LastTime
        }</span>
    }

    // return encoded result
    <span class="cov1" title="1">switch format </span>{
    <span class="cov1" title="1">case "json":
        return json.Marshal(result)</span>
    <span class="cov0" title="0">case "hier_json":
        return module_state2.GetCdHierJson(result)</span>
    <span class="cov0" title="0">case "noah":
        return result.NoahString(), nil</span>
    <span class="cov0" title="0">default:
        return nil, fmt.Errorf("format not support: %s", format)</span>
    }
}

func processDelayOutput(stateData [][]byte, format string) ([]byte, error) <span class="cov1" title="1">{
    var result *delay_counter.DelayOutput
    var err error

    // aggregate state data
    for i := 0; i &lt; len(stateData); i ++ </span><span class="cov3" title="2">{
        delay := new(delay_counter.DelayOutput)
        if err = json.Unmarshal(stateData[i], delay); err != nil </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("json.Unmarshal():%d:%s", i, err.Error())
        }</span>
        <span class="cov3" title="2">if i == 0 </span><span class="cov1" title="1">{
            result = delay
            continue</span>
        }

        <span class="cov1" title="1">if err = result.Sum(*delay); err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
    }

    // return encoded result
    <span class="cov1" title="1">switch format </span>{
    <span class="cov1" title="1">case "json":
        return result.GetJson()</span>
    <span class="cov0" title="0">case "noah":
        return result.GetNoah(), nil</span>
    <span class="cov0" title="0">default:
        return nil, fmt.Errorf("format not support: %s", format)</span>
    }
}

func processStateData(stateData [][]byte, format string) ([]byte, error) <span class="cov1" title="1">{
    var result *module_state2.StateData

    // aggregate state data
    for i := 0; i &lt; len(stateData); i ++ </span><span class="cov3" title="2">{
        sd := new(module_state2.StateData)
        if err := json.Unmarshal(stateData[i], sd); err != nil </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("json.Unmarshal():%d:%s", i, err.Error())
        }</span>
        <span class="cov3" title="2">if i == 0 </span><span class="cov1" title="1">{
            result = sd
            continue</span>
        }
        <span class="cov1" title="1">result.SCounters.Sum(sd.SCounters)</span>
    }

    // return encoded result
    <span class="cov1" title="1">switch format </span>{
    <span class="cov1" title="1">case "json":
        return json.Marshal(result)</span>
    <span class="cov0" title="0">case "hier_json":
        return module_state2.GetSdHierJson(result)</span>
    <span class="cov0" title="0">case "noah":
        return result.NoahString(), nil</span>
    <span class="cov0" title="0">default:
        return nil, fmt.Errorf("format not support: %s", format)</span>
    }
}
</pre>
		
		<pre class="file" id="file137" style="display: none">/* monitor_handler.go - handlers for web monitor */
/*
modification history
--------------------
2014/10/8, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package bfe_monitor_proxy

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "net/http"
    "net/url"
)

const MONITOR_URL_FMT string = "http://localhost:%d/monitor/%s"

// get aggregated state for module
func (m *BfeMonitorProxy) aggreModuleStateGet(name string, stateType string, 
                                              query url.Values) ([]byte, error) <span class="cov7" title="5">{
    var stateData [][]byte
    var err error

    format := query.Get("format")
    if format == "" </span><span class="cov0" title="0">{
        format = "json"
    }</span>

    <span class="cov7" title="5">_format := format
    // get state data of all children processes
    if IsRegisterStateType(stateType) </span><span class="cov5" title="3">{
        // Note: It's convenient to convert json data to variable of type registered. 
        // After performing aggregation, we can output result in any desired format.
        _format = "json"
    }</span>

    <span class="cov7" title="5">query.Set("format", _format)
    urls := m.prepareModuleStateUrls(name, m.BfeProcessNum, query)
    stateData, err = m.getModuleStateAll(urls, _format)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // return aggregated module state in desired format
    <span class="cov7" title="5">return m.processModuleState(stateType, stateData, format)</span>
}

// prepare module state urls
func (m *BfeMonitorProxy) prepareModuleStateUrls(name string, childCount int,
                                                 query url.Values) []string <span class="cov7" title="5">{
    result := make([]string, childCount)
    for i:=0; i&lt;childCount; i++ </span><span class="cov10" title="10">{
        port := m.MonitorPorts[i]
        result[i] = monitorUrl(port, name, query)
    }</span>

    <span class="cov7" title="5">return result</span>
}

func monitorUrl(port int, name string, query url.Values) string <span class="cov10" title="10">{
    u := fmt.Sprintf(MONITOR_URL_FMT, port, name)
    q := query.Encode()

    return fmt.Sprintf("%s?%s", u, q)
}</span>

// get module states
func (m *BfeMonitorProxy) getModuleStateAll(urls []string, format string) ([][]byte, error) <span class="cov7" title="5">{
    var err error
    stateData := make([][]byte, m.BfeProcessNum)

    for i:=0; i&lt;m.BfeProcessNum; i++ </span><span class="cov10" title="10">{
        if m.MonitorDataGetter != nil </span><span class="cov10" title="10">{
            stateData[i], err = m.MonitorDataGetter(urls[i], format)
        }</span> <span class="cov0" title="0">else {
            stateData[i], err = m.getModuleState(urls[i], format)
        }</span>
        <span class="cov10" title="10">if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
    }
    <span class="cov7" title="5">return stateData, nil</span>
}

// request module state by url
func (m *BfeMonitorProxy) getModuleState(url string, format string) ([]byte, error) <span class="cov0" title="0">{
    // get request
    resp, err := http.Get(url)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov0" title="0">defer resp.Body.Close()

    // check status code
    if resp.StatusCode != 200 </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("request %s fail: %s", url, resp.Status)
    }</span>

    // check content
    <span class="cov0" title="0">data, err := ioutil.ReadAll(resp.Body)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("request %s fail: %s", url, err)
    }</span>
    <span class="cov0" title="0">if err := validateData(data, format); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("request %s fail: %s", url, err)
    }</span>

    <span class="cov0" title="0">return data, nil</span>
}

// validate module state data
func validateData(data []byte, format string) error <span class="cov10" title="10">{
    var result interface{}

    if format == "json" </span><span class="cov9" title="8">{
        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
            return err
        }</span>

        // if content has error
        <span class="cov9" title="8">value := result.(map[string]interface{})
        if value["error"] != nil </span><span class="cov0" title="0">{
            return fmt.Errorf("%s", value["error"])
        }</span>
    } <span class="cov3" title="2">else if format == "noah" </span><span class="cov3" title="2">{
        if err := json.Unmarshal(data, &amp;result); err == nil </span><span class="cov0" title="0">{
            // if content has error
            value := result.(map[string]interface{})
            if value["error"] != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", value["error"])
            }</span>
        }
    } <span class="cov0" title="0">else {
        return fmt.Errorf("unknown format: %s", format)
    }</span>

    <span class="cov10" title="10">return nil</span>
}

// process module state data
func (m *BfeMonitorProxy) processModuleState(stateType string, stateData [][]byte, format string) (
                                             []byte, error) <span class="cov7" title="5">{
    dataHandler := GetStateDataHandler(stateType)
    if dataHandler == nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("stateType %s not support", stateType)
    }</span>

    <span class="cov7" title="5">return dataHandler(stateData, format)</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">/* master_reload_handler.go - implemention for master to distribution reload to children */
/*
modification history
--------------------
2014/10/8, by Weiwei, create
*/
/*
DESCRIPTION
*/

package bfe_monitor_proxy

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "net/http"
    "net/url"
)

import (
        "www.baidu.com/golang-lib/log"
)

// create reload handlers;
// return reloadChildren with name binding
func (m *BfeMonitorProxy) createReloadHandler(name string) (func(params url.Values) error) <span class="cov9" title="11">{
    return func(params url.Values) error </span><span class="cov0" title="0">{
        return m.reloadChildren(name, params)
    }</span>
}

// trigger children to reload
// params:
//   - name, class of data to reload, also suffix of request path
//      path = /reload/$name
//   - params, http reload request query params
// return:
//   err : 
func (m *BfeMonitorProxy) reloadChildren(name string, params url.Values) error <span class="cov0" title="0">{
    // prepare reload worker urls
    url := url.URL {
        Scheme: "http",
        Path : fmt.Sprintf("/reload/%s", name),
        RawQuery: params.Encode(),
    }
    urls := m.prepareReloadUrls(url, m.BfeProcessNum)

    // trigger reload
    err := reloadChildren(urls)
    if err != nil </span><span class="cov0" title="0">{
        // reload failed
        return err
    }</span>

    <span class="cov0" title="0">return nil</span>
}

// prepare URLs for children, saved in a slice
// for children, URL only differ in port
func (m *BfeMonitorProxy) prepareReloadUrls(u url.URL, childCount int) []url.URL <span class="cov1" title="1">{
    result := make([]url.URL, childCount)
    for i:=0; i&lt;childCount; i++ </span><span class="cov5" title="4">{
        // localhost:slaveport
        host := fmt.Sprintf("localhost:%d", m.MonitorPorts[i])
        u.Host = host
        result[i] = u
    }</span>

    <span class="cov1" title="1">return result</span>
}

// reload children on given urls
func reloadChildren(urls []url.URL) error <span class="cov3" title="2">{
    for i, u := range(urls) </span><span class="cov9" title="12">{
        if err := reloadChild(u.String()); err != nil </span><span class="cov1" title="1">{
            log.Logger.Warn("reload %d child [%s] error [%s]", i, u, err)
            return err
        }</span>

        <span class="cov9" title="11">log.Logger.Info("reload %d child [%s] success", i, u)</span>
    }

    <span class="cov1" title="1">return nil</span>
}

// reload a child on given url
func reloadChild(u string) error <span class="cov10" title="14">{
    // should use post?
    resp, err := http.Get(u)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov10" title="14">defer resp.Body.Close()

    // not return 200
    if resp.StatusCode != 200 </span><span class="cov0" title="0">{
        return fmt.Errorf("request %s fail: %s", u, resp.Status)
    }</span>

    // check return error is not nil

    <span class="cov10" title="14">buf, err := ioutil.ReadAll(resp.Body)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("request %s fail: readall %s", u, err)
    }</span>

    // return resp has a field Error
    <span class="cov10" title="14">type ReloadResp struct {
        Error *string   // error msg return from bfe
    }

    // unmarshal json
    var reloadResp ReloadResp
    err = json.Unmarshal(buf, &amp;reloadResp)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("response unmarshal err %s", err)
    }</span>

    // check err field in body
    <span class="cov10" title="14">if reloadResp.Error != nil &amp;&amp; *reloadResp.Error != "" </span><span class="cov3" title="2">{
        return fmt.Errorf("%s", *reloadResp.Error)
    }</span>

    <span class="cov9" title="12">return nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">/* web_monitor_proxy.go - monitor proxy for bfe processes */
/*
modification history
--------------------
2014/10/8, by Sijie YANG, create
*/
/*
DESCRIPTION
*/
package bfe_monitor_proxy

import (
        "fmt"
        "net/url"
)

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_basic"
        "bfe_config/bfe_conf"
        "bfe_module"
        "bfe_modules"
)

// function prototype for getting monitor data
type DataGetter func(url string, format string) ([]byte, error)

// Every bfe children process has its own web monitor.
// BfeMonitorProxy is a proxy for these monitors.
// It aggregates information from bfe children web monitors.
type BfeMonitorProxy struct {
        WebServer     *web_monitor.MonitorServer
        WebHandlers   *web_monitor.WebHandlers
        BfeProcessNum int // BfeMonitorProxy works as proxy for all
        // bfe children processes. BfeProcessNum is the
        // num of children processes.
        MonitorPorts []int // Each bfe children process has a web monitor,
        // MonitorPorts collects all these monitors
        // listening ports.

        Modules        *bfe_module.BfeModules // bfe modules
        ModulesEnabled []string               // enabled modules for children processes

        MonitorDataGetter DataGetter // handler for requesting data
}

// initialize moniter web server for master bfe process
func NewBfeMonitorProxy(cfg bfe_conf.BfeConfig, bfeProcessNum int,
        ports []int, version string) (*BfeMonitorProxy, error) <span class="cov1" title="1">{
        m := new(BfeMonitorProxy)
        m.BfeProcessNum = bfeProcessNum

        // bfe children process monitor ports
        m.MonitorPorts = make([]int, bfeProcessNum)
        for i, port := range ports </span><span class="cov2" title="2">{
                m.MonitorPorts[i] = port
        }</span>

        // initialize modules
        <span class="cov1" title="1">m.Modules = bfe_module.NewBfeModules()
        m.ModulesEnabled = cfg.Server.Modules
        m.registerModules(m.ModulesEnabled)

        // initialize web handlers
        m.WebHandlers = web_monitor.NewWebHandlers()
        if err := m.WebHandlersInit(); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("NewBfeMonitorProxy(): in WebHandlersInit(): ", err.Error())
                return nil, err
        }</span>

        // initialize web server
        <span class="cov1" title="1">m.WebServer = web_monitor.NewMonitorServer("go-bfe", version, cfg.Server.MonitorPort)
        m.WebServer.HandlersSet(m.WebHandlers)

        return m, nil</span>
}

// register enabled modules
func (m *BfeMonitorProxy) registerModules(modules []string) <span class="cov1" title="1">{
        bfe_modules.SetModules()

        for _, module := range modules </span><span class="cov5" title="6">{
                if err := m.Modules.RegisterModule(module); err != nil </span><span class="cov1" title="1">{
                        log.Logger.Warn("register modules: %s", err.Error())
                }</span>
        }
}

// get attribution for module
func (m *BfeMonitorProxy) getModuleAttr(moduleName, attrName string) (interface{}, error) <span class="cov8" title="18">{
        module := m.Modules.GetModule(moduleName)
        if module == nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("module [%s] not exist", moduleName)
        }</span>

        <span class="cov7" title="15">attrs := module.Attr()
        if attrs == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("module [%s] attributions not provided", moduleName)
        }</span>

        <span class="cov7" title="15">value, ok := attrs[attrName]
        if !ok </span><span class="cov5" title="5">{
                return nil, fmt.Errorf("module [%s] attribution not exist: %s", moduleName, attrName)
        }</span>
        <span class="cov6" title="10">return value, nil</span>
}

// get monitor items for module
func (m *BfeMonitorProxy) getMonitorItems(name string) (map[string]string, error) <span class="cov7" title="12">{
        value, err := m.getModuleAttr(name, bfe_basic.MON_ATTR_MONITOR)
        if err != nil </span><span class="cov5" title="6">{
                return nil, err
        }</span>

        <span class="cov5" title="6">monitorItems, ok := value.(map[string]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong type for attr %s: %T",
                        bfe_basic.MON_ATTR_MONITOR, value)
        }</span>
        <span class="cov5" title="6">return monitorItems, nil</span>
}

// get reload items for module
func (m *BfeMonitorProxy) getReloadItems(name string) ([]string, error) <span class="cov5" title="6">{
        value, err := m.getModuleAttr(name, bfe_basic.MON_ATTR_RELOAD)
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="4">reloadItems, ok := value.([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong type for attr %s: %T",
                        bfe_basic.MON_ATTR_RELOAD, value)
        }</span>
        <span class="cov4" title="4">return reloadItems, nil</span>
}

/* createMonitorHandler - Create monitor handler
 *
 * Params:
 *     - name: module name
 *     - stateType: type of module state
 *
 * Returns:
 *     - monitor handler
 */
func (m *BfeMonitorProxy) createMonitorHandler(name string, stateType string) func(url.Values) ([]byte, error) <span class="cov10" title="36">{

        return func(query url.Values) ([]byte, error) </span><span class="cov5" title="5">{
                return m.aggreModuleStateGet(name, stateType, query)
        }</span>
}

// all monitor handlers
func (m *BfeMonitorProxy) monitorHandlers() map[string]interface{} <span class="cov2" title="2">{
        handlers := map[string]interface{}{
                // for proxy_state
                bfe_basic.MON_ITEM_PROXY_STATE: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_STATE,
                        bfe_basic.MON_TYPE_STATE),
                bfe_basic.MON_ITEM_PROXY_STATE_DIFF: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_STATE_DIFF,
                        bfe_basic.MON_TYPE_COUNTER_SLICE),

                // for proxy mem stat
                bfe_basic.MON_ITEM_PROXY_MEM_STAT: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_MEM_STAT,
                        bfe_basic.MON_TYPE_DEFAULT),

                // for proxy_delay
                bfe_basic.MON_ITEM_PROXY_DELAY: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_DELAY,
                        bfe_basic.MON_TYPE_DELAY_RECENT),

                bfe_basic.MON_ITEM_PROXY_POST_DELAY: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_POST_DELAY,
                        bfe_basic.MON_TYPE_DELAY_RECENT),

                bfe_basic.MON_ITEM_PROXY_HANDSHAKE_DELAY: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_HANDSHAKE_DELAY,
                        bfe_basic.MON_TYPE_DELAY_RECENT),

                bfe_basic.MON_ITEM_PROXY_HANDSHAKE_FULL_DELAY: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_HANDSHAKE_FULL_DELAY,
                        bfe_basic.MON_TYPE_DELAY_RECENT),

                bfe_basic.MON_ITEM_PROXY_HANDSHAKE_RESUME_DELAY: m.createMonitorHandler(bfe_basic.MON_ITEM_PROXY_HANDSHAKE_RESUME_DELAY,
                        bfe_basic.MON_TYPE_DELAY_RECENT),
                // for cluster
                bfe_basic.MON_ITEM_CLUSTER_TABLE_VERSION: m.createMonitorHandler(bfe_basic.MON_ITEM_CLUSTER_TABLE_VERSION,
                        bfe_basic.MON_TYPE_DEFAULT),
                // for balance
                bfe_basic.MON_ITEM_BAL_TABLE_STATUS: m.createMonitorHandler(bfe_basic.MON_ITEM_BAL_TABLE_STATUS,
                        bfe_basic.MON_TYPE_DEFAULT),
                bfe_basic.MON_ITEM_BAL_TABLE_VERSION: m.createMonitorHandler(bfe_basic.MON_ITEM_BAL_TABLE_VERSION,
                        bfe_basic.MON_TYPE_DEFAULT),

                // for host
                bfe_basic.MON_ITEM_HOST_TABLE_STATUS: m.createMonitorHandler(bfe_basic.MON_ITEM_HOST_TABLE_STATUS,
                        bfe_basic.MON_TYPE_DEFAULT),
                bfe_basic.MON_ITEM_HOST_TABLE_VERSION: m.createMonitorHandler(bfe_basic.MON_ITEM_HOST_TABLE_VERSION,
                        bfe_basic.MON_TYPE_DEFAULT),

                // for module status
                bfe_basic.MON_ITEM_MODULE_STATUS: m.createMonitorHandler(bfe_basic.MON_ITEM_MODULE_STATUS,
                        bfe_basic.MON_TYPE_DEFAULT),

                // for process information
                bfe_basic.MON_ITEM_PROCESS_STATE: m.createMonitorHandler(bfe_basic.MON_ITEM_PROCESS_STATE,
                        bfe_basic.MON_TYPE_DEFAULT),
        }

        // for modules enabled
        for _, name := range m.ModulesEnabled </span><span class="cov7" title="12">{
                monitorItems, err := m.getMonitorItems(name)
                if err != nil </span><span class="cov5" title="6">{ // ignore
                        log.Logger.Debug("getMonitorItems(): %s", err.Error())
                        continue</span>
                }

                <span class="cov5" title="6">for itemName, itemType := range monitorItems </span><span class="cov5" title="6">{
                        handlers[itemName] = m.createMonitorHandler(itemName, itemType)
                }</span>
        }

        <span class="cov2" title="2">return handlers</span>
}

// all reload handlers
func (m *BfeMonitorProxy) reloadHandlers() map[string]interface{} <span class="cov1" title="1">{
        handlers := map[string]interface{}{
                // for server data conf
                "server_data_conf": m.createReloadHandler("server_data_conf"),

                // for gslb data conf
                "gslb_data_conf": m.createReloadHandler("gslb_data_conf"),

                // for tls
                "tls_session_ticket_key": m.createReloadHandler("tls_session_ticket_key"),
                "tls_certificate":        m.createReloadHandler("tls_certificate"),
                "tls_ocsp_staple":        m.createReloadHandler("tls_ocsp_staple"),
                "tls_next_protos":        m.createReloadHandler("tls_next_protos"),
        }

        // for modules enabled
        for _, name := range m.ModulesEnabled </span><span class="cov5" title="6">{
                reloadItems, err := m.getReloadItems(name)
                if err != nil </span><span class="cov2" title="2">{ // ignore
                        log.Logger.Debug("getReloadItems(): %s", err.Error())
                        continue</span>
                }

                <span class="cov4" title="4">for _, itemName := range reloadItems </span><span class="cov5" title="5">{
                        handlers[itemName] = m.createReloadHandler(itemName)
                }</span>
        }

        <span class="cov1" title="1">return handlers</span>
}

func (m *BfeMonitorProxy) WebHandlersInit() error <span class="cov2" title="2">{
        // register handlers for monitor
        err := web_monitor.RegisterHandlers(m.WebHandlers, web_monitor.WEB_HANDLE_MONITOR,
                m.monitorHandlers())
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // register handlers for reload
        <span class="cov1" title="1">err = web_monitor.RegisterHandlers(m.WebHandlers, web_monitor.WEB_HANDLE_RELOAD,
                m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return err</span>
}

// start web monitor in new goroutine
func (m *BfeMonitorProxy) Start() chan error <span class="cov1" title="1">{
        status := make(chan error)
        go m.startWebMonitor(status)

        return status
}</span>

func (m *BfeMonitorProxy) startWebMonitor(status chan error) <span class="cov1" title="1">{
        err := m.WebServer.ListenAndServe()
        status &lt;- err
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

// A MIMEHeader represents a MIME-style header mapping
// keys to sets of values.
type MIMEHeader map[string][]string

// A MIMEKyes represents keys of header in orginal order
type MIMEKeys []string

// Add adds the key, value pair to the header.
// It appends to any existing values associated with key.
func (h MIMEHeader) Add(key, value string) <span class="cov0" title="0">{
        key = CanonicalMIMEHeaderKey(key)
        h[key] = append(h[key], value)
}</span>

// Set sets the header entries associated with key to
// the single element value.  It replaces any existing
// values associated with key.
func (h MIMEHeader) Set(key, value string) <span class="cov0" title="0">{
        h[CanonicalMIMEHeaderKey(key)] = []string{value}
}</span>

// Get gets the first value associated with the given key.
// If there are no values associated with the key, Get returns "".
// Get is a convenience method.  For more complex queries,
// access the map directly.
func (h MIMEHeader) Get(key string) string <span class="cov8" title="1">{
        if h == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">v := h[CanonicalMIMEHeaderKey(key)]
        if len(v) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return v[0]</span>
}

// Del deletes the values associated with key.
func (h MIMEHeader) Del(key string) <span class="cov0" title="0">{
        delete(h, CanonicalMIMEHeaderKey(key))
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

import (
        "sync"
)

// A Pipeline manages a pipelined in-order request/response sequence.
//
// To use a Pipeline p to manage multiple clients on a connection,
// each client should run:
//
//        id := p.Next()        // take a number
//
//        p.StartRequest(id)        // wait for turn to send request
//        send request
//        p.EndRequest(id)        // notify Pipeline that request is sent
//
//        p.StartResponse(id)        // wait for turn to read response
//        read response
//        p.EndResponse(id)        // notify Pipeline that response is read
//
// A pipelined server can use the same calls to ensure that
// responses computed in parallel are written in the correct order.
type Pipeline struct {
        mu       sync.Mutex
        id       uint
        request  sequencer
        response sequencer
}

// Next returns the next id for a request/response pair.
func (p *Pipeline) Next() uint <span class="cov0" title="0">{
        p.mu.Lock()
        id := p.id
        p.id++
        p.mu.Unlock()
        return id
}</span>

// StartRequest blocks until it is time to send (or, if this is a server, receive)
// the request with the given id.
func (p *Pipeline) StartRequest(id uint) <span class="cov0" title="0">{
        p.request.Start(id)
}</span>

// EndRequest notifies p that the request with the given id has been sent
// (or, if this is a server, received).
func (p *Pipeline) EndRequest(id uint) <span class="cov0" title="0">{
        p.request.End(id)
}</span>

// StartResponse blocks until it is time to receive (or, if this is a server, send)
// the request with the given id.
func (p *Pipeline) StartResponse(id uint) <span class="cov0" title="0">{
        p.response.Start(id)
}</span>

// EndResponse notifies p that the response with the given id has been received
// (or, if this is a server, sent).
func (p *Pipeline) EndResponse(id uint) <span class="cov0" title="0">{
        p.response.End(id)
}</span>

// A sequencer schedules a sequence of numbered events that must
// happen in order, one after the other.  The event numbering must start
// at 0 and increment without skipping.  The event number wraps around
// safely as long as there are not 2^32 simultaneous events pending.
type sequencer struct {
        mu   sync.Mutex
        id   uint
        wait map[uint]chan uint
}

// Start waits until it is time for the event numbered id to begin.
// That is, except for the first event, it waits until End(id-1) has
// been called.
func (s *sequencer) Start(id uint) <span class="cov0" title="0">{
        s.mu.Lock()
        if s.id == id </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">c := make(chan uint)
        if s.wait == nil </span><span class="cov0" title="0">{
                s.wait = make(map[uint]chan uint)
        }</span>
        <span class="cov0" title="0">s.wait[id] = c
        s.mu.Unlock()
        &lt;-c</span>
}

// End notifies the sequencer that the event numbered id has completed,
// allowing it to schedule the event numbered id+1.  It is a run-time error
// to call End with an id that is not the number of the active event.
func (s *sequencer) End(id uint) <span class="cov0" title="0">{
        s.mu.Lock()
        if s.id != id </span><span class="cov0" title="0">{
                panic("out of sync")
        }</span>
        <span class="cov0" title="0">id++
        s.id = id
        if s.wait == nil </span><span class="cov0" title="0">{
                s.wait = make(map[uint]chan uint)
        }</span>
        <span class="cov0" title="0">c, ok := s.wait[id]
        if ok </span><span class="cov0" title="0">{
                delete(s.wait, id)
        }</span>
        <span class="cov0" title="0">s.mu.Unlock()
        if ok </span><span class="cov0" title="0">{
                c &lt;- 1
        }</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">/* reader.go - text-based protocol message reader */
/*
modification history
--------------------
2014/11/19, by Sijie Yang, modify, add ReadMIMEHeaderAndKeys()
    - Note: HeaderKeys is required by mod_header_defence
*/
/*
DESCRIPTION
*/

// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

import (
        "bytes"
        "io"
        "io/ioutil"
        "strconv"
        "strings"
)

import (
        "bfe_bufio"    
)

// BUG(rsc): To let callers manage exposure to denial of service
// attacks, Reader should allow them to set and reset a limit on
// the number of bytes read from the connection.

// A Reader implements convenience methods for reading requests
// or responses from a text protocol network connection.
type Reader struct {
        R   *bfe_bufio.Reader
        dot *dotReader
        buf []byte // a re-usable buffer for readContinuedLineSlice
}

// NewReader returns a new Reader reading from r.
func NewReader(r *bfe_bufio.Reader) *Reader <span class="cov4" title="13">{
        return &amp;Reader{R: r}
}</span>

// ReadLine reads a single line from r,
// eliding the final \n or \r\n from the returned string.
func (r *Reader) ReadLine() (string, error) <span class="cov5" title="26">{
        line, err := r.readLineSlice()
        return string(line), err
}</span>

// ReadLineBytes is like ReadLine but returns a []byte instead of a string.
func (r *Reader) ReadLineBytes() ([]byte, error) <span class="cov0" title="0">{
        line, err := r.readLineSlice()
        if line != nil </span><span class="cov0" title="0">{
                buf := make([]byte, len(line))
                copy(buf, line)
                line = buf
        }</span>
        <span class="cov0" title="0">return line, err</span>
}

func (r *Reader) readLineSlice() ([]byte, error) <span class="cov6" title="46">{
        r.closeDot()
        var line []byte
        for </span><span class="cov6" title="50">{
                l, more, err := r.R.ReadLine()
                if err != nil </span><span class="cov3" title="4">{
                        return nil, err
                }</span>
                // Avoid the copy if the first call produced a full line.
                <span class="cov6" title="46">if line == nil &amp;&amp; !more </span><span class="cov6" title="41">{
                        return l, nil
                }</span>
                <span class="cov3" title="5">line = append(line, l...)
                if !more </span><span class="cov1" title="1">{
                        break</span>
                }
        }
        <span class="cov1" title="1">return line, nil</span>
}

// ReadContinuedLine reads a possibly continued line from r,
// eliding the final trailing ASCII white space.
// Lines after the first are considered continuations if they
// begin with a space or tab character.  In the returned data,
// continuation lines are separated from the previous line
// only by a single space: the newline and leading white space
// are removed.
//
// For example, consider this input:
//
//        Line 1
//          continued...
//        Line 2
//
// The first call to ReadContinuedLine will return "Line 1 continued..."
// and the second will return "Line 2".
//
// A line consisting of only white space is never continued.
//
func (r *Reader) ReadContinuedLine() (string, error) <span class="cov3" title="4">{
        line, err := r.readContinuedLineSlice()
        return string(line), err
}</span>

// trim returns s with leading and trailing spaces and tabs removed.
// It does not assume Unicode or UTF-8.
func trim(s []byte) []byte <span class="cov4" title="13">{
        i := 0
        for i &lt; len(s) &amp;&amp; (s[i] == ' ' || s[i] == '\t') </span><span class="cov0" title="0">{
                i++
        }</span>
        <span class="cov4" title="13">n := len(s)
        for n &gt; i &amp;&amp; (s[n-1] == ' ' || s[n-1] == '\t') </span><span class="cov2" title="3">{
                n--
        }</span>
        <span class="cov4" title="13">return s[i:n]</span>
}

// ReadContinuedLineBytes is like ReadContinuedLine but
// returns a []byte instead of a string.
func (r *Reader) ReadContinuedLineBytes() ([]byte, error) <span class="cov0" title="0">{
        line, err := r.readContinuedLineSlice()
        if line != nil </span><span class="cov0" title="0">{
                buf := make([]byte, len(line))
                copy(buf, line)
                line = buf
        }</span>
        <span class="cov0" title="0">return line, err</span>
}

func (r *Reader) readContinuedLineSlice() ([]byte, error) <span class="cov5" title="18">{
        // Read the first line.
        line, err := r.readLineSlice()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="17">if len(line) == 0 </span><span class="cov3" title="4">{ // blank line - no continuation
                return line, nil
        }</span>

        // Optimistically assume that we have started to buffer the next line
        // and it starts with an ASCII letter (the next header key), so we can
        // avoid copying that buffered data around in memory and skipping over
        // non-existent whitespace.
        <span class="cov4" title="13">if r.R.Buffered() &gt; 1 </span><span class="cov4" title="9">{
                peek, err := r.R.Peek(1)
                if err == nil &amp;&amp; isASCIILetter(peek[0]) </span><span class="cov3" title="6">{
                        return trim(line), nil
                }</span>
        }

        // ReadByte or the next readLineSlice will flush the read buffer;
        // copy the slice into buf.
        <span class="cov3" title="7">r.buf = append(r.buf[:0], trim(line)...)

        // Read continuation lines.
        for r.skipSpace() &gt; 0 </span><span class="cov2" title="2">{
                line, err := r.readLineSlice()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov2" title="2">r.buf = append(r.buf, ' ')
                r.buf = append(r.buf, line...)</span>
        }
        <span class="cov3" title="7">return r.buf, nil</span>
}

// skipSpace skips R over all spaces and returns the number of bytes skipped.
func (r *Reader) skipSpace() int <span class="cov4" title="9">{
        n := 0
        for </span><span class="cov4" title="11">{
                c, err := r.R.ReadByte()
                if err != nil </span><span class="cov1" title="1">{
                        // Bufio will keep err until next read.
                        break</span>
                }
                <span class="cov4" title="10">if c != ' ' &amp;&amp; c != '\t' </span><span class="cov4" title="8">{
                        r.R.UnreadByte()
                        break</span>
                }
                <span class="cov2" title="2">n++</span>
        }
        <span class="cov4" title="9">return n</span>
}

func (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error) <span class="cov4" title="8">{
        line, err := r.ReadLine()
        if err != nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov3" title="7">return parseCodeLine(line, expectCode)</span>
}

func parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error) <span class="cov4" title="13">{
        if len(line) &lt; 4 || line[3] != ' ' &amp;&amp; line[3] != '-' </span><span class="cov1" title="1">{
                err = ProtocolError("short response: " + line)
                return
        }</span>
        <span class="cov4" title="12">continued = line[3] == '-'
        code, err = strconv.Atoi(line[0:3])
        if err != nil || code &lt; 100 </span><span class="cov0" title="0">{
                err = ProtocolError("invalid response code: " + line)
                return
        }</span>
        <span class="cov4" title="12">message = line[4:]
        if 1 &lt;= expectCode &amp;&amp; expectCode &lt; 10 &amp;&amp; code/100 != expectCode ||
                10 &lt;= expectCode &amp;&amp; expectCode &lt; 100 &amp;&amp; code/10 != expectCode ||
                100 &lt;= expectCode &amp;&amp; expectCode &lt; 1000 &amp;&amp; code != expectCode </span><span class="cov1" title="1">{
                err = &amp;Error{code, message}
        }</span>
        <span class="cov4" title="12">return</span>
}

// ReadCodeLine reads a response code line of the form
//        code message
// where code is a three-digit status code and the message
// extends to the rest of the line.  An example of such a line is:
//        220 plan9.bell-labs.com ESMTP
//
// If the prefix of the status does not match the digits in expectCode,
// ReadCodeLine returns with err set to &amp;Error{code, message}.
// For example, if expectCode is 31, an error will be returned if
// the status is not in the range [310,319].
//
// If the response is multi-line, ReadCodeLine returns an error.
//
// An expectCode &lt;= 0 disables the check of the status code.
//
func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error) <span class="cov3" title="4">{
        code, continued, message, err := r.readCodeLine(expectCode)
        if err == nil &amp;&amp; continued </span><span class="cov0" title="0">{
                err = ProtocolError("unexpected multi-line response: " + message)
        }</span>
        <span class="cov3" title="4">return</span>
}

// ReadResponse reads a multi-line response of the form:
//
//        code-message line 1
//        code-message line 2
//        ...
//        code message line n
//
// where code is a three-digit status code. The first line starts with the
// code and a hyphen. The response is terminated by a line that starts
// with the same code followed by a space. Each line in message is
// separated by a newline (\n).
//
// See page 36 of RFC 959 (http://www.ietf.org/rfc/rfc959.txt) for
// details.
//
// If the prefix of the status does not match the digits in expectCode,
// ReadResponse returns with err set to &amp;Error{code, message}.
// For example, if expectCode is 31, an error will be returned if
// the status is not in the range [310,319].
//
// An expectCode &lt;= 0 disables the check of the status code.
//
func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error) <span class="cov3" title="4">{
        code, continued, message, err := r.readCodeLine(expectCode)
        for err == nil &amp;&amp; continued </span><span class="cov3" title="6">{
                line, err := r.ReadLine()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, "", err
                }</span>

                <span class="cov3" title="6">var code2 int
                var moreMessage string
                code2, continued, moreMessage, err = parseCodeLine(line, expectCode)
                if err != nil || code2 != code </span><span class="cov1" title="1">{
                        message += "\n" + strings.TrimRight(line, "\r\n")
                        continued = true
                        continue</span>
                }
                <span class="cov3" title="5">message += "\n" + moreMessage</span>
        }
        <span class="cov3" title="4">return</span>
}

// DotReader returns a new Reader that satisfies Reads using the
// decoded text of a dot-encoded block read from r.
// The returned Reader is only valid until the next call
// to a method on r.
//
// Dot encoding is a common framing used for data blocks
// in text protocols such as SMTP.  The data consists of a sequence
// of lines, each of which ends in "\r\n".  The sequence itself
// ends at a line containing just a dot: ".\r\n".  Lines beginning
// with a dot are escaped with an additional dot to avoid
// looking like the end of the sequence.
//
// The decoded form returned by the Reader's Read method
// rewrites the "\r\n" line endings into the simpler "\n",
// removes leading dot escapes if present, and stops with error io.EOF
// after consuming (and discarding) the end-of-sequence line.
func (r *Reader) DotReader() io.Reader <span class="cov2" title="2">{
        r.closeDot()
        r.dot = &amp;dotReader{r: r}
        return r.dot
}</span>

type dotReader struct {
        r     *Reader
        state int
}

// Read satisfies reads by decoding dot-encoded data read from d.r.
func (d *dotReader) Read(b []byte) (n int, err error) <span class="cov2" title="2">{
        // Run data through a simple state machine to
        // elide leading dots, rewrite trailing \r\n into \n,
        // and detect ending .\r\n line.
        const (
                stateBeginLine = iota // beginning of line; initial state; must be zero
                stateDot              // read . at beginning of line
                stateDotCR            // read .\r at beginning of line
                stateCR               // read \r (possibly at end of line)
                stateData             // reading data in middle of line
                stateEOF              // reached .\r\n end marker line
        )
        br := d.r.R
        for n &lt; len(b) &amp;&amp; d.state != stateEOF </span><span class="cov6" title="51">{
                var c byte
                c, err = br.ReadByte()
                if err != nil </span><span class="cov1" title="1">{
                        if err == io.EOF </span><span class="cov1" title="1">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov1" title="1">break</span>
                }
                <span class="cov6" title="50">switch d.state </span>{
                <span class="cov4" title="8">case stateBeginLine:
                        if c == '.' </span><span class="cov3" title="4">{
                                d.state = stateDot
                                continue</span>
                        }
                        <span class="cov3" title="4">if c == '\r' </span><span class="cov1" title="1">{
                                d.state = stateCR
                                continue</span>
                        }
                        <span class="cov2" title="3">d.state = stateData</span>

                <span class="cov3" title="4">case stateDot:
                        if c == '\r' </span><span class="cov1" title="1">{
                                d.state = stateDotCR
                                continue</span>
                        }
                        <span class="cov2" title="3">if c == '\n' </span><span class="cov0" title="0">{
                                d.state = stateEOF
                                continue</span>
                        }
                        <span class="cov2" title="3">d.state = stateData</span>

                <span class="cov1" title="1">case stateDotCR:
                        if c == '\n' </span><span class="cov1" title="1">{
                                d.state = stateEOF
                                continue</span>
                        }
                        // Not part of .\r\n.
                        // Consume leading dot and emit saved \r.
                        <span class="cov0" title="0">br.UnreadByte()
                        c = '\r'
                        d.state = stateData</span>

                <span class="cov3" title="5">case stateCR:
                        if c == '\n' </span><span class="cov3" title="5">{
                                d.state = stateBeginLine
                                break</span>
                        }
                        // Not part of \r\n.  Emit saved \r
                        <span class="cov0" title="0">br.UnreadByte()
                        c = '\r'
                        d.state = stateData</span>

                <span class="cov6" title="32">case stateData:
                        if c == '\r' </span><span class="cov3" title="4">{
                                d.state = stateCR
                                continue</span>
                        }
                        <span class="cov5" title="28">if c == '\n' </span><span class="cov2" title="2">{
                                d.state = stateBeginLine
                        }</span>
                }
                <span class="cov6" title="39">b[n] = c
                n++</span>
        }
        <span class="cov2" title="2">if err == nil &amp;&amp; d.state == stateEOF </span><span class="cov1" title="1">{
                err = io.EOF
        }</span>
        <span class="cov2" title="2">if err != nil &amp;&amp; d.r.dot == d </span><span class="cov2" title="2">{
                d.r.dot = nil
        }</span>
        <span class="cov2" title="2">return</span>
}

// closeDot drains the current DotReader if any,
// making sure that it reads until the ending dot line.
func (r *Reader) closeDot() <span class="cov6" title="48">{
        if r.dot == nil </span><span class="cov6" title="48">{
                return
        }</span>
        <span class="cov0" title="0">buf := make([]byte, 128)
        for r.dot != nil </span><span class="cov0" title="0">{
                // When Read reaches EOF or an error,
                // it will set r.dot == nil.
                r.dot.Read(buf)
        }</span>
}

// ReadDotBytes reads a dot-encoding and returns the decoded data.
//
// See the documentation for the DotReader method for details about dot-encoding.
func (r *Reader) ReadDotBytes() ([]byte, error) <span class="cov2" title="2">{
        return ioutil.ReadAll(r.DotReader())
}</span>

// ReadDotLines reads a dot-encoding and returns a slice
// containing the decoded lines, with the final \r\n or \n elided from each.
//
// See the documentation for the DotReader method for details about dot-encoding.
func (r *Reader) ReadDotLines() ([]string, error) <span class="cov2" title="2">{
        // We could use ReadDotBytes and then Split it,
        // but reading a line at a time avoids needing a
        // large contiguous block of memory and is simpler.
        var v []string
        var err error
        for </span><span class="cov4" title="9">{
                var line string
                line, err = r.ReadLine()
                if err != nil </span><span class="cov1" title="1">{
                        if err == io.EOF </span><span class="cov1" title="1">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov1" title="1">break</span>
                }

                // Dot by itself marks end; otherwise cut one dot.
                <span class="cov4" title="8">if len(line) &gt; 0 &amp;&amp; line[0] == '.' </span><span class="cov3" title="4">{
                        if len(line) == 1 </span><span class="cov1" title="1">{
                                break</span>
                        }
                        <span class="cov2" title="3">line = line[1:]</span>
                }
                <span class="cov3" title="7">v = append(v, line)</span>
        }
        <span class="cov2" title="2">return v, err</span>
}

// ReadMIMEHeader reads a MIME-style header from r.
// The header is a sequence of possibly continued Key: Value lines
// ending in a blank line.
// The returned map m maps CanonicalMIMEHeaderKey(key) to a
// sequence of values in the same order encountered in the input.
//
// For example, consider this input:
//
//        My-Key: Value 1
//        Long-Key: Even
//               Longer Value
//        My-Key: Value 2
//
// Given that input, ReadMIMEHeader returns the map:
//
//        map[string][]string{
//                "My-Key": {"Value 1", "Value 2"},
//                "Long-Key": {"Even Longer Value"},
//        }
//
func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) <span class="cov3" title="4">{
        header, _, err := r.ReadMIMEHeaderAndKeys()
        return header, err
}</span>

func (r *Reader) ReadMIMEHeaderAndKeys() (MIMEHeader, MIMEKeys, error) <span class="cov3" title="4">{
        // Avoid lots of small slice allocations later by allocating one
        // large one ahead of time which we'll cut up into smaller
        // slices. If this isn't big enough later, we allocate small ones.
        var strs []string
        hint := r.upcomingHeaderNewlines()
        if hint &gt; 0 </span><span class="cov2" title="3">{
                strs = make([]string, hint)
        }</span>

        <span class="cov3" title="4">m := make(MIMEHeader, hint)
        mkeys := make(MIMEKeys, 0, hint)
        for </span><span class="cov4" title="14">{
                kv, err := r.readContinuedLineSlice()
                if len(kv) == 0 </span><span class="cov3" title="4">{
                        return m, mkeys, err
                }</span>

                // Key ends at first colon; should not have spaces but
                // they appear in the wild, violating specs, so we
                // remove them if present.
                <span class="cov4" title="10">i := bytes.IndexByte(kv, ':')
                if i &lt; 0 </span><span class="cov0" title="0">{
                        return m, mkeys, ProtocolError("malformed MIME header line: " + string(kv))
                }</span>
                <span class="cov4" title="10">endKey := i
                for endKey &gt; 0 &amp;&amp; kv[endKey-1] == ' ' </span><span class="cov2" title="3">{
                        endKey--
                }</span>
                <span class="cov4" title="10">key := canonicalMIMEHeaderKey(kv[:endKey])

                // Skip initial spaces in value.
                i++ // skip colon
                for i &lt; len(kv) &amp;&amp; (kv[i] == ' ' || kv[i] == '\t') </span><span class="cov4" title="10">{
                        i++
                }</span>
                <span class="cov4" title="10">value := string(kv[i:])

                vv := m[key]
                if vv == nil &amp;&amp; len(strs) &gt; 0 </span><span class="cov4" title="8">{
                        // More than likely this will be a single-element key.
                        // Most headers aren't multi-valued.
                        // Set the capacity on strs[0] to 1, so any future append
                        // won't extend the slice into the other strings.
                        vv, strs = strs[:1:1], strs[1:]
                        vv[0] = value
                        m[key] = vv
                }</span> <span class="cov2" title="2">else {
                        m[key] = append(vv, value)
                }</span>

                // append key in orginal order
                <span class="cov4" title="10">mkeys = append(mkeys, key)

                if err != nil </span><span class="cov0" title="0">{
                        return m, mkeys, err
                }</span>
        }
}

// upcomingHeaderNewlines returns an approximation of the number of newlines
// that will be in this header. If it gets confused, it returns 0.
func (r *Reader) upcomingHeaderNewlines() (n int) <span class="cov3" title="4">{
        // Try to determine the 'hint' size.
        r.R.Peek(1) // force a buffer load if empty
        s := r.R.Buffered()
        if s == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="4">peek, _ := r.R.Peek(s)
        for len(peek) &gt; 0 </span><span class="cov4" title="14">{
                i := bytes.IndexByte(peek, '\n')
                if i &lt; 3 </span><span class="cov3" title="4">{
                        // Not present (-1) or found within the next few bytes,
                        // implying we're at the end ("\r\n\r\n" or "\n\n")
                        return
                }</span>
                <span class="cov4" title="10">n++
                peek = peek[i+1:]</span>
        }
        <span class="cov0" title="0">return</span>
}

// CanonicalMIMEHeaderKey returns the canonical format of the
// MIME header key s.  The canonicalization converts the first
// letter and any letter following a hyphen to upper case;
// the rest are converted to lowercase.  For example, the
// canonical key for "accept-encoding" is "Accept-Encoding".
// MIME header keys are assumed to be ASCII only.
func CanonicalMIMEHeaderKey(s string) string <span class="cov6" title="49">{
        // Quick check for canonical encoding.
        upper := true
        for i := 0; i &lt; len(s); i++ </span><span class="cov10" title="427">{
                c := s[i]
                if upper &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z' </span><span class="cov3" title="6">{
                        return canonicalMIMEHeaderKey([]byte(s))
                }</span>
                <span class="cov9" title="421">if !upper &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov2" title="2">{
                        return canonicalMIMEHeaderKey([]byte(s))
                }</span>
                <span class="cov9" title="419">upper = c == '-'</span>
        }
        <span class="cov6" title="41">return s</span>
}

func canonicalMIMEHeaderKey(a []byte) string <span class="cov5" title="18">{
        r := canonicalMIMEHeaderKeyOriginal(a)

        // Note: we should use CLIENTIP/CLIENTPORT instead of Clientip/Clientport
        // to maintain compatibility with downstream servers.
        // It's not safe to fix this problem in application code.
        if r == "Clientip" </span><span class="cov0" title="0">{
                return "CLIENTIP"
        }</span>
        <span class="cov5" title="18">if r == "Clientport" </span><span class="cov0" title="0">{
                return "CLIENTPORT"
        }</span>
        <span class="cov5" title="18">return r</span>
}

const toLower = 'a' - 'A'

// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is
// allowed to mutate the provided byte slice before returning the
// string.
func canonicalMIMEHeaderKeyOriginal(a []byte) string <span class="cov5" title="18">{
        // Look for it in commonHeaders , so that we can avoid an
        // allocation by sharing the strings among all users
        // of textproto. If we don't find it, a has been canonicalized
        // so just return string(a).
        upper := true
        lo := 0
        hi := len(commonHeaders)
        for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="154">{
                // Canonicalize: first letter upper case
                // and upper case after each dash.
                // (Host, User-Agent, If-Modified-Since).
                // MIME headers are ASCII only, so no Unicode issues.
                c := a[i]
                if c == ' ' </span><span class="cov2" title="3">{
                        c = '-'
                }</span> <span class="cov8" title="151">else if upper &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z' </span><span class="cov5" title="16">{
                        c -= toLower
                }</span> <span class="cov8" title="135">else if !upper &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov5" title="17">{
                        c += toLower
                }</span>
                <span class="cov8" title="154">a[i] = c
                upper = c == '-' // for next time

                if lo &lt; hi </span><span class="cov7" title="79">{
                        for lo &lt; hi &amp;&amp; (len(commonHeaders[lo]) &lt;= i || commonHeaders[lo][i] &lt; c) </span><span class="cov9" title="366">{
                                lo++
                        }</span>
                        <span class="cov7" title="79">for hi &gt; lo &amp;&amp; commonHeaders[hi-1][i] &gt; c </span><span class="cov9" title="331">{
                                hi--
                        }</span>
                }
        }
        <span class="cov5" title="18">if lo &lt; hi &amp;&amp; len(commonHeaders[lo]) == len(a) </span><span class="cov3" title="5">{
                return commonHeaders[lo]
        }</span>
        <span class="cov4" title="13">return string(a)</span>
}

var commonHeaders = []string{
        "Accept",
        "Accept-Charset",
        "Accept-Encoding",
        "Accept-Language",
        "Accept-Ranges",
        "Cache-Control",
        "Cc",
        "Connection",
        "Content-Id",
        "Content-Language",
        "Content-Length",
        "Content-Transfer-Encoding",
        "Content-Type",
        "Cookie",
        "Date",
        "Dkim-Signature",
        "Etag",
        "Expires",
        "From",
        "Host",
        "If-Modified-Since",
        "If-None-Match",
        "In-Reply-To",
        "Last-Modified",
        "Location",
        "Message-Id",
        "Mime-Version",
        "Pragma",
        "Received",
        "Return-Path",
        "Server",
        "Set-Cookie",
        "Subject",
        "To",
        "User-Agent",
        "Via",
        "X-Forwarded-For",
        "X-Imforwards",
        "X-Powered-By",
}
</pre>
		
		<pre class="file" id="file143" style="display: none">// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package textproto implements generic support for text-based request/response
// protocols in the style of HTTP, NNTP, and SMTP.
//
// The package provides:
//
// Error, which represents a numeric error response from
// a server.
//
// Pipeline, to manage pipelined requests and responses
// in a client.
//
// Reader, to read numeric response code lines,
// key: value headers, lines wrapped with leading spaces
// on continuation lines, and whole text blocks ending
// with a dot on a line by itself.
//
// Writer, to write dot-encoded text blocks.
//
// Conn, a convenient packaging of Reader, Writer, and Pipeline for use
// with a single network connection.
//
package textproto

import (
        "fmt"
        "io"
        "net"
)

import (
        "bfe_bufio"
)

// An Error represents a numeric error response from a server.
type Error struct {
        Code int
        Msg  string
}

func (e *Error) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%03d %s", e.Code, e.Msg)
}</span>

// A ProtocolError describes a protocol violation such
// as an invalid response or a hung-up connection.
type ProtocolError string

func (p ProtocolError) Error() string <span class="cov0" title="0">{
        return string(p)
}</span>

// A Conn represents a textual network protocol connection.
// It consists of a Reader and Writer to manage I/O
// and a Pipeline to sequence concurrent requests on the connection.
// These embedded types carry methods with them;
// see the documentation of those types for details.
type Conn struct {
        Reader
        Writer
        Pipeline
        conn io.ReadWriteCloser
}

// NewConn returns a new Conn using conn for I/O.
func NewConn(conn io.ReadWriteCloser) *Conn <span class="cov0" title="0">{
        return &amp;Conn{
                Reader: Reader{R: bfe_bufio.NewReader(conn)},
                Writer: Writer{W: bfe_bufio.NewWriter(conn)},
                conn:   conn,
        }
}</span>

// Close closes the connection.
func (c *Conn) Close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

// Dial connects to the given address on the given network using net.Dial
// and then returns a new Conn for the connection.
func Dial(network, addr string) (*Conn, error) <span class="cov0" title="0">{
        c, err := net.Dial(network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewConn(c), nil</span>
}

// Cmd is a convenience method that sends a command after
// waiting its turn in the pipeline.  The command text is the
// result of formatting format with args and appending \r\n.
// Cmd returns the id of the command, for use with StartResponse and EndResponse.
//
// For example, a client might run a HELP command that returns a dot-body
// by using:
//
//        id, err := c.Cmd("HELP")
//        if err != nil {
//                return nil, err
//        }
//
//        c.StartResponse(id)
//        defer c.EndResponse(id)
//
//        if _, _, err = c.ReadCodeLine(110); err != nil {
//                return nil, err
//        }
//        text, err := c.ReadDotBytes()
//        if err != nil {
//                return nil, err
//        }
//        return c.ReadCodeLine(250)
//
func (c *Conn) Cmd(format string, args ...interface{}) (id uint, err error) <span class="cov0" title="0">{
        id = c.Next()
        c.StartRequest(id)
        err = c.PrintfLine(format, args...)
        c.EndRequest(id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

// TrimString returns s without leading and trailing ASCII space.
func TrimString(s string) string <span class="cov0" title="0">{
        for len(s) &gt; 0 &amp;&amp; isASCIISpace(s[0]) </span><span class="cov0" title="0">{
                s = s[1:]
        }</span>
        <span class="cov0" title="0">for len(s) &gt; 0 &amp;&amp; isASCIISpace(s[len(s)-1]) </span><span class="cov0" title="0">{
                s = s[:len(s)-1]
        }</span>
        <span class="cov0" title="0">return s</span>
}

// TrimBytes returns b without leading and trailing ASCII space.
func TrimBytes(b []byte) []byte <span class="cov0" title="0">{
        for len(b) &gt; 0 &amp;&amp; isASCIISpace(b[0]) </span><span class="cov0" title="0">{
                b = b[1:]
        }</span>
        <span class="cov0" title="0">for len(b) &gt; 0 &amp;&amp; isASCIISpace(b[len(b)-1]) </span><span class="cov0" title="0">{
                b = b[:len(b)-1]
        }</span>
        <span class="cov0" title="0">return b</span>
}

func isASCIISpace(b byte) bool <span class="cov0" title="0">{
        return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}</span>

func isASCIILetter(b byte) bool <span class="cov10" title="9">{
        b |= 0x20 // make lower case
        return 'a' &lt;= b &amp;&amp; b &lt;= 'z'
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">// Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package textproto

import (
        "fmt"
        "io"
)

import (
        "bfe_bufio"
)

// A Writer implements convenience methods for writing
// requests or responses to a text protocol network connection.
type Writer struct {
        W   *bfe_bufio.Writer
        dot *dotWriter
}

// NewWriter returns a new Writer writing to w.
func NewWriter(w *bfe_bufio.Writer) *Writer <span class="cov3" title="2">{
        return &amp;Writer{W: w}
}</span>

var crnl = []byte{'\r', '\n'}
var dotcrnl = []byte{'.', '\r', '\n'}

// PrintfLine writes the formatted output followed by \r\n.
func (w *Writer) PrintfLine(format string, args ...interface{}) error <span class="cov1" title="1">{
        w.closeDot()
        fmt.Fprintf(w.W, format, args...)
        w.W.Write(crnl)
        return w.W.Flush()
}</span>

// DotWriter returns a writer that can be used to write a dot-encoding to w.
// It takes care of inserting leading dots when necessary,
// translating line-ending \n into \r\n, and adding the final .\r\n line
// when the DotWriter is closed.  The caller should close the
// DotWriter before the next call to a method on w.
//
// See the documentation for Reader's DotReader method for details about dot-encoding.
func (w *Writer) DotWriter() io.WriteCloser <span class="cov1" title="1">{
        w.closeDot()
        w.dot = &amp;dotWriter{w: w}
        return w.dot
}</span>

func (w *Writer) closeDot() <span class="cov3" title="2">{
        if w.dot != nil </span><span class="cov0" title="0">{
                w.dot.Close() // sets w.dot = nil
        }</span>
}

type dotWriter struct {
        w     *Writer
        state int
}

const (
        wstateBeginLine = iota // beginning of line; initial state; must be zero
        wstateCR               // wrote \r (possibly at end of line)
        wstateData             // writing data in middle of line
)

func (d *dotWriter) Write(b []byte) (n int, err error) <span class="cov1" title="1">{
        bw := d.w.W
        for n &lt; len(b) </span><span class="cov10" title="21">{
                c := b[n]
                switch d.state </span>{
                <span class="cov5" title="5">case wstateBeginLine:
                        d.state = wstateData
                        if c == '.' </span><span class="cov5" title="4">{
                                // escape leading dot
                                bw.WriteByte('.')
                        }</span>
                        <span class="cov5" title="5">fallthrough</span>

                <span class="cov10" title="21">case wstateData:
                        if c == '\r' </span><span class="cov0" title="0">{
                                d.state = wstateCR
                        }</span>
                        <span class="cov10" title="21">if c == '\n' </span><span class="cov5" title="4">{
                                bw.WriteByte('\r')
                                d.state = wstateBeginLine
                        }</span>

                <span class="cov0" title="0">case wstateCR:
                        d.state = wstateData
                        if c == '\n' </span><span class="cov0" title="0">{
                                d.state = wstateBeginLine
                        }</span>
                }
                <span class="cov10" title="21">if err = bw.WriteByte(c); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov10" title="21">n++</span>
        }
        <span class="cov1" title="1">return</span>
}

func (d *dotWriter) Close() error <span class="cov1" title="1">{
        if d.w.dot == d </span><span class="cov1" title="1">{
                d.w.dot = nil
        }</span>
        <span class="cov1" title="1">bw := d.w.W
        switch d.state </span>{
        <span class="cov1" title="1">default:
                bw.WriteByte('\r')
                fallthrough</span>
        <span class="cov1" title="1">case wstateCR:
                bw.WriteByte('\n')
                fallthrough</span>
        <span class="cov1" title="1">case wstateBeginLine:
                bw.Write(dotcrnl)</span>
        }
        <span class="cov1" title="1">return bw.Flush()</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">/* bfe_confdata_load.go - load config data for bfe   */
/*
modification history
--------------------
2014/5/15, by Zhang Miao, create
2014/7/02, by Zhang Miao, add loading multiple files for HostTableLoadAll()
2015/4/17, by Sijie Yang, add loading tls certificate/ocsp staple/session ticket key
*/
/*
DESCRIPTION
*/
package bfe_server

import (
        "fmt"
        "net/url"
        "path/filepath"
        "strings"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
    "bfe_config/bfe_tls_conf/tls_rule_conf"
    "bfe_config/bfe_tls_conf/server_cert_conf"
    "bfe_config/bfe_tls_conf/session_ticket_key_conf"    
    "bfe_data"
)

// load data when bfe start
func (srv *BfeServer) InitDataLoad() error <span class="cov8" title="1">{
        // load ServerDataConf
        serverConf, err := bfe_data.LoadServerDataConf(srv.Config.Server.HostRuleConf,
                srv.Config.Server.RouteRuleConf,
                srv.Config.Server.ClusterConf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("InitDataLoad():bfe_data.LoadServerDataConf Error %s", err)
        }</span>

        <span class="cov8" title="1">srv.ServerConf = serverConf
        srv.ReverseProxy.setTransports(srv.ServerConf.ClusterTable.ClusterMap())
        log.Logger.Info("init serverDataConf success")

        // load bal table
        if err := srv.balTable.Init(srv.Config.Server.GslbConf,
                srv.Config.Server.ClusterTableConf); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("InitDataLoad():balTableInit Error %s", err)
        }</span>

        // set gslb retry config
        <span class="cov8" title="1">if srv.ServerConf != nil </span><span class="cov8" title="1">{
                ct := srv.ServerConf.ClusterTable
                srv.balTable.SetGslbRetry(ct)
        }</span>

        <span class="cov8" title="1">log.Logger.Info("init bal table success")
        return nil</span>
}

func joinPath(path, suffix string) string <span class="cov0" title="0">{
        words := strings.Split(suffix, "/")
        if len(words) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return filepath.Join(path, words[len(words)-1])</span>
}

// reload host, route and cluster conf
func (srv *BfeServer) ServerDataConfReload(query url.Values) error <span class="cov0" title="0">{
        hostFile := srv.Config.Server.HostRuleConf
        routeFile := srv.Config.Server.RouteRuleConf
        clusterConfFile := srv.Config.Server.ClusterConf

        path := query.Get("path")
        if path != "" </span><span class="cov0" title="0">{
                hostFile = joinPath(path, hostFile)
                routeFile = joinPath(path, routeFile)
                clusterConfFile = joinPath(path, clusterConfFile)
        }</span>

        <span class="cov0" title="0">return srv.serverDataConfReload(hostFile, routeFile, clusterConfFile)</span>
}

func (srv *BfeServer) serverDataConfReload(hostFile, routeFile, clusterConfFile string) error <span class="cov0" title="0">{
        newServerConf, err := bfe_data.LoadServerDataConf(hostFile, routeFile, clusterConfFile)
        // TODO
        // module conf move from module and centralized management in bfeServer in future
        // newModulesConf, err1 := loadModulesConf(params url.Values)

        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("ServerDataConfReload():bfe_data.LoadServerDataConf: %s", err)
                return err
        }</span>

        <span class="cov0" title="0">srv.confLock.Lock()
        srv.ServerConf = newServerConf
        // TODO
        // s.modulesConf = newModulesConf
        srv.confLock.Unlock()

        srv.ReverseProxy.setTransports(srv.ServerConf.ClusterTable.ClusterMap())

        // set gslb retry num
        srv.balTable.SetGslbRetry(newServerConf.ClusterTable)

        return nil</span>
}

// reload gslb and bns file
func (srv *BfeServer) GslbDataConfReload(query url.Values) error <span class="cov0" title="0">{
        gslbFile := srv.Config.Server.GslbConf
        clusterTableFile := srv.Config.Server.ClusterTableConf

        path := query.Get("path")
        if path != "" </span><span class="cov0" title="0">{
                gslbFile = joinPath(path, gslbFile)
                clusterTableFile = joinPath(path, clusterTableFile)
        }</span>

        <span class="cov0" title="0">return srv.gslbDataConfReload(gslbFile, clusterTableFile)</span>
}

func (srv *BfeServer) gslbDataConfReload(gslbFile, clusterTableFile string) error <span class="cov0" title="0">{
        // load gslb and cluster_table file
        gslbConf, backendConf, err := srv.balTable.BalTableConfLoad(gslbFile, clusterTableFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("GslbDataConfReload():BalTable conf load err [%s]", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := srv.balTable.BalTableReload(gslbConf, backendConf); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("GslbDataConfReload():BalTableReload err [%s]", err)
                return err
        }</span>

        // set gslb retry num
        <span class="cov0" title="0">srv.confLock.Lock()
        serverConf := srv.ServerConf
        srv.confLock.Unlock()
        srv.balTable.SetGslbRetry(serverConf.ClusterTable)

        return nil</span>
}

// reload for session ticket key
func (srv *BfeServer) SessionTicketKeyReload() error <span class="cov0" title="0">{
        log.Logger.Info("start session ticket key reload")
        sessionTicketConf := srv.Config.SessionTicket
        if sessionTicketConf.SessionTicketsDisabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // load session ticket key
        <span class="cov0" title="0">keyFile := sessionTicketConf.SessionTicketKeyFile
        keyConf, err := session_ticket_key_conf.SessionTicketKeyConfLoad(keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update session ticket key
        <span class="cov0" title="0">srv.SessionTicketKey = keyConf.SessionTicketKey
        srv.HttpsListener.UpdateSessionTicketKey(srv.SessionTicketKey)
        log.Logger.Debug("update session ticket key for %s", srv.SessionTicketKey)

        return nil</span>
}

func (srv *BfeServer) CertificateReload() error <span class="cov0" title="0">{
    log.Logger.Info("start certificate reload")
    certConfFile := srv.Config.HttpsBasic.ServerCertConf
    tlsRuleFile := srv.Config.HttpsBasic.TlsRuleConf

    return srv.certificateLoad(certConfFile, tlsRuleFile)
}</span>

// reload for certificate
func (srv *BfeServer) certificateLoad(certConfFile string, certRuleFile string) error <span class="cov0" title="0">{
        // load certificate conf
        certConf, err := server_cert_conf.ServerCertConfLoad(certConfFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertConfLoad() :%s", err.Error())
        }</span>

        // parse certificate
        <span class="cov0" title="0">certMap, err := server_cert_conf.ServerCertParse(certConf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertParse() :%s", err.Error())
        }</span>

    // load certificate rule
    <span class="cov0" title="0">certRule, err := tls_rule_conf.TlsRuleConfLoad(certRuleFile)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("in CertRuleConfLoad() :%s", err.Error())
    }</span>

        // update certificates
        <span class="cov0" title="0">err = srv.MultiCert.Update(certMap, certRule.Config)
        log.Logger.Debug("update certificate/private key/ocsp staple")
        return err</span>
}

func (srv *BfeServer) NextProtosReload() error <span class="cov0" title="0">{
    log.Logger.Info("start next protos reload")
    tlsRuleFile := srv.Config.HttpsBasic.TlsRuleConf
    return srv.nextProtosLoad(tlsRuleFile)
}</span>

func (srv *BfeServer) nextProtosLoad(tlsRuleFile string) error <span class="cov0" title="0">{
    // load certificate rule
    tlsRule, err := tls_rule_conf.TlsRuleConfLoad(tlsRuleFile)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("in nextProtosLoad() :%s", err.Error())
    }</span>

    // update certificates
    <span class="cov0" title="0">err = srv.NextProtoNeg.Update(tlsRule.Config)
    log.Logger.Debug("update tls next protos conf")
    return err</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">/* bfe_server.go - the main structure of bfe-server  */
/*
modification history
--------------------
2014/6/5, by Zhang Miao, create
2015/5/6, by Sijie Yang, modify
    - support https protocol
2015/6/8, by Sijie Yang, modify
    - support spdy protocol
*/
/*
DESCRIPTION

*/
package bfe_server

import (
        "encoding/hex"
        "fmt"
    "io/ioutil"
        "net"
        "sync"
        "sync/atomic"
        "time"
)

import (
        "www.baidu.com/golang-lib/delay_counter"
        "www.baidu.com/golang-lib/module_state2"
        "www.baidu.com/golang-lib/signal_table"
)

import (
        "bfe_balance"
        "bfe_basic"
        "bfe_config/bfe_conf"
        "bfe_config/bfe_tls_conf/session_ticket_key_conf"
        "bfe_config/bfe_tls_conf/tls_rule_conf"
        "bfe_data"
        "bfe_http"
        "bfe_module"
        "bfe_spdy/spdy2"
        "bfe_spdy/spdy3"
        bfe_spdy_common "bfe_spdy/common"
        "bfe_tls"
        "bfe_util"
)

// DefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request.
// This can be overridden by setting config.MaxHeaderBytes.
const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB

// DefaultMaxHeaderUriBytes is the maximum permitted size of URI in headers in an HTTP request.
// This can be overridden by setting config.MaxHeaderUriBytes.
const DefaultMaxHeaderUriBytes = 8 * 1024

// setting for proxyDelay
const (
        DELAY_COUNTER_INTERVAL    = 60 // interval for moving current to past (in s)
        DELAY_COUNTER_BUCKET_SIZE = 1  // size of delay counter bucket (in ms)
        DELAY_COUNTER_BUCKET_NUM  = 10 // number of delay counter bucket
)

// BfeServer
type BfeServer struct {
        // service listeners
        listenerMap    map[string]net.Listener   // all listeners
        HttpListener   net.Listener              // listener for http
        HttpsListener  *HttpsListener            // listener for https

        enableAccept     bool // should accept new connections or not
        enableAcceptLock sync.Mutex

        // for http server
        Addr         string        // TCP address to listen on, ":http" if empty
        ReverseProxy *ReverseProxy // reverse proxy

        // for https server
        SessionCache     bfe_tls.ServerSessionCache // TLS session cache
        SessionTicketKey string                     // TLS session ticket key

        // supported cipher suites. If nil, default ciphersuites will be used
        CipherSuites []uint16

        // elliptic curves used in an ECDHE handshake(in preference order)
        // If empty, the default will be used.
        CurvePreferences []bfe_tls.CurveID

    // TLS certificates
    MultiCert *MultiCertMap

        // TLSNextProto optionally specifies a function to take over
        // ownership of the provided TLS connection when an NPN
        // protocol upgrade has occurred.  The map key is the protocol
        // name negotiated. The Handler argument should be used to
        // handle HTTP requests and will initialize the Request's TLS
        // and RemoteAddr if not already set.  The connection is
        // automatically closed when the function returns.
        TLSNextProto map[string]func(bfe_http.ServerHandler, *bfe_tls.Conn)

    // Supported application level protocols
    NextProtoNeg *NextProtosMap

        // for communicate with http client
        ReadTimeout       time.Duration // maximum duration before timing out read of the request
        WriteTimeout      time.Duration // maximum duration before timing out write of the response (spdy)
        MaxHeaderBytes    int           // max header length in bytes in request
        MaxHeaderUriBytes int           // max URI(in header) length in bytes in request

        // server config
        Config bfe_conf.BfeConfig

        // module and callback
        CallBacks *bfe_module.BfeCallbacks // call back functions
        Modules   *bfe_module.BfeModules   // bfe modules

        // web server for bfe monitor and reload
        Monitor *BfeMonitor

        // bufio cache
        BufioCache *BufioCache

        // signal table
        SignalTable *signal_table.SignalTable

        disableKeepAlives int32 // accessed atomically

        // for monitor
        // proxy related state
        proxyState module_state2.State
        // for monitor "internal delay"
        proxyDelay delay_counter.DelayRecent
        // for monitor "internal delay" of post/put request
        // note: part of body read is counted in post delay
        proxyPostDelay delay_counter.DelayRecent
        // for monitor "internal delay" of tls handshake
        proxyHandshakeDelay       delay_counter.DelayRecent
        proxyHandshakeFullDelay   delay_counter.DelayRecent
        proxyHandshakeResumeDelay delay_counter.DelayRecent

        proxyStateDiff module_state2.CounterSlice // for get diff of server state

        procInfo ProcessInfo // interface for process information

        confLock   sync.RWMutex             // mutex when reload data conf
        ServerConf *bfe_data.ServerDataConf // cluster_conf and host table conf
        balTable   *bfe_balance.BalTable    // for balance

        Version string // version of bfe server
}

// create a new instance of BfeServer
func NewBfeServer(cfg bfe_conf.BfeConfig,
        listenerMap map[string]net.Listener,
        version string,
        procInfo ProcessInfo) *BfeServer <span class="cov8" title="1">{

        s := new(BfeServer)

        // bfe config
        s.Config = cfg
        s.InitConfig()

        // set service listener
        s.listenerMap = listenerMap
        s.HttpListener = listenerMap["HTTP"]

        // initialize counters, proxyState
        s.proxyState.Init() // for proxy
        s.proxyState.CountersInit(COUNTER_KEYS)
        s.proxyState.SetNoahKeyPrefix(bfe_basic.NOAH_SD_PROXY_STATE)

        // initialize proxyDelay
        s.proxyDelay.Init(DELAY_COUNTER_INTERVAL, DELAY_COUNTER_BUCKET_SIZE, DELAY_COUNTER_BUCKET_NUM)
        s.proxyPostDelay.Init(DELAY_COUNTER_INTERVAL, DELAY_COUNTER_BUCKET_SIZE, DELAY_COUNTER_BUCKET_NUM)
        s.proxyHandshakeDelay.Init(HS_DC_INTERVAL, HS_DC_BUCKET_SIZE, HS_DC_BUCKET_NUM)
        s.proxyHandshakeFullDelay.Init(HS_DC_INTERVAL, HS_DC_BUCKET_SIZE, HS_DC_BUCKET_NUM)
        s.proxyHandshakeResumeDelay.Init(HS_DC_INTERVAL, HS_DC_BUCKET_SIZE, HS_DC_BUCKET_NUM)

        s.proxyDelay.SetNoahKeyPrefix(bfe_basic.NOAH_PROXY_DELAY)
        s.proxyPostDelay.SetNoahKeyPrefix(bfe_basic.NOAH_PROXY_POST_DEALY)
        s.proxyHandshakeDelay.SetNoahKeyPrefix(bfe_basic.NOAH_PROXY_HANDSHAKE_DELAY)
        s.proxyHandshakeFullDelay.SetNoahKeyPrefix(bfe_basic.NOAH_PROXY_HANDSHAKE_FULL_DELAY)
        s.proxyHandshakeResumeDelay.SetNoahKeyPrefix(bfe_basic.NOAH_PROXY_HANDSHAKE_RESUME_DELAY)

        // initialize bufioCache
        s.BufioCache = NewBufioCache()

        // create reverse proxy
        s.ReverseProxy = NewReverseProxy(s, &amp;s.proxyState)

        // initialize callbacks
        s.CallBacks = bfe_module.NewBfeCallbacks()
        // create modules
        s.Modules = bfe_module.NewBfeModules()

        // initialize balTable
        s.balTable = bfe_balance.NewBalTable()

        // initialize server-state-diff
        s.proxyStateDiff.Init(&amp;s.proxyState, cfg.Server.MonitorInterval)
        s.proxyStateDiff.SetNoahKeyPrefix(bfe_basic.NOAH_SD_PROXY_STATE_DIFF)

        // set keep-alive
        s.SetKeepAlivesEnabled(cfg.Server.KeepAliveEnabled)

        s.Version = version

        // process information
        s.procInfo = procInfo

        return s
}</span>

// set some parameter based on config
func (srv *BfeServer) InitConfig() <span class="cov8" title="1">{
        // set service port, according to config
        srv.Addr = fmt.Sprintf(":%d", srv.Config.Server.HttpPort)

        // set ReadTimeout
        if srv.Config.Server.ClientReadTimeout != 0 </span><span class="cov8" title="1">{
                srv.ReadTimeout = time.Duration(srv.Config.Server.ClientReadTimeout) * time.Second
        }</span>

        // set MaxHeaderBytes
        <span class="cov8" title="1">if srv.Config.Server.MaxHeaderBytes != 0 </span><span class="cov0" title="0">{
                srv.MaxHeaderBytes = srv.Config.Server.MaxHeaderBytes
        }</span> <span class="cov8" title="1">else {
                srv.MaxHeaderBytes = DefaultMaxHeaderBytes
        }</span>

        // set MaxHeaderUriBytes
        <span class="cov8" title="1">if srv.Config.Server.MaxHeaderUriBytes != 0 </span><span class="cov0" title="0">{
                srv.MaxHeaderUriBytes = srv.Config.Server.MaxHeaderUriBytes
        }</span> <span class="cov8" title="1">else {
                srv.MaxHeaderUriBytes = DefaultMaxHeaderUriBytes
        }</span>
}

func (srv *BfeServer) InitHttps() (err error) <span class="cov0" title="0">{
        // initialize state counters for tls
        bfe_tls.SetTlsState(&amp;srv.proxyState)
        srv.proxyState.CountersInit(bfe_tls.AllCounters())

        // initialize params for tls record protocol
        httpsConf := srv.Config.HttpsBasic
        bfe_tls.SetRecordParams(httpsConf.RecordInitPlaintextSize, httpsConf.RecordBytesThreshold,
                httpsConf.RecordInactiveSeconds)

    // initialize tls next proto
    if err = srv.initTLSNextProto(httpsConf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

        // initialize session cache
        <span class="cov0" title="0">sessionCacheConf := srv.Config.SessionCache
        if !sessionCacheConf.SessionCacheDisabled </span><span class="cov0" title="0">{
                srv.SessionCache = NewRedisSessionCache(sessionCacheConf, &amp;srv.proxyState)
        }</span>

        // initialize session ticket key
        <span class="cov0" title="0">sessionTicketConf := srv.Config.SessionTicket
        if !sessionTicketConf.SessionTicketsDisabled </span><span class="cov0" title="0">{
                keyFile := sessionTicketConf.SessionTicketKeyFile
                keyConf, err := session_ticket_key_conf.SessionTicketKeyConfLoad(keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">srv.SessionTicketKey = keyConf.SessionTicketKey</span>
        }

    // set ticket format to be compatible with OpenSSL
    <span class="cov0" title="0">bfe_tls.SetTicketFormat(bfe_tls.FORMAT_ASN1)

        // initialize ciphersuites perference
        srv.CipherSuites, err = bfe_conf.GetCipherSuites(httpsConf.CipherSuites)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertConfLoad() :%s", err.Error())
        }</span>

        // initialize elliptic curves perference
        <span class="cov0" title="0">srv.CurvePreferences, err = bfe_conf.GetCurvePreferences(httpsConf.CurvePreferences)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in ServerCertConfLoad() :%s", err.Error())
        }</span>

    // initialize certificates
    <span class="cov0" title="0">srv.MultiCert = NewMultiCertMap(&amp;srv.proxyState, httpsConf.DefaultCertType)
    if err := srv.certificateLoad(httpsConf.ServerCertConf, httpsConf.TlsRuleConf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

        // initialize https listeners
        <span class="cov0" title="0">config, err := srv.createTlsConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("in createTlsConfig() :%s", err.Error())
        }</span>
        <span class="cov0" title="0">srv.HttpsListener = NewHttpsListener(srv.listenerMap["HTTPS"], config)

    // disable spdy output to stdout
    bfe_spdy_common.SetLogOutput(ioutil.Discard)

        return nil</span>
}

func (srv *BfeServer) initTLSNextProto(conf bfe_conf.ConfigHttpsBasic) error <span class="cov0" title="0">{
    // init next protos
    srv.NextProtoNeg = NewNextProtosMap(&amp;srv.proxyState)
    if err := srv.nextProtosLoad(conf.TlsRuleConf); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // init next protocol handler
    <span class="cov0" title="0">srv.TLSNextProto = make(map[string]func(bfe_http.ServerHandler, *bfe_tls.Conn))
    srv.TLSNextProto[tls_rule_conf.SPDY31] = spdy3.NextProto1
    srv.TLSNextProto[tls_rule_conf.SPDY3]  = spdy3.NextProto
    srv.TLSNextProto[tls_rule_conf.SPDY2]  = spdy2.NextProto

    return nil</span>
}

func (srv *BfeServer) createTlsConfig() (config *bfe_tls.Config, err error) <span class="cov0" title="0">{
        // create TLS config
        config = new(bfe_tls.Config)

    // set max and min TLS version
    config.MaxVersion, config.MinVersion = bfe_conf.GetTlsVersion(&amp;srv.Config.HttpsBasic) 

    // enable Sslv2 ClientHello for compatible with ancient TLS-capable clients
    config.EnableSslv2ClientHello = srv.Config.HttpsBasic.EnableSslv2ClientHello

        // set certificates
    // Note: config.Certficates must be initialized, but we just use config.MultiCert 
    // for server certificates
    cert := srv.MultiCert.GetDefault()
    if cert == nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("createTlsConfig get default Cert error")
    }</span>
        <span class="cov0" title="0">config.Certificates = make([]bfe_tls.Certificate, 1)
        config.Certificates[0] = *cert
    config.MultiCert = srv.MultiCert

        // set session cache
        if srv.SessionCache != nil </span><span class="cov0" title="0">{
                config.ServerSessionCache = srv.SessionCache
                config.SessionCacheDisabled = false
        }</span> <span class="cov0" title="0">else {
                config.SessionCacheDisabled = true
        }</span>

        // set session ticket
        <span class="cov0" title="0">if len(srv.SessionTicketKey) &gt; 0 </span><span class="cov0" title="0">{
                key, err := hex.DecodeString(srv.SessionTicketKey)
        if err != nil </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("wrong session ticket key %s (%s)", err, key)
        }</span>
                <span class="cov0" title="0">copy(config.SessionTicketKeyName[:], key[:16])
                copy(config.SessionTicketKey[:], key[16:])
                config.SessionTicketsDisabled = false</span>
        } <span class="cov0" title="0">else {
                config.SessionTicketsDisabled = true
        }</span>

        // set cipher suites used
        <span class="cov0" title="0">config.CipherSuites = srv.CipherSuites

        // set elliptic curves used in an ECDHE handshake
        config.CurvePreferences = srv.CurvePreferences

    // set next protos
        config.NextProtoNeg = srv.NextProtoNeg

        return config, nil</span>
}

// initialize modules
func (srv *BfeServer) InitModules(confRoot string) error <span class="cov0" title="0">{
        return srv.Modules.Init(srv.CallBacks, srv.Monitor.WebHandlers, confRoot)
}</span>

// setup signal table
func (srv *BfeServer) InitSignalTable() <span class="cov0" title="0">{
        /* create signal table */
        srv.SignalTable = signal_table.NewSignalTable()

        /* register signal handlers */
        bfe_util.RegisterSignalHandlers(srv.SignalTable)

        /* start signal handler routine */
        srv.SignalTable.StartSignalHandle()
}</span>

func (s *BfeServer) doKeepAlives() bool <span class="cov0" title="0">{
        return atomic.LoadInt32(&amp;s.disableKeepAlives) == 0
}</span>

// SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.
// By default, keep-alives are always enabled. Only very
// resource-constrained environments or servers in the process of
// shutting down should disable them.
func (s *BfeServer) SetKeepAlivesEnabled(v bool) <span class="cov8" title="1">{
        if v </span><span class="cov8" title="1">{
                atomic.StoreInt32(&amp;s.disableKeepAlives, 0)
        }</span> <span class="cov0" title="0">else {
                atomic.StoreInt32(&amp;s.disableKeepAlives, 1)
        }</span>
}

// initialize moniter web server for bfe process
func (s *BfeServer) InitWebMonitor(port int) error <span class="cov0" title="0">{
        var err error
        s.Monitor, err = newBfeMonitor(s, port)
        return err
}</span>

func (s* BfeServer) GetServerConf() *bfe_data.ServerDataConf <span class="cov0" title="0">{
    s.confLock.RLock()
    sf := s.ServerConf
    s.confLock.RUnlock()

    return sf
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">/* bfe_server_init.go - create bfe service and init  */
/*
modification history
--------------------
2014/8/27, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
    "net"
)

import (
    "www.baidu.com/golang-lib/log"
)

import (
    "bfe_config/bfe_conf"
    "bfe_modules"
)

// start bfe server
func StartUp(id int, cfg bfe_conf.BfeConfig, lnMap map[string]net.Listener, monitorPort int,
    version string, confRoot string, procInfo ProcessInfo) (*BfeServer, error) <span class="cov0" title="0">{
    var err error

    /* register all modules */
    bfe_modules.SetModules()

    /* create bfe server */
    bfeServer := NewBfeServer(cfg, lnMap, version, procInfo)

    /* initial https */
    err = bfeServer.InitHttps()
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Error("StartUp(): InitHttps():%s", err.Error())
        return nil, err
    }</span>

    /* setup signal table */
    <span class="cov0" title="0">bfeServer.InitSignalTable()
    log.Logger.Info("StartUp():bfeServer.InitSignalTable() OK")

    // prepare for model reload init
    err = bfeServer.InitWebMonitor(monitorPort)
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Error("StartUp(): InitWebMonitor():%s", err.Error())
        return nil, err
    }</span>

    /* register modules */
    <span class="cov0" title="0">err = bfeServer.RegisterModules(cfg.Server.Modules)
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Error("StartUp(): RegisterModules():%s", err.Error())
        return nil, err
    }</span>

    /* initialize modules */
    <span class="cov0" title="0">err = bfeServer.InitModules(confRoot)
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Error("StartUp(): bfeServer.InitModules():%s",
            err.Error())
        return nil, err
    }</span>
    <span class="cov0" title="0">log.Logger.Info("StartUp():bfeServer.InitModules() OK")

    /* load data    */
    err = bfeServer.InitDataLoad()
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Error("StartUp(): bfeServer.InitDataLoad():%s",
            err.Error())
        return nil, err
    }</span>
    <span class="cov0" title="0">log.Logger.Info("StartUp(): bfeServer.InitDataLoad() OK")

    /* start embeded web server */
    bfeServer.Monitor.Start()

    /* start goroutine to accept http connections */
    go bfeServer.ServeHttp(bfeServer.HttpListener)

    /* start goroutine to accept https connections */
    go bfeServer.ServeHttps(bfeServer.HttpsListener)

    return bfeServer, nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">/* bufio_cache.go - cache for bufio */
/*
modification history
--------------------
2014/6/26, by Zhang Miao, modify
2014/9/1, by Weiwei, modify , use sync.Pool as cache
*/
/*
DESCRIPTION
This file is derived from net/http/server.go
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
    "io"
    "sync"
)

import (
    bufio "bfe_bufio"
)

var (
    bufioReaderPool   sync.Pool
    bufioWriter2kPool sync.Pool
    bufioWriter4kPool sync.Pool
)

func bufioWriterPool(size int) *sync.Pool <span class="cov0" title="0">{
    switch size </span>{
    <span class="cov0" title="0">case 2 &lt;&lt; 10:
        return &amp;bufioWriter2kPool</span>
    <span class="cov0" title="0">case 4 &lt;&lt; 10:
        return &amp;bufioWriter4kPool</span>
    }
    <span class="cov0" title="0">return nil</span>
}

// BufioCache provide api to get/put buf
type BufioCache struct {
}

// create a bufio cache
func NewBufioCache() *BufioCache <span class="cov8" title="1">{
    return new(BufioCache)
}</span>

func (*BufioCache) newBufioReader(r io.Reader) *bufio.Reader <span class="cov0" title="0">{
    if v := bufioReaderPool.Get(); v != nil </span><span class="cov0" title="0">{
        br := v.(*bufio.Reader)
        br.Reset(r)
        return br
    }</span>
    <span class="cov0" title="0">return bufio.NewReader(r)</span>
}

func (*BufioCache) putBufioReader(br *bufio.Reader) <span class="cov0" title="0">{
    br.Reset(nil)
    bufioReaderPool.Put(br)
}</span>

func (*BufioCache) newBufioWriterSize(w io.Writer, size int) *bufio.Writer <span class="cov0" title="0">{
    pool := bufioWriterPool(size)
    if pool != nil </span><span class="cov0" title="0">{
        if v := pool.Get(); v != nil </span><span class="cov0" title="0">{
            bw := v.(*bufio.Writer)
            bw.Reset(w)
            return bw
        }</span>
    }
    <span class="cov0" title="0">return bufio.NewWriterSize(w, size)</span>
}

func (*BufioCache) putBufioWriter(bw *bufio.Writer) <span class="cov0" title="0">{
    bw.Reset(nil)
    if pool := bufioWriterPool(bw.Available()); pool != nil </span><span class="cov0" title="0">{
        pool.Put(bw)
    }</span>
}

</pre>
		
		<pre class="file" id="file149" style="display: none">/* chunk_writer.go - chunkWriter    */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
2015/3/25, by Sijie Yang, modify
 - add signature for response body
*/
/*
DESCRIPTION
This file is derived from net/http/server.go
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "fmt"
        "io"
        "io/ioutil"
        "strconv"
        "sync"
        "time"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
        "bfe_bufio"
        "bfe_http"
)

// maxPostHandlerReadBytes is the max number of Request.Body bytes not
// consumed by a handler that the server will read from the client
// in order to keep a connection alive.  If there are more bytes than
// this then the server to be paranoid instead sends a "Connection:
// close" response.
//
// This number is approximately what a typical machine's TCP buffer
// size is anyway.  (if we have the bytes on the machine, we might as
// well read them)
const maxPostHandlerReadBytes = 256 &lt;&lt; 10

// extraHeader is the set of headers sometimes added by chunkWriter.writeHeader.
// This type is used to avoid extra allocations from cloning and/or populating
// the response Header map and all its 1-element slices.
type extraHeader struct {
        contentType      string
        connection       string
        transferEncoding string
        date             []byte // written if not nil
        contentLength    []byte // written if not nil
}

// Sorted the same as extraHeader.Write's loop.
var extraHeaderKeys = [][]byte{
        []byte("Content-Type"),
        []byte("Connection"),
        []byte("Transfer-Encoding"),
}

var (
        headerContentLength = []byte("Content-Length: ")
        headerDate          = []byte("Date: ")
)

// Write writes the headers described in h to w.
//
// This method has a value receiver, despite the somewhat large size
// of h, because it prevents an allocation. The escape analysis isn't
// smart enough to realize this function doesn't mutate h.
func (h extraHeader) Write(w *bfe_bufio.Writer) <span class="cov0" title="0">{
        if h.date != nil </span><span class="cov0" title="0">{
                w.Write(headerDate)
                w.Write(h.date)
                w.Write(crlf)
        }</span>
        <span class="cov0" title="0">if h.contentLength != nil </span><span class="cov0" title="0">{
                w.Write(headerContentLength)
                w.Write(h.contentLength)
                w.Write(crlf)
        }</span>
        <span class="cov0" title="0">for i, v := range []string{h.contentType, h.connection, h.transferEncoding} </span><span class="cov0" title="0">{
                if v != "" </span><span class="cov0" title="0">{
                        w.Write(extraHeaderKeys[i])
                        w.Write(colonSpace)
                        w.WriteString(v)
                        w.Write(crlf)
                }</span>
        }
}

// chunkWriter writes to a response's conn buffer, and is the writer
// wrapped by the response.bufw buffered writer.
//
// chunkWriter also is responsible for finalizing the Header, including
// conditionally setting the Content-Type and setting a Content-Length
// in cases where the handler's final output is smaller than the buffer
// size. It also conditionally adds chunk headers, when in chunking mode.
//
// See the comment above (*response).Write for the entire write flow.
type chunkWriter struct {
        res *response

        // header is either nil or a deep clone of res.handlerHeader
        // at the time of res.WriteHeader, if res.WriteHeader is
        // called and extra buffering is being done to calculate
        // Content-Type and/or Content-Length.
        header bfe_http.Header

        // wroteHeader tells whether the header's been written to "the
        // wire" (or rather: w.conn.buf). this is unlike
        // (*response).wroteHeader, which tells only whether it was
        // logically written.
        wroteHeader bool

        // set by the writeHeader method:
        chunking bool // using chunked transfer encoding for reply body

        // total bytes of body written
        length int

        // Signer calcuates signature for current response
        Signer bfe_http.SignCalculater
}

var (
        crlf       = []byte("\r\n")
        colonSpace = []byte(": ")
)

func (cw *chunkWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        if !cw.wroteHeader </span><span class="cov0" title="0">{
                cw.writeHeader(p)
        }</span>
        <span class="cov0" title="0">if cw.res.req.Method == "HEAD" </span><span class="cov0" title="0">{
                // Eat writes.
                return len(p), nil
        }</span>
        <span class="cov0" title="0">if cw.chunking </span><span class="cov0" title="0">{
                _, err = fmt.Fprintf(cw.res.conn.buf, "%x\r\n", len(p))
                if err != nil </span><span class="cov0" title="0">{
                        cw.res.conn.rwc.Close()
                        return
                }</span>
        }
        <span class="cov0" title="0">n, err = cw.res.conn.buf.Write(p)
        if cw.chunking &amp;&amp; err == nil </span><span class="cov0" title="0">{
                _, err = cw.res.conn.buf.Write(crlf)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                cw.res.conn.rwc.Close()
        }</span>

        // update total bytes written
        <span class="cov0" title="0">cw.length += len(p)

        return</span>
}

func (cw *chunkWriter) flush() <span class="cov0" title="0">{
        if !cw.wroteHeader </span><span class="cov0" title="0">{
                cw.writeHeader(nil)
        }</span>
        <span class="cov0" title="0">cw.res.conn.buf.Flush()</span>
}

func (cw *chunkWriter) close() <span class="cov0" title="0">{
        if !cw.wroteHeader </span><span class="cov0" title="0">{
                cw.writeHeader(nil)
        }</span>
        <span class="cov0" title="0">if cw.chunking </span><span class="cov0" title="0">{
                // zero EOF chunk, trailer key/value pairs (currently
                // unsupported in Go's server), followed by a blank
                // line.
                if cw.Signer != nil </span><span class="cov0" title="0">{
                        signature := cw.Signer.CalcSign(strconv.Itoa(cw.length))
                        cw.res.conn.buf.WriteString(fmt.Sprintf("0;bcts=%s\r\n\r\n", signature))
                }</span> <span class="cov0" title="0">else {
                        cw.res.conn.buf.WriteString("0\r\n\r\n")
                }</span>
        }
}

// appendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat))
func appendTime(b []byte, t time.Time) []byte <span class="cov0" title="0">{
        const days = "SunMonTueWedThuFriSat"
        const months = "JanFebMarAprMayJunJulAugSepOctNovDec"

        t = t.UTC()
        yy, mm, dd := t.Date()
        hh, mn, ss := t.Clock()
        day := days[3*t.Weekday():]
        mon := months[3*(mm-1):]

        return append(b,
                day[0], day[1], day[2], ',', ' ',
                byte('0'+dd/10), byte('0'+dd%10), ' ',
                mon[0], mon[1], mon[2], ' ',
                byte('0'+yy/1000), byte('0'+(yy/100)%10), byte('0'+(yy/10)%10), byte('0'+yy%10), ' ',
                byte('0'+hh/10), byte('0'+hh%10), ':',
                byte('0'+mn/10), byte('0'+mn%10), ':',
                byte('0'+ss/10), byte('0'+ss%10), ' ',
                'G', 'M', 'T')
}</span>

// statusLines is a cache of Status-Line strings, keyed by code (for
// HTTP/1.1) or negative code (for HTTP/1.0). This is faster than a
// map keyed by struct of two fields. This map's max size is bounded
// by 2*len(statusText), two protocol types for each known official
// status code in the statusText map.
var (
        statusMu    sync.RWMutex
        statusLines = make(map[int]string)
)

// statusLine returns a response Status-Line (RFC 2616 Section 6.1)
// for the given request and response status code.
func statusLine(req *bfe_http.Request, code int) string <span class="cov0" title="0">{
        // Fast path:
        key := code
        proto11 := req.ProtoAtLeast(1, 1)
        if !proto11 </span><span class="cov0" title="0">{
                key = -key
        }</span>
        <span class="cov0" title="0">statusMu.RLock()
        line, ok := statusLines[key]
        statusMu.RUnlock()
        if ok </span><span class="cov0" title="0">{
                return line
        }</span>

        // Slow path:
        <span class="cov0" title="0">proto := "HTTP/1.0"
        if proto11 </span><span class="cov0" title="0">{
                proto = "HTTP/1.1"
        }</span>
        <span class="cov0" title="0">codestring := strconv.Itoa(code)
        text, ok := bfe_http.StatusText[code]
        if !ok </span><span class="cov0" title="0">{
                text = "status code " + codestring
        }</span>
        <span class="cov0" title="0">line = proto + " " + codestring + " " + text + "\r\n"
        if ok </span><span class="cov0" title="0">{
                statusMu.Lock()
                defer statusMu.Unlock()
                statusLines[key] = line
        }</span>
        <span class="cov0" title="0">return line</span>
}

// writeHeader finalizes the header sent to the client and writes it
// to cw.res.conn.buf.
//
// p is not written by writeHeader, but is the first chunk of the body
// that will be written.  It is sniffed for a Content-Type if none is
// set explicitly.  It's also used to set the Content-Length, if the
// total body size was small and the handler has already finished
// running.
func (cw *chunkWriter) writeHeader(p []byte) <span class="cov0" title="0">{
        if cw.wroteHeader </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">cw.wroteHeader = true

        w := cw.res
        isHEAD := w.req.Method == "HEAD"

        // header is written out to w.conn.buf below. Depending on the
        // state of the handler, we either own the map or not. If we
        // don't own it, the exclude map is created lazily for
        // WriteSubset to remove headers. The setHeader struct holds
        // headers we need to add.
        header := cw.header
        owned := header != nil
        if !owned </span><span class="cov0" title="0">{
                header = w.handlerHeader
        }</span>
        <span class="cov0" title="0">var excludeHeader map[string]bool
        delHeader := func(key string) </span><span class="cov0" title="0">{
                if owned </span><span class="cov0" title="0">{
                        header.Del(key)
                        return
                }</span>
                <span class="cov0" title="0">if _, ok := header[key]; !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if excludeHeader == nil </span><span class="cov0" title="0">{
                        excludeHeader = make(map[string]bool)
                }</span>
                <span class="cov0" title="0">excludeHeader[key] = true</span>
        }
        <span class="cov0" title="0">var setHeader extraHeader

        // If the handler is done but never sent a Content-Length
        // response header and this is our first (and last) write, set
        // it, even to zero. This helps HTTP/1.0 clients keep their
        // "keep-alive" connections alive.
        // Exceptions: 304 responses never get Content-Length, and if
        // it was a HEAD request, we don't know the difference between
        // 0 actual bytes and 0 bytes because the handler noticed it
        // was a HEAD request and chose not to write anything.  So for
        // HEAD, the handler should either write the Content-Length or
        // write non-zero bytes.  If it's actually 0 bytes and the
        // handler never looked at the Request.Method, we just don't
        // send a Content-Length header.
        if w.handlerDone &amp;&amp; w.status != bfe_http.StatusNotModified &amp;&amp; header.GetDirect("Content-Length") == "" &amp;&amp; (!isHEAD || len(p) &gt; 0) </span><span class="cov0" title="0">{
                w.contentLength = int64(len(p))
                setHeader.contentLength = strconv.AppendInt(cw.res.clenBuf[:0], int64(len(p)), 10)
        }</span>

        // get Res-length from response header
        // see mod_http_sign
        <span class="cov0" title="0">resLength := header.GetDirect("Res-Length")
        hijackDectctResLength, err := strconv.Atoi(resLength)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Debug("Get Res-Length failed, err %s", err)
                hijackDectctResLength = -1
        }</span>

        // If this was an HTTP/1.0 request with keep-alive and we sent a
        // Content-Length back, we can make this a keep-alive response ...
        <span class="cov0" title="0">if w.req.WantsHttp10KeepAlive() </span><span class="cov0" title="0">{
                sentLength := header.GetDirect("Content-Length") != ""
                if sentLength &amp;&amp; header.GetDirect("Connection") == "keep-alive" </span><span class="cov0" title="0">{
                        w.closeAfterReply = false
                }</span>
        }

        // Check for a explicit (and valid) Content-Length header.
        <span class="cov0" title="0">hasCL := w.contentLength != -1

        if w.req.WantsHttp10KeepAlive() &amp;&amp; (isHEAD || hasCL) </span><span class="cov0" title="0">{
                _, connectionHeaderSet := header["Connection"]
                if !connectionHeaderSet </span><span class="cov0" title="0">{
                        setHeader.connection = "keep-alive"
                }</span>
        } <span class="cov0" title="0">else if !w.req.ProtoAtLeast(1, 1) || w.req.WantsClose() </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        <span class="cov0" title="0">if header.GetDirect("Connection") == "close" </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        <span class="cov0" title="0">if !w.conn.server.doKeepAlives() </span><span class="cov0" title="0">{
                w.closeAfterReply = true
        }</span>

        // Per RFC 2616, we should consume the request body before
        // replying, if the handler hasn't already done so.  But we
        // don't want to do an unbounded amount of reading here for
        // DoS reasons, so we only try up to a threshold.
        <span class="cov0" title="0">if w.req.ContentLength != 0 &amp;&amp; !w.closeAfterReply </span><span class="cov0" title="0">{
                ecr, isExpecter := w.req.Body.(*expectContinueReader)
                if !isExpecter || ecr.resp.wroteContinue </span><span class="cov0" title="0">{
                        n, _ := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
                        if n &gt;= maxPostHandlerReadBytes </span><span class="cov0" title="0">{
                                w.requestTooLarge()
                                delHeader("Connection")
                                setHeader.connection = "close"
                        }</span> <span class="cov0" title="0">else {
                                w.req.Body.Close()
                        }</span>
                }
        }

        <span class="cov0" title="0">code := w.status
        if code == bfe_http.StatusNotModified </span><span class="cov0" title="0">{
                // Must not have body.
                // RFC 2616 section 10.3.5: "the response MUST NOT include other entity-headers"
                for _, k := range []string{"Content-Type", "Content-Length", "Transfer-Encoding"} </span><span class="cov0" title="0">{
                        delHeader(k)
                }</span>
        } <span class="cov0" title="0">else {
                // If no content type, apply sniffing algorithm to body.
                _, haveType := header["Content-Type"]
                if !haveType </span><span class="cov0" title="0">{
                        setHeader.contentType = bfe_http.DetectContentType(p)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := header["Date"]; !ok </span><span class="cov0" title="0">{
                setHeader.date = appendTime(cw.res.dateBuf[:0], time.Now())
        }</span>

        <span class="cov0" title="0">te := header.GetDirect("Transfer-Encoding")
        hasTE := te != ""
        if hasCL &amp;&amp; hasTE &amp;&amp; te != "identity" </span><span class="cov0" title="0">{
                // TODO: return an error if WriteHeader gets a return parameter
                // For now just ignore the Content-Length.
                log.Logger.Warn("http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d",
                        te, w.contentLength)
                delHeader("Content-Length")
                hasCL = false
        }</span>

        <span class="cov0" title="0">if w.req.Method == "HEAD" || code == bfe_http.StatusNotModified </span><span class="cov0" title="0">{
                // do nothing
        }</span> <span class="cov0" title="0">else if code == bfe_http.StatusNoContent </span><span class="cov0" title="0">{
                delHeader("Transfer-Encoding")
        }</span> <span class="cov0" title="0">else if hasCL </span><span class="cov0" title="0">{
                delHeader("Transfer-Encoding")
        }</span> <span class="cov0" title="0">else if w.req.ProtoAtLeast(1, 1) </span><span class="cov0" title="0">{
                // HTTP/1.1 or greater: use chunked transfer encoding
                // to avoid closing the connection at EOF.
                // TODO: this blows away any custom or stacked Transfer-Encoding they
                // might have set.  Deal with that as need arises once we have a valid
                // use case.
                cw.chunking = true
                setHeader.transferEncoding = "chunked"
        }</span> <span class="cov0" title="0">else {
                // HTTP version &lt; 1.1: cannot do chunked transfer
                // encoding and we don't know the Content-Length so
                // signal EOF by closing connection.
                w.closeAfterReply = true
                delHeader("Transfer-Encoding") // in case already set
        }</span>

        // Cannot use Content-Length with non-identity Transfer-Encoding.
        <span class="cov0" title="0">if cw.chunking </span><span class="cov0" title="0">{
                delHeader("Content-Length")
        }</span>
        <span class="cov0" title="0">if !w.req.ProtoAtLeast(1, 0) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if w.closeAfterReply &amp;&amp; !bfe_http.HasToken(cw.header.GetDirect("Connection"), "close") </span><span class="cov0" title="0">{
                delHeader("Connection")
                if w.req.ProtoAtLeast(1, 1) </span><span class="cov0" title="0">{
                        setHeader.connection = "close"
                }</span>
        }

        // set signature headers for response
        <span class="cov0" title="0">cw.setSignField(setHeader.transferEncoding, cw.res.contentLength, hijackDectctResLength)

        prev := w.conn.buf.TotalWrite
        w.conn.buf.WriteString(statusLine(w.req, code))
        cw.header.WriteSubset(w.conn.buf, excludeHeader)
        setHeader.Write(w.conn.buf.Writer)

        w.conn.buf.Write(crlf)
        w.headerWritten = int64(w.conn.buf.TotalWrite - prev)</span>
}

func (cw *chunkWriter) setSignField(transferEncoding string, contentLength int64, hijackDectctResLength int) <span class="cov0" title="0">{
        if cw.Signer == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // use res-length first
        <span class="cov0" title="0">if hijackDectctResLength != -1 </span><span class="cov0" title="0">{
                log.Logger.Debug("http: writeSignField(): use Res-Length %d %s", hijackDectctResLength, strconv.Itoa(hijackDectctResLength))
                signature := cw.Signer.CalcSign(strconv.Itoa(hijackDectctResLength))
                cw.header.Set("X-Res-Oc", signature)
        }</span>

        <span class="cov0" title="0">if transferEncoding == "chunked" </span><span class="cov0" title="0">{
                log.Logger.Debug("http: writeSignField(): chunked encoding")
                cw.header.Set("X-BD-Oc", "0")
        }</span> <span class="cov0" title="0">else if contentLength != -1 </span><span class="cov0" title="0">{
                log.Logger.Debug("http: writeSignField(): not chunked, with valid content length %d %s", contentLength, strconv.FormatInt(contentLength, 10))
                signature := cw.Signer.CalcSign(strconv.FormatInt(contentLength, 10))
                cw.header.Set("X-BD-Oc", signature)
        }</span> <span class="cov0" title="0">else {
                log.Logger.Debug("http: writeSignField(): not chunked, without valid content Length")
        }</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "io"
)

import (
    "bfe_http"
)

// wrapper around io.ReaderCloser which on first read, sends an
// HTTP/1.1 100 Continue header
type expectContinueReader struct {
        resp       *response
        readCloser io.ReadCloser
        closed     bool
}

func (ecr *expectContinueReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if ecr.closed </span><span class="cov0" title="0">{
                return 0, bfe_http.ErrBodyReadAfterClose
        }</span>
        <span class="cov0" title="0">if !ecr.resp.wroteContinue </span><span class="cov0" title="0">{
                ecr.resp.wroteContinue = true
                ecr.resp.conn.buf.WriteString("HTTP/1.1 100 Continue\r\n\r\n")
                ecr.resp.conn.buf.Flush()
        }</span>
        <span class="cov0" title="0">return ecr.readCloser.Read(p)</span>
}

func (ecr *expectContinueReader) Close() error <span class="cov0" title="0">{
        ecr.closed = true
        return ecr.readCloser.Close()
}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">/* find_location.go - find cluster name for incoming request */
/*
modification history
--------------------
2014/5/6, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
        "time"
)

// loookup backend for incoming request
func (srv *BfeServer) FindLocation(request *Request) (string, error) <span class="cov10" title="2190">{
    req := request.BasicRequest
        req.Stat.LocateStart = time.Now()
        defer func() </span><span class="cov10" title="2190">{
                req.Stat.LocateEnd = time.Now()
        }</span>()

    <span class="cov10" title="2190">serverConf := request.ServerConf

    // lookup product name for request
        req.Route = serverConf.HostTable.Lookup(req)
        if req.Route.Error != nil </span><span class="cov0" title="0">{
                return "", req.Route.Error
        }</span>

        <span class="cov10" title="2190">return req.Route.ClusterName, nil</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">/* http_conn.go - handle http connection in bfe */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
2015/6/10, by Sijie Yang, modify
    - support application layer protocol over TLS connnection
*/
/*
DESCRIPTION
This file is derived from net/http/server.go
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "bfe_tls"
        "errors"
        "io"
        "net"
        "runtime"
        "strings"
        "sync"
        "time"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
        "bfe_basic"
        "bfe_bufio"
        "bfe_http"
        "bfe_module"
        "bfe_util"
)

// This should be &gt;= 512 bytes for DetectContentType,
// but otherwise it's somewhat arbitrary.
const bufferBeforeChunkingSize = 2048

var errTooLarge = errors.New("http: request too large")

// A switchReader can have its Reader changed at runtime.
// It's not safe for concurrent Reads and switches.
type switchReader struct {
        io.Reader
}

// A liveSwitchReader is a switchReader that's safe for concurrent
// reads and switches, if its mutex is held.
type liveSwitchReader struct {
        sync.Mutex
        r io.Reader
}

func (sr *liveSwitchReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        sr.Lock()
        r := sr.r
        sr.Unlock()
        return r.Read(p)
}</span>

// A conn represents the server side of an HTTP/HTTPS connection.
type conn struct {
        remoteAddr string                   // network address of remote side
        proto      string                   // protocol for the connection
        server     *BfeServer               // the Server on which the connection arrived
        rwc        net.Conn                 // i/o connection
        sr         liveSwitchReader         // where the LimitReader reads from; usually the rwc
        lr         *io.LimitedReader        // io.LimitReader(sr)
        buf        *bfe_bufio.ReadWriter    // buffered(lr,rwc), reading from bufio-&gt;limitReader-&gt;sr-&gt;rwc
        tlsState   *bfe_tls.ConnectionState // or nil when not using TLS

        mu           sync.Mutex // guards the following
        clientGone   bool       // if client has disconnected mid-request
        closeNotifyc chan bool  // made lazily

        session *bfe_basic.Session // for maintain connection information
}

func (c *conn) closeNotify() &lt;-chan bool <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.closeNotifyc == nil </span><span class="cov0" title="0">{
                c.closeNotifyc = make(chan bool, 1)

                pr, pw := io.Pipe()

                readSource := c.sr.r
                c.sr.Lock()
                c.sr.r = pr
                c.sr.Unlock()
                go func() </span><span class="cov0" title="0">{
                        _, err := io.Copy(pw, readSource)
                        if err == nil </span><span class="cov0" title="0">{
                                err = io.EOF
                        }</span>
                        <span class="cov0" title="0">pw.CloseWithError(err)
                        c.noteClientGone()</span>
                }()
        }
        <span class="cov0" title="0">return c.closeNotifyc</span>
}

func (c *conn) noteClientGone() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.closeNotifyc != nil &amp;&amp; !c.clientGone </span><span class="cov0" title="0">{
                c.closeNotifyc &lt;- true
        }</span>
        <span class="cov0" title="0">c.clientGone = true</span>
}

// noLimit is an effective infinite upper bound for io.LimitedReader
const noLimit int64 = (1 &lt;&lt; 63) - 1

// Create new connection from rwc.
func newConn(rwc net.Conn, srv *BfeServer) (c *conn, err error) <span class="cov0" title="0">{
        c = new(conn)
        c.remoteAddr = rwc.RemoteAddr().String()
        c.proto = "HTTP"
        c.server = srv
        c.rwc = rwc
        c.sr = liveSwitchReader{r: c.rwc}
        c.lr = io.LimitReader(&amp;c.sr, noLimit).(*io.LimitedReader)
        br := srv.BufioCache.newBufioReader(c.lr)
        bw := srv.BufioCache.newBufioWriterSize(c.rwc, 4&lt;&lt;10)
        c.buf = bfe_bufio.NewReadWriter(br, bw)

        c.session = bfe_basic.NewSession(rwc)
        vip := bfe_util.GetVip(rwc)
        if vip != nil </span><span class="cov0" title="0">{
                c.session.Vip = vip
                log.Logger.Debug("newConn(): VIP : %v", c.session.Vip.String())
        }</span>
        <span class="cov0" title="0">if _, ok := rwc.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                c.session.IsHttps = true
                c.proto = "HTTPS"
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

// Read next request from connection.
func (c *conn) readRequest() (request *Request, err error) <span class="cov0" title="0">{
        c.lr.N = int64(c.server.MaxHeaderBytes) + 4096 /* bufio slop */

        var req *bfe_http.Request
        var start time.Time

        if req, start, err = bfe_http.ReadRequest(c.buf.Reader, c.server.MaxHeaderUriBytes); err != nil </span><span class="cov0" title="0">{
                if c.lr.N == 0 </span><span class="cov0" title="0">{
                        return nil, errTooLarge
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">c.lr.N = noLimit

        req.RemoteAddr = c.remoteAddr

        reqStat := bfe_basic.NewRequestStat(start)
        reqStat.ReadReqEnd = time.Now()

        sf := c.server.GetServerConf()

        return NewRequest(req, reqStat, c, sf), nil</span>
}

func (c *conn) finalFlush() <span class="cov0" title="0">{
        if c.buf != nil </span><span class="cov0" title="0">{
                c.buf.Flush()

                // Steal the bufio.Reader (~4KB worth of memory) and its associated
                // reader for a future connection.
                c.server.BufioCache.putBufioReader(c.buf.Reader)

                // Steal the bufio.Writer (~4KB worth of memory) and its associated
                // writer for a future connection.
                c.server.BufioCache.putBufioWriter(c.buf.Writer)

                c.buf = nil
        }</span>
}

// Close the connection.
func (c *conn) close() <span class="cov0" title="0">{
        c.finalFlush()
        if c.rwc != nil </span><span class="cov0" title="0">{
                c.rwc.Close()
                c.rwc = nil
        }</span>
}

// rstAvoidanceDelay is the amount of time we sleep after closing the
// write side of a TCP connection before closing the entire socket.
// By sleeping, we increase the chances that the client sees our FIN
// and processes its final data before they process the subsequent RST
// from closing a connection with known unread data.
// This RST seems to occur mostly on BSD systems. (And Windows?)
// This timeout is somewhat arbitrary (~latency around the planet).
const rstAvoidanceDelay = 500 * time.Millisecond

// closeWrite flushes any outstanding data and sends a FIN packet (if
// client is connected via TCP), signalling that we're done.  We then
// pause for a bit, hoping the client processes it before `any
// subsequent RST.
//
// See http://golang.org/issue/3595
func (c *conn) closeWriteAndWait() <span class="cov0" title="0">{
        c.finalFlush()
        if tcp, ok := c.rwc.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                tcp.CloseWrite()
        }</span>
        <span class="cov0" title="0">time.Sleep(rstAvoidanceDelay)</span>
}

// callback of finish connection
func (c *conn) finish() <span class="cov0" title="0">{
        srv := c.server

        // finish session
        c.session.Finish()

        // Callback for HANDLE_FINISH
        hl := srv.CallBacks.GetHandlerList(bfe_module.HANDLE_FINISH)
        if hl != nil </span><span class="cov0" title="0">{
                hl.FilterFinish(c.session)
        }</span>
}

// Serve a new connection.
func (c *conn) serve() <span class="cov0" title="0">{
        var hl *bfe_module.HandlerList
        var retVal int
        session := c.session

        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        const size = 4096
                        buf := make([]byte, size)
                        buf = buf[:runtime.Stack(buf, false)]
                        log.Logger.Warn("panic: conn.serve(): %v, readTotal=%d,writeTotal=%d,reqNum=%d,%v\n%s",
                                c.remoteAddr,
                                c.session.ReadTotal, c.session.WriteTotal,
                                c.session.ReqNum,
                                err, buf)

                        c.server.proxyStateInc(c.proto, "PANIC_CLIENT_CONN_SERVE", 1)
                }</span>

                // callback of finish connection
                <span class="cov0" title="0">c.finish()
                c.close()

                c.server.proxyStateInc(c.proto, "CLIENT_CONN_ACTIVE", -1)
                if session.ReqNumActive != 0 </span><span class="cov0" title="0">{
                        c.server.proxyStateInc(c.proto, "CLIENT_CONN_UNFINISHED_REQ", 1)
                }</span>
        }()

        // Callback for HANDLE_ACCEPT
        <span class="cov0" title="0">hl = c.server.CallBacks.GetHandlerList(bfe_module.HANDLE_ACCEPT)
        if hl != nil </span><span class="cov0" title="0">{
                retVal = hl.FilterAccept(c.session)
                if retVal == bfe_module.BFE_HANDLER_FINISH </span><span class="cov0" title="0">{
                        // close the connection
                        c.server.proxyStateInc(c.proto, "HANDLE_ACCEPT.FINISH", 1)
                        return
                }</span>
        }

        <span class="cov0" title="0">if tlsConn, ok := c.rwc.(*bfe_tls.Conn); ok </span><span class="cov0" title="0">{
                c.server.proxyState.Inc("TLS_HANDSHAKE_ALL", 1)
                if d := c.server.ReadTimeout; d != 0 </span><span class="cov0" title="0">{
                        c.rwc.SetReadDeadline(time.Now().Add(d))
                }</span>

                <span class="cov0" title="0">start := time.Now()
                if err := tlsConn.Handshake(); err != nil </span><span class="cov0" title="0">{
                        log.Logger.Info("conn.serve(): Handshake error %s (remote %s), elapse %d us", 
                                                         err, c.remoteAddr, time.Since(start).Nanoseconds()/1000)
                        return
                }</span>
                <span class="cov0" title="0">finHs := time.Now()
                log.Logger.Debug("conn.serve(): Handshake success (remote %s, resume %v), elapse %d us",
                        c.remoteAddr, tlsConn.IsResume(), time.Since(start).Nanoseconds()/1000)
                c.server.proxyState.Inc("TLS_HANDSHAKE_SUCC", 1)
                c.server.proxyHandshakeDelay.AddBySub(start, finHs)

                if tlsConn.IsResume() </span><span class="cov0" title="0">{
                        c.server.proxyHandshakeResumeDelay.AddBySub(start, finHs)
                }</span> <span class="cov0" title="0">else {
                        c.server.proxyHandshakeFullDelay.AddBySub(start, finHs)
                }</span>

                <span class="cov0" title="0">c.session.IsResume = tlsConn.IsResume()
                c.tlsState = new(bfe_tls.ConnectionState)
                *c.tlsState = tlsConn.ConnectionState()

                // upgrade to negotiated protocol
                if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) </span><span class="cov0" title="0">{
                        if fn := c.server.TLSNextProto[proto]; fn != nil </span><span class="cov0" title="0">{
                                log.Logger.Debug("conn.serve(): Use negotiated protocol %s over TLS", proto)
                                c.server.alpStateInc(proto, "CLIENT_CONN_SERVED", 1)
                                c.server.alpStateInc(proto, "CLIENT_CONN_ACTIVE", 1)

                // process protocol over TLS connection
                                handler := NewProtocolHandler(c, proto)
                                fn(handler, tlsConn)
                                c.server.alpStateInc(proto, "CLIENT_CONN_ACTIVE", -1)
                        }</span> <span class="cov0" title="0">else {
                                log.Logger.Info("conn.serve(): unknown negotiated protocol %s over TLS", proto) 
                                c.server.alpStateInc(proto, "NOT_REGISTER", 1)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">firstRequest := true
        for </span><span class="cov0" title="0">{
                if firstRequest </span><span class="cov0" title="0">{
                        // set timeout only for first request
                        // following request's timeout is controlled by TimeoutReadClientAgain
                        // the read again timeout is different for each cluster
                        // so it's not set here, see reverseproxy.go
                        if d := c.server.ReadTimeout; d != 0 </span><span class="cov0" title="0">{
                                c.rwc.SetReadDeadline(time.Now().Add(d))
                        }</span>
                        <span class="cov0" title="0">firstRequest = false</span>
                }
                <span class="cov0" title="0">request, err := c.readRequest()

                if request != nil </span><span class="cov0" title="0">{
                        diff := session.UpdateReadTotal(c.buf.Reader.TotalRead)
                        request.BasicRequest.Stat.HeaderLenIn = diff
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if err == errTooLarge </span><span class="cov0" title="0">{
                                session.ErrCode = bfe_basic.ERR_CLIENT_LONG_HEADER
                                c.server.proxyStateInc(c.proto, "ERR_CLIENT_LONG_HEADER", 1)
                                // Their HTTP client may or may not be
                                // able to read this if we're
                                // responding to them and hanging up
                                // while they're still writing their
                                // request.  Undefined behavior.
                                io.WriteString(c.rwc, "HTTP/1.1 413 Request Entity Too Large\r\n\r\n")
                                c.closeWriteAndWait()
                                break</span>
                        } <span class="cov0" title="0">else if err == io.EOF </span><span class="cov0" title="0">{
                                session.ErrCode = bfe_basic.ERR_CLIENT_CLOSE
                                c.server.proxyStateInc(c.proto, "ERR_CLIENT_CLOSE", 1)
                                break</span> // Don't reply
                        } <span class="cov0" title="0">else if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() </span><span class="cov0" title="0">{
                                session.ErrCode = bfe_basic.ERR_CLIENT_TIMEOUT
                                c.server.proxyStateInc(c.proto, "ERR_CLIENT_TIMEOUT", 1)
                                break</span> // Don't reply
                        } <span class="cov0" title="0">else if strings.Contains(err.Error(), "connection reset by peer") </span><span class="cov0" title="0">{
                                session.ErrCode = bfe_basic.ERR_CLIENT_RESET
                                c.server.proxyStateInc(c.proto, "ERR_CLIENT_RESET", 1)
                                break</span>
                        }
                        <span class="cov0" title="0">session.ErrCode = bfe_basic.ERR_CLIENT_BAD_REQUEST
                        c.server.proxyStateInc(c.proto, "ERR_CLIENT_BAD_REQUEST", 1)
                        session.ErrMsg = err.Error()
                        io.WriteString(c.rwc, "HTTP/1.1 400 Bad Request\r\n\r\n")
                        break</span>
                }

                <span class="cov0" title="0">req := request.BasicRequest.HttpRequest

                // create context for response
                w := newResponse(c, req) 

                // Expect 100 Continue support
                if req.ExpectsContinue() </span><span class="cov0" title="0">{
                        session.Use100Continue = true
                        c.server.proxyStateInc(c.proto, "CLIENT_CONN_USE_100_CONTINUE", 1)

                        if req.ProtoAtLeast(1, 1) </span><span class="cov0" title="0">{
                                // Wrap the Body reader with one that replies on the connection
                                req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}
                        }</span>
                        <span class="cov0" title="0">if req.ContentLength == 0 </span><span class="cov0" title="0">{
                                session.ErrCode = bfe_basic.ERR_CLIENT_ZERO_CONTENTLEN
                                c.server.proxyStateInc(c.proto, "ERR_CLIENT_ZERO_CONTENTLEN", 1)

                                w.Header().Set("Connection", "close")
                                w.WriteHeader(bfe_http.StatusBadRequest)
                                w.finishRequest()
                                break</span>
                        }
                        <span class="cov0" title="0">req.Header.Del("Expect")</span>
                } <span class="cov0" title="0">else if req.Header.GetDirect("Expect") != "" </span><span class="cov0" title="0">{
                        session.ErrCode = bfe_basic.ERR_CLIENT_EXPECT_FAIL
                        c.server.proxyStateInc(c.proto, "ERR_CLIENT_EXPECT_FAIL", 1)

                        w.sendExpectationFailed()
                        break</span>
                }

                <span class="cov0" title="0">closeAfterReply := c.serveRequest(w, request)

        /* close connection if needed:
         * - server-level close (closeAfterReply): 
         *   connection blocked, request processed error, etc
         *
         * - http-level close (w.closeAfterReply): 
         *   proto version &lt; 1.1, request or response with header "connection: close",
         *   keepalive disabled, etc
         */
                if closeAfterReply || w.closeAfterReply </span><span class="cov0" title="0">{
                        if w.requestBodyLimitHit </span><span class="cov0" title="0">{
                                c.closeWriteAndWait()
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

func (c *conn) serveRequest(w bfe_http.ResponseWriter, req *Request) (closeAfterRelpy bool) <span class="cov0" title="0">{
        session := c.session
        session.IncReqNum(1)
        session.IncReqNumActive(1)
        c.server.proxyStateInc(c.proto, "CLIENT_REQ_SERVED", 1)
        c.server.proxyStateInc(c.proto, "CLIENT_REQ_ACTIVE", 1)

        // HTTP cannot have multiple simultaneous active requests.[*]
        // Until the server replies to this request, it can't read another,
        // so we might as well run the handler in this goroutine.
        // [*] Not strictly true: HTTP pipelining.  We could let them all process
        // in parallel even if their responses need to be serialized.

        request := req.BasicRequest

        // server the request
        ret1 := c.server.ReverseProxy.ServeHTTP(w, req)
    if res, ok := w.(*response); ok </span><span class="cov0" title="0">{
        res.finishRequest()
    }</span>

        // callback for finish request
        <span class="cov0" title="0">ret2 := c.server.ReverseProxy.FinishReq(w, request)

        // modify state counters
        session.IncReqNumActive(-1)
        c.server.proxyStateInc(c.proto, "CLIENT_REQ_ACTIVE", -1)
        if request.ErrCode != nil </span><span class="cov0" title="0">{
                c.server.proxyStateInc(c.proto, "CLIENT_REQ_FAIL", 1)
        }</span> <span class="cov0" title="0">else {
                // only counter "internal delay" for successful request
                if !request.Stat.BackendFirst.IsZero() </span><span class="cov0" title="0">{
                        // In redirect and some other cases, BackendFirst may be not set

                        if request.HttpRequest.ContentLength == 0 </span><span class="cov0" title="0">{
                                // for get/head request
                                c.server.proxyDelay.AddBySub(request.Stat.ReadReqEnd, request.Stat.BackendFirst)
                        }</span> <span class="cov0" title="0">else {
                                // for post/put request
                                c.server.proxyPostDelay.AddBySub(request.Stat.ReadReqEnd, request.Stat.BackendFirst)
                        }</span>
                }
        }

    <span class="cov0" title="0">closeAfterRelpy = ret1 || ret2
    return</span>
}

// validNPN reports whether the proto is not a blacklisted Next
// Protocol Negotiation protocol.  Empty and built-in protocol types
// are blacklisted and can't be overridden with alternate
// implementations.
func validNPN(proto string) bool <span class="cov0" title="0">{
        switch proto </span>{
        <span class="cov0" title="0">case "", "http/1.1", "http/1.0":
                return false</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">/* response.go - handle http/https listen and accept in bfe   */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
2015/4/08, by Sijie Yang, modify
 - update Serve() to support accept http/https connection
2015/4/17, by Sijie Yang, modify
 - support multiply https services for different certificate
*/
/*
DESCRIPTION
This file is derived from net/http/server.go
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "net"
        "strings"
        "time"
)

import (
        "www.baidu.com/golang-lib/log"
)

func delayCalc(delay time.Duration) time.Duration <span class="cov0" title="0">{
        if delay == 0 </span><span class="cov0" title="0">{
                delay = 5 * time.Millisecond
        }</span> <span class="cov0" title="0">else {
                delay *= 2
        }</span>
        <span class="cov0" title="0">if max := 1 * time.Second; delay &gt; max </span><span class="cov0" title="0">{
                delay = max
        }</span>
        <span class="cov0" title="0">return delay</span>
}

func isTimeout(err error) bool <span class="cov0" title="0">{
        e, ok := err.(net.Error)
        return ok &amp;&amp; e.Timeout()
}</span>

// accept incoming http connections
func (srv *BfeServer) ServeHttp(ln net.Listener) error <span class="cov0" title="0">{
        return srv.Serve(ln, ln, "HTTP")
}</span>

// accept incoming https connections
func (srv *BfeServer) ServeHttps(ln *HttpsListener) error <span class="cov0" title="0">{
        return srv.Serve(ln.tlsListener, ln.tcpListener, "HTTPS")
}</span>

/* Serve - Serve accepts incoming connections on the Listener l, creating a
 * new service goroutine for each.  The service goroutines read requests and
 * then call srv.Handler to reply to them.
 *
 * Params
 *     - l  : net listener
 *     - raw: underlying tcp listener (different from `l` in HTTPS)
 *
 * Return
 *     - err: error
 */
func (srv *BfeServer) Serve(l net.Listener, raw net.Listener, proto string) error <span class="cov0" title="0">{
        var tempDelay time.Duration // how long to sleep on accept failure
        var hasInitPool = false
        interval := time.Duration(5 * time.Millisecond)

        for </span><span class="cov0" title="0">{
                // should accept new connections or not
                if !srv.checkAccept(raw, &amp;hasInitPool) </span><span class="cov0" title="0">{
                        time.Sleep(interval)
                        continue</span>
                }

                // set timeout
                // Listener.Accept() will block current goroutine. While the server has
                // a predefined service time slice : BfeProcess.timeSetting.SvrSecs.
                // So Accept() function must has a timeout. After each timeout,
                // bfeServer will check current state, and decide if continue service.
                <span class="cov0" title="0">deadline := time.Now().Add(interval)
                raw.(*net.TCPListener).SetDeadline(deadline)

                // accept new connection
                rw, e := l.Accept()
                if e != nil </span><span class="cov0" title="0">{
                        if isTimeout(e) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">srv.proxyStateInc(proto, "ERR_CLIENT_CONN_ACCEPT", 1)

                        if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() </span><span class="cov0" title="0">{
                                tempDelay = delayCalc(tempDelay)

                                log.Logger.Error("http: Accept error: %v; retrying in %v", e, tempDelay)
                                time.Sleep(tempDelay)
                                continue</span>
                        }

                        <span class="cov0" title="0">return e</span>
                }

                <span class="cov0" title="0">srv.proxyStateInc(proto, "CLIENT_CONN_SERVED", 1)
                srv.proxyStateInc(proto, "CLIENT_CONN_ACTIVE", 1)

                // create data structure for new connection
                c, err := newConn(rw, srv)
                if err != nil </span><span class="cov0" title="0">{
                        // current, here is unreachable
                        continue</span>
                }

                // 10.*.*.* internal ip address
                <span class="cov0" title="0">if strings.HasPrefix(c.remoteAddr, "10.") </span><span class="cov0" title="0">{
                        srv.proxyStateInc(proto, "CLIENT_ADDR_INTERNAL", 1)
                }</span>

                // start go-routine for new connection
                <span class="cov0" title="0">go c.serve()</span>
        }
}

// check if accept is enabled, modify underlying pool if necessary
func (srv *BfeServer) checkAccept(l net.Listener, hasInitPool *bool) bool <span class="cov0" title="0">{
        enableAccept := srv.ShouldAccept()
        if enableAccept </span><span class="cov0" title="0">{
                // put listen socket handler into underlying poll
                if !*hasInitPool </span><span class="cov0" title="0">{
                        // Note: net.TCPListener.StartAccept() is in customized patch to go package.
                        // this function put listen socket fd into epoll in golang network runtime.
                        // Only after this operation, TCPListener.Accept() is valid.
                        l.(*net.TCPListener).StartAccept()
                        *hasInitPool = true
                }</span>
        } <span class="cov0" title="0">else {
                // delete listen socket handler from underlying poll
                if *hasInitPool </span><span class="cov0" title="0">{
                        // Note: net.TCPListener.CloseAccept() is in customized patch to go package.
                        // this function get listen socket fd out from epoll in golang network runtime.
                        // After this operation, TCPListener.Accept() will cause system panic.
                        l.(*net.TCPListener).StopAccept()
                        *hasInitPool = false
                }</span>
        }
        <span class="cov0" title="0">return enableAccept</span>
}

// enable accept new connections
func (srv *BfeServer) StartAccept() <span class="cov0" title="0">{
        srv.enableAcceptLock.Lock()
        srv.enableAccept = true
        srv.enableAcceptLock.Unlock()
}</span>

// disable accept new connections
func (srv *BfeServer) StopAccept() <span class="cov0" title="0">{
        srv.enableAcceptLock.Lock()
        srv.enableAccept = false
        srv.enableAcceptLock.Unlock()
}</span>

// should accept new connections or not
func (srv *BfeServer) ShouldAccept() bool <span class="cov0" title="0">{
        srv.enableAcceptLock.Lock()
        enableAccept := srv.enableAccept
        srv.enableAcceptLock.Unlock()

        return enableAccept
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">/* https_listener.go - wrapper of tls.listener */
/*
modification history
--------------------
2015/4/17, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
        "net"
    "sync"
)

import (
    "bfe_tls"
)

type HttpsListener struct {
    tlsListener net.Listener // listener for https
    tcpListener net.Listener // underlying tcp listener

    config      *bfe_tls.Config  // tls config for listener  
    lock        sync.Mutex
}

func NewHttpsListener(listener net.Listener, config *bfe_tls.Config) (*HttpsListener) <span class="cov0" title="0">{
    httpsListener := &amp;HttpsListener {
        tcpListener: listener,
        config     : config,
        tlsListener: bfe_tls.NewListener(listener, config),
    }
    return httpsListener
}</span>

// update session ticket key
func (l* HttpsListener) UpdateSessionTicketKey(key string) <span class="cov0" title="0">{
    l.lock.Lock()
    defer l.lock.Unlock()

    // clone and modify config
    config := new(bfe_tls.Config)
    *config = *(l.config)
    copy(config.SessionTicketKey[:], key)

    // update config for listener
    l.config = config
    bfe_tls.UpdateListener(l.tlsListener, config)
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">/* monitor_stat.go - web monitor module stat   */
/*
modification history
--------------------
2014/5/5, by Zhang Miao, create
2014/5/5, by Zhang Miao, move most of code to src/bfe_route
*/
/*
DESCRIPTION
*/
package bfe_server

import (
        "encoding/json"
        "fmt"
    "net/url"
)

import (
        "www.baidu.com/golang-lib/noah_encode"
)

// get status of HostTable in json
func (srv *BfeServer) HostTableStatusGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
    srv.confLock.RLock()
    serverConf := srv.ServerConf
    srv.confLock.RUnlock()

        s := serverConf.HostTable.GetStatus()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(s)</span>
        <span class="cov0" title="0">case "noah":
                buff, err = noah_encode.Encode(s)</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// get version of HostTable in json
func (srv *BfeServer) HostTableVersionGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
    srv.confLock.RLock()
    serverConf := srv.ServerConf
    srv.confLock.RUnlock()

        versions := serverConf.HostTable.GetVersions()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(versions)</span>
        <span class="cov0" title="0">case "noah":
                buff, err = noah_encode.Encode(versions)</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// get versions of clusterTable
func (srv *BfeServer) ClusterTableVersionGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
    srv.confLock.RLock()
    serverConf := srv.ServerConf
    srv.confLock.RUnlock()

        // get versions
        output := serverConf.ClusterTable.GetVersions()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error

        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(output)</span>
        <span class="cov0" title="0">case "noah":
                buff, err = noah_encode.Encode(output)</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// get state of balTable
func (srv *BfeServer) BalTableStatusGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
    var buff []byte
    var err error
    // cluster_name is not giving
    clusterName := query.Get("cluster_name")

    if len(clusterName) == 0 </span><span class="cov0" title="0">{
            // get states
            output := srv.balTable.GetState()
    
            // convert to json
            buff, err = json.Marshal(output)
    }</span> <span class="cov0" title="0">else {
        // search cluster whether is in balTable or not
        if bal, err1 := srv.balTable.Lookup(clusterName); err1 != nil </span><span class="cov0" title="0">{
            buff = []byte("{\"status\": \"Not Exist\"}")
        }</span> <span class="cov0" title="0">else if bal.SubClusterNum() == 0 </span><span class="cov0" title="0">{
            buff = []byte("{\"status\": \"No SubCluster\"}")
        }</span> <span class="cov0" title="0">else {
            buff = []byte("{\"status\": \"Exist\"}")
        }</span>
    }

        <span class="cov0" title="0">return buff, err</span>
}

// get versions of balTable
func (srv *BfeServer) BalTableVersionGet(query url.Values) ([]byte, error) <span class="cov0" title="0">{
        // get versions
        output := srv.balTable.GetVersions()

        // get param for format
        format := query.Get("format")
        if len(format) == 0 </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        var err error
        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(output)</span>
        <span class="cov0" title="0">case "noah":
                buff, err = noah_encode.Encode(output)</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">/* process_info.go - process info interface    */
/*
modification history
--------------------
2014/12/09, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
    "encoding/json"
    "fmt"
)

import (
    "www.baidu.com/golang-lib/web_monitor"
)

type ProcessInfo interface {
    ProcessStateGet() string
    ProcessIdGet() int
}

func (srv *BfeServer) processInfoGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
    // get param for format
    format, err := web_monitor.ParamsValueGet(params, "format")
    if err != nil </span><span class="cov0" title="0">{
        // default format is json
        format = "json"
    }</span>
    
    <span class="cov0" title="0">id := srv.procInfo.ProcessIdGet()
    state := srv.procInfo.ProcessStateGet()
    
    info := make(map[string]string)
    info["PROCESS_ID"] = fmt.Sprintf("%d", id)
    info["PROCESS_STATE"] = state

    var buff []byte
    err = nil
    switch format </span>{
        <span class="cov0" title="0">case "json":
            buff, err = json.Marshal(info)</span>
        <span class="cov0" title="0">default:
            err = fmt.Errorf("invalid format:%s", format)</span>
    }
    <span class="cov0" title="0">return buff, err</span>
}

</pre>
		
		<pre class="file" id="file157" style="display: none">/* protocol_handler.go - handler for application layer protocol over TLS connection */
/*
modification history
-------------------
2015/6/9, by Sijie Yang, create
        - Support spdy2, spdy3, spdy3.1
*/
/*
DESCRIPTION

*/
package bfe_server

import (
        "time"
)

import (
        "www.baidu.com/golang-lib/log"
)

import (
        "bfe_basic"
        "bfe_http"
        "bfe_spdy"
        "bfe_spdy/spdy2"
        "bfe_spdy/spdy3"
)

type ProtocolHandler struct {
        server *BfeServer // the server on which the connection arrived
        conn   *conn      // connection for handler 
        proto  string     // name of application layer protocol
}

func NewProtocolHandler(conn *conn, proto string) *ProtocolHandler <span class="cov0" title="0">{
        p := new(ProtocolHandler)
        p.server = conn.server
        p.conn = conn
        p.proto = proto
        return p
}</span>

/* ServeHTTP - process http request and send http response
 *
 * Params:
 *         - w : a reponse writer
 *         - r : a http request
 */
func (p *ProtocolHandler) ServeHTTP(w bfe_http.ResponseWriter, r *bfe_http.Request) <span class="cov0" title="0">{
        switch p.proto </span>{
        <span class="cov0" title="0">case "spdy/2", "spdy/3", "spdy/3.1":
                p.server.alpStateInc(p.proto, "CLIENT_REQ_SERVED", 1)
                p.server.alpStateInc(p.proto, "CLIENT_REQ_ACTIVE", 1)
                p.serveHTTPForSpdy(p.proto, w, r)
                p.server.alpStateInc(p.proto, "CLIENT_REQ_ACTIVE", -1)</span>

        /* never go here */
        <span class="cov0" title="0">default:
                w.WriteHeader(bfe_http.StatusInternalServerError)</span>
        }
}

func (p *ProtocolHandler) serveHTTPForSpdy(proto string, rw bfe_http.ResponseWriter,
                                                                                   request *bfe_http.Request) <span class="cov0" title="0">{
        var s bfe_spdy.Stream
        ok := false

        switch proto </span>{
        <span class="cov0" title="0">case "spdy/2":
                s, ok = rw.(*spdy2.ResponseStream)</span>

        <span class="cov0" title="0">case "spdy/3", "spdy/3.1":
                s, ok = rw.(*spdy3.ResponseStream)</span>
        }
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                log.Logger.Error("ProtocolHandler: wrong type of ResponseWriter %T", rw)
                p.server.alpStateInc(proto, "WRONG_RESP_WRITER_TYPE", 1)
                rw.WriteHeader(bfe_http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">log.Logger.Debug("ProtocolHandler(%s): process request from stream %d", 
                                         proto, s.StreamID())

        // convert request to be compatible with http
        convertRequestFromSpdy(proto, request)
        sf := p.server.GetServerConf()
        reqInfo := NewRequest(request, new(bfe_basic.RequestStat), p.conn, sf)

        // process request
        closeAfterReply := p.conn.serveRequest(rw, reqInfo)
        if closeAfterReply </span><span class="cov0" title="0">{
                conn := s.Conn()
                conn.Close()
        }</span>
}

func convertRequestFromSpdy(proto string, req *bfe_http.Request) <span class="cov0" title="0">{
        header := req.Header
        if proto == "spdy/2" </span><span class="cov0" title="0">{
                // Note: Following headers are reserved by spdy/2 
                // and should not be use by application
                header.Del("scheme")
                header.Del("method")
                header.Del("path")
                header.Del("version")
        }</span> <span class="cov0" title="0">else if proto == "spdy/3" || proto == "spdy/3.1" </span><span class="cov0" title="0">{
                header.Set("Host", header.Get(":host"))
                // Note: Following headers are reserved by spdy/3 and spdy/3.1
                // and should not be use by application
                header.Del(":host")
                header.Del(":scheme")
                header.Del(":method")
                header.Del(":path")
                header.Del(":version")
        }</span>
}

func (p *ProtocolHandler) GetReadTimeout() time.Duration <span class="cov0" title="0">{
        return p.conn.server.ReadTimeout
}</span>

func (p *ProtocolHandler) GetWriteTimeout() time.Duration <span class="cov0" title="0">{
        return p.conn.server.WriteTimeout
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "fmt"
        "net/url"
        "path"
        "strings"
)

import (
    "bfe_http"
)

// Redirect replies to the request with a redirect to url,
// which may be a path relative to the request path.
func Redirect(w bfe_http.ResponseWriter, r *bfe_http.Request, urlStr string, code int) <span class="cov0" title="0">{
        if u, err := url.Parse(urlStr); err == nil </span><span class="cov0" title="0">{
                // If url was relative, make absolute by
                // combining with request path.
                // The browser would probably do this for us,
                // but doing it ourselves is more reliable.

                // NOTE(rsc): RFC 2616 says that the Location
                // line must be an absolute URI, like
                // "http://www.google.com/redirect/",
                // not a path like "/redirect/".
                // Unfortunately, we don't know what to
                // put in the host name section to get the
                // client to connect to us again, so we can't
                // know the right absolute URI to send back.
                // Because of this problem, no one pays attention
                // to the RFC; they all send back just a new path.
                // So do we.
                oldpath := r.URL.Path
                if oldpath == "" </span><span class="cov0" title="0">{ // should not happen, but avoid a crash if it does
                        oldpath = "/"
                }</span>
                <span class="cov0" title="0">if u.Scheme == "" </span><span class="cov0" title="0">{
                        // no leading http://server
                        if urlStr == "" || urlStr[0] != '/' </span><span class="cov0" title="0">{
                                // make relative path absolute
                                olddir, _ := path.Split(oldpath)
                                urlStr = olddir + urlStr
                        }</span>

                        <span class="cov0" title="0">var query string
                        if i := strings.Index(urlStr, "?"); i != -1 </span><span class="cov0" title="0">{
                                urlStr, query = urlStr[:i], urlStr[i:]
                        }</span>

                        // clean up but preserve trailing slash
                        <span class="cov0" title="0">trailing := strings.HasSuffix(urlStr, "/")
                        urlStr = path.Clean(urlStr)
                        if trailing &amp;&amp; !strings.HasSuffix(urlStr, "/") </span><span class="cov0" title="0">{
                                urlStr += "/"
                        }</span>
                        <span class="cov0" title="0">urlStr += query</span>
                }
        }

        <span class="cov0" title="0">w.Header().Set("Location", urlStr)
        w.WriteHeader(code)

        // RFC2616 recommends that a short note "SHOULD" be included in the
        // response because older user agents may not understand 301/307.
        // Shouldn't send the response for POST or HEAD; that leaves GET.
        if r.Method == "GET" </span><span class="cov0" title="0">{
                note := "&lt;a href=\"" + htmlEscape(urlStr) + "\"&gt;" + bfe_http.StatusText[code] + "&lt;/a&gt;.\n"
                fmt.Fprintln(w, note)
        }</span>
}

func htmlEscape(s string) string <span class="cov0" title="0">{
        return htmlReplacer.Replace(s)
}</span>

var htmlReplacer = strings.NewReplacer(
        "&amp;", "&amp;amp;",
        "&lt;", "&amp;lt;",
        "&gt;", "&amp;gt;",
        // "&amp;#34;" is shorter than "&amp;quot;".
        `"`, "&amp;#34;",
        // "&amp;#39;" is shorter than "&amp;apos;" and apos was not in HTML until HTML5.
        "'", "&amp;#39;",
)

</pre>
		
		<pre class="file" id="file159" style="display: none">/* register_modules.go - register modules for bfe */
/*
modification history
--------------------
2014/4/23, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
    "strings"
)

import (
    "www.baidu.com/golang-lib/log"    
)

// register bfe work module
func (srv *BfeServer) RegisterModules(modules []string) error <span class="cov0" title="0">{
    if modules == nil </span><span class="cov0" title="0">{
        return nil
    }</span>
    
    <span class="cov0" title="0">for _, moduleName := range modules </span><span class="cov0" title="0">{
        moduleName = strings.Trim(moduleName, " ")
        if len(moduleName) == 0 </span><span class="cov0" title="0">{
            continue</span>
        }
        
        <span class="cov0" title="0">if err := srv.Modules.RegisterModule(moduleName); err != nil </span><span class="cov0" title="0">{
            return err
        }</span>
    
        <span class="cov0" title="0">log.Logger.Info("RegisterModule():moduleName=%s", moduleName)</span>
    }
    
    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">/* request.go - internal data structure for http request    */
/*
modification history
--------------------
2015/4/10, by caodong, create
2015/6/12, by Sijie Yang, modify
        - add necessary context info for request
*/
/*
DESCRIPTION
*/
package bfe_server

import (
        "bfe_data"
        "bfe_basic"
        "bfe_http"
)

// Context of Request in server side
type Request struct {
        BasicRequest *bfe_basic.Request
        ServerConf   *bfe_data.ServerDataConf // HostTable &amp; ClusterConf
        Conn         *conn
}

func NewRequest(request *bfe_http.Request, stat *bfe_basic.RequestStat, conn *conn, 
        sf *bfe_data.ServerDataConf) *Request <span class="cov10" title="2190">{

        req := new(Request)
        req.BasicRequest = bfe_basic.NewRequest(request, conn.rwc, stat, conn.session)
        req.ServerConf = sf
        req.Conn = conn

        return req
}</span>
</pre>
		
		<pre class="file" id="file161" style="display: none">/* response.go - handle response in bfe */
/*
modification history
--------------------
2014/6/19, by Zhang Miao, modify
*/
/*
DESCRIPTION
This file is derived from net/http/server.go
*/
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP server.  See RFC 2616.

package bfe_server

import (
        "errors"
        "io"
        "os"
        "strconv"
)

import (
    "www.baidu.com/golang-lib/log"
)

import (
        "bfe_bufio"
    "bfe_http"
)

const (
    sniffLen = 512      // previous defined in net/http/sniff.go
)

// The CloseNotifier interface is implemented by ResponseWriters which
// allow detecting when the underlying connection has gone away.
//
// This mechanism can be used to cancel long operations on the server
// if the client has disconnected before the response is ready.
type CloseNotifier interface {
        // CloseNotify returns a channel that receives a single value
        // when the client connection has gone away.
        CloseNotify() &lt;-chan bool
}


// Errors introduced by the HTTP server.
var (
        ErrBodyNotAllowed  = errors.New("http: request method or response status code does not allow body")
        ErrContentLength   = errors.New("Conn.Write wrote more than the declared Content-Length")
)

// A switchWriter can have its Writer changed at runtime.
// It's not safe for concurrent Writes and switches.
type switchWriter struct {
        io.Writer
}

// A response represents the server side of an HTTP response.
type response struct {
        conn          *conn
        req           *bfe_http.Request // request for this response
        wroteHeader   bool     // reply header has been (logically) written
        wroteContinue bool     // 100 Continue response was written

        w  *bfe_bufio.Writer // buffers output in chunks to chunkWriter
        cw chunkWriter
        sw *switchWriter // of the bufio.Writer, for return to putBufioWriter

        // handlerHeader is the Header that Handlers get access to,
        // which may be retained and mutated even after WriteHeader.
        // handlerHeader is copied into cw.header at WriteHeader
        // time, and privately mutated thereafter.
        handlerHeader bfe_http.Header
        calledHeader  bool // handler accessed handlerHeader via Header

    headerWritten int64 // number of bytes written in header
        written       int64 // number of bytes written in body
        contentLength int64 // explicitly-declared Content-Length; or -1
        status        int   // status code passed to WriteHeader

        // close connection after this reply.  set on request and
        // updated after response from handler if there's a
        // "Connection: keep-alive" response header and a
        // Content-Length.
        closeAfterReply bool

        // requestBodyLimitHit is set by requestTooLarge when
        // maxBytesReader hits its max size. It is checked in
        // WriteHeader, to make sure we don't consume the
        // remaining request body to try to advance to the next HTTP
        // request. Instead, when this is set, we stop reading
        // subsequent requests on this connection and stop reading
        // input from it.
        requestBodyLimitHit bool

        handlerDone bool // set true when the handler exits

        // Buffers for Date and Content-Length
        dateBuf [len(bfe_http.TimeFormat)]byte
        clenBuf [10]byte
}

func newResponse(c *conn, req *bfe_http.Request) *response <span class="cov0" title="0">{
        w := &amp;response{
                conn:          c,
                req:           req,
                handlerHeader: make(bfe_http.Header),
                contentLength: -1,
        }
        w.cw.res = w
        w.w = c.server.BufioCache.newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)
        return w
}</span>

// requestTooLarge is called by maxBytesReader when too much input has
// been read from the client.
func (w *response) requestTooLarge() <span class="cov0" title="0">{
        w.closeAfterReply = true
        w.requestBodyLimitHit = true
        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.Header().Set("Connection", "close")
        }</span>
}

// needsSniff reports whether a Content-Type still needs to be sniffed.
func (w *response) needsSniff() bool <span class="cov10" title="2">{
        _, haveType := w.handlerHeader["Content-Type"]
        return !w.cw.wroteHeader &amp;&amp; !haveType &amp;&amp; w.written &lt; sniffLen
}</span>

// writerOnly hides an io.Writer value's optional ReadFrom method
// from io.Copy.
type writerOnly struct {
        io.Writer
}

func srcIsRegularFile(src io.Reader) (isRegular bool, err error) <span class="cov0" title="0">{
        switch v := src.(type) </span>{
        <span class="cov0" title="0">case *os.File:
                fi, err := v.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return fi.Mode().IsRegular(), nil</span>
        <span class="cov0" title="0">case *io.LimitedReader:
                return srcIsRegularFile(v.R)</span>
        <span class="cov0" title="0">default:
                return</span>
        }
}

// set signature calculater for response
func (w *response) SetSigner(signer bfe_http.SignCalculater) <span class="cov0" title="0">{
    w.cw.Signer = signer
}</span>

// ReadFrom is here to optimize copying from an *os.File regular file
// to a *net.TCPConn with sendfile.
func (w *response) ReadFrom(src io.Reader) (n int64, err error) <span class="cov0" title="0">{
        // Our underlying w.conn.rwc is usually a *TCPConn (with its
        // own ReadFrom method). If not, or if our src isn't a regular
        // file, just fall back to the normal copy method.
        rf, ok := w.conn.rwc.(io.ReaderFrom)
        regFile, err := srcIsRegularFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if !ok || !regFile </span><span class="cov0" title="0">{
                return io.Copy(writerOnly{w}, src)
        }</span>

        // sendfile path:

        <span class="cov0" title="0">if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>

        <span class="cov0" title="0">if w.needsSniff() </span><span class="cov0" title="0">{
                n0, err := io.Copy(writerOnly{w}, io.LimitReader(src, sniffLen))
                n += n0
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }

        <span class="cov0" title="0">w.w.Flush()  // get rid of any previous writes
        w.cw.flush() // make sure Header is written; flush data to rwc

        // Now that cw has been flushed, its chunking field is guaranteed initialized.
        if !w.cw.chunking &amp;&amp; w.bodyAllowed() </span><span class="cov0" title="0">{
                n0, err := rf.ReadFrom(src)
                n += n0
                w.written += n0
                return n, err
        }</span>

        <span class="cov0" title="0">n0, err := io.Copy(writerOnly{w}, src)
        n += n0
        return n, err</span>
}

func (w *response) Header() bfe_http.Header <span class="cov0" title="0">{
        if w.cw.header == nil &amp;&amp; w.wroteHeader &amp;&amp; !w.cw.wroteHeader </span><span class="cov0" title="0">{
                // Accessing the header between logically writing it
                // and physically writing it means we need to allocate
                // a clone to snapshot the logically written state.
                w.cw.header = w.handlerHeader.Clone()
        }</span>
        <span class="cov0" title="0">w.calledHeader = true
        return w.handlerHeader</span>
}

func (w *response) WriteHeader(code int) <span class="cov0" title="0">{
        if w.wroteHeader </span><span class="cov0" title="0">{
                log.Logger.Warn("http: multiple response.WriteHeader calls")
                return
        }</span>
        <span class="cov0" title="0">w.wroteHeader = true
        w.status = code

        if w.calledHeader &amp;&amp; w.cw.header == nil </span><span class="cov0" title="0">{
                w.cw.header = w.handlerHeader.Clone()
        }</span>

        <span class="cov0" title="0">if cl := w.handlerHeader.GetDirect("Content-Length"); cl != "" </span><span class="cov0" title="0">{
                v, err := strconv.ParseInt(cl, 10, 64)
                if err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                        w.contentLength = v
                }</span> <span class="cov0" title="0">else {
                        log.Logger.Warn("http: invalid Content-Length of %q", cl)
                        w.handlerHeader.Del("Content-Length")
                }</span>
        }
}

// bodyAllowed returns true if a Write is allowed for this response type.
// It's illegal to call this before the header has been flushed.
func (w *response) bodyAllowed() bool <span class="cov0" title="0">{
        if !w.wroteHeader </span><span class="cov0" title="0">{
                panic("")
        }</span>
        <span class="cov0" title="0">return w.status != bfe_http.StatusNotModified</span>
}

// The Life Of A Write is like this:
//
// Handler starts. No header has been sent. The handler can either
// write a header, or just start writing.  Writing before sending a header
// sends an implicitly empty 200 OK header.
//
// If the handler didn't declare a Content-Length up front, we either
// go into chunking mode or, if the handler finishes running before
// the chunking buffer size, we compute a Content-Length and send that
// in the header instead.
//
// Likewise, if the handler didn't set a Content-Type, we sniff that
// from the initial chunk of output.
//
// The Writers are wired together like:
//
// 1. *response (the ResponseWriter) -&gt;
// 2. (*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes
// 3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)
//    and which writes the chunk headers, if needed.
// 4. conn.buf, a bufio.Writer of default (4kB) bytes
// 5. the rwc, the net.Conn.
//
// TODO(bradfitz): short-circuit some of the buffering when the
// initial header contains both a Content-Type and Content-Length.
// Also short-circuit in (1) when the header's been sent and not in
// chunking mode, writing directly to (4) instead, if (2) has no
// buffered data.  More generally, we could short-circuit from (1) to
// (3) even in chunking mode if the write size from (1) is over some
// threshold and nothing is in (2).  The answer might be mostly making
// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal
// with this instead.
func (w *response) Write(data []byte) (n int, err error) <span class="cov0" title="0">{
        return w.write(len(data), data, "")
}</span>

func (w *response) WriteString(data string) (n int, err error) <span class="cov0" title="0">{
        return w.write(len(data), nil, data)
}</span>

// either dataB or dataS is non-zero.
func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error) <span class="cov0" title="0">{
        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>
        <span class="cov0" title="0">if lenData == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if !w.bodyAllowed() </span><span class="cov0" title="0">{
                return 0, ErrBodyNotAllowed
        }</span>

        <span class="cov0" title="0">w.written += int64(lenData) // ignoring errors, for errorKludge
        if w.contentLength != -1 &amp;&amp; w.written &gt; w.contentLength </span><span class="cov0" title="0">{
                return 0, ErrContentLength
        }</span>
        <span class="cov0" title="0">if dataB != nil </span><span class="cov0" title="0">{
                return w.w.Write(dataB)
        }</span> <span class="cov0" title="0">else {
                return w.w.WriteString(dataS)
        }</span>
}

func (w *response) finishRequest() <span class="cov0" title="0">{
        w.handlerDone = true

        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>

        <span class="cov0" title="0">w.w.Flush()
        w.conn.server.BufioCache.putBufioWriter(w.w)
        w.cw.close()
        w.conn.buf.Flush()

        // Close the body, unless we're about to close the whole TCP connection
        // anyway.
        if !w.closeAfterReply </span><span class="cov0" title="0">{
                w.req.Body.Close()
        }</span>
        <span class="cov0" title="0">if w.req.MultipartForm != nil </span><span class="cov0" title="0">{
                w.req.MultipartForm.RemoveAll()
        }</span>

        <span class="cov0" title="0">if w.req.Method != "HEAD" &amp;&amp; w.contentLength != -1 &amp;&amp; w.bodyAllowed() &amp;&amp; w.contentLength != w.written </span><span class="cov0" title="0">{
                // Did not write enough. Avoid getting out of sync.
                w.closeAfterReply = true
        }</span>
}

func (w *response) Flush() <span class="cov0" title="0">{
        if !w.wroteHeader </span><span class="cov0" title="0">{
                w.WriteHeader(bfe_http.StatusOK)
        }</span>
        <span class="cov0" title="0">w.w.Flush()
        w.cw.flush()</span>
}

func (w *response) sendExpectationFailed() <span class="cov0" title="0">{
        // TODO(bradfitz): let ServeHTTP handlers handle
        // requests with non-standard expectation[s]? Seems
        // theoretical at best, and doesn't fit into the
        // current ServeHTTP model anyway.  We'd need to
        // make the ResponseWriter an optional
        // "ExpectReplier" interface or something.
        //
        // For now we'll just obey RFC 2616 14.20 which says
        // "If a server receives a request containing an
        // Expect field that includes an expectation-
        // extension that it does not support, it MUST
        // respond with a 417 (Expectation Failed) status."
        w.Header().Set("Connection", "close")
        w.WriteHeader(bfe_http.StatusExpectationFailed)
        w.finishRequest()
}</span>

func (w *response) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return w.conn.closeNotify()
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">/* reverseproxy.go - handlers as a reverse proxy    */
/*
modification history
--------------------
2014/6/4, by Zhang Miao, create, modify from net/http/httputil/reverseproxy.go
2014/9/3, by Zhang Miao, add state counter
2014/11/24, by Sijie Yang, add clientport carry
2015/6/15, By Sijie Yang, modify
    - change prototype of ServeHTTP() for better maintainability
*/
/*
DESCRIPTION
*/
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// HTTP reverse proxy handler

package bfe_server

import (
        "fmt"
        "io"
        "net"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"
)

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/module_state2"
)

import (
        bfe_cluster_backend "bfe_balance/backend"
        bal_gslb "bfe_balance/bal_gslb"
        "bfe_basic"
        "bfe_data"
        "bfe_data/bfe_cluster"
        "bfe_debug"
        "bfe_http"
        "bfe_module"
)

// map from cluster-name to RoundTripper
type RoundTripperMap map[string]bfe_http.RoundTripper

// ReverseProxy takes an incoming request and sends it to another server,
// proxying the response back to the client.
type ReverseProxy struct {
        // The transport used to perform proxy requests.
        // If no transport from clustername-&gt;transport map, create one.
        tsMu       sync.RWMutex
        transports RoundTripperMap

        // FlushInterval specifies the flush interval
        // to flush to the client while copying the
        // response body.
        // If zero, no periodic flushing is done.
        FlushInterval time.Duration

        server     *BfeServer           // link to bfe server
        proxyState *module_state2.State // state of proxy
}

// NewSingleHostReverseProxy returns a new ReverseProxy that rewrites
// URLs to the scheme, host, and base path provided in target. If the
// target's path is "/base" and the incoming request was for "/dir",
// the target request will be for /base/dir.
func NewReverseProxy(server *BfeServer, state *module_state2.State) *ReverseProxy <span class="cov1" title="1">{
        rp := new(ReverseProxy)
        rp.transports = make(RoundTripperMap)
        rp.server = server
        rp.proxyState = state
        return rp
}</span>

func copyHeader(dst, src bfe_http.Header) <span class="cov0" title="0">{
        for k, vv := range src </span><span class="cov0" title="0">{
                for _, v := range vv </span><span class="cov0" title="0">{
                        dst.Add(k, v)
                }</span>
        }
}

// Hop-by-hop headers. These are removed when sent to the backend.
// http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html
var hopHeaders = []string{
        "Connection",
        "Keep-Alive",
        "Proxy-Authenticate",
        "Proxy-Authorization",
        "Te", // canonicalized version of "TE"
        "Trailers",
        "Transfer-Encoding",
        "Upgrade",
}

// set http proto for out request
func httpProtoSet(outreq *bfe_http.Request) <span class="cov0" title="0">{
        outreq.Proto = "HTTP/1.1"
        outreq.ProtoMajor = 1
        outreq.ProtoMinor = 1
        outreq.Close = false
}</span>

// remove hop-by-hop headers
func hopByHopHeaderRemove(outreq, req *bfe_http.Request) <span class="cov0" title="0">{
        // Remove hop-by-hop headers to the backend.  Especially
        // important is "Connection" because we want a persistent
        // connection, regardless of what the client sent to us.  This
        // is modifying the same underlying map from req (shallow
        // copied above) so we only copy it if necessary.
        copiedHeaders := false
        for _, h := range hopHeaders </span><span class="cov0" title="0">{
                if outreq.Header.Get(h) != "" </span><span class="cov0" title="0">{
                        if !copiedHeaders </span><span class="cov0" title="0">{
                                outreq.Header = make(bfe_http.Header)
                                copyHeader(outreq.Header, req.Header)
                                copiedHeaders = true
                        }</span>
                        <span class="cov0" title="0">outreq.Header.Del(h)</span>
                }
        }
}

// modify x-forward for outreq, add req.RemoteAddr
func xforwardedModify(req, outreq *bfe_http.Request) <span class="cov0" title="0">{
        if clientIP, clientPort, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                // If we aren't the first proxy retain prior
                // X-Forwarded-For information as a comma+space
                // separated list and fold multiple headers into one.
                if prior, existIP := outreq.Header["X-Forwarded-For"]; existIP </span><span class="cov0" title="0">{
                        clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }</span>
                <span class="cov0" title="0">outreq.Header.Set("X-Forwarded-For", clientIP)

                // If we aren't the first proxy retain prior
                // X-Forwarded-Port information as a comma+space
                // separated list and fold multiple headers into one.
                if priorPort, existPort := outreq.Header["X-Forwarded-Port"]; existPort </span><span class="cov0" title="0">{
                        clientPort = strings.Join(priorPort, ", ") + ", " + clientPort
                }</span>

                <span class="cov0" title="0">outreq.Header.Set("X-Forwarded-Port", clientPort)</span>
        }
}

// add req.RemoteAddr to outreq, in CLIENTIP/CLIENTPORT
func clientipAdd(req, outreq *bfe_http.Request, isTrustIP bool) <span class="cov0" title="0">{
        if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                log.Logger.Debug("clientipAdd():src ip=%s, isTrustIP=%s", req.RemoteAddr, isTrustIP)
        }</span>

        <span class="cov0" title="0">if clientIP, clientPort, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                // 1. if from Trust IP, then make no change to Header["CLIENTIP"]
                // 2. if not from Trust IP, save removeAddr to Header["CLIENTIP"]
                // 2.1 if Header["CLIENTIP"] exists, backup value in Header["baidu_clientip"] first
                if !isTrustIP </span><span class="cov0" title="0">{
                        // set clientip, backup clientip if exists
                        if prior, ok := outreq.Header["CLIENTIP"]; ok </span><span class="cov0" title="0">{
                                if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                                        log.Logger.Debug("clientipAdd():src ip=%s, move clientip to baidu_clientip",
                                                req.RemoteAddr)
                                }</span>
                                <span class="cov0" title="0">outreq.Header.Set("baidu_clientip", strings.Join(prior, ", "))</span>
                        }
                        <span class="cov0" title="0">outreq.Header.Set("CLIENTIP", clientIP)

                        // set clientport, backup clientport if exists
                        if priorPort, ok := outreq.Header["CLIENTPORT"]; ok </span><span class="cov0" title="0">{
                                if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                                        log.Logger.Debug("clientipAdd():src port=%s, move clientport to baidu_clientport",
                                                req.RemoteAddr)
                                }</span>
                                <span class="cov0" title="0">outreq.Header.Set("baidu_clientport", strings.Join(priorPort, ", "))</span>
                        }
                        <span class="cov0" title="0">outreq.Header.Set("CLIENTPORT", clientPort)</span>
                }
        }
}

// use "bfeip" header to passthrough current bfe ip to upstream server
// because some web server like modified nginx of orp can not get bfe ip
func bfeipAdd(req *bfe_basic.Request, outreq *bfe_http.Request) <span class="cov0" title="0">{
        localip := req.Connection.LocalAddr().(*net.TCPAddr).IP.String()
        outreq.Header.Set("bfeip", localip)
}</span>

// add remote addr info to header
func remoteAddrAdd(request *bfe_basic.Request, outreq *bfe_http.Request) <span class="cov0" title="0">{
        // add req.RemoteAddr to outreq
        // use x-forward-for
        xforwardedModify(request.HttpRequest, outreq)
        // use clientip
        clientipAdd(request.HttpRequest, outreq, request.Session.IsTrustIP)
        // use bfeip
        bfeipAdd(request, outreq)
}</span>

// set user addr for request
func setClientAddr(req *bfe_basic.Request) <span class="cov4" title="6">{
        // use remote addr
        if !req.Session.IsTrustIP </span><span class="cov1" title="1">{ // request not from upstream bfe server
                req.ClientAddr = req.RemoteAddr
                return
        }</span>

        // use client ip or x-forward-for
        <span class="cov4" title="5">if clientip := req.HttpRequest.Header.Get("CLIENTIP"); len(clientip) &gt; 0 </span><span class="cov3" title="4">{
                clientport := req.HttpRequest.Header.Get("CLIENTPORT")
                parseClientAddr(req, clientip, clientport)
        }</span> <span class="cov1" title="1">else {
                // Note: It's not safe to use address in X-Forwarded-For header
                // Which may be forged
                req.ClientAddr = nil // unknown user addr
        }</span>
}

func parseClientAddr(req *bfe_basic.Request, clientip string, clientport string) <span class="cov3" title="4">{
        if ip := net.ParseIP(clientip); ip != nil </span><span class="cov3" title="3">{ // valid clientip
                req.ClientAddr = new(net.TCPAddr)
                req.ClientAddr.IP = ip
                if port, err := strconv.Atoi(clientport); err == nil </span><span class="cov1" title="1">{ // valid port
                        req.ClientAddr.Port = port
                }</span>
        } <span class="cov1" title="1">else {
                req.ClientAddr = nil // unknown clientip for user
                return
        }</span>
}

// set backend addr to out request
func setBackendAddr(req *bfe_http.Request, backend *bfe_cluster_backend.BfeBackend) <span class="cov0" title="0">{
        req.URL.Scheme = "http"
        req.URL.Host = fmt.Sprintf("%s:%d", backend.Addr, backend.Port)
}</span>

// check address equal
func addressEqual(la, ra net.Addr) bool <span class="cov0" title="0">{
        // reflect slow??
        return reflect.DeepEqual(la, ra)
}</span>

func (p *ReverseProxy) setTransports(clusterMap bfe_data.ClusterMap) <span class="cov1" title="1">{
        p.tsMu.Lock()
        defer p.tsMu.Unlock()

        newTransports := make(RoundTripperMap)
        for cluster, conf := range clusterMap </span><span class="cov10" title="92">{
                transport, ok := p.transports[cluster]
                if !ok </span><span class="cov10" title="92">{
                        transport = createTransport(conf, p.proxyState)
                        newTransports[cluster] = transport
                        continue</span>
                }

                <span class="cov0" title="0">t := transport.(*bfe_http.Transport)

                // get transport, check if transport needs update
                backendConf := conf.BackendConf()
                if (t.MaxIdleConnsPerHost != *backendConf.MaxIdleConnsPerHost) ||
                        (t.ResponseHeaderTimeout != time.Millisecond*time.Duration(*backendConf.TimeoutResponseHeader)) </span><span class="cov0" title="0">{
                        // create new transport with newConf instead of update transport
                        // update transport needs lock
                        transport = createTransport(conf, p.proxyState)
                        newTransports[cluster] = transport
                        continue</span>
                }

                <span class="cov0" title="0">newTransports[cluster] = transport</span>
        }

        <span class="cov1" title="1">p.transports = newTransports</span>
}

// get transport from map
// if not exist, create a transport
func (p *ReverseProxy) getTransport(cluster *bfe_cluster.BfeCluster) bfe_http.RoundTripper <span class="cov0" title="0">{
        p.tsMu.RLock()
        defer p.tsMu.RUnlock()

        transport, ok := p.transports[cluster.Name]
        if !ok </span><span class="cov0" title="0">{
                transport = createTransport(cluster, p.proxyState)
                p.transports[cluster.Name] = transport
        }</span>

        <span class="cov0" title="0">return transport</span>
}

func createTransport(cluster *bfe_cluster.BfeCluster, state *module_state2.State) bfe_http.RoundTripper <span class="cov10" title="92">{
        backendConf := cluster.BackendConf()

        log.Logger.Debug("create a new transport for %s, timeout %d", cluster.Name, *backendConf.TimeoutResponseHeader)

        // cluster has its own Connect Server Timeout.
        // so each cluster has a different transport
        // once cluster's timeout updated, dailer use new value
        dailer := func(network, add string) (net.Conn, error) </span><span class="cov0" title="0">{
                timeout := time.Duration(cluster.TimeoutConnSrv()) * time.Millisecond
                return net.DialTimeout(network, add, timeout)
        }</span>

        <span class="cov10" title="92">return &amp;bfe_http.Transport{
                Dial:                  dailer,
                DisableKeepAlives:     (*backendConf.MaxIdleConnsPerHost) == 0,
                MaxIdleConnsPerHost:   *backendConf.MaxIdleConnsPerHost,
                ResponseHeaderTimeout: time.Millisecond * time.Duration(*backendConf.TimeoutResponseHeader),
                DisableCompression:    true,
                State:                 state,
        }</span>
}

// invoke cluster to get response
func (p *ReverseProxy) clusterInvoke(srv *BfeServer, cluster *bfe_cluster.BfeCluster,
        c *conn, request *bfe_basic.Request, outreq *bfe_http.Request, rw bfe_http.ResponseWriter) (
        res *bfe_http.Response, closeAfterReply bool, err error) <span class="cov0" title="0">{
        var clusterBackend *bfe_cluster_backend.BfeBackend
        var bal *bal_gslb.BalanceGslb

        // mark start/end of cluster invoke
        request.Stat.ClusterStart = time.Now()
        defer func() </span><span class="cov0" title="0">{
                request.Stat.ClusterEnd = time.Now()
        }</span>()

        <span class="cov0" title="0">clusterTransport := p.getTransport(cluster)
        checkConf := cluster.BackendCheckConf()

        // look up for balance
        bal, err = srv.balTable.Lookup(cluster.Name)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("no balance for %s", cluster.Name)
                request.Stat.ResponseStart = time.Now()
                request.ErrCode = bfe_basic.ERR_BK_NO_CLUSTER
                p.proxyState.Inc("ERR_BK_NO_BALANCE", 1)
                request.BfeStatusCode = bfe_http.StatusInternalServerError
                rw.WriteHeader(bfe_http.StatusInternalServerError)
                closeAfterReply = true
                return
        }</span>

        // When request.RetryTime exceeds some value, srv.clusterTable.Lookup()
        // will return error. Here set a limit of 20, to avoid endless loop
        <span class="cov0" title="0">for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                // get backend with cluster-name and request
                clusterBackend, err = bal.Balance(request, p.proxyState)
                if err != nil </span><span class="cov0" title="0">{
                        if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                                log.Logger.Debug("ReverseProxy.ServeHTTP(): error[%s] in clusterTable.Lookup(%s)",
                                        err.Error(), cluster.Name)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">request.SetRequestTransport(clusterBackend, clusterTransport, checkConf)

                log.Logger.Debug("ReverseProxy.Invoke(): before HANDLE_FORWARD backend %s:%d",
                        request.Trans.Backend.Addr, request.Trans.Backend.Port)

                // Callback for HANDLE_FORWARD
                hl := srv.CallBacks.GetHandlerList(bfe_module.HANDLE_FORWARD)
                if hl != nil </span><span class="cov0" title="0">{
                        retVal := hl.FilterForward(request)
                        switch retVal </span>{
                        <span class="cov0" title="0">case bfe_module.BFE_HANDLER_FINISH:
                                // close the connection
                                closeAfterReply = true

                                p.proxyState.Inc("HANDLE_FORWARD.FINISH", 1)
                                return</span>
                        }
                }

                <span class="cov0" title="0">log.Logger.Debug("ReverseProxy.Invoke(): after HANDLE_FORWARD backend %s:%d",
                        request.Trans.Backend.Addr, request.Trans.Backend.Port)

                // set backend addr to out request
                backend := request.Trans.Backend
                setBackendAddr(outreq, backend)

                // invoke backend
                request.Stat.BackendStart = time.Now()
                if i == 0 </span><span class="cov0" title="0">{
                        // record start time of the first try
                        request.Stat.BackendFirst = request.Stat.BackendStart
                }</span>

                <span class="cov0" title="0">transport := request.Trans.Transport
                res, err = transport.RoundTrip(outreq)

                request.Stat.BackendEnd = time.Now()

                if err == nil </span><span class="cov0" title="0">{
                        // succeed in invoking backend
                        backend.OnSuccess()
                        // get length of input body
                        diff := c.session.UpdateReadTotal(c.buf.Reader.TotalRead)
                        request.Stat.BodyLenIn = diff

                        // record backend info to request
                        request.Backend.SubclusterName = backend.SubCluster
                        request.Backend.BackendName = backend.Name
                        request.Backend.BackendAddr = backend.Addr

                        // clear err msg in req.
                        // this step is required, if finally succeed after retry
                        request.ErrCode = nil
                        request.ErrMsg = ""

                        if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                                log.Logger.Debug("ReverseProxy.ServeHTTP(): get response from %s", backend.Name)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // fail in invoking backend
                <span class="cov0" title="0">if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                        log.Logger.Debug("ReverseProxy.ServeHTTP(): error[%s] in transport.RoundTrip(%s)",
                                err.Error(), backend.Name)
                }</span>

                <span class="cov0" title="0">request.ErrCode = bfe_basic.ERR_BK_CONNECT_BACKEND
                p.proxyState.Inc("ERR_BK_CONNECT_BACKEND", 1)

                log.Logger.Info("[%s] [%s:%d] roundtrip err %s",
                        cluster.Name, backend.Addr, backend.Port, err)

                // deal with errors here, possible error type:
                //  1, read client request body error(POST/PUT)
                //  2, write backend request error (
                //     a, haven't write any byte
                //     b, aleady write part of data
                //  3, read backend error
                //  4, other error ()
                // if error happens when headers sent finish(or part of headers been sent ?),
                // we should response error instead of retry.
                allowRetry := false
                switch rerr := err.(type) </span>{
                <span class="cov0" title="0">case *net.OpError:
                        </span><span class="cov0" title="0">{
                                // if error happens in dial phrase, we can retry
                                if rerr.Op == "dial" </span><span class="cov0" title="0">{
                                        allowRetry = true
                                }</span>

                                // if error is caused by backend server
                                <span class="cov0" title="0">if !addressEqual(rerr.Addr, request.RemoteAddr) </span><span class="cov0" title="0">{
                                        backend.OnFail(request.Trans.CheckConf)
                                }</span>
                        }
                <span class="cov0" title="0">default:
                        // NOTICE: for unknown err, we need to log and classify
                        // should call cluster.OnFail(backend) if error is caused by backend
                        log.Logger.Info("roundtrip return non OpError %s %s", reflect.TypeOf(err), err)</span>
                }

                <span class="cov0" title="0">if !allowRetry </span><span class="cov0" title="0">{
                        log.Logger.Debug("request fail, not retry now")
                        p.proxyState.Inc("CLIENT_REQ_FAIL_WITH_NO_RETRY", 1)
                        break</span>
                }
                <span class="cov0" title="0">request.RetryTime += 1</span>
        }

        // have retry?
        <span class="cov0" title="0">if request.RetryTime &gt; 0 </span><span class="cov0" title="0">{
                p.proxyState.Inc("CLIENT_REQ_WITH_RETRY", 1)
        }</span>
        // have cross-cluster retry?
        <span class="cov0" title="0">if request.Stat.IsCrossCluster </span><span class="cov0" title="0">{
                p.proxyState.Inc("CLIENT_REQ_WITH_CROSS_RETRY", 1)
        }</span>

        <span class="cov0" title="0">log.Logger.Debug("clusterInvoke %v %v", res, err)
        return</span>
}

// send http response to client
func (p *ReverseProxy) sendResponse(rw bfe_http.ResponseWriter, res *bfe_http.Response) error <span class="cov0" title="0">{
        // prepare SignCalculater for response
        p.prepareSigner(rw, res)

        copyHeader(rw.Header(), res.Header)

        // note: writeheader don't guarantee send header
        rw.WriteHeader(res.StatusCode)

        return p.copyResponse(rw, res.Body)
}</span>

// prepare SignCalculater for response
func (p *ReverseProxy) prepareSigner(rw bfe_http.ResponseWriter, res *bfe_http.Response) <span class="cov0" title="0">{
        // not need to add signature for respsone
        if res.Signer == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // prepare Singer for signature
        <span class="cov0" title="0">if resp, ok := rw.(*response); ok </span><span class="cov0" title="0">{
                resp.SetSigner(res.Signer)
        }</span>
}

// invoked after quit ServHTTP()
func (p *ReverseProxy) FinishReq(rw bfe_http.ResponseWriter, request *bfe_basic.Request) (closeAfterReply bool) <span class="cov0" title="0">{
        // get instance of BfeServer
        srv := p.server

        // Callback for HANDLE_REQUEST_FINISH
        hl := srv.CallBacks.GetHandlerList(bfe_module.HANDLE_REQUEST_FINISH)
        if hl != nil </span><span class="cov0" title="0">{
                retVal := hl.FilterResponse(request, request.HttpResponse)
                switch retVal </span>{
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_FINISH:
                        // close the connection
                        closeAfterReply = true

                        p.proxyState.Inc("HANDLE_REQUEST_FINISH.FINISH", 1)
                        return</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (p *ReverseProxy) setWriteClientResponseTimeout(cluster *bfe_cluster.BfeCluster, conn net.Conn) <span class="cov0" title="0">{
        conn.SetWriteDeadline(time.Now().Add(cluster.TimeoutWriteClient()))
}</span>

func (p *ReverseProxy) setReadClientRequestTimeout(cluster *bfe_cluster.BfeCluster, conn net.Conn) <span class="cov0" title="0">{
        conn.SetReadDeadline(time.Now().Add(cluster.TimeoutReadClient()))
}</span>

// for idle time + read next header time
func (p *ReverseProxy) setReadClientAgainTimeout(cluster *bfe_cluster.BfeCluster, conn net.Conn) <span class="cov0" title="0">{
        conn.SetReadDeadline(time.Now().Add(cluster.TimeoutReadClientAgain()))
}</span>

/* ServeHTTP - process http request and send http response
 *
 * Params:
 *     - rw : context for sending response
 *     - request: context for request
 *
 * Return:
 *     - closeAfterReply: should close connection after reply if true, else not
 */
func (p *ReverseProxy) ServeHTTP(rw bfe_http.ResponseWriter, request *Request) (closeAfterReply bool) <span class="cov0" title="0">{
        var err error
        var res *bfe_http.Response
        var hl *bfe_module.HandlerList
        var retVal int
        var clusterName string
        var cluster *bfe_cluster.BfeCluster
        var outreq *bfe_http.Request
        var serverConf *bfe_data.ServerDataConf

        basicReq := request.BasicRequest
        req := basicReq.HttpRequest
        isRedirect := false

        // get instance of BfeServer
        srv := p.server

        // set clientip of orginal user for request
        setClientAddr(basicReq)

        // Callback for HANDLE_BEFORE_LOCATION
        hl = srv.CallBacks.GetHandlerList(bfe_module.HANDLE_BEFORE_LOCATION)
        if hl != nil </span><span class="cov0" title="0">{
                retVal, res = hl.FilterRequest(basicReq)
                basicReq.HttpResponse = res
                switch retVal </span>{
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_FINISH:
                        // close the connection
                        closeAfterReply = true
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                        p.proxyState.Inc("HANDLE_BEFORE_LOCATION.FINISH", 1)
                        return</span>
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_REDIRECT:
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code)
                        isRedirect = true
                        basicReq.BfeStatusCode = basicReq.Redirect.Code
                        p.proxyState.Inc("HANDLE_BEFORE_LOCATION.REDIRECT", 1)
                        goto send_redirect</span>
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_RESPONSE:
                        p.proxyState.Inc("HANDLE_BEFORE_LOCATION.RESPONSE", 1)
                        goto response_got</span>
                }
        }

        // find cluster name
        <span class="cov0" title="0">clusterName, err = srv.FindLocation(request)
        if err != nil </span><span class="cov0" title="0">{
                basicReq.ErrCode = bfe_basic.ERR_BK_FIND_LOCATION
                p.proxyState.Inc("ERR_BK_FIND_LOCATION", 1)
                log.Logger.Info("FindLocation error[%s] [%s]", basicReq.HttpRequest.Host, clusterName)

                if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                        log.Logger.Debug("ReverseProxy.ServeHTTP(): error[%s] in srv.FindLocation()",
                                err.Error())
                }</span>

                // close connection
                <span class="cov0" title="0">rw.WriteHeader(bfe_http.StatusInternalServerError)
                closeAfterReply = true
                return</span>
        }

        // look up for cluster
        <span class="cov0" title="0">serverConf = request.ServerConf
        cluster, err = serverConf.ClusterTable.Lookup(clusterName)
        if err != nil </span><span class="cov0" title="0">{
                log.Logger.Warn("no cluster for %s", clusterName)
                basicReq.Stat.ResponseStart = time.Now()
                basicReq.ErrCode = bfe_basic.ERR_BK_NO_CLUSTER
                p.proxyState.Inc("ERR_BK_NO_CLUSTER", 1)

                rw.WriteHeader(bfe_http.StatusInternalServerError)
                closeAfterReply = true
                return
        }</span>

        <span class="cov0" title="0">basicReq.Backend.ClusterName = clusterName

        // set deadline to finish read client request body
        p.setReadClientRequestTimeout(cluster, basicReq.Connection)

        // Callback for HANDLE_AFTER_LOCATION
        hl = srv.CallBacks.GetHandlerList(bfe_module.HANDLE_AFTER_LOCATION)
        if hl != nil </span><span class="cov0" title="0">{
                retVal, res = hl.FilterRequest(basicReq)
                basicReq.HttpResponse = res
                switch retVal </span>{
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_FINISH:
                        // close the connection
                        closeAfterReply = true
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError

                        p.proxyState.Inc("HANDLE_AFTER_LOCATION.FINISH", 1)
                        return</span>
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_REDIRECT:
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code)

                        isRedirect = true

                        basicReq.BfeStatusCode = basicReq.Redirect.Code
                        p.proxyState.Inc("HANDLE_AFTER_LOCATION.REDIRECT", 1)
                        goto send_redirect</span>
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_RESPONSE:
                        p.proxyState.Inc("HANDLE_AFTER_LOCATION.RESPONSE", 1)
                        goto response_got</span>
                }
        }

        <span class="cov0" title="0">if bfe_debug.DEBUG_SERV_HTTP </span><span class="cov0" title="0">{
                log.Logger.Debug("ReverseProxy.ServeHTTP(): cluster name = %s", clusterName)
        }</span>

        // prepare out request to downstream RS backend
        <span class="cov0" title="0">outreq = new(bfe_http.Request)
        *outreq = *req // includes shallow copies of maps, but okay
        basicReq.OutRequest = outreq

        // add clientip clientport, will change request.HttpRequest.Header and outreq.Header
        // must be called before hopByHopHeaderRemove
        // as hopByHopHeaderRemove could set outreq.Header to a new map
        remoteAddrAdd(basicReq, outreq)

        // set http proto for out request
        httpProtoSet(outreq)
        // remove hop-by-hop headers
        hopByHopHeaderRemove(outreq, req)

        // record cluster name in Request
        //request.Backend.ClusterName = clusterName
        // record cluster name in Session
        request.Conn.session.SetClusterName(clusterName)
        // invoke cluster to get response
        res, closeAfterReply, err = p.clusterInvoke(srv, cluster, request.Conn, basicReq, outreq, rw)
        basicReq.HttpResponse = res
        if err != nil </span><span class="cov0" title="0">{
                basicReq.Stat.ResponseStart = time.Now()
                rw.WriteHeader(bfe_http.StatusInternalServerError)
                basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                return
        }</span>

        <span class="cov0" title="0">p.setWriteClientResponseTimeout(cluster, basicReq.Connection)

        // for read next request
        defer p.setReadClientAgainTimeout(cluster, basicReq.Connection)
        defer res.Body.Close()

response_got:
        // Callback for HANDLE_READ_BACKEND
        hl = srv.CallBacks.GetHandlerList(bfe_module.HANDLE_READ_BACKEND)
        if hl != nil </span><span class="cov0" title="0">{
                retVal = hl.FilterResponse(basicReq, res)
                switch retVal </span>{
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_FINISH:
                        // close the connection
                        closeAfterReply = true
                        basicReq.BfeStatusCode = bfe_http.StatusInternalServerError
                        p.proxyState.Inc("HANDLE_READ_BACKEND.FINISH", 1)
                        return</span>
                <span class="cov0" title="0">case bfe_module.BFE_HANDLER_REDIRECT:
                        // make redirect
                        Redirect(rw, req, basicReq.Redirect.Url, basicReq.Redirect.Code)
                        isRedirect = true
                        basicReq.BfeStatusCode = basicReq.Redirect.Code

                        p.proxyState.Inc("HANDLE_READ_BACKEND.REDIRECT", 1)
                        goto send_redirect</span>
                }
        }

<span class="cov0" title="0">send_redirect:
        // send http response to client
        basicReq.Stat.ResponseStart = time.Now()

        if !isRedirect &amp;&amp; res != nil </span><span class="cov0" title="0">{
                err = p.sendResponse(rw, res)
                if err != nil </span><span class="cov0" title="0">{
                        closeAfterReply = true
                        basicReq.ErrCode = bfe_basic.ERR_CLIENT_WRITE
                        basicReq.ErrMsg = err.Error()

                        p.proxyState.Inc("ERR_CLIENT_WRITE", 1)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (p *ReverseProxy) copyResponse(dst io.Writer, src io.Reader) error <span class="cov0" title="0">{
        if p.FlushInterval != 0 </span><span class="cov0" title="0">{
                if wf, ok := dst.(writeFlusher); ok </span><span class="cov0" title="0">{
                        mlw := &amp;maxLatencyWriter{
                                dst:     wf,
                                latency: p.FlushInterval,
                                done:    make(chan bool),
                        }
                        go mlw.flushLoop()
                        defer mlw.stop()
                        dst = mlw
                }</span>
        }

        <span class="cov0" title="0">_, err := io.Copy(dst, src)
        return err</span>
}

// The Flusher interface is implemented by ResponseWriters that allow
// an HTTP handler to flush buffered data to the client.
//
// Note that even for ResponseWriters that support Flush,
// if the client is connected through an HTTP proxy,
// the buffered data may not reach the client until the response
// completes.
type Flusher interface {
        // Flush sends any buffered data to the client.
        Flush()
}

// onExitFlushLoop is a callback set by tests to detect the state of the
// flushLoop() goroutine.
var onExitFlushLoop func()

type writeFlusher interface {
        io.Writer
        Flusher
}

type maxLatencyWriter struct {
        dst     writeFlusher
        latency time.Duration

        lk   sync.Mutex // protects Write + Flush
        done chan bool
}

func (m *maxLatencyWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        m.lk.Lock()
        defer m.lk.Unlock()
        return m.dst.Write(p)
}</span>

func (m *maxLatencyWriter) flushLoop() <span class="cov0" title="0">{
        t := time.NewTicker(m.latency)
        defer t.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                <span class="cov0" title="0">case &lt;-m.done:
                        if onExitFlushLoop != nil </span><span class="cov0" title="0">{
                                onExitFlushLoop()
                        }</span>
                        <span class="cov0" title="0">return</span>
                <span class="cov0" title="0">case &lt;-t.C:
                        m.lk.Lock()
                        m.dst.Flush()
                        m.lk.Unlock()</span>
                }
        }
}

func (m *maxLatencyWriter) stop() <span class="cov0" title="0">{ m.done &lt;- true }</span>
</pre>
		
		<pre class="file" id="file163" style="display: none">/* server_status.go - web handlers for providing internal status    */
/*
modification history
--------------------
2014/9/3, by Zhang Miao, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
        "encoding/json"
        "fmt"
    "strings"
)

import (
        "www.baidu.com/golang-lib/delay_counter"
        "www.baidu.com/golang-lib/web_monitor"
)

import (
        "bfe_module"
)

// setting for handshake delay
const (
    HS_DC_INTERVAL = 60 // interval for moving current to past (in s)
    HS_DC_BUCKET_SIZE = 100 // size of delay counter bucket (in ms)
    HS_DC_BUCKET_NUM = 10 // number of delay counter bucket
)

var COUNTER_KEYS = []string{
        // panics
        "PANIC_CLIENT_CONN_SERVE", // panic when accept from client
        "PANIC_BACKEND_WRITE",     // panic when write to backend
        "PANIC_BACKEND_READ",      // panic when read from backend

        // errors. most of keys are same to defines in bfe_basic/error_code.go
        // client side
        "ERR_CLIENT_LONG_HEADER",
        "ERR_CLIENT_CLOSE",
        "ERR_CLIENT_TIMEOUT",
        "ERR_CLIENT_BAD_REQUEST",
        "ERR_CLIENT_ZERO_CONTENTLEN",
        "ERR_CLIENT_EXPECT_FAIL",
        "ERR_CLIENT_CONN_ACCEPT", // no correspond error code
        "ERR_CLIENT_WRITE",
        "ERR_CLIENT_RESET",
        // backend side
        "ERR_BK_FIND_LOCATION",
        "ERR_BK_NO_CLUSTER",
        "ERR_BK_NO_SUB_CLUSTER",
        "ERR_BK_NO_BACKEND",
        "ERR_BK_CONNECT_BACKEND",
        "ERR_BK_RETRY_TOOMANY",
        "ERR_BK_NO_SUB_CLUSTER_CROSS",
        // gslb
        "ERR_GSLB_BLACKHOLE",
        // blacklist
        // "ERR_BLACKLIST",             // replaced by counters in mod_block

        // tls
        "TLS_HANDSHAKE_ALL",
        "TLS_HANDSHAKE_SUCC",

        // tls session cache
        "SESSION_CACHE_CONN",
        "SESSION_CACHE_CONN_FAIL",
        "SESSION_CACHE_SET",
        "SESSION_CACHE_SET_FAIL",
        "SESSION_CACHE_GET",
        "SESSION_CACHE_GET_FAIL",
    "SESSION_CACHE_TYPE_NOT_BYTES",
        "SESSION_CACHE_MISS",
        "SESSION_CACHE_HIT",
    "SESSION_CACHE_GET_BNS_INSTANCE_ERR",
    "SESSION_CACHE_NO_BNS_INSTANCE",

    // tls multiply certificates
        "TLS_MULTI_CERT_GET",
    "TLS_MULTI_CERT_CONN_WITHOUT_VIP",
    "TLS_MULTI_CERT_CONN_VIP_UNKOWN",
    "TLS_MULTI_CERT_CONN_WITHOUT_SNI",
    "TLS_MULTI_CERT_USE_DEFAULT",
    "TLS_MULTI_CERT_UPDATE",

    // tls next protos
    "TLS_NEXT_PROTOS_GET",
    "TLS_NEXT_PROTOS_CONN_WITHOUT_VIP",
    "TLS_NEXT_PROTOS_CONN_VIP_UNKNOWN",
    "TLS_NEXT_PROTOS_UPDATE",

        // client side
        "CLIENT_REQ_SERVED",             // req head successful received
        "CLIENT_REQ_ACTIVE",             // active req
        "CLIENT_REQ_WITH_RETRY",         // req served with retry
        "CLIENT_REQ_WITH_CROSS_RETRY",   // req served with cross cluster retry
        "CLIENT_REQ_FAIL",               // req with ErrCode != nil
        "CLIENT_REQ_FAIL_WITH_NO_RETRY", // req fail with no retry

        "CLIENT_CONN_SERVED",           // connection successful accepted
        "CLIENT_CONN_ACTIVE",           // active connection
        "CLIENT_CONN_USE_100_CONTINUE", // connection used Expect 100 Continue
        "CLIENT_CONN_UNFINISHED_REQ",   // connection closed with unfinished request

        // for handler actions
        "HANDLE_ACCEPT.FINISH", // HANDLE_ACCEPT, return FINISH

        "HANDLE_BEFORE_LOCATION.FINISH",   // HANDLE_BEFORE_LOCATION, return FINISH
        "HANDLE_BEFORE_LOCATION.REDIRECT", // HANDLE_BEFORE_LOCATION, return REDIRECT
        "HANDLE_BEFORE_LOCATION.RESPONSE", // HANDLE_BEFORE_LOCATION, return RESPONSE

        "HANDLE_AFTER_LOCATION.FINISH",   // HANDLE_AFTER_LOCATION, return FINISH
        "HANDLE_AFTER_LOCATION.REDIRECT", // HANDLE_AFTER_LOCATION, return REDIRECT
        "HANDLE_AFTER_LOCATION.RESPONSE", // HANDLE_AFTER_LOCATION, return RESPONSE

        "HANDLE_READ_BACKEND.FINISH",   // HANDLE_READ_BACKEND, return FINISH
        "HANDLE_READ_BACKEND.REDIRECT", // HANDLE_READ_BACKEND, return REDIRECT

        "HANDLE_REQUEST_FINISH.FINISH", // HANDLE_REQUEST_FINISH, return FINISH
}

func (srv *BfeServer) proxyStateInc(proto string, key string, value int) <span class="cov0" title="0">{
        key2 := fmt.Sprintf("%s_%s", proto, key)
        srv.proxyState.Inc(key2, value)
        srv.proxyState.Inc(key, value)
}</span>

func (srv *BfeServer) alpStateInc(proto string, key string, value int) <span class="cov0" title="0">{
    key = fmt.Sprintf("TLS_ALP_%s_%s", strings.ToUpper(proto), key)
    srv.proxyState.Inc(key, value)
}</span>

// get srv.proxyState
func (srv *BfeServer) proxyStateGet(params map[string][]string) ([]byte, error) <span class="cov0" title="0">{
        // get data for proxyState
        s := srv.proxyState.GetAll()

        // get param for format
        format, err := web_monitor.ParamsValueGet(params, "format")
        if err != nil </span><span class="cov0" title="0">{
                // default format is json
                format = "json"
        }</span>

        <span class="cov0" title="0">var buff []byte
        err = nil
        switch format </span>{
        <span class="cov0" title="0">case "json":
                buff, err = json.Marshal(s)</span>
        <span class="cov0" title="0">case "noah":
                buff = s.NoahString()</span>
        <span class="cov0" title="0">default:
                err = fmt.Errorf("invalid format:%s", format)</span>
        }
        <span class="cov0" title="0">return buff, err</span>
}

// get srv.proxyDelay
func (srv *BfeServer) proxyDelayGet() *delay_counter.DelayOutput <span class="cov0" title="0">{
        delayOuput := srv.proxyDelay.Get()
        return &amp;delayOuput
}</span>

// get srv.proxyPostDelay
func (srv *BfeServer) proxyPostDelayGet() *delay_counter.DelayOutput <span class="cov0" title="0">{
        delayOuput := srv.proxyPostDelay.Get()
        return &amp;delayOuput
}</span>

// get srv.handshakeDelay
func (srv *BfeServer) proxyHandshakeDelayGet() *delay_counter.DelayOutput <span class="cov0" title="0">{
        delayOuput := srv.proxyHandshakeDelay.Get()
        return &amp;delayOuput
}</span>

// get srv.handshakeFullDelay
func (srv *BfeServer) proxyHandshakeFullDelayGet() *delay_counter.DelayOutput <span class="cov0" title="0">{
        delayOuput := srv.proxyHandshakeFullDelay.Get()
        return &amp;delayOuput
}</span>

// get srv.handshakeResumeDelay
func (srv *BfeServer) proxyHandshakeResumeDelayGet() *delay_counter.DelayOutput <span class="cov0" title="0">{
        delayOuput := srv.proxyHandshakeResumeDelay.Get()
        return &amp;delayOuput
}</span>

// get module status (available, enabled)
func (srv *BfeServer) ModuleStatusGetJson() ([]byte, error) <span class="cov0" title="0">{
        return bfe_module.ModuleStatusGetJson()
}</span>
</pre>
		
		<pre class="file" id="file164" style="display: none">/* tls_multi_cert.go - an implementation of tls.MultiCertificate */
/*
modification history
--------------------
2015/7/21, by Sijie Yang, create

2015/9/07, by Weiwei Zhang, modify
    - use certGroup to manage vip-cert map
    - get cert from certGroup by cert type

2015/10/28, by Sijie Yang, modify
    - choose cert by SNI (Server Name Indication) if vip for connection 
      not found unexpectedly
*/
/*
DESCRIPTION
*/
package bfe_server

import (
    "fmt"
    "strings"
    "sync"
)

import (
    "www.baidu.com/golang-lib/module_state2"
)

import (
    "bfe_config/bfe_tls_conf/tls_rule_conf"
    "bfe_config/bfe_tls_conf/server_cert_conf"
    "bfe_util"
    "bfe_tls"
)

type MultiCertMap struct {
    vipCertMap       map[string]*server_cert_conf.CertGroup // vip -&gt; CertGroup
    nameCertMap      *NameCertMap                           // name -&gt; CertGroup

    defaultCertGroup *server_cert_conf.CertGroup            // default CertGroup
    defaultCertType  string                                 // default cert type

    lock             sync.RWMutex
    state            *module_state2.State                   // state for MultiCertMap
}

func NewMultiCertMap(state *module_state2.State, defaultCertType string) *MultiCertMap <span class="cov0" title="0">{
    m := new(MultiCertMap)
    m.vipCertMap = make(map[string]*server_cert_conf.CertGroup)
    m.nameCertMap = NewNameCertMap()
    m.state = state
    m.defaultCertType = defaultCertType
    return m
}</span>

// get certificate for given connection
func (m *MultiCertMap) Get(c *bfe_tls.Conn) *bfe_tls.Certificate <span class="cov0" title="0">{
    var certGroup *server_cert_conf.CertGroup
    m.state.Inc("TLS_MULTI_CERT_GET", 1)

    m.lock.RLock()
    defer m.lock.RUnlock()

    // choose certificate by vip
    conn := c.GetNetConn()
    vip := bfe_util.GetVip(conn)
    if vip != nil </span><span class="cov0" title="0">{
        key := vip.To4().String()
        certGroup = m.vipCertMap[key]
        if certGroup == nil </span><span class="cov0" title="0">{
            m.state.Inc("TLS_MULTI_CERT_CONN_VIP_UNKNOWN", 1)
        }</span>
    } <span class="cov0" title="0">else {
        m.state.Inc("TLS_MULTI_CERT_CONN_WITHOUT_VIP", 1)
    }</span>

    // if vip for connection is not found unexpectedly, or vip for connection is unknown,
    // try to choose cert by SNI (Server Name Indication)
    <span class="cov0" title="0">if certGroup == nil </span><span class="cov0" title="0">{
        serverName := c.GetServerName()
        if len(serverName) &gt; 0 </span><span class="cov0" title="0">{
            certGroup = m.nameCertMap.Get(serverName)
        }</span> <span class="cov0" title="0">else {
            m.state.Inc("TLS_MULTI_CERT_CONN_WITHOUT_SNI", 1)
        }</span>
    }

    // choose default cert
    <span class="cov0" title="0">if certGroup == nil </span><span class="cov0" title="0">{
        certGroup = m.defaultCertGroup
        m.state.Inc("TLS_MULTI_CERT_USE_DEFAULT", 1)
    }</span>

    // return cert with preferred type
    <span class="cov0" title="0">preferredCertType := c.GetCertType()
    if preferredCertType == bfe_tls.CertTypeUnsure </span><span class="cov0" title="0">{
        preferredCertType = m.defaultCertType
    }</span>
    <span class="cov0" title="0">return certGroup.GetCert(preferredCertType)</span>
}

func (m *MultiCertMap) GetDefault() *bfe_tls.Certificate <span class="cov0" title="0">{
    m.lock.RLock()
    defer m.lock.RUnlock()

    if m.defaultCertGroup == nil </span><span class="cov0" title="0">{
        return nil
    }</span>

    <span class="cov0" title="0">cert := m.defaultCertGroup.GetCert(m.defaultCertType)
    return cert</span>
}

// update all certificates
func (m *MultiCertMap) Update(certConf map[string]*server_cert_conf.CertGroup,
                              ruleMap tls_rule_conf.TlsRuleMap) error <span class="cov0" title="0">{
    m.state.Inc("TLS_MULTI_CERT_UPDATE", 1)

    vipCertMap := make(map[string]*server_cert_conf.CertGroup)
    for _, ruleConf := range(ruleMap) </span><span class="cov0" title="0">{
        cert, ok := certConf[ruleConf.CertName]
        if !ok </span><span class="cov0" title="0">{
            m.state.Inc("TLS_MULTI_CERT_UPDATE_ERR", 1)
            return fmt.Errorf("certificate %s not exist", ruleConf.CertName)
        }</span>
        <span class="cov0" title="0">for _, vip := range(ruleConf.VipConf) </span><span class="cov0" title="0">{
            vipCertMap[vip] = cert
        }</span>
    }

    <span class="cov0" title="0">nameCertMap := NewNameCertMap()
    nameCertMap.Update(certConf)

    defaultCertGroup := certConf[server_cert_conf.DefaultCert]
    if defaultCertGroup == nil </span><span class="cov0" title="0">{
         m.state.Inc("TLS_MULTI_CERT_UPDATE_ERR", 1)
         return fmt.Errorf("default certificate group not exist")
    }</span>

    <span class="cov0" title="0">m.lock.Lock()
    m.vipCertMap = vipCertMap
    m.nameCertMap = nameCertMap
    m.defaultCertGroup = defaultCertGroup
    m.lock.Unlock()

    return nil</span>
}

type NameCertMap struct {
    normalCertMap   map[string]*server_cert_conf.CertGroup  // cert map for normal name
    wildcardCertMap map[string]*server_cert_conf.CertGroup  // cert map for wildcard name
}

func NewNameCertMap() *NameCertMap <span class="cov0" title="0">{
    m := new(NameCertMap)
    m.normalCertMap = make(map[string]*server_cert_conf.CertGroup)
    m.wildcardCertMap = make(map[string]*server_cert_conf.CertGroup)
    return m
}</span>

func (m *NameCertMap) Get(serverName string) *server_cert_conf.CertGroup <span class="cov0" title="0">{
    serverName = strings.ToLower(serverName) 
    for len(serverName) &gt; 0 &amp;&amp; serverName[len(serverName)-1] == '.' </span><span class="cov0" title="0">{
        serverName = serverName[:len(serverName)-1]
    }</span>

    <span class="cov0" title="0">if cert, ok := m.normalCertMap[serverName]; ok </span><span class="cov0" title="0">{
        return cert
    }</span>

    // Note: Since number of wildcard names is too small, 
    // just perform sequent matching here
    <span class="cov0" title="0">for name, cert := range(m.wildcardCertMap) </span><span class="cov0" title="0">{
        if m.matchHostnames(name, serverName) </span><span class="cov0" title="0">{
            return cert
        }</span>
    }

    <span class="cov0" title="0">return nil</span>
}

func (m *NameCertMap) matchHostnames(pattern, host string) bool <span class="cov0" title="0">{
    if len(pattern) == 0 || len(host) == 0 </span><span class="cov0" title="0">{
        return false
    }</span>

    <span class="cov0" title="0">patternParts := strings.Split(pattern, ".")
    hostParts := strings.Split(host, ".")

    if len(patternParts) != len(hostParts) </span><span class="cov0" title="0">{
        return false
    }</span>

    <span class="cov0" title="0">for i, patternPart := range patternParts </span><span class="cov0" title="0">{
        if patternPart == "*" </span><span class="cov0" title="0">{
            continue</span>
        }
        <span class="cov0" title="0">if patternPart != hostParts[i] </span><span class="cov0" title="0">{
            return false
        }</span>
    }

    <span class="cov0" title="0">return true</span>
}

func (m *NameCertMap) Update(certConf map[string]*server_cert_conf.CertGroup) <span class="cov0" title="0">{
    normalCertMap := make(map[string]*server_cert_conf.CertGroup)
    wildcardCertMap := make(map[string]*server_cert_conf.CertGroup)

    for _, certGroup := range(certConf) </span><span class="cov0" title="0">{
        names := certGroup.GetNames()
        for _, name := range(names) </span><span class="cov0" title="0">{
            if strings.Contains(name, "*") </span><span class="cov0" title="0">{
                wildcardCertMap[name] = certGroup
            }</span> <span class="cov0" title="0">else {
                normalCertMap[name] = certGroup
            }</span>
        }
    }
    <span class="cov0" title="0">m.normalCertMap = normalCertMap
    m.wildcardCertMap = wildcardCertMap</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">/* tls_next_protos.go - an implementation of tls.NextProtoNegotiate*/
/*
modification history
--------------------
2015/8/10, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package bfe_server

import (
    "sync"
)

import (
    "www.baidu.com/golang-lib/module_state2"
)

import (
    "bfe_config/bfe_tls_conf/tls_rule_conf"
    "bfe_util"
    "bfe_tls"
)

/* NextProtosMap selects NextProtos for tls connection based on VIP.
 *
 * NextProtos is a list of supported, application level protocols (eg spdy, http2, etc)
 * over tls connection. We may use different NextProtos for different product.
 *
 * SNI (Server Name Indication) is an extension to the TLS protocol by
 * which a client indicates which hostname(product) it is attempting to connect.
 * Unfortunately, not all the browsers implement SNI now. 
 * 
 * In practice, we just use VIP of the connection to identify the product and select
 * configured NextProtos for the product.
 */
type NextProtosMap struct {
    allNextProtos map[string][]string  // vip -&gt; next proto conf
    lock          sync.RWMutex
    state         *module_state2.State // state for NextProtosMap
}

func NewNextProtosMap(state *module_state2.State) *NextProtosMap <span class="cov0" title="0">{
    m := new(NextProtosMap)
    m.allNextProtos = make(map[string][]string)
    m.state = state
    return m
}</span>

// get next protos for given connection
func (m *NextProtosMap) NextProtos(c *bfe_tls.Conn) []string <span class="cov0" title="0">{
    m.state.Inc("TLS_NEXT_PROTOS_GET", 1)

    // get vip for given connection
    conn := c.GetNetConn()
    vip := bfe_util.GetVip(conn)
    if vip == nil </span><span class="cov0" title="0">{
        m.state.Inc("TLS_NEXT_PROTOS_CONN_WITHOUT_VIP", 1)
        return nil
    }</span>

    // choose certificate by vip
    <span class="cov0" title="0">key := vip.To4().String()
    m.lock.RLock()
    nextProtos, ok := m.allNextProtos[key]
    m.lock.RUnlock()

    if !ok </span><span class="cov0" title="0">{
        m.state.Inc("TLS_NEXT_PROTOS_CONN_VIP_UNKNOWN", 1)
    }</span>

    <span class="cov0" title="0">return nextProtos</span>
}

// get next protos conf
func (m *NextProtosMap) Update(ruleMap tls_rule_conf.TlsRuleMap) error <span class="cov0" title="0">{
    m.state.Inc("TLS_NEXT_PROTOS_UPDATE", 1)

    nextProtosMap := make(map[string][]string)
    for _, ruleConf := range(ruleMap) </span><span class="cov0" title="0">{
        for _, vip := range(ruleConf.VipConf) </span><span class="cov0" title="0">{
            nextProtosMap[vip] = ruleConf.NextProtos
        }</span>
    }

    <span class="cov0" title="0">m.lock.Lock()
    m.allNextProtos = nextProtosMap
    m.lock.Unlock()

    return nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">/* tls_session_cache.go - an implementation of tls.ServerSessionCache */
/*
modification history
--------------------
2015/4/11, by Sijie Yang, create
    - merge code from session cache demo written by Weiwei Zhang
    - support connection pool to multiply redis servers
*/
/*
DESCRIPTION
    A session cache implementation based on redis
*/
package bfe_server

import (
    "fmt"
    "math/rand"
    "reflect"
    "sync"
    "time"
)

import (
    "github.com/garyburd/redigo/redis"
    "www.baidu.com/golang-lib/bns"
    "www.baidu.com/golang-lib/log"
    "www.baidu.com/golang-lib/module_state2"
)

import (
    "bfe_config/bfe_conf"
)

type RedisSessionCache struct {
    Servers        []string             // tcp address for redis servers
    serversLock    sync.RWMutex         // lock for servers
    bnsClient      *bns.Client          // bns client

    ConnectTimeout time.Duration        // connect timeout (ms)
    ReadTimeout    time.Duration        // read timeout (ms)
    WriteTimeout   time.Duration        // write timeout (ms)
    KeyPrefix      string               // prefix for cache key

    SessionExpire  int                  // expire time for sessionState (ms)
    MaxIdle        int                  // max idle conenctions in pool
    pool           *redis.Pool          // connection pool to redis server
    poolLock       sync.RWMutex         // lock for pool

    state          *module_state2.State // state for session cache
}

func NewRedisSessionCache (conf bfe_conf.ConfigSessionCache, state *module_state2.State) (
                           c *RedisSessionCache) <span class="cov0" title="0">{
    var err error
    c = new(RedisSessionCache)

    // get address list of redis servers
    c.bnsClient = bns.NewClient()
    if c.Servers, err = bns.GetAddr(c.bnsClient, conf.Servers); err != nil </span><span class="cov0" title="0">{
        log.Logger.Warn("RedisSessionCache: get instance for %s error (%s)", conf.Servers, err)
        c.Servers = make([]string, 0)
    }</span>

    <span class="cov0" title="0">c.ConnectTimeout = time.Duration(conf.ConnectTimeout) * time.Millisecond
    c.ReadTimeout = time.Duration(conf.ReadTimeout) * time.Millisecond
    c.WriteTimeout = time.Duration(conf.WriteTimeout) * time.Millisecond
    c.KeyPrefix = conf.KeyPrefix

    c.SessionExpire = conf.SessionExpire
    c.MaxIdle = conf.MaxIdle
    c.pool = &amp;redis.Pool {
        MaxIdle: c.MaxIdle,
        Dial: c.dial,
    }

    c.state = state
    go c.checkServerInstance(conf.Servers)

    return c</span>
}

func (c *RedisSessionCache) dial() (redis.Conn, error) <span class="cov0" title="0">{
    c.state.Inc("SESSION_CACHE_CONN", 1)

    // choose a random server
    c.serversLock.RLock()
    if len(c.Servers) == 0 </span><span class="cov0" title="0">{
        c.serversLock.RUnlock()
        return nil, fmt.Errorf("no available connnection in pool") 
    }</span>
    <span class="cov0" title="0">server := c.Servers[rand.Intn(len(c.Servers))]
    c.serversLock.RUnlock()

    // create connection to server
    conn, err := redis.Dial("tcp", server)
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Debug("RedisSessionCache:dail() to %s err(%v)", server, err)
        c.state.Inc("SESSION_CACHE_CONN_FAIL", 1)
        return nil, err
    }</span>
    <span class="cov0" title="0">return conn, err</span>
}

// save sessionState to session cache
func (c *RedisSessionCache) Put(sessionKey string, sessionState []byte) (err error) <span class="cov0" title="0">{
    c.state.Inc("SESSION_CACHE_SET", 1)
    sessionKey = fmt.Sprintf("%s:%s", c.KeyPrefix, sessionKey)

    c.poolLock.RLock()
    pool := c.pool
    c.poolLock.RUnlock()

    // get connection from pool
    conn := pool.Get()
    defer conn.Close()

    // save session state to redis
    conn.Send("SET", sessionKey, sessionState)
    conn.Send("EXPIRE", sessionKey, c.SessionExpire)
    conn.Flush()
    if _, err = conn.Receive(); err != nil </span><span class="cov0" title="0">{
        log.Logger.Debug("RedisSessionCache:put() sessionState %v", err)
        c.state.Inc("SESSION_CACHE_SET_FAIL", 1)
        return err
    }</span>
    <span class="cov0" title="0">if _, err = conn.Receive(); err != nil </span><span class="cov0" title="0">{
        log.Logger.Debug("RedisSessionCache:put() sessionState %v", err)
        c.state.Inc("SESSION_CACHE_SET_FAIL", 1)
        return err
    }</span>

    <span class="cov0" title="0">log.Logger.Debug("RedisSessionCache:put() sessionState success (%s: %x)",
                     sessionKey, sessionState)
    return nil</span>
}

// get sessionState from session cache
func (c *RedisSessionCache) Get(sessionKey string) ([]byte, bool) <span class="cov0" title="0">{
    c.state.Inc("SESSION_CACHE_GET", 1)
    sessionKey = fmt.Sprintf("%s:%s", c.KeyPrefix, sessionKey)

    c.poolLock.RLock()
    pool := c.pool
    c.poolLock.RUnlock()

    // get connection from pool
    conn := pool.Get()
    defer conn.Close()

    // get session state from redis
    sessionParam, err := conn.Do("GET", sessionKey)
    if err != nil </span><span class="cov0" title="0">{
        log.Logger.Debug("RedisSessionCache:get() sessionState %v", err)
        if err != redis.ErrNil </span><span class="cov0" title="0">{
            c.state.Inc("SESSION_CACHE_GET_FAIL", 1)
        }</span> <span class="cov0" title="0">else {
            c.state.Inc("SESSION_CACHE_MISS", 1)
        }</span>
        <span class="cov0" title="0">return nil, false</span>
    }

    <span class="cov0" title="0">sessionState, ok := sessionParam.([]byte)
    if !ok </span><span class="cov0" title="0">{
        c.state.Inc("SESSION_CACHE_TYPE_NOT_BYTES", 1)
        log.Logger.Debug("RedisSessionCache:get() sessionState type not []byte(%s: %T)", 
                         sessionKey, sessionParam)
        return nil, false
    }</span>
    
    <span class="cov0" title="0">log.Logger.Debug("RedisSessionCache:get() sessionState success (%s: %x)", 
                     sessionKey, sessionState)
    c.state.Inc("SESSION_CACHE_HIT", 1)
    return sessionState, true</span>
}

func (c *RedisSessionCache) UpdateServers(servers []string) <span class="cov0" title="0">{
    c.serversLock.Lock()    
    c.Servers = servers
    c.serversLock.Unlock()
}</span>

func (c *RedisSessionCache) UpdatePool(pool *redis.Pool) *redis.Pool <span class="cov0" title="0">{
    c.poolLock.RLock()
    oldPool := c.pool
    c.pool = pool
    c.poolLock.RUnlock()

    return oldPool
}</span>

func (c *RedisSessionCache) checkServerInstance(name string) <span class="cov0" title="0">{
    for </span><span class="cov0" title="0">{
        time.Sleep(10 * time.Second)

        // check addresses of redis servers
        servers, err := bns.GetAddr(c.bnsClient, name)
        if err != nil </span><span class="cov0" title="0">{
            log.Logger.Warn("RedisSessionCache: get instance address %s", err.Error())
            c.state.Inc("SESSION_CACHE_GET_BNS_INSTANCE_ERR", 1)
            continue</span>
        }
        <span class="cov0" title="0">if len(servers) == 0 </span><span class="cov0" title="0">{
            log.Logger.Warn("RedisSessionCache: no address configured for %v", name)
            c.state.Inc("SESSION_CACHE_NO_BNS_INSTANCE", 1)
            continue</span>
        }
        <span class="cov0" title="0">if reflect.DeepEqual(servers, c.Servers) </span><span class="cov0" title="0">{
            continue</span>
        }

        // update addresses of redis servers
        <span class="cov0" title="0">c.UpdateServers(servers)

        // update connection pool
        pool := &amp;redis.Pool {
            MaxIdle: c.MaxIdle,
            Dial: c.dial,
        }
        oldPool := c.UpdatePool(pool)
        oldPool.Close()</span>
    }
}
</pre>
		
		<pre class="file" id="file167" style="display: none">/* web_server.go - embeded web server in bfe */
/*
modification history
--------------------
2014/4/17, by Zhang Miao, create from copy in waf-server
*/
/*
DESCRIPTION
This web server is for monitor internal state of bfe
*/
package bfe_server

import (
        "www.baidu.com/golang-lib/log"
        "www.baidu.com/golang-lib/web_monitor"
)

type BfeMonitor struct {
        WebServer   *web_monitor.MonitorServer
        WebHandlers *web_monitor.WebHandlers
        srv         *BfeServer
}

func newBfeMonitor(srv *BfeServer, monitorPort int) (*BfeMonitor, error) <span class="cov0" title="0">{
        m := &amp;BfeMonitor{nil, nil, srv}

        // initialize web handlers
        m.WebHandlers = web_monitor.NewWebHandlers()
        if err := m.WebHandlersInit(m.srv); err != nil </span><span class="cov0" title="0">{
                log.Logger.Error("newBfeMonitor(): in WebHandlersInit(): ", err.Error())
                return nil, err
        }</span>

        // initialize web server
        <span class="cov0" title="0">m.WebServer = web_monitor.NewMonitorServer("go-bfe", srv.Version, monitorPort)
        m.WebServer.HandlersSet(m.WebHandlers)

        return m, nil</span>
}

// all monitor handlers
func (m *BfeMonitor) monitorHandlers() map[string]interface{} <span class="cov0" title="0">{
        handlers := map[string]interface{}{
                // for host-table
                "host_table_status":  m.srv.HostTableStatusGet,
                "host_table_version": m.srv.HostTableVersionGet,
                // for cluster-table: only contain cluster_conf version
                "cluster_table_version": m.srv.ClusterTableVersionGet,
                // for bal-table
                "bal_table_status":  m.srv.BalTableStatusGet,
                "bal_table_version": m.srv.BalTableVersionGet,
                // for proxy_state
                "proxy_state":      m.srv.proxyStateGet,
                "proxy_state_diff": m.srv.proxyStateDiff.GetJson,
                // for proxy_delay
                "proxy_delay":                  web_monitor.CreateDelayOutputHandler(m.srv.proxyDelayGet),
                "proxy_post_delay":             web_monitor.CreateDelayOutputHandler(m.srv.proxyPostDelayGet),
                "proxy_handshake_delay":        web_monitor.CreateDelayOutputHandler(m.srv.proxyHandshakeDelayGet),
                "proxy_handshake_full_delay":   web_monitor.CreateDelayOutputHandler(m.srv.proxyHandshakeFullDelayGet),
                "proxy_handshake_resume_delay": web_monitor.CreateDelayOutputHandler(m.srv.proxyHandshakeResumeDelayGet),

                // for module status
                "module_status": m.srv.ModuleStatusGetJson,
                // for process info
                "process_info": m.srv.processInfoGet,
                // for proxy memory stat
                "proxy_mem_stat": web_monitor.CreateMemStatsHandler("proxy_mem_stat"),
        }
        return handlers
}</span>

// all reload handlers
func (m *BfeMonitor) reloadHandlers() map[string]interface{} <span class="cov0" title="0">{
        handlers := map[string]interface{}{
                // for server data conf
                "server_data_conf": m.srv.ServerDataConfReload,

                // for gslb data conf
                "gslb_data_conf": m.srv.GslbDataConfReload,

                // for tls
                "tls_session_ticket_key": m.srv.SessionTicketKeyReload,
                "tls_ocsp_staple":        m.srv.CertificateReload,
                "tls_certificate":        m.srv.CertificateReload,
                "tls_next_protos":        m.srv.NextProtosReload,
        }
        return handlers
}</span>

func (m *BfeMonitor) WebHandlersInit(srv *BfeServer) error <span class="cov0" title="0">{
        // register handlers for monitor
        err := web_monitor.RegisterHandlers(m.WebHandlers, web_monitor.WEB_HANDLE_MONITOR,
                m.monitorHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // register handlers for for reload
        <span class="cov0" title="0">err = web_monitor.RegisterHandlers(m.WebHandlers, web_monitor.WEB_HANDLE_RELOAD,
                m.reloadHandlers())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *BfeMonitor) Start() <span class="cov0" title="0">{
        go m.WebServer.Start()
}</span>
</pre>
		
		<pre class="file" id="file168" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "bytes"
        "compress/zlib"
        "errors"
        "io"
        "strings"
        "sync"
)

import (
        http "bfe_http"
)

var versionError = errors.New("Version not supported.")

var zlibV2Writers chan *zlib.Writer
var zlibV3Writers chan *zlib.Writer

func init() <span class="cov1" title="1">{
        zlibV2Writers = make(chan *zlib.Writer, 5)
        zlibV3Writers = make(chan *zlib.Writer, 5)
}</span>

// Decompressor is used to decompress name/value header blocks.
// Decompressors retain their state, so a single Decompressor
// should be used for each direction of a particular connection.
type decompressor struct {
        sync.Mutex
        in      *bytes.Buffer
        out     io.ReadCloser
        version uint16
}

// NewDecompressor is used to create a new decompressor.
// It takes the SPDY version to use.
func NewDecompressor(version uint16) Decompressor <span class="cov4" title="2">{
        out := new(decompressor)
        out.version = version
        return out
}</span>

// Decompress uses zlib decompression to decompress the provided
// data, according to the SPDY specification of the given version.
func (d *decompressor) Decompress(data []byte) (headers http.Header, err error) <span class="cov4" title="2">{
        d.Lock()
        defer d.Unlock()

        // Make sure the buffer is ready.
        if d.in == nil </span><span class="cov4" title="2">{
                d.in = bytes.NewBuffer(data)
        }</span> <span class="cov0" title="0">else {
                d.in.Reset()
                d.in.Write(data)
        }</span>

        // Initialise the decompressor with the appropriate
        // dictionary, depending on SPDY version.
        <span class="cov4" title="2">if d.out == nil </span><span class="cov4" title="2">{
                switch d.version </span>{
                <span class="cov1" title="1">case 2:
                        d.out, err = zlib.NewReaderDict(d.in, HeaderDictionaryV2)</span>
                <span class="cov1" title="1">case 3:
                        d.out, err = zlib.NewReaderDict(d.in, HeaderDictionaryV3)</span>
                <span class="cov0" title="0">default:
                        err = versionError</span>
                }

                <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov4" title="2">var size int
        var bytesToInt func([]byte) int

        // SPDY/2 uses 16-bit fixed fields, where SPDY/3 uses 32-bit fields.
        switch d.version </span>{
        <span class="cov1" title="1">case 2:
                size = 2
                bytesToInt = func(b []byte) int </span><span class="cov10" title="5">{
                        return int(BytesToUint16(b))
                }</span>
        <span class="cov1" title="1">case 3:
                size = 4
                bytesToInt = func(b []byte) int </span><span class="cov10" title="5">{
                        return int(BytesToUint32(b))
                }</span>
        <span class="cov0" title="0">default:
                return nil, versionError</span>
        }

        // Read in the number of name/value pairs.
        <span class="cov4" title="2">pairs, err := ReadExactly(d.out, size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">numNameValuePairs := bytesToInt(pairs)

        headers = make(http.Header)
        bounds := MAX_FRAME_SIZE - 12 // Maximum frame size minus maximum non-headers data (SYN_STREAM)
        for i := 0; i &lt; numNameValuePairs; i++ </span><span class="cov8" title="4">{
                var nameLength, valueLength int

                // Get the name's length.
                length, err := ReadExactly(d.out, size)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="4">nameLength = bytesToInt(length)
                bounds -= size

                if nameLength &gt; bounds </span><span class="cov0" title="0">{
                        debug.Printf("Error: Maximum header length is %d. Received name length %d.\n", bounds, nameLength)
                        return nil, errors.New("Error: Incorrect header name length.")
                }</span>
                <span class="cov8" title="4">bounds -= nameLength

                // Get the name.
                name, err := ReadExactly(d.out, nameLength)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Get the value's length.
                <span class="cov8" title="4">length, err = ReadExactly(d.out, size)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="4">valueLength = bytesToInt(length)
                bounds -= size

                if valueLength &gt; bounds </span><span class="cov0" title="0">{
                        debug.Printf("Error: Maximum header length is %d. Received values length %d.\n", bounds, valueLength)
                        return nil, errors.New("Error: Incorrect header values length.")
                }</span>
                <span class="cov8" title="4">bounds -= valueLength

                // Get the values.
                values, err := ReadExactly(d.out, valueLength)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Split the value on null boundaries.
                <span class="cov8" title="4">for _, value := range bytes.Split(values, []byte{'\x00'}) </span><span class="cov8" title="4">{
                        headers.Add(string(name), string(value))
                }</span>
        }

        <span class="cov4" title="2">return headers, nil</span>
}

// Compressor is used to compress name/value header blocks.
// Compressors retain their state, so a single Compressor
// should be used for each direction of a particular
// connection.
type compressor struct {
        sync.Mutex
        buf     *bytes.Buffer
        w       *zlib.Writer
        version uint16
}

// NewCompressor is used to create a new compressor.
// It takes the SPDY version to use.
func NewCompressor(version uint16) Compressor <span class="cov4" title="2">{
        out := new(compressor)
        out.version = version
        return out
}</span>

// Compress uses zlib compression to compress the provided
// data, according to the SPDY specification of the given version.
func (c *compressor) Compress(h http.Header) ([]byte, error) <span class="cov4" title="2">{
        c.Lock()
        defer c.Unlock()

        // Ensure the buffer is prepared.
        if c.buf == nil </span><span class="cov4" title="2">{
                c.buf = new(bytes.Buffer)
        }</span> <span class="cov0" title="0">else {
                c.buf.Reset()
        }</span>

        // Same for the compressor.
        <span class="cov4" title="2">if c.w == nil </span><span class="cov4" title="2">{
                var err error
                switch c.version </span>{
                <span class="cov1" title="1">case 2:
                        select </span>{
                        <span class="cov0" title="0">case c.w = &lt;-zlibV2Writers:
                                c.w.Reset(c.buf)</span>
                        <span class="cov1" title="1">default:
                                c.w, err = zlib.NewWriterLevelDict(c.buf, zlib.BestCompression, HeaderDictionaryV2)</span>
                        }
                <span class="cov1" title="1">case 3:
                        select </span>{
                        <span class="cov0" title="0">case c.w = &lt;-zlibV3Writers:
                                c.w.Reset(c.buf)</span>
                        <span class="cov1" title="1">default:
                                c.w, err = zlib.NewWriterLevelDict(c.buf, zlib.BestCompression, HeaderDictionaryV3)</span>
                        }
                <span class="cov0" title="0">default:
                        err = versionError</span>
                }
                <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov4" title="2">var size int // Size of length values.
        switch c.version </span>{
        <span class="cov1" title="1">case 2:
                size = 2</span>
        <span class="cov1" title="1">case 3:
                size = 4</span>
        <span class="cov0" title="0">default:
                return nil, versionError</span>
        }

        // Remove invalid headers.
        <span class="cov4" title="2">h.Del("Connection")
        h.Del("Keep-Alive")
        h.Del("Proxy-Connection")
        h.Del("Transfer-Encoding")

        length := size                   // The 4-byte or 2-byte number of name/value pairs.
        pairs := make(map[string]string) // Used to store the validated, joined headers.
        for name, values := range h </span><span class="cov8" title="4">{
                // Ignore invalid names.
                if _, ok := pairs[name]; ok </span><span class="cov0" title="0">{ // We've already seen this name.
                        return nil, errors.New("Error: Duplicate header name discovered.")
                }</span>
                <span class="cov8" title="4">if name == "" </span><span class="cov0" title="0">{ // Ignore empty names.
                        continue</span>
                }

                // Multiple values are separated by a single null byte.
                <span class="cov8" title="4">pairs[name] = strings.Join(values, "\x00")

                // +size for len(name), +size for len(values).
                length += len(name) + size + len(pairs[name]) + size</span>
        }

        // Uncompressed data.
        <span class="cov4" title="2">out := make([]byte, length)

        // Current offset into out.
        var offset uint32

        // Write the number of name/value pairs.
        num := uint32(len(pairs))
        switch c.version </span>{
        <span class="cov1" title="1">case 3:
                out[0] = byte(num &gt;&gt; 24)
                out[1] = byte(num &gt;&gt; 16)
                out[2] = byte(num &gt;&gt; 8)
                out[3] = byte(num)
                offset = 4</span>
        <span class="cov1" title="1">case 2:
                out[0] = byte(num &gt;&gt; 8)
                out[1] = byte(num)
                offset = 2</span>
        }

        // For each name/value pair...
        <span class="cov4" title="2">for name, value := range pairs </span><span class="cov8" title="4">{

                // The length of the name.
                nLen := uint32(len(name))
                switch c.version </span>{
                <span class="cov4" title="2">case 3:
                        out[offset+0] = byte(nLen &gt;&gt; 24)
                        out[offset+1] = byte(nLen &gt;&gt; 16)
                        out[offset+2] = byte(nLen &gt;&gt; 8)
                        out[offset+3] = byte(nLen)
                        offset += 4</span>
                <span class="cov4" title="2">case 2:
                        out[offset+0] = byte(nLen &gt;&gt; 8)
                        out[offset+1] = byte(nLen)
                        offset += 2</span>
                }

                // The name itself.
                <span class="cov8" title="4">copy(out[offset:], []byte(strings.ToLower(name)))
                offset += nLen

                // The length of the value.
                vLen := uint32(len(value))
                switch c.version </span>{
                <span class="cov4" title="2">case 3:
                        out[offset+0] = byte(vLen &gt;&gt; 24)
                        out[offset+1] = byte(vLen &gt;&gt; 16)
                        out[offset+2] = byte(vLen &gt;&gt; 8)
                        out[offset+3] = byte(vLen)
                        offset += 4</span>
                <span class="cov4" title="2">case 2:
                        out[offset+0] = byte(vLen &gt;&gt; 8)
                        out[offset+1] = byte(vLen)
                        offset += 2</span>
                }

                // The value itself.
                <span class="cov8" title="4">copy(out[offset:], []byte(value))
                offset += vLen</span>
        }

        // Compress.
        <span class="cov4" title="2">err := WriteExactly(c.w, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">c.w.Flush()
        return c.buf.Bytes(), nil</span>
}

func (c *compressor) Close() error <span class="cov4" title="2">{
        if c.w == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="2">var channel chan *zlib.Writer
        switch c.version </span>{
        <span class="cov1" title="1">case 2:
                channel = zlibV2Writers</span>
        <span class="cov1" title="1">case 3:
                channel = zlibV3Writers</span>
        <span class="cov0" title="0">default:
                return ErrInvalidVersion</span>
        }
        <span class="cov4" title="2">select </span>{
        <span class="cov4" title="2">case channel &lt;- c.w:</span>
        <span class="cov0" title="0">default:
                err := c.w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov4" title="2">c.w = nil
        return nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "net/url"
        "strings"
)

// Frame types in SPDY/2
const (
        SYN_STREAMv2    = 1
        SYN_REPLYv2     = 2
        RST_STREAMv2    = 3
        SETTINGSv2      = 4
        NOOPv2          = 5
        PINGv2          = 6
        GOAWAYv2        = 7
        HEADERSv2       = 8
        WINDOW_UPDATEv2 = 9
        CONTROL_FRAMEv2 = -1
        DATA_FRAMEv2    = -2
)

// Frame types in SPDY/3
const (
        SYN_STREAMv3    = 1
        SYN_REPLYv3     = 2
        RST_STREAMv3    = 3
        SETTINGSv3      = 4
        PINGv3          = 6
        GOAWAYv3        = 7
        HEADERSv3       = 8
        WINDOW_UPDATEv3 = 9
        CREDENTIALv3    = 10
        CONTROL_FRAMEv3 = -1
        DATA_FRAMEv3    = -2
)

// Flags
const (
        FLAG_FIN                     = 1
        FLAG_UNIDIRECTIONAL          = 2
        FLAG_SETTINGS_CLEAR_SETTINGS = 1
        FLAG_SETTINGS_PERSIST_VALUE  = 1
        FLAG_SETTINGS_PERSISTED      = 2
)

// RST_STREAM status codes
const (
        RST_STREAM_PROTOCOL_ERROR        = 1
        RST_STREAM_INVALID_STREAM        = 2
        RST_STREAM_REFUSED_STREAM        = 3
        RST_STREAM_UNSUPPORTED_VERSION   = 4
        RST_STREAM_CANCEL                = 5
        RST_STREAM_INTERNAL_ERROR        = 6
        RST_STREAM_FLOW_CONTROL_ERROR    = 7
        RST_STREAM_STREAM_IN_USE         = 8
        RST_STREAM_STREAM_ALREADY_CLOSED = 9
        RST_STREAM_INVALID_CREDENTIALS   = 10
        RST_STREAM_FRAME_TOO_LARGE       = 11
)

// GOAWAY status codes
const (
        GOAWAY_OK                 = 0
        GOAWAY_PROTOCOL_ERROR     = 1
        GOAWAY_INTERNAL_ERROR     = 2
        GOAWAY_FLOW_CONTROL_ERROR = 3
)

// Settings IDs
const (
        SETTINGS_UPLOAD_BANDWIDTH               = 1
        SETTINGS_DOWNLOAD_BANDWIDTH             = 2
        SETTINGS_ROUND_TRIP_TIME                = 3
        SETTINGS_MAX_CONCURRENT_STREAMS         = 4
        SETTINGS_CURRENT_CWND                   = 5
        SETTINGS_DOWNLOAD_RETRANS_RATE          = 6
        SETTINGS_INITIAL_WINDOW_SIZE            = 7
        SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE = 8
)

// Maximum frame size (2 ** 24 -1).
const MAX_FRAME_SIZE = 0xffffff

const MAX_DATA_SIZE = 0xffffff

// Maximum stream ID (2 ** 31 -1).
const MAX_STREAM_ID = 0x7fffffff

// Maximum number of bytes in the transfer window.
const MAX_TRANSFER_WINDOW_SIZE = 0x80000000

// The default initial transfer window size, as defined in the spec.
const DEFAULT_INITIAL_WINDOW_SIZE = 65535

// The default initial transfer window sent by the client.
const DEFAULT_INITIAL_CLIENT_WINDOW_SIZE = 10485760

// Maximum delta window size field for WINDOW_UPDATE.
const MAX_DELTA_WINDOW_SIZE = 0x7fffffff

// The default maximum number of concurrent streams.
const DEFAULT_STREAM_LIMIT = 1000

// NO_STREAM_LIMIT can be used to disable the stream limit.
const NO_STREAM_LIMIT = 0x80000000

var statusCodeText = map[StatusCode]string{
        RST_STREAM_PROTOCOL_ERROR:        "PROTOCOL_ERROR",
        RST_STREAM_INVALID_STREAM:        "INVALID_STREAM",
        RST_STREAM_REFUSED_STREAM:        "REFUSED_STREAM",
        RST_STREAM_UNSUPPORTED_VERSION:   "UNSUPPORTED_VERSION",
        RST_STREAM_CANCEL:                "CANCEL",
        RST_STREAM_INTERNAL_ERROR:        "INTERNAL_ERROR",
        RST_STREAM_FLOW_CONTROL_ERROR:    "FLOW_CONTROL_ERROR",
        RST_STREAM_STREAM_IN_USE:         "STREAM_IN_USE",
        RST_STREAM_STREAM_ALREADY_CLOSED: "STREAM_ALREADY_CLOSED",
        RST_STREAM_INVALID_CREDENTIALS:   "INVALID_CREDENTIALS",
        RST_STREAM_FRAME_TOO_LARGE:       "FRAME_TOO_LARGE",
}

var settingText = map[uint32]string{
        SETTINGS_UPLOAD_BANDWIDTH:               "UPLOAD_BANDWIDTH",
        SETTINGS_DOWNLOAD_BANDWIDTH:             "DOWNLOAD_BANDWIDTH",
        SETTINGS_ROUND_TRIP_TIME:                "ROUND_TRIP_TIME",
        SETTINGS_MAX_CONCURRENT_STREAMS:         "MAX_CONCURRENT_STREAMS",
        SETTINGS_CURRENT_CWND:                   "CURRENT_CWND",
        SETTINGS_DOWNLOAD_RETRANS_RATE:          "DOWNLOAD_RETRANS_RATE",
        SETTINGS_INITIAL_WINDOW_SIZE:            "INITIAL_WINDOW_SIZE",
        SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE: "CLIENT_CERTIFICATE_VECTOR_SIZE",
}

// DefaultPriority returns the default request
// priority for the given target path. This is
// currently in accordance with Google Chrome;
// giving 0 for pages, 1 for CSS, 2 for JS, 3
// for images. Other types default to 2.
func DefaultPriority(url *url.URL) Priority <span class="cov0" title="0">{
        path := strings.ToLower(url.Path)
        switch </span>{
        <span class="cov0" title="0">case strings.HasSuffix(path, "/"), strings.HasSuffix(path, ".html"), strings.HasSuffix(path, ".xhtml"):
                return 0</span>

        <span class="cov0" title="0">case strings.HasSuffix(path, ".css"):
                return 1</span>

        <span class="cov0" title="0">case strings.HasSuffix(path, ".js"), strings.HasSuffix(path, ".javascript"):
                return 2</span>

        <span class="cov0" title="0">case strings.HasSuffix(path, ".ico"), strings.HasSuffix(path, ".png"), strings.HasSuffix(path, ".jpg"),
                strings.HasSuffix(path, ".jpeg"), strings.HasSuffix(path, ".gif"), strings.HasSuffix(path, ".webp"),
                strings.HasSuffix(path, ".svg"), strings.HasSuffix(path, ".bmp"), strings.HasSuffix(path, ".tiff"),
                strings.HasSuffix(path, ".apng"):
                return 3</span>

        <span class="cov0" title="0">default:
                return 2</span>
        }
}

// frameNamesV3 provides the name for a particular SPDY/3
// frame type.
var frameNamesV3 = map[int]string{
        SYN_STREAMv3:    "SYN_STREAM",
        SYN_REPLYv3:     "SYN_REPLY",
        RST_STREAMv3:    "RST_STREAM",
        SETTINGSv3:      "SETTINGS",
        PINGv3:          "PING",
        GOAWAYv3:        "GOAWAY",
        HEADERSv3:       "HEADERS",
        WINDOW_UPDATEv3: "WINDOW_UPDATE",
        CREDENTIALv3:    "CREDENTIAL",
        CONTROL_FRAMEv3: "CONTROL_FRAME",
        DATA_FRAMEv3:    "DATA_FRAME",
}

// frameNamesV2 provides the name for a particular SPDY/2
// frame type.
var frameNamesV2 = map[int]string{
        SYN_STREAMv2:    "SYN_STREAM",
        SYN_REPLYv2:     "SYN_REPLY",
        RST_STREAMv2:    "RST_STREAM",
        SETTINGSv2:      "SETTINGS",
        NOOPv2:          "NOOP",
        PINGv2:          "PING",
        GOAWAYv2:        "GOAWAY",
        HEADERSv2:       "HEADERS",
        WINDOW_UPDATEv2: "WINDOW_UPDATE",
        CONTROL_FRAMEv2: "CONTROL_FRAME",
        DATA_FRAMEv2:    "DATA_FRAME",
}

// Compression header for SPDY/2
var HeaderDictionaryV2 = []byte{
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x67,
        0x65, 0x74, 0x68, 0x65, 0x61, 0x64, 0x70, 0x6f,
        0x73, 0x74, 0x70, 0x75, 0x74, 0x64, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x74, 0x72, 0x61, 0x63, 0x65,
        0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x61, 0x63,
        0x63, 0x65, 0x70, 0x74, 0x2d, 0x63, 0x68, 0x61,
        0x72, 0x73, 0x65, 0x74, 0x61, 0x63, 0x63, 0x65,
        0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f, 0x64,
        0x69, 0x6e, 0x67, 0x61, 0x63, 0x63, 0x65, 0x70,
        0x74, 0x2d, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61,
        0x67, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x65,
        0x78, 0x70, 0x65, 0x63, 0x74, 0x66, 0x72, 0x6f,
        0x6d, 0x68, 0x6f, 0x73, 0x74, 0x69, 0x66, 0x2d,
        0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64,
        0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x69, 0x66,
        0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x69, 0x66,
        0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d, 0x6d, 0x61,
        0x74, 0x63, 0x68, 0x69, 0x66, 0x2d, 0x72, 0x61,
        0x6e, 0x67, 0x65, 0x69, 0x66, 0x2d, 0x75, 0x6e,
        0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64,
        0x73, 0x69, 0x6e, 0x63, 0x65, 0x6d, 0x61, 0x78,
        0x2d, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
        0x73, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61,
        0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x72, 0x61, 0x6e, 0x67,
        0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72,
        0x74, 0x65, 0x75, 0x73, 0x65, 0x72, 0x2d, 0x61,
        0x67, 0x65, 0x6e, 0x74, 0x31, 0x30, 0x30, 0x31,
        0x30, 0x31, 0x32, 0x30, 0x30, 0x32, 0x30, 0x31,
        0x32, 0x30, 0x32, 0x32, 0x30, 0x33, 0x32, 0x30,
        0x34, 0x32, 0x30, 0x35, 0x32, 0x30, 0x36, 0x33,
        0x30, 0x30, 0x33, 0x30, 0x31, 0x33, 0x30, 0x32,
        0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33, 0x30,
        0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37, 0x34,
        0x30, 0x30, 0x34, 0x30, 0x31, 0x34, 0x30, 0x32,
        0x34, 0x30, 0x33, 0x34, 0x30, 0x34, 0x34, 0x30,
        0x35, 0x34, 0x30, 0x36, 0x34, 0x30, 0x37, 0x34,
        0x30, 0x38, 0x34, 0x30, 0x39, 0x34, 0x31, 0x30,
        0x34, 0x31, 0x31, 0x34, 0x31, 0x32, 0x34, 0x31,
        0x33, 0x34, 0x31, 0x34, 0x34, 0x31, 0x35, 0x34,
        0x31, 0x36, 0x34, 0x31, 0x37, 0x35, 0x30, 0x30,
        0x35, 0x30, 0x31, 0x35, 0x30, 0x32, 0x35, 0x30,
        0x33, 0x35, 0x30, 0x34, 0x35, 0x30, 0x35, 0x61,
        0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x72, 0x61,
        0x6e, 0x67, 0x65, 0x73, 0x61, 0x67, 0x65, 0x65,
        0x74, 0x61, 0x67, 0x6c, 0x6f, 0x63, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x70, 0x72, 0x6f, 0x78, 0x79,
        0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
        0x69, 0x63, 0x61, 0x74, 0x65, 0x70, 0x75, 0x62,
        0x6c, 0x69, 0x63, 0x72, 0x65, 0x74, 0x72, 0x79,
        0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x73, 0x65,
        0x72, 0x76, 0x65, 0x72, 0x76, 0x61, 0x72, 0x79,
        0x77, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x77,
        0x77, 0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65,
        0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x61,
        0x6c, 0x6c, 0x6f, 0x77, 0x63, 0x6f, 0x6e, 0x74,
        0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65,
        0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d,
        0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67,
        0x63, 0x61, 0x63, 0x68, 0x65, 0x2d, 0x63, 0x6f,
        0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x63, 0x6f, 0x6e,
        0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x64,
        0x61, 0x74, 0x65, 0x74, 0x72, 0x61, 0x69, 0x6c,
        0x65, 0x72, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66,
        0x65, 0x72, 0x2d, 0x65, 0x6e, 0x63, 0x6f, 0x64,
        0x69, 0x6e, 0x67, 0x75, 0x70, 0x67, 0x72, 0x61,
        0x64, 0x65, 0x76, 0x69, 0x61, 0x77, 0x61, 0x72,
        0x6e, 0x69, 0x6e, 0x67, 0x63, 0x6f, 0x6e, 0x74,
        0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x61, 0x6e, 0x67,
        0x75, 0x61, 0x67, 0x65, 0x63, 0x6f, 0x6e, 0x74,
        0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67,
        0x74, 0x68, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x2d, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x2d, 0x6d, 0x64, 0x35, 0x63, 0x6f, 0x6e,
        0x74, 0x65, 0x6e, 0x74, 0x2d, 0x72, 0x61, 0x6e,
        0x67, 0x65, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x65, 0x74,
        0x61, 0x67, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65,
        0x73, 0x6c, 0x61, 0x73, 0x74, 0x2d, 0x6d, 0x6f,
        0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x73, 0x65,
        0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65,
        0x4d, 0x6f, 0x6e, 0x64, 0x61, 0x79, 0x54, 0x75,
        0x65, 0x73, 0x64, 0x61, 0x79, 0x57, 0x65, 0x64,
        0x6e, 0x65, 0x73, 0x64, 0x61, 0x79, 0x54, 0x68,
        0x75, 0x72, 0x73, 0x64, 0x61, 0x79, 0x46, 0x72,
        0x69, 0x64, 0x61, 0x79, 0x53, 0x61, 0x74, 0x75,
        0x72, 0x64, 0x61, 0x79, 0x53, 0x75, 0x6e, 0x64,
        0x61, 0x79, 0x4a, 0x61, 0x6e, 0x46, 0x65, 0x62,
        0x4d, 0x61, 0x72, 0x41, 0x70, 0x72, 0x4d, 0x61,
        0x79, 0x4a, 0x75, 0x6e, 0x4a, 0x75, 0x6c, 0x41,
        0x75, 0x67, 0x53, 0x65, 0x70, 0x4f, 0x63, 0x74,
        0x4e, 0x6f, 0x76, 0x44, 0x65, 0x63, 0x63, 0x68,
        0x75, 0x6e, 0x6b, 0x65, 0x64, 0x74, 0x65, 0x78,
        0x74, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x69, 0x6d,
        0x61, 0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x69,
        0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67,
        0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67, 0x69,
        0x66, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x6d, 0x6c,
        0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x68, 0x74, 0x6d,
        0x6c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c,
        0x61, 0x69, 0x6e, 0x70, 0x75, 0x62, 0x6c, 0x69,
        0x63, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65,
        0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d,
        0x69, 0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39,
        0x2d, 0x31, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x67,
        0x7a, 0x69, 0x70, 0x64, 0x65, 0x66, 0x6c, 0x61,
        0x74, 0x65, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31,
        0x2e, 0x31, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
        0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x75,
        0x72, 0x6c, 0x00,
}

// Compression header for SPDY/3
var HeaderDictionaryV3 = []byte{
        0x00, 0x00, 0x00, 0x07, 0x6f, 0x70, 0x74, 0x69, // - - - - o p t i
        0x6f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x04, 0x68, // o n s - - - - h
        0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x04, 0x70, // e a d - - - - p
        0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x03, 0x70, // o s t - - - - p
        0x75, 0x74, 0x00, 0x00, 0x00, 0x06, 0x64, 0x65, // u t - - - - d e
        0x6c, 0x65, 0x74, 0x65, 0x00, 0x00, 0x00, 0x05, // l e t e - - - -
        0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00, // t r a c e - - -
        0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x00, // - a c c e p t -
        0x00, 0x00, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70, // - - - a c c e p
        0x74, 0x2d, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, // t - c h a r s e
        0x74, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63, // t - - - - a c c
        0x65, 0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f, // e p t - e n c o
        0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x0f, // d i n g - - - -
        0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x6c, // a c c e p t - l
        0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00, // a n g u a g e -
        0x00, 0x00, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x70, // - - - a c c e p
        0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, // t - r a n g e s
        0x00, 0x00, 0x00, 0x03, 0x61, 0x67, 0x65, 0x00, // - - - - a g e -
        0x00, 0x00, 0x05, 0x61, 0x6c, 0x6c, 0x6f, 0x77, // - - - a l l o w
        0x00, 0x00, 0x00, 0x0d, 0x61, 0x75, 0x74, 0x68, // - - - - a u t h
        0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, // o r i z a t i o
        0x6e, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x61, 0x63, // n - - - - c a c
        0x68, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, // h e - c o n t r
        0x6f, 0x6c, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x6f, // o l - - - - c o
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, // n n e c t i o n
        0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, // - - - - c o n t
        0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65, // e n t - b a s e
        0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74, // - - - - c o n t
        0x65, 0x6e, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f, // e n t - e n c o
        0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, // d i n g - - - -
        0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, // c o n t e n t -
        0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, // l a n g u a g e
        0x00, 0x00, 0x00, 0x0e, 0x63, 0x6f, 0x6e, 0x74, // - - - - c o n t
        0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67, // e n t - l e n g
        0x74, 0x68, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, // t h - - - - c o
        0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x6f, // n t e n t - l o
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, // c a t i o n - -
        0x00, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, // - - c o n t e n
        0x74, 0x2d, 0x6d, 0x64, 0x35, 0x00, 0x00, 0x00, // t - m d 5 - - -
        0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, // - c o n t e n t
        0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, // - r a n g e - -
        0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, // - - c o n t e n
        0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00, // t - t y p e - -
        0x00, 0x04, 0x64, 0x61, 0x74, 0x65, 0x00, 0x00, // - - d a t e - -
        0x00, 0x04, 0x65, 0x74, 0x61, 0x67, 0x00, 0x00, // - - e t a g - -
        0x00, 0x06, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, // - - e x p e c t
        0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x70, 0x69, // - - - - e x p i
        0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x66, // r e s - - - - f
        0x72, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x04, 0x68, // r o m - - - - h
        0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x08, 0x69, // o s t - - - - i
        0x66, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, // f - m a t c h -
        0x00, 0x00, 0x11, 0x69, 0x66, 0x2d, 0x6d, 0x6f, // - - - i f - m o
        0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73, // d i f i e d - s
        0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d, // i n c e - - - -
        0x69, 0x66, 0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d, // i f - n o n e -
        0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00, // m a t c h - - -
        0x08, 0x69, 0x66, 0x2d, 0x72, 0x61, 0x6e, 0x67, // - i f - r a n g
        0x65, 0x00, 0x00, 0x00, 0x13, 0x69, 0x66, 0x2d, // e - - - - i f -
        0x75, 0x6e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, // u n m o d i f i
        0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65, // e d - s i n c e
        0x00, 0x00, 0x00, 0x0d, 0x6c, 0x61, 0x73, 0x74, // - - - - l a s t
        0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, // - m o d i f i e
        0x64, 0x00, 0x00, 0x00, 0x08, 0x6c, 0x6f, 0x63, // d - - - - l o c
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, // a t i o n - - -
        0x0c, 0x6d, 0x61, 0x78, 0x2d, 0x66, 0x6f, 0x72, // - m a x - f o r
        0x77, 0x61, 0x72, 0x64, 0x73, 0x00, 0x00, 0x00, // w a r d s - - -
        0x06, 0x70, 0x72, 0x61, 0x67, 0x6d, 0x61, 0x00, // - p r a g m a -
        0x00, 0x00, 0x12, 0x70, 0x72, 0x6f, 0x78, 0x79, // - - - p r o x y
        0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, // - a u t h e n t
        0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, // i c a t e - - -
        0x13, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61, // - p r o x y - a
        0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, // u t h o r i z a
        0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x05, // t i o n - - - -
        0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, // r a n g e - - -
        0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, // - r e f e r e r
        0x00, 0x00, 0x00, 0x0b, 0x72, 0x65, 0x74, 0x72, // - - - - r e t r
        0x79, 0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, // y - a f t e r -
        0x00, 0x00, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, // - - - s e r v e
        0x72, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x00, // r - - - - t e -
        0x00, 0x00, 0x07, 0x74, 0x72, 0x61, 0x69, 0x6c, // - - - t r a i l
        0x65, 0x72, 0x00, 0x00, 0x00, 0x11, 0x74, 0x72, // e r - - - - t r
        0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2d, 0x65, // a n s f e r - e
        0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, // n c o d i n g -
        0x00, 0x00, 0x07, 0x75, 0x70, 0x67, 0x72, 0x61, // - - - u p g r a
        0x64, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x75, 0x73, // d e - - - - u s
        0x65, 0x72, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74, // e r - a g e n t
        0x00, 0x00, 0x00, 0x04, 0x76, 0x61, 0x72, 0x79, // - - - - v a r y
        0x00, 0x00, 0x00, 0x03, 0x76, 0x69, 0x61, 0x00, // - - - - v i a -
        0x00, 0x00, 0x07, 0x77, 0x61, 0x72, 0x6e, 0x69, // - - - w a r n i
        0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x77, 0x77, // n g - - - - w w
        0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, // w - a u t h e n
        0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, // t i c a t e - -
        0x00, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, // - - m e t h o d
        0x00, 0x00, 0x00, 0x03, 0x67, 0x65, 0x74, 0x00, // - - - - g e t -
        0x00, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, // - - - s t a t u
        0x73, 0x00, 0x00, 0x00, 0x06, 0x32, 0x30, 0x30, // s - - - - 2 0 0
        0x20, 0x4f, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x76, // - O K - - - - v
        0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00, // e r s i o n - -
        0x00, 0x08, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, // - - H T T P - 1
        0x2e, 0x31, 0x00, 0x00, 0x00, 0x03, 0x75, 0x72, // - 1 - - - - u r
        0x6c, 0x00, 0x00, 0x00, 0x06, 0x70, 0x75, 0x62, // l - - - - p u b
        0x6c, 0x69, 0x63, 0x00, 0x00, 0x00, 0x0a, 0x73, // l i c - - - - s
        0x65, 0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69, // e t - c o o k i
        0x65, 0x00, 0x00, 0x00, 0x0a, 0x6b, 0x65, 0x65, // e - - - - k e e
        0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x00, // p - a l i v e -
        0x00, 0x00, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69, // - - - o r i g i
        0x6e, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x32, // n 1 0 0 1 0 1 2
        0x30, 0x31, 0x32, 0x30, 0x32, 0x32, 0x30, 0x35, // 0 1 2 0 2 2 0 5
        0x32, 0x30, 0x36, 0x33, 0x30, 0x30, 0x33, 0x30, // 2 0 6 3 0 0 3 0
        0x32, 0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33, // 2 3 0 3 3 0 4 3
        0x30, 0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37, // 0 5 3 0 6 3 0 7
        0x34, 0x30, 0x32, 0x34, 0x30, 0x35, 0x34, 0x30, // 4 0 2 4 0 5 4 0
        0x36, 0x34, 0x30, 0x37, 0x34, 0x30, 0x38, 0x34, // 6 4 0 7 4 0 8 4
        0x30, 0x39, 0x34, 0x31, 0x30, 0x34, 0x31, 0x31, // 0 9 4 1 0 4 1 1
        0x34, 0x31, 0x32, 0x34, 0x31, 0x33, 0x34, 0x31, // 4 1 2 4 1 3 4 1
        0x34, 0x34, 0x31, 0x35, 0x34, 0x31, 0x36, 0x34, // 4 4 1 5 4 1 6 4
        0x31, 0x37, 0x35, 0x30, 0x32, 0x35, 0x30, 0x34, // 1 7 5 0 2 5 0 4
        0x35, 0x30, 0x35, 0x32, 0x30, 0x33, 0x20, 0x4e, // 5 0 5 2 0 3 - N
        0x6f, 0x6e, 0x2d, 0x41, 0x75, 0x74, 0x68, 0x6f, // o n - A u t h o
        0x72, 0x69, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, // r i t a t i v e
        0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, // - I n f o r m a
        0x74, 0x69, 0x6f, 0x6e, 0x32, 0x30, 0x34, 0x20, // t i o n 2 0 4 -
        0x4e, 0x6f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65, // N o - C o n t e
        0x6e, 0x74, 0x33, 0x30, 0x31, 0x20, 0x4d, 0x6f, // n t 3 0 1 - M o
        0x76, 0x65, 0x64, 0x20, 0x50, 0x65, 0x72, 0x6d, // v e d - P e r m
        0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x34, // a n e n t l y 4
        0x30, 0x30, 0x20, 0x42, 0x61, 0x64, 0x20, 0x52, // 0 0 - B a d - R
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x34, 0x30, // e q u e s t 4 0
        0x31, 0x20, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, // 1 - U n a u t h
        0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x34, 0x30, // o r i z e d 4 0
        0x33, 0x20, 0x46, 0x6f, 0x72, 0x62, 0x69, 0x64, // 3 - F o r b i d
        0x64, 0x65, 0x6e, 0x34, 0x30, 0x34, 0x20, 0x4e, // d e n 4 0 4 - N
        0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, // o t - F o u n d
        0x35, 0x30, 0x30, 0x20, 0x49, 0x6e, 0x74, 0x65, // 5 0 0 - I n t e
        0x72, 0x6e, 0x61, 0x6c, 0x20, 0x53, 0x65, 0x72, // r n a l - S e r
        0x76, 0x65, 0x72, 0x20, 0x45, 0x72, 0x72, 0x6f, // v e r - E r r o
        0x72, 0x35, 0x30, 0x31, 0x20, 0x4e, 0x6f, 0x74, // r 5 0 1 - N o t
        0x20, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, // - I m p l e m e
        0x6e, 0x74, 0x65, 0x64, 0x35, 0x30, 0x33, 0x20, // n t e d 5 0 3 -
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, // S e r v i c e -
        0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, // U n a v a i l a
        0x62, 0x6c, 0x65, 0x4a, 0x61, 0x6e, 0x20, 0x46, // b l e J a n - F
        0x65, 0x62, 0x20, 0x4d, 0x61, 0x72, 0x20, 0x41, // e b - M a r - A
        0x70, 0x72, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x4a, // p r - M a y - J
        0x75, 0x6e, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x41, // u n - J u l - A
        0x75, 0x67, 0x20, 0x53, 0x65, 0x70, 0x74, 0x20, // u g - S e p t -
        0x4f, 0x63, 0x74, 0x20, 0x4e, 0x6f, 0x76, 0x20, // O c t - N o v -
        0x44, 0x65, 0x63, 0x20, 0x30, 0x30, 0x3a, 0x30, // D e c - 0 0 - 0
        0x30, 0x3a, 0x30, 0x30, 0x20, 0x4d, 0x6f, 0x6e, // 0 - 0 0 - M o n
        0x2c, 0x20, 0x54, 0x75, 0x65, 0x2c, 0x20, 0x57, // - - T u e - - W
        0x65, 0x64, 0x2c, 0x20, 0x54, 0x68, 0x75, 0x2c, // e d - - T h u -
        0x20, 0x46, 0x72, 0x69, 0x2c, 0x20, 0x53, 0x61, // - F r i - - S a
        0x74, 0x2c, 0x20, 0x53, 0x75, 0x6e, 0x2c, 0x20, // t - - S u n - -
        0x47, 0x4d, 0x54, 0x63, 0x68, 0x75, 0x6e, 0x6b, // G M T c h u n k
        0x65, 0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, // e d - t e x t -
        0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x69, 0x6d, 0x61, // h t m l - i m a
        0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x2c, 0x69, // g e - p n g - i
        0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67, // m a g e - j p g
        0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67, // - i m a g e - g
        0x69, 0x66, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69, // i f - a p p l i
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, // c a t i o n - x
        0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69, // m l - a p p l i
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, // c a t i o n - x
        0x68, 0x74, 0x6d, 0x6c, 0x2b, 0x78, 0x6d, 0x6c, // h t m l - x m l
        0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c, // - t e x t - p l
        0x61, 0x69, 0x6e, 0x2c, 0x74, 0x65, 0x78, 0x74, // a i n - t e x t
        0x2f, 0x6a, 0x61, 0x76, 0x61, 0x73, 0x63, 0x72, // - j a v a s c r
        0x69, 0x70, 0x74, 0x2c, 0x70, 0x75, 0x62, 0x6c, // i p t - p u b l
        0x69, 0x63, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, // i c p r i v a t
        0x65, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65, // e m a x - a g e
        0x3d, 0x67, 0x7a, 0x69, 0x70, 0x2c, 0x64, 0x65, // - g z i p - d e
        0x66, 0x6c, 0x61, 0x74, 0x65, 0x2c, 0x73, 0x64, // f l a t e - s d
        0x63, 0x68, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, // c h c h a r s e
        0x74, 0x3d, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x63, // t - u t f - 8 c
        0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x69, // h a r s e t - i
        0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39, 0x2d, // s o - 8 8 5 9 -
        0x31, 0x2c, 0x75, 0x74, 0x66, 0x2d, 0x2c, 0x2a, // 1 - u t f - - -
        0x2c, 0x65, 0x6e, 0x71, 0x3d, 0x30, 0x2e, // - e n q - 0 -
}
</pre>
		
		<pre class="file" id="file170" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "errors"
        "fmt"
        "path/filepath"
        "runtime"
)

// MaxBenignErrors is the maximum number of minor errors each
// connection will allow without ending the session.
//
// By default, MaxBenignErrors is set to 0, disabling checks
// and allowing minor errors to go unchecked, although they
// will still be reported to the debug logger. If it is
// important that no errors go unchecked, such as when testing
// another implementation, set MaxBenignErrors to 1 or higher.
var MaxBenignErrors = 0

var (
        ErrConnNil        = errors.New("Error: Connection is nil.")
        ErrConnClosed     = errors.New("Error: Connection is closed.")
        ErrGoaway         = errors.New("Error: GOAWAY received.")
        ErrNoFlowControl  = errors.New("Error: This connection does not use flow control.")
        ErrConnectFail    = errors.New("Error: Failed to connect.")
        ErrInvalidVersion = errors.New("Error: Invalid SPDY version.")

        // ErrNotSPDY indicates that a SPDY-specific feature was attempted
        // with a ResponseWriter using a non-SPDY connection.
        ErrNotSPDY = errors.New("Error: Not a SPDY connection.")

        // ErrNotConnected indicates that a SPDY-specific feature was
        // attempted with a Client not connected to the given server.
        ErrNotConnected = errors.New("Error: Not connected to given server.")
)

type incorrectDataLength struct {
        got, expected int
}

func IncorrectDataLength(got, expected int) error <span class="cov0" title="0">{
        return &amp;incorrectDataLength{got, expected}
}</span>

func (i *incorrectDataLength) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error: Incorrect amount of data for frame: got %d bytes, expected %d.", i.got, i.expected)
}</span>

var FrameTooLarge = errors.New("Error: Frame too large.")

type invalidField struct {
        field         string
        got, expected int
}

func InvalidField(field string, got, expected int) error <span class="cov0" title="0">{
        return &amp;invalidField{field, got, expected}
}</span>

func (i *invalidField) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error: Field %q recieved invalid data %d, expecting %d.", i.field, i.got, i.expected)
}</span>

type incorrectFrame struct {
        got, expected, version int
}

func IncorrectFrame(got, expected, version int) error <span class="cov0" title="0">{
        return &amp;incorrectFrame{got, expected, version}
}</span>

func (i *incorrectFrame) Error() string <span class="cov0" title="0">{
        if i.version == 3 </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error: Frame %s tried to parse data for a %s.", frameNamesV3[i.expected], frameNamesV3[i.got])
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Error: Frame %s tried to parse data for a %s.", frameNamesV2[i.expected], frameNamesV2[i.got])</span>
}

var StreamIdTooLarge = errors.New("Error: Stream ID is too large.")

var StreamIdIsZero = errors.New("Error: Stream ID is zero.")

type UnsupportedVersion uint16

func (u UnsupportedVersion) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error: Unsupported SPDY version: %d.\n", u)
}</span>

func Recover() <span class="cov0" title="0">{
        v := recover()
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Printf("spdy: panic: %v (%[1]T)\n", v)
        for skip := 1; ; skip++ </span><span class="cov0" title="0">{
                pc, file, line, ok := runtime.Caller(skip)
                if ok </span><span class="cov0" title="0">{
                        f := runtime.FuncForPC(pc)
                        if filepath.Ext(file) != ".go" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">log.Printf("- %s:%d in %s()\n", file, line, f.Name())
                        if f.Name() == "main.main" </span><span class="cov0" title="0">{
                                return
                        }</span>
                } <span class="cov0" title="0">else {
                        log.Println("- ???:? in ???()")
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file171" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "sync"
)

// StreamLimit is used to add and enforce
// a limit on the number of concurrently
// active streams.
type StreamLimit struct {
        lock    sync.Mutex
        limit   uint32
        current uint32
}

func NewStreamLimit(limit uint32) *StreamLimit <span class="cov1" title="1">{
        out := new(StreamLimit)
        out.limit = limit
        return out
}</span>

// SetLimit is used to modify the stream limit. If the
// limit is set to NO_STREAM_LIMIT, then the limiting
// is disabled.
func (s *StreamLimit) SetLimit(l uint32) <span class="cov1" title="1">{
        s.lock.Lock()
        s.limit = l
        s.lock.Unlock()
}</span>

// Limit returns the current limit.
func (s *StreamLimit) Limit() uint32 <span class="cov5" title="2">{
        return s.limit
}</span>

// Add is called when a new stream is to be opened. Add
// returns a bool indicating whether the stream is safe
// open.
func (s *StreamLimit) Add() bool <span class="cov10" title="4">{
        s.lock.Lock()
        if s.current &gt;= s.limit </span><span class="cov1" title="1">{
                s.lock.Unlock()
                return false
        }</span>
        <span class="cov8" title="3">s.current++
        s.lock.Unlock()
        return true</span>
}

// Close is called when a stream is closed; thus freeing
// up a slot.
func (s *StreamLimit) Close() <span class="cov1" title="1">{
        s.lock.Lock()
        s.current--
        s.lock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "io"
        "io/ioutil"
        logging "log"
        "os"
)

type Logger struct {
        *logging.Logger
}

var log = &amp;Logger{logging.New(os.Stderr, "(spdy) ", logging.LstdFlags|logging.Lshortfile)}
var debug = &amp;Logger{logging.New(ioutil.Discard, "(spdy debug) ", logging.LstdFlags)}
var VerboseLogging = false

func GetLogger() *Logger <span class="cov0" title="0">{
        return log
}</span>

func GetDebugLogger() *Logger <span class="cov0" title="0">{
        return debug
}</span>

// SetLogger sets the package's error logger.
func SetLogger(l *logging.Logger) <span class="cov0" title="0">{
        log.Logger = l
}</span>

// SetLogOutput sets the output for the package's error logger.
func SetLogOutput(w io.Writer) <span class="cov0" title="0">{
        log.Logger = logging.New(w, "(spdy) ", logging.LstdFlags|logging.Lshortfile)
}</span>

// SetDebugLogger sets the package's debug info logger.
func SetDebugLogger(l *logging.Logger) <span class="cov0" title="0">{
        debug.Logger = l
}</span>

// SetDebugOutput sets the output for the package's debug info logger.
func SetDebugOutput(w io.Writer) <span class="cov0" title="0">{
        debug.Logger = logging.New(w, "(spdy debug) ", logging.LstdFlags)
}</span>

// EnableDebugOutput sets the output for the package's debug info logger to os.Stdout.
func EnableDebugOutput() <span class="cov0" title="0">{
        SetDebugOutput(os.Stdout)
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "bytes"
        "compress/gzip"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "strconv"
        "strings"
        "sync"
)

import (
        http "bfe_http"
)

// Response is used in handling responses; storing
// the data as it's received, and producing an
// http.Response once complete.
//
// Response may be given a Receiver to enable live
// handling of the response data. This is provided
// by setting spdy.Transport.Receiver. Note that
// providing a Receiver disables the default data
// storage so the returned http.Response.Body will
// be empty.
type Response struct {
        StatusCode int

        headerM sync.Mutex
        Header  http.Header

        dataM sync.Mutex
        data  *hybridBuffer

        Request  *http.Request
        Receiver Receiver
}

func NewResponse(request *http.Request, receiver Receiver) *Response <span class="cov0" title="0">{
        resp := new(Response)
        resp.Request = request
        resp.Receiver = receiver
        if receiver == nil </span><span class="cov0" title="0">{
                resp.data = newHybridBuffer()
        }</span>
        <span class="cov0" title="0">return resp</span>
}

func (r *Response) ReceiveData(req *http.Request, data []byte, finished bool) <span class="cov0" title="0">{
        if r.Receiver != nil </span><span class="cov0" title="0">{
                r.Receiver.ReceiveData(req, data, finished)
        }</span> <span class="cov0" title="0">else {
                r.dataM.Lock()
                r.data.Write(data)
                r.dataM.Unlock()
        }</span>
}

func (r *Response) ReceiveHeader(req *http.Request, header http.Header) <span class="cov0" title="0">{
        r.headerM.Lock()
        if r.Header == nil </span><span class="cov0" title="0">{
                r.Header = make(http.Header)
        }</span>
        <span class="cov0" title="0">UpdateHeader(r.Header, header)
        if status := r.Header.Get(":status"); status != "" </span><span class="cov0" title="0">{
                status = strings.TrimSpace(status)
                if i := strings.Index(status, " "); i &gt;= 0 </span><span class="cov0" title="0">{
                        status = status[:i]
                }</span>
                <span class="cov0" title="0">s, err := strconv.Atoi(status)
                if err == nil </span><span class="cov0" title="0">{
                        r.StatusCode = s
                }</span>
        }
        <span class="cov0" title="0">if r.Receiver != nil </span><span class="cov0" title="0">{
                r.Receiver.ReceiveHeader(req, header)
        }</span>
        <span class="cov0" title="0">r.headerM.Unlock()</span>
}

func (r *Response) ReceiveRequest(req *http.Request) bool <span class="cov0" title="0">{
        if r.Receiver != nil </span><span class="cov0" title="0">{
                return r.Receiver.ReceiveRequest(req)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (r *Response) Response() *http.Response <span class="cov0" title="0">{
        out := new(http.Response)

        r.headerM.Lock()
        out.Status = fmt.Sprintf("%d %s", r.StatusCode, http.StatusTextGet(r.StatusCode))
        out.StatusCode = r.StatusCode
        out.Header = r.Header
        r.headerM.Unlock()

        out.Proto = "HTTP/1.1"
        out.ProtoMajor = 1
        out.ProtoMinor = 1

        r.dataM.Lock()
        if r.data == nil </span><span class="cov0" title="0">{
                out.Body = &amp;ReadCloser{new(bytes.Buffer)}
        }</span> <span class="cov0" title="0">else if unrequestedGzip(r) </span><span class="cov0" title="0">{
                // User-agents MUST support gzip compression.
                // Regardless of the Accept-Encoding sent by the user-agent, the server may
                // always send content encoded with gzip or deflate encoding.
                r.data.Prep()
                out.Header.Del("Content-Encoding")
                out.Header.Del("Content-Length")
                out.ContentLength = -1
                out.Body = &amp;gzipReader{body: r.data}
        }</span> <span class="cov0" title="0">else {
                r.data.Prep()
                out.Body = r.data
                out.ContentLength = r.data.written
        }</span>
        <span class="cov0" title="0">r.dataM.Unlock()

        out.TransferEncoding = nil
        out.Close = true
        out.Trailer = make(http.Header)
        out.Request = r.Request
        return out</span>
}

// 10 MB
var _MAX_MEM_STORAGE = 10 * 1024 * 1024

// hybridBuffer is used in Response to make sure that
// large volumes of data can be stored safely.
type hybridBuffer struct {
        io.Reader

        buf     *bytes.Buffer
        file    *os.File
        written int64
}

func newHybridBuffer() *hybridBuffer <span class="cov0" title="0">{
        hb := new(hybridBuffer)
        hb.buf = new(bytes.Buffer)
        hb.Reader = hb.buf
        return hb
}</span>

func (h *hybridBuffer) Close() error <span class="cov0" title="0">{
        h.buf.Reset()
        if h.file != nil </span><span class="cov0" title="0">{
                err := h.file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return os.Remove(h.file.Name())</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *hybridBuffer) Prep() error <span class="cov0" title="0">{
        if h.file != nil </span><span class="cov0" title="0">{
                name := h.file.Name()
                err := h.file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h.file, err = os.Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h.Reader = io.MultiReader(h.buf, h.file)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *hybridBuffer) Write(b []byte) (int, error) <span class="cov0" title="0">{
        buffered := h.buf.Len()
        var err error

        // Straight to memory
        if len(b)+buffered &lt; _MAX_MEM_STORAGE </span><span class="cov0" title="0">{
                n, err := h.buf.Write(b)
                h.written += int64(n)
                return n, err
        }</span>

        // Partially to disk
        <span class="cov0" title="0">if buffered &lt; _MAX_MEM_STORAGE </span><span class="cov0" title="0">{
                mem := _MAX_MEM_STORAGE - buffered
                n, err := h.buf.Write(b[:mem])
                h.written += int64(n)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">if h.file == nil </span><span class="cov0" title="0">{
                        h.file, err = ioutil.TempFile("", "spdy_content")
                        if err != nil </span><span class="cov0" title="0">{
                                return n, err
                        }</span>
                        <span class="cov0" title="0">h.Reader = io.MultiReader(h.buf, h.file)</span>
                }
                <span class="cov0" title="0">m, err := h.file.Write(b[mem:])
                h.written += int64(m)
                return m + n, err</span>
        }

        // Fully to disk
        <span class="cov0" title="0">if h.file == nil </span><span class="cov0" title="0">{
                h.file, err = ioutil.TempFile("", "spdy_content")
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">h.Reader = io.MultiReader(h.buf, h.file)</span>
        }
        <span class="cov0" title="0">n, err := h.file.Write(b)
        h.written += int64(n)
        return n, err</span>
}

// unrequestedGzip returns true iff the request did
// not ask for the returned content encoding and that
// encoding is gzip or deflate, which is allowed in
// the SPDY spec.
func unrequestedGzip(r *Response) bool <span class="cov0" title="0">{
        got := r.Header.Get("Content-Encoding")
        switch got </span>{
        <span class="cov0" title="0">case "gzip", "deflate":</span>
        <span class="cov0" title="0">default:
                return false</span>
        }

        <span class="cov0" title="0">requested := r.Request.Header.Get("Accept-Encoding")
        return !strings.Contains(requested, got)</span>
}

// gzipReader wraps a response body so it can lazily
// call gzip.NewReader on the first call to Read
type gzipReader struct {
        body io.ReadCloser // underlying Response.Body
        zr   io.Reader     // lazily-initialized gzip reader
}

func (gz *gzipReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if gz.zr == nil </span><span class="cov0" title="0">{
                gz.zr, err = gzip.NewReader(gz.body)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }
        <span class="cov0" title="0">return gz.zr.Read(p)</span>
}

func (gz *gzipReader) Close() error <span class="cov0" title="0">{
        return gz.body.Close()
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "sync"
)

// State variables used internally in StreamState.
const (
        stateOpen uint8 = iota
        stateHalfClosedHere
        stateHalfClosedThere
        stateClosed
)

// StreamState is used to store and query the stream's state. The active methods
// do not directly affect the stream's state, but it will use that information
// to effect the changes.
type StreamState struct {
        l sync.Mutex
        s uint8
}

// Check whether the stream is open.
func (s *StreamState) Open() bool <span class="cov0" title="0">{
        s.l.Lock()
        open := s.s == stateOpen
        s.l.Unlock()
        return open
}</span>

// Check whether the stream is closed.
func (s *StreamState) Closed() bool <span class="cov0" title="0">{
        s.l.Lock()
        closed := s.s == stateClosed
        s.l.Unlock()
        return closed
}</span>

// Check whether the stream is half-closed at the other endpoint.
func (s *StreamState) ClosedThere() bool <span class="cov0" title="0">{
        s.l.Lock()
        closedThere := s.s == stateClosed || s.s == stateHalfClosedThere
        s.l.Unlock()
        return closedThere
}</span>

// Check whether the stream is open at the other endpoint.
func (s *StreamState) OpenThere() bool <span class="cov0" title="0">{
        return !s.ClosedThere()
}</span>

// Check whether the stream is half-closed at the other endpoint.
func (s *StreamState) ClosedHere() bool <span class="cov0" title="0">{
        s.l.Lock()
        closedHere := s.s == stateClosed || s.s == stateHalfClosedHere
        s.l.Unlock()
        return closedHere
}</span>

// Check whether the stream is open locally.
func (s *StreamState) OpenHere() bool <span class="cov0" title="0">{
        return !s.ClosedHere()
}</span>

// Closes the stream.
func (s *StreamState) Close() <span class="cov0" title="0">{
        s.l.Lock()
        s.s = stateClosed
        s.l.Unlock()
}</span>

// Half-close the stream locally.
func (s *StreamState) CloseHere() <span class="cov0" title="0">{
        s.l.Lock()
        if s.s == stateOpen </span><span class="cov0" title="0">{
                s.s = stateHalfClosedHere
        }</span> <span class="cov0" title="0">else if s.s == stateHalfClosedThere </span><span class="cov0" title="0">{
                s.s = stateClosed
        }</span>
        <span class="cov0" title="0">s.l.Unlock()</span>
}

// Half-close the stream at the other endpoint.
func (s *StreamState) CloseThere() <span class="cov0" title="0">{
        s.l.Lock()
        if s.s == stateOpen </span><span class="cov0" title="0">{
                s.s = stateHalfClosedThere
        }</span> <span class="cov0" title="0">else if s.s == stateHalfClosedHere </span><span class="cov0" title="0">{
                s.s = stateClosed
        }</span>
        <span class="cov0" title="0">s.l.Unlock()</span>
}

// State description.
func (s *StreamState) String() string <span class="cov0" title="0">{
        var str string
        if s.OpenHere() </span><span class="cov0" title="0">{
                str = "open here, "
        }</span> <span class="cov0" title="0">else {
                str = "closed here, "
        }</span>
        <span class="cov0" title="0">if s.OpenThere() </span><span class="cov0" title="0">{
                str += "open there"
        }</span> <span class="cov0" title="0">else {
                str += "closed there"
        }</span>
        <span class="cov0" title="0">return str</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "fmt"
        "sort"
)

/************
 * StreamID *
 ************/

// StreamID is the unique identifier for a single SPDY stream.
type StreamID uint32

func (s StreamID) B1() byte <span class="cov0" title="0">{
        return byte(s &gt;&gt; 24)
}</span>

func (s StreamID) B2() byte <span class="cov0" title="0">{
        return byte(s &gt;&gt; 16)
}</span>

func (s StreamID) B3() byte <span class="cov0" title="0">{
        return byte(s &gt;&gt; 8)
}</span>

func (s StreamID) B4() byte <span class="cov0" title="0">{
        return byte(s)
}</span>

// Client indicates whether the ID should belong to a client-sent stream.
func (s StreamID) Client() bool <span class="cov0" title="0">{
        return s != 0 &amp;&amp; s&amp;1 != 0
}</span>

// Server indicates whether the ID should belong to a server-sent stream.
func (s StreamID) Server() bool <span class="cov0" title="0">{
        return s != 0 &amp;&amp; s&amp;1 == 0
}</span>

// Valid indicates whether the ID is in the range of legal values (including 0).
func (s StreamID) Valid() bool <span class="cov0" title="0">{
        return s &lt;= MAX_STREAM_ID
}</span>

// Zero indicates whether the ID is zero.
func (s StreamID) Zero() bool <span class="cov0" title="0">{
        return s == 0
}</span>

/*********
 * Flags *
 *********/

// Flags represent a frame's Flags.
type Flags byte

// CLEAR_SETTINGS indicates whether the CLEAR_SETTINGS
// flag is set.
func (f Flags) CLEAR_SETTINGS() bool <span class="cov0" title="0">{
        return f&amp;FLAG_SETTINGS_CLEAR_SETTINGS != 0
}</span>

// FIN indicates whether the FIN flag is set.
func (f Flags) FIN() bool <span class="cov0" title="0">{
        return f&amp;FLAG_FIN != 0
}</span>

// PERSIST_VALUE indicates whether the PERSIST_VALUE
// flag is set.
func (f Flags) PERSIST_VALUE() bool <span class="cov0" title="0">{
        return f&amp;FLAG_SETTINGS_PERSIST_VALUE != 0
}</span>

// PERSISTED indicates whether the PERSISTED flag is
// set.
func (f Flags) PERSISTED() bool <span class="cov0" title="0">{
        return f&amp;FLAG_SETTINGS_PERSISTED != 0
}</span>

// UNIDIRECTIONAL indicates whether the UNIDIRECTIONAL
// flag is set.
func (f Flags) UNIDIRECTIONAL() bool <span class="cov0" title="0">{
        return f&amp;FLAG_UNIDIRECTIONAL != 0
}</span>

/************
 * Priority *
 ************/

// Priority represents a stream's priority.
type Priority byte

// Byte returns the priority in binary form, adjusted
// for the given SPDY version.
func (p Priority) Byte(version uint16) byte <span class="cov0" title="0">{
        switch version </span>{
        <span class="cov0" title="0">case 3:
                return byte((p &amp; 7) &lt;&lt; 5)</span>
        <span class="cov0" title="0">case 2:
                return byte((p &amp; 3) &lt;&lt; 6)</span>
        <span class="cov0" title="0">default:
                return 0</span>
        }
}

// Valid indicates whether the priority is in the valid
// range for the given SPDY version.
func (p Priority) Valid(version uint16) bool <span class="cov0" title="0">{
        switch version </span>{
        <span class="cov0" title="0">case 3:
                return p &lt;= 7</span>
        <span class="cov0" title="0">case 2:
                return p &lt;= 3</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}

/**************
 * StatusCode *
 **************/

// StatusCode represents a status code sent in
// certain SPDY frames, such as RST_STREAM and
// GOAWAY.
type StatusCode uint32

func (r StatusCode) B1() byte <span class="cov0" title="0">{
        return byte(r &gt;&gt; 24)
}</span>

func (r StatusCode) B2() byte <span class="cov0" title="0">{
        return byte(r &gt;&gt; 16)
}</span>

func (r StatusCode) B3() byte <span class="cov0" title="0">{
        return byte(r &gt;&gt; 8)
}</span>

func (r StatusCode) B4() byte <span class="cov0" title="0">{
        return byte(r)
}</span>

// IsFatal returns a bool indicating
// whether receiving the given status
// code should end the connection.
func (r StatusCode) IsFatal() bool <span class="cov0" title="0">{
        switch r </span>{
        <span class="cov0" title="0">case RST_STREAM_PROTOCOL_ERROR:
                return true</span>
        <span class="cov0" title="0">case RST_STREAM_INTERNAL_ERROR:
                return true</span>
        <span class="cov0" title="0">case RST_STREAM_FRAME_TOO_LARGE:
                return true</span>
        <span class="cov0" title="0">case RST_STREAM_UNSUPPORTED_VERSION:
                return true</span>

        <span class="cov0" title="0">default:
                return false</span>
        }
}

// String gives the StatusCode in text form.
func (r StatusCode) String() string <span class="cov0" title="0">{
        return statusCodeText[r]
}</span>

/************
 * Settings *
 ************/

// Setting represents a single setting as sent
// in a SPDY SETTINGS frame.
type Setting struct {
        Flags Flags
        ID    uint32
        Value uint32
}

// String gives the textual representation of a Setting.
func (s *Setting) String() string <span class="cov0" title="0">{
        id := settingText[s.ID] + ":"
        Flags := ""
        if s.Flags.PERSIST_VALUE() </span><span class="cov0" title="0">{
                Flags += " FLAG_SETTINGS_PERSIST_VALUE"
        }</span>
        <span class="cov0" title="0">if s.Flags.PERSISTED() </span><span class="cov0" title="0">{
                Flags += " FLAG_SETTINGS_PERSISTED"
        }</span>
        <span class="cov0" title="0">if Flags == "" </span><span class="cov0" title="0">{
                Flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                Flags = Flags[1:]
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%-31s %-10d %s", id, s.Value, Flags)</span>
}

// Settings represents a series of settings, stored in a map
// by setting ID. This ensures that duplicate settings are
// not sent, since the new value will replace the old.
type Settings map[uint32]*Setting

// Settings returns a slice of Setting, sorted into order by
// ID, as in the SPDY specification.
func (s Settings) Settings() []*Setting <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return []*Setting{}
        }</span>

        <span class="cov0" title="0">ids := make([]int, 0, len(s))
        for id := range s </span><span class="cov0" title="0">{
                ids = append(ids, int(id))
        }</span>

        <span class="cov0" title="0">sort.Sort(sort.IntSlice(ids))

        out := make([]*Setting, len(s))

        for i, id := range ids </span><span class="cov0" title="0">{
                out[i] = s[uint32(id)]
        }</span>

        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package common

import (
        "io"
)

import (
        http "bfe_http"
)

// CloneHeader returns a duplicate of the provided Header.
func CloneHeader(h http.Header) http.Header <span class="cov0" title="0">{
        h2 := make(http.Header, len(h))
        for k, vv := range h </span><span class="cov0" title="0">{
                vv2 := make([]string, len(vv))
                copy(vv2, vv)
                h2[k] = vv2
        }</span>
        <span class="cov0" title="0">return h2</span>
}

// UpdateHeader adds and new name/value pairs and replaces
// those already existing in the older header.
func UpdateHeader(older, newer http.Header) <span class="cov0" title="0">{
        for name, values := range newer </span><span class="cov0" title="0">{
                for i, value := range values </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                older.Set(name, value)
                        }</span> <span class="cov0" title="0">else {
                                older.Add(name, value)
                        }</span>
                }
        }
}

func BytesToUint16(b []byte) uint16 <span class="cov6" title="5">{
        return (uint16(b[0]) &lt;&lt; 8) + uint16(b[1])
}</span>

func BytesToUint24(b []byte) uint32 <span class="cov0" title="0">{
        return (uint32(b[0]) &lt;&lt; 16) + (uint32(b[1]) &lt;&lt; 8) + uint32(b[2])
}</span>

func BytesToUint24Reverse(b []byte) uint32 <span class="cov0" title="0">{
        return (uint32(b[2]) &lt;&lt; 16) + (uint32(b[1]) &lt;&lt; 8) + uint32(b[0])
}</span>

func BytesToUint32(b []byte) uint32 <span class="cov6" title="5">{
        return (uint32(b[0]) &lt;&lt; 24) + (uint32(b[1]) &lt;&lt; 16) + (uint32(b[2]) &lt;&lt; 8) + uint32(b[3])
}</span>

// ReadExactly is used to ensure that the given number of bytes
// are read if possible, even if multiple calls to Read
// are required.
func ReadExactly(r io.Reader, i int) ([]byte, error) <span class="cov10" title="18">{
        out := make([]byte, i)
        in := out[:]
        for i &gt; 0 </span><span class="cov10" title="18">{
                if r == nil </span><span class="cov0" title="0">{
                        return nil, ErrConnNil
                }</span>
                <span class="cov10" title="18">if n, err := r.Read(in); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> <span class="cov10" title="18">else {
                        in = in[n:]
                        i -= n
                }</span>
        }
        <span class="cov10" title="18">return out, nil</span>
}

// WriteExactly is used to ensure that the given data is written
// if possible, even if multiple calls to Write are
// required.
func WriteExactly(w io.Writer, data []byte) error <span class="cov3" title="2">{
        i := len(data)
        for i &gt; 0 </span><span class="cov3" title="2">{
                if w == nil </span><span class="cov0" title="0">{
                        return ErrConnNil
                }</span>
                <span class="cov3" title="2">if n, err := w.Write(data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> <span class="cov3" title="2">else {
                        data = data[n:]
                        i -= n
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// ReadCloser is a helper structure to allow
// an io.Reader to satisfy the io.ReadCloser
// interface.
type ReadCloser struct {
        io.Reader
}

func (r *ReadCloser) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file177" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy2

import (
        "bufio"
        "net"
        "net/url"
        "sync"
        "time"
)

import (
        http "bfe_http"
        tls "bfe_tls"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// Conn is a spdy.Conn implementing SPDY/2. This is used in both
// servers and clients, and is created with either NewServerConn,
// or NewClientConn.
type Conn struct {
        PushReceiver common.Receiver // Receiver to call for server Pushes.

        // network state
        remoteAddr  string
        server      http.ServerHandler                // nil if client connection.
        conn        net.Conn                          // underlying network (TLS) connection.
        connLock    sync.Mutex                        // protects the interface value of the above conn.
        buf         *bufio.Reader                     // buffered reader on conn.
        tlsState    *tls.ConnectionState              // underlying TLS connection state.
        streams     map[common.StreamID]common.Stream // map of active streams.
        streamsLock sync.Mutex                        // protects streams.
        output      [8]chan common.Frame              // one output channel per priority level.

        // other state
        compressor       common.Compressor   // outbound compression state.
        decompressor     common.Decompressor // inbound decompression state.
        receivedSettings common.Settings     // settings sent by client.
        goawayReceived   bool                // goaway has been received.
        goawaySent       bool                // goaway has been sent.
        goawayLock       sync.Mutex          // protects goawaySent and goawayReceived.
        numBenignErrors  int                 // number of non-serious errors encountered.
        readTimeout      time.Duration       // optional timeout for network reads.
        writeTimeout     time.Duration       // optional timeout for network writes.
        timeoutLock      sync.Mutex          // protects changes to readTimeout and writeTimeout.

        // SPDY features
        pings                map[uint32]chan&lt;- bool                // response channel for pings.
        pingsLock            sync.Mutex                            // protects pings.
        nextPingID           uint32                                // next outbound ping ID.
        nextPingIDLock       sync.Mutex                            // protects nextPingID.
        pushStreamLimit      *common.StreamLimit                   // Limit on streams started by the server.
        pushRequests         map[common.StreamID]*http.Request     // map of requests sent in server pushes.
        lastPushStreamID     common.StreamID                       // last push stream ID. (even)
        lastPushStreamIDLock sync.Mutex                            // protects lastPushStreamID.
        pushedResources      map[common.Stream]map[string]struct{} // prevents duplicate headers being pushed.

        // requests
        lastRequestStreamID     common.StreamID     // last request stream ID. (odd)
        lastRequestStreamIDLock sync.Mutex          // protects lastRequestStreamID.
        streamCreation          sync.Mutex          // ensures new streams are sent in order.
        oddity                  common.StreamID     // whether locally-sent streams are odd or even.
        initialWindowSize       uint32              // initial transport window.
        initialWindowSizeLock   sync.Mutex          // lock for initialWindowSize
        requestStreamLimit      *common.StreamLimit // Limit on streams started by the client.

        // startup and shutdown
        stop          chan bool     // this channel is closed when the connection closes.
        sending       chan struct{} // this channel is used to ensure pending frames are sent.
        sendingLock   sync.Mutex    // protects changes to sending's value.
        init          func()        // this function is called before the connection begins.
        shutdownOnce  sync.Once     // used to ensure clean shutdown.
        shutdownError error         // error that caused shutdown if non-nil
}

// NewConn produces an initialised spdy3 connection.
func NewConn(conn net.Conn, server http.ServerHandler) *Conn <span class="cov10" title="6">{
        out := new(Conn)

        // Common ground.
        out.remoteAddr = conn.RemoteAddr().String()
        out.server = server
        out.conn = conn
        out.buf = bufio.NewReader(conn)
        if tlsConn, ok := conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                out.tlsState = new(tls.ConnectionState)
                *out.tlsState = tlsConn.ConnectionState()
        }</span>
        <span class="cov10" title="6">out.streams = make(map[common.StreamID]common.Stream)
        out.output[0] = make(chan common.Frame)
        out.output[1] = make(chan common.Frame)
        out.output[2] = make(chan common.Frame)
        out.output[3] = make(chan common.Frame)
        out.output[4] = make(chan common.Frame)
        out.output[5] = make(chan common.Frame)
        out.output[6] = make(chan common.Frame)
        out.output[7] = make(chan common.Frame)
        out.pings = make(map[uint32]chan&lt;- bool)
        out.compressor = common.NewCompressor(2)
        out.decompressor = common.NewDecompressor(2)
        out.receivedSettings = make(common.Settings)
        out.lastPushStreamID = 0
        out.lastRequestStreamID = 0
        out.stop = make(chan bool)

        // Server/client specific.
        if server != nil </span><span class="cov6" title="3">{ // servers
                out.nextPingID = 2
                out.oddity = 0
                out.initialWindowSize = common.DEFAULT_INITIAL_WINDOW_SIZE
                out.requestStreamLimit = common.NewStreamLimit(common.DEFAULT_STREAM_LIMIT)
                out.pushStreamLimit = common.NewStreamLimit(common.NO_STREAM_LIMIT)
                out.init = func() </span><span class="cov6" title="3">{
                        // Initialise the connection by sending the connection settings.
                        settings := new(frames.SETTINGS)
                        settings.Settings = defaultServerSettings(common.DEFAULT_STREAM_LIMIT)
                        out.output[0] &lt;- settings
                }</span>
                <span class="cov6" title="3">if d := server.GetReadTimeout(); d != 0 </span><span class="cov6" title="3">{
                        out.SetReadTimeout(d)
                }</span>
                <span class="cov6" title="3">if d := server.GetWriteTimeout(); d != 0 </span><span class="cov6" title="3">{
                        out.SetWriteTimeout(d)
                }</span>
                <span class="cov6" title="3">out.pushedResources = make(map[common.Stream]map[string]struct{})</span>

        } <span class="cov6" title="3">else { // clients
                out.nextPingID = 1
                out.oddity = 1
                out.initialWindowSize = common.DEFAULT_INITIAL_CLIENT_WINDOW_SIZE
                out.requestStreamLimit = common.NewStreamLimit(common.NO_STREAM_LIMIT)
                out.pushStreamLimit = common.NewStreamLimit(common.DEFAULT_STREAM_LIMIT)
                out.pushRequests = make(map[common.StreamID]*http.Request)
                out.init = func() </span><span class="cov6" title="3">{
                        // Initialise the connection by sending the connection settings.
                        settings := new(frames.SETTINGS)
                        settings.Settings = defaultClientSettings(common.DEFAULT_STREAM_LIMIT)
                        out.output[0] &lt;- settings
                }</span>
        }
        <span class="cov10" title="6">return out</span>
}

// NextProto is intended for use in http.Server.TLSNextProto,
// using SPDY/2 for the connection.
func NextProto(s http.ServerHandler, tlsConn *tls.Conn) <span class="cov0" title="0">{
        NewConn(tlsConn, s).Run()
}</span>

func (c *Conn) Run() error <span class="cov10" title="6">{
        defer common.Recover()
        go c.send()        // Start the send loop.
        if c.init != nil </span><span class="cov10" title="6">{ // Must be after sending is enabled.
                c.init() // Prepare any initialisation frames.
        }</span>
        <span class="cov10" title="6">go c.readFrames() // Start the main loop.
        &lt;-c.stop          // Run until the connection ends.
        return nil</span>
}

// newStream is used to create a new serverStream from a SYN_STREAM frame.
func (c *Conn) newStream(frame *frames.SYN_STREAM) *ResponseStream <span class="cov6" title="3">{
        header := frame.Header
        rawUrl := header.Get("scheme") + "://" + header.Get("host") + header.Get("url")

        url, err := url.Parse(rawUrl)
        if c.check(err != nil, "Received SYN_STREAM with invalid request URL (%v)", err) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="3">vers := header.Get("version")
        major, minor, ok := http.ParseHTTPVersion(vers)
        if c.check(!ok, "Invalid HTTP version: "+vers) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="3">method := header.Get("method")

        // Build this into a request to present to the Handler.
        request := &amp;http.Request{
                Method:     method,
                URL:        url,
                Proto:      vers,
                ProtoMajor: major,
                ProtoMinor: minor,
                RemoteAddr: c.remoteAddr,
                Header:     header,
                Host:       url.Host,
                RequestURI: url.RequestURI(),
                TLS:        c.tlsState,
        }

        output := c.output[frame.Priority]
        c.streamCreation.Lock()
        out := NewResponseStream(c, frame, output, c.server, request)
        c.streamCreation.Unlock()

        return out</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package spdy2

import (
        "io"
        "net"
        "time"

        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// check returns the error condition and
// updates the connection accordingly.
func (c *Conn) check(condition bool, format string, v ...interface{}) bool <span class="cov10" title="38">{
        if !condition </span><span class="cov10" title="38">{
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Error: "+format+".\n", v...)
        c.numBenignErrors++
        return true</span>
}

// criticalCheck returns the error condition
// and ends the connection accordingly.
func (c *Conn) criticalCheck(condition bool, sid common.StreamID, format string, v ...interface{}) bool <span class="cov7" title="12">{
        if !condition </span><span class="cov7" title="12">{
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Error: "+format+".\n", v...)
        c.protocolError(sid)
        return true</span>
}

func (c *Conn) _RST_STREAM(streamID common.StreamID, status common.StatusCode) <span class="cov0" title="0">{
        rst := new(frames.RST_STREAM)
        rst.StreamID = streamID
        rst.Status = status
        c.output[0] &lt;- rst
}</span>

func (c *Conn) _GOAWAY() <span class="cov0" title="0">{
        c.output[0] &lt;- new(frames.GOAWAY)
        c.Close()
}</span>

// handleReadWriteError differentiates between normal and
// unexpected errors when performing I/O with the network,
// then shuts down the connection.
func (c *Conn) handleReadWriteError(err error) <span class="cov6" title="9">{
        if _, ok := err.(*net.OpError); ok || err == io.EOF || err == common.ErrConnNil ||
                err.Error() == "use of closed network connection" </span><span class="cov3" title="3">{
                // Server has closed the TCP connection.
                debug.Println("Note: Endpoint has discected.")
        }</span> <span class="cov5" title="6">else {
                // Unexpected error which prevented a read/write.
                log.Printf("Error: Encountered error: %q (%T)\n", err.Error(), err)
        }</span>

        // Make sure c.Close succeeds and sending stops.
        <span class="cov6" title="9">c.sendingLock.Lock()
        if c.sending == nil </span><span class="cov3" title="3">{
                c.sending = make(chan struct{})
        }</span>
        <span class="cov6" title="9">c.sendingLock.Unlock()

        c.Close()</span>
}

// protocolError informs the other endpoint that a protocol error has
// occurred, stops all running streams, and ends the connection.
func (c *Conn) protocolError(streamID common.StreamID) <span class="cov0" title="0">{
        reply := new(frames.RST_STREAM)
        reply.StreamID = streamID
        reply.Status = common.RST_STREAM_PROTOCOL_ERROR
        select </span>{
        <span class="cov0" title="0">case c.output[0] &lt;- reply:</span>
        <span class="cov0" title="0">case &lt;-time.After(100 * time.Millisecond):
                debug.Println("Failed to send PROTOCOL_ERROR RST_STREAM.")</span>
        }
        <span class="cov0" title="0">c.shutdownError = reply
        c.Close()</span>
}
</pre>
		
		<pre class="file" id="file179" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bufio"
        "errors"

        "bfe_spdy/common"
)

// ReadFrame reads and parses a frame from reader.
func ReadFrame(reader *bufio.Reader) (frame common.Frame, err error) <span class="cov0" title="0">{
        start, err := reader.Peek(4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if start[0] != 128 </span><span class="cov0" title="0">{
                frame = new(DATA)
                _, err = frame.ReadFrom(reader)
                return frame, err
        }</span>

        <span class="cov0" title="0">switch common.BytesToUint16(start[2:4]) </span>{
        <span class="cov0" title="0">case _SYN_STREAM:
                frame = new(SYN_STREAM)</span>
        <span class="cov0" title="0">case _SYN_REPLY:
                frame = new(SYN_REPLY)</span>
        <span class="cov0" title="0">case _RST_STREAM:
                frame = new(RST_STREAM)</span>
        <span class="cov0" title="0">case _SETTINGS:
                frame = new(SETTINGS)</span>
        <span class="cov0" title="0">case _NOOP:
                frame = new(NOOP)</span>
        <span class="cov0" title="0">case _PING:
                frame = new(PING)</span>
        <span class="cov0" title="0">case _GOAWAY:
                frame = new(GOAWAY)</span>
        <span class="cov0" title="0">case _HEADERS:
                frame = new(HEADERS)</span>
        <span class="cov0" title="0">case _WINDOW_UPDATE:
                frame = new(WINDOW_UPDATE)</span>

        <span class="cov0" title="0">default:
                return nil, errors.New("Error Failed to parse frame type.")</span>
        }

        <span class="cov0" title="0">_, err = frame.ReadFrom(reader)
        return frame, err</span>
}

// controlFrameCommonProcessing performs checks identical between
// all control frames. This includes the control bit, the version
// number, the type byte (which is checked against the byte
// provided), and the flags (which are checked against the bitwise
// OR of valid flags provided).
func controlFrameCommonProcessing(data []byte, frameType uint16, flags byte) error <span class="cov10" title="7">{
        // Check it's a control frame.
        if data[0] != 128 </span><span class="cov0" title="0">{
                return common.IncorrectFrame(_DATA_FRAME, int(frameType), 2)
        }</span>

        // Check version.
        <span class="cov10" title="7">version := (uint16(data[0]&amp;0x7f) &lt;&lt; 8) + uint16(data[1])
        if version != 2 </span><span class="cov0" title="0">{
                return common.UnsupportedVersion(version)
        }</span>

        // Check its type.
        <span class="cov10" title="7">realType := common.BytesToUint16(data[2:])
        if realType != frameType </span><span class="cov0" title="0">{
                return common.IncorrectFrame(int(realType), int(frameType), 2)
        }</span>

        // Check the flags.
        <span class="cov10" title="7">if data[4] &amp; ^flags != 0 </span><span class="cov0" title="0">{
                return common.InvalidField("flags", int(data[4]), int(flags))
        }</span>

        <span class="cov10" title="7">return nil</span>
}

// Frame types in SPDY/2
const (
        _SYN_STREAM    = 1
        _SYN_REPLY     = 2
        _RST_STREAM    = 3
        _SETTINGS      = 4
        _NOOP          = 5
        _PING          = 6
        _GOAWAY        = 7
        _HEADERS       = 8
        _WINDOW_UPDATE = 9
        _CONTROL_FRAME = -1
        _DATA_FRAME    = -2
)

// frameNames provides the name for a particular SPDY/2
// frame type.
var frameNames = map[int]string{
        _SYN_STREAM:    "SYN_STREAM",
        _SYN_REPLY:     "SYN_REPLY",
        _RST_STREAM:    "RST_STREAM",
        _SETTINGS:      "SETTINGS",
        _NOOP:          "NOOP",
        _PING:          "PING",
        _GOAWAY:        "GOAWAY",
        _HEADERS:       "HEADERS",
        _WINDOW_UPDATE: "WINDOW_UPDATE",
        _CONTROL_FRAME: "CONTROL_FRAME",
        _DATA_FRAME:    "DATA_FRAME",
}
</pre>
		
		<pre class="file" id="file180" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type DATA struct {
        StreamID common.StreamID
        Flags    common.Flags
        Data     []byte
}

func (frame *DATA) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *DATA) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *DATA) Name() string <span class="cov8" title="1">{
        return "DATA"
}</span>

func (frame *DATA) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 8)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Check it's a data frame.
        <span class="cov8" title="1">if data[0]&amp;0x80 == 1 </span><span class="cov0" title="0">{
                return 8, common.IncorrectFrame(_CONTROL_FRAME, _DATA_FRAME, 2)
        }</span>

        // Check flags.
        <span class="cov8" title="1">if data[4] &amp; ^byte(common.FLAG_FIN) != 0 </span><span class="cov0" title="0">{
                return 8, common.InvalidField("flags", int(data[4]), common.FLAG_FIN)
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 8, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">if length != 0 </span><span class="cov8" title="1">{
                frame.Data, err = common.ReadExactly(reader, length)
                if err != nil </span><span class="cov0" title="0">{
                        return 8, err
                }</span>
        }

        <span class="cov8" title="1">frame.StreamID = common.StreamID(common.BytesToUint32(data[0:4]))
        frame.Flags = common.Flags(data[4])
        if frame.Data == nil </span><span class="cov0" title="0">{
                frame.Data = []byte{}
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}

func (frame *DATA) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("DATA {\n\t")
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Length:               %d\n\t", len(frame.Data)))
        if common.VerboseLogging || len(frame.Data) &lt;= 21 </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("Data:                 [% x]\n}\n", frame.Data))
        }</span> <span class="cov8" title="1">else {
                buf.WriteString(fmt.Sprintf("Data:                 [% x ... % x]\n}\n", frame.Data[:9],
                        frame.Data[len(frame.Data)-9:]))
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}

func (frame *DATA) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        length := len(frame.Data)
        if length &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Data size too large.")
        }</span>
        <span class="cov8" title="1">if length == 0 &amp;&amp; !frame.Flags.FIN() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Data is empty.")
        }</span>

        <span class="cov8" title="1">out := make([]byte, 8)

        out[0] = frame.StreamID.B1() // Control bit and Stream ID
        out[1] = frame.StreamID.B2() // Stream ID
        out[2] = frame.StreamID.B3() // Stream ID
        out[3] = frame.StreamID.B4() // Stream ID
        out[4] = byte(frame.Flags)   // Flags
        out[5] = byte(length &gt;&gt; 16)  // Length
        out[6] = byte(length &gt;&gt; 8)   // Length
        out[7] = byte(length)        // Length

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, frame.Data)
        if err != nil </span><span class="cov0" title="0">{
                return 8, err
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type GOAWAY struct {
        LastGoodStreamID common.StreamID
}

func (frame *GOAWAY) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *GOAWAY) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *GOAWAY) Name() string <span class="cov8" title="1">{
        return "GOAWAY"
}</span>

func (frame *GOAWAY) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _GOAWAY, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4)
        }</span>

        <span class="cov8" title="1">frame.LastGoodStreamID = common.StreamID(common.BytesToUint32(data[8:12]))

        if !frame.LastGoodStreamID.Valid() </span><span class="cov0" title="0">{
                return 12, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return 12, nil</span>
}

func (frame *GOAWAY) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("GOAWAY {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Last good stream ID:  %d\n}\n", frame.LastGoodStreamID))

        return buf.String()
}</span>

func (frame *GOAWAY) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if !frame.LastGoodStreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">out := make([]byte, 12)

        out[0] = 128                          // Control bit and Version
        out[1] = 2                            // Version
        out[2] = 0                            // Type
        out[3] = 7                            // Type
        out[4] = 0                            // Flags
        out[5] = 0                            // Length
        out[6] = 0                            // Length
        out[7] = 4                            // Length
        out[8] = frame.LastGoodStreamID.B1()  // Last Good Stream ID
        out[9] = frame.LastGoodStreamID.B2()  // Last Good Stream ID
        out[10] = frame.LastGoodStreamID.B3() // Last Good Stream ID
        out[11] = frame.LastGoodStreamID.B4() // Last Good Stream ID

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 12, nil</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
)

type HEADERS struct {
        Flags     common.Flags
        StreamID  common.StreamID
        Header    http.Header
        rawHeader []byte
}

func (frame *HEADERS) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *HEADERS) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *HEADERS) Name() string <span class="cov8" title="1">{
        return "HEADERS"
}</span>

/* ReadFrom - read and parse Header frame 
 *
 * Note: format of Header frame 
 *  +----------------------------------+
 *  |C|     2           |      8       |
 *  +----------------------------------+
 *  | Flags (8)  |  Length (24 bits)   |
 *  +----------------------------------+
 *  |X|          Stream-ID (31bits)    |
 *  +----------------------------------+
 *  |  Unused (16 bits) |              |
 *  |--------------------              |
 *  | Name/value header block          |
 *  +----------------------------------+
 *
 * For more information, see:
 *  https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2#TOC-HEADERS
 */
func (frame *HEADERS) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 14)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _HEADERS, common.FLAG_FIN)
        if err != nil </span><span class="cov0" title="0">{
                return 16, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 6 </span><span class="cov0" title="0">{
                return 14, common.IncorrectDataLength(length, 6)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 14, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-6)
        if err != nil </span><span class="cov0" title="0">{
                return 14, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.rawHeader = header

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return int64(length + 8), common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return int64(length + 8), common.StreamIdIsZero
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}

func (frame *HEADERS) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        Flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                Flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if Flags == "" </span><span class="cov8" title="1">{
                Flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                Flags = Flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("HEADERS {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", Flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Header:               %v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *HEADERS) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Headers not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 6 + len(header)
        out := make([]byte, 14)

        out[0] = 128                  // Control bit and Version
        out[1] = 2                    // Version
        out[2] = 0                    // Type
        out[3] = 8                    // Type
        out[4] = byte(frame.Flags)    // Flags
        out[5] = byte(length &gt;&gt; 16)   // Length
        out[6] = byte(length &gt;&gt; 8)    // Length
        out[7] = byte(length)         // Length
        out[8] = frame.StreamID.B1()  // Stream ID
        out[9] = frame.StreamID.B2()  // Stream ID
        out[10] = frame.StreamID.B3() // Stream ID
        out[11] = frame.StreamID.B4() // Stream ID
    // skip unused 2 bytes

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 14, err
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "io"

        "bfe_spdy/common"
)

type NOOP struct{}

func (frame *NOOP) Compress(comp common.Compressor) error <span class="cov0" title="0">{
        return nil
}</span>

func (frame *NOOP) Decompress(decomp common.Decompressor) error <span class="cov0" title="0">{
        return nil
}</span>

func (frame *NOOP) Name() string <span class="cov8" title="1">{
        return "NOOP"
}</span>

func (frame *NOOP) ReadFrom(reader io.Reader) (int64, error) <span class="cov0" title="0">{
        data, err := common.ReadExactly(reader, 8)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = controlFrameCommonProcessing(data[:5], _NOOP, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 8, err
        }</span>

        // Get and check length.
        <span class="cov0" title="0">length := int(common.BytesToUint24(data[5:8]))
        if length != 0 </span><span class="cov0" title="0">{
                return 8, common.IncorrectDataLength(length, 0)
        }</span>

        <span class="cov0" title="0">return 8, nil</span>
}

func (frame *NOOP) String() string <span class="cov8" title="1">{
        return "NOOP {\n\tVersion:              2\n}\n"
}</span>

func (frame *NOOP) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        return 0, nil
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type PING struct {
        PingID uint32
}

func (frame *PING) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *PING) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *PING) Name() string <span class="cov8" title="1">{
        return "PING"
}</span>

func (frame *PING) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _PING, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4)
        }</span>

        <span class="cov8" title="1">frame.PingID = common.BytesToUint32(data[8:12])

        return 12, nil</span>
}

func (frame *PING) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("PING {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Ping ID:              %d\n}\n", frame.PingID))

        return buf.String()
}</span>

func (frame *PING) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        out := make([]byte, 12)

        out[0] = 128                      // Control bit and Version
        out[1] = 2                        // Version
        out[2] = 0                        // Type
        out[3] = 6                        // Type
        out[4] = 0                        // Flags
        out[5] = 0                        // Length
        out[6] = 0                        // Length
        out[7] = 4                        // Length
        out[8] = byte(frame.PingID &gt;&gt; 24) // Ping ID
        out[9] = byte(frame.PingID &gt;&gt; 16) // Ping ID
        out[10] = byte(frame.PingID &gt;&gt; 8) // Ping ID
        out[11] = byte(frame.PingID)      // Ping ID

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 12, nil</span>
}
</pre>
		
		<pre class="file" id="file185" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "fmt"
        "io"
)

import (
        "bfe_spdy/common"
)

type RST_STREAM struct {
        StreamID common.StreamID
        Status   common.StatusCode
}

func (frame *RST_STREAM) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *RST_STREAM) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *RST_STREAM) Error() string <span class="cov0" title="0">{
        if err := frame.Status.String(); err != "" </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("[unknown status code %d]", frame.Status)</span>
}

func (frame *RST_STREAM) Name() string <span class="cov8" title="1">{
        return "RST_STREAM"
}</span>

func (frame *RST_STREAM) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _RST_STREAM, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 16, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 8 </span><span class="cov0" title="0">{
                return 16, common.IncorrectDataLength(length, 8)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 16, common.FrameTooLarge
        }</span>

        <span class="cov8" title="1">frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.Status = common.StatusCode(common.BytesToUint32(data[12:16]))

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 16, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}

func (frame *RST_STREAM) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("RST_STREAM {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Status code:          %s\n}\n", frame.Status))

        return buf.String()
}</span>

func (frame *RST_STREAM) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">out := make([]byte, 16)

        out[0] = 128                  // Control bit and Version
        out[1] = 2                    // Version
        out[2] = 0                    // Type
        out[3] = 3                    // Type
        out[4] = 0                    // Flags
        out[5] = 0                    // Length
        out[6] = 0                    // Length
        out[7] = 8                    // Length
        out[8] = frame.StreamID.B1()  // Stream ID
        out[9] = frame.StreamID.B2()  // Stream ID
        out[10] = frame.StreamID.B3() // Stream ID
        out[11] = frame.StreamID.B4() // Stream ID
        out[12] = frame.Status.B1()   // Status
        out[13] = frame.Status.B2()   // Status
        out[14] = frame.Status.B3()   // Status
        out[15] = frame.Status.B4()   // Status

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "sort"

        "bfe_spdy/common"
)

type SETTINGS struct {
        Flags    common.Flags
        Settings common.Settings
}

func (frame *SETTINGS) Add(Flags common.Flags, id uint32, value uint32) <span class="cov0" title="0">{
        frame.Settings[id] = &amp;common.Setting{Flags, id, value}
}</span>

func (frame *SETTINGS) Compress(comp common.Compressor) error <span class="cov1" title="1">{
        return nil
}</span>

func (frame *SETTINGS) Decompress(decomp common.Decompressor) error <span class="cov1" title="1">{
        return nil
}</span>

func (frame *SETTINGS) Name() string <span class="cov1" title="1">{
        return "SETTINGS"
}</span>

func (frame *SETTINGS) ReadFrom(reader io.Reader) (int64, error) <span class="cov1" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">err = controlFrameCommonProcessing(data[:5], _SETTINGS, common.FLAG_SETTINGS_CLEAR_SETTINGS)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov1" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 8)
        }</span> <span class="cov1" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 12, common.FrameTooLarge
        }</span>

        // Check size.
        <span class="cov1" title="1">numSettings := int(common.BytesToUint32(data[8:12]))
        if length != 4+(8*numSettings) </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4+(8*numSettings))
        }</span>

        // Read in data.
        <span class="cov1" title="1">settings, err := common.ReadExactly(reader, 8*numSettings)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov1" title="1">frame.Flags = common.Flags(data[4])
        frame.Settings = make(common.Settings)
        for i := 0; i &lt; numSettings; i++ </span><span class="cov10" title="2">{
                j := i * 8
                setting := decodeSetting(settings[j:])
                if setting == nil </span><span class="cov0" title="0">{
                        return int64(length), errors.New("Error: Failed to parse settings.")
                }</span>
                <span class="cov10" title="2">frame.Settings[setting.ID] = setting</span>
        }

        <span class="cov1" title="1">return int64(length + 8), nil</span>
}

func (frame *SETTINGS) String() string <span class="cov1" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.CLEAR_SETTINGS() </span><span class="cov0" title="0">{
                flags += " FLAG_SETTINGS_CLEAR_SETTINGS"
        }</span>
        <span class="cov1" title="1">if flags == "" </span><span class="cov1" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov1" title="1">buf.WriteString("SETTINGS {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Settings:\n"))
        settings := frame.Settings.Settings()
        for _, setting := range settings </span><span class="cov10" title="2">{
                buf.WriteString("\t\t" + setting.String() + "\n")
        }</span>
        <span class="cov1" title="1">buf.WriteString("}\n")

        return buf.String()</span>
}

func (frame *SETTINGS) WriteTo(writer io.Writer) (int64, error) <span class="cov1" title="1">{
        settings := encodeSettings(frame.Settings)
        numSettings := uint32(len(frame.Settings))
        length := 4 + len(settings)
        out := make([]byte, 12)

        out[0] = 128                     // Control bit and Version
        out[1] = 2                       // Version
        out[2] = 0                       // Type
        out[3] = 4                       // Type
        out[4] = byte(frame.Flags)       // Flags
        out[5] = byte(length &gt;&gt; 16)      // Length
        out[6] = byte(length &gt;&gt; 8)       // Length
        out[7] = byte(length)            // Length
        out[8] = byte(numSettings &gt;&gt; 24) // Number of Entries
        out[9] = byte(numSettings &gt;&gt; 16) // Number of Entries
        out[10] = byte(numSettings &gt;&gt; 8) // Number of Entries
        out[11] = byte(numSettings)      // Number of Entries

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">err = common.WriteExactly(writer, settings)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov1" title="1">return int64(length + 8), nil</span>
}

func decodeSetting(data []byte) *common.Setting <span class="cov10" title="2">{
        if len(data) &lt; 8 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="2">setting := new(common.Setting)
        setting.ID = common.BytesToUint24Reverse(data[0:]) // Might need to reverse this.
        setting.Flags = common.Flags(data[3])
        setting.Value = common.BytesToUint32(data[4:])

        return setting</span>
}

func encodeSettings(s common.Settings) []byte <span class="cov1" title="1">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return []byte{}
        }</span>

        <span class="cov1" title="1">ids := make([]int, 0, len(s))
        for id := range s </span><span class="cov10" title="2">{
                ids = append(ids, int(id))
        }</span>

        <span class="cov1" title="1">sort.Sort(sort.IntSlice(ids))

        out := make([]byte, 8*len(s))

        offset := 0
        for _, id := range ids </span><span class="cov10" title="2">{
                setting := s[uint32(id)]
                out[offset] = byte(setting.ID)         // Might need to reverse this.
                out[offset+1] = byte(setting.ID &gt;&gt; 8)  // Might need to reverse this.
                out[offset+2] = byte(setting.ID &gt;&gt; 16) // Might need to reverse this.
                out[offset+3] = byte(setting.Flags)
                out[offset+4] = byte(setting.Value &gt;&gt; 24)
                out[offset+5] = byte(setting.Value &gt;&gt; 16)
                out[offset+6] = byte(setting.Value &gt;&gt; 8)
                out[offset+7] = byte(setting.Value)
                offset += 8
        }</span>

        <span class="cov1" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
)

type SYN_REPLY struct {
        Flags     common.Flags
        StreamID  common.StreamID
        Header    http.Header
        rawHeader []byte
}

func (frame *SYN_REPLY) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *SYN_REPLY) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *SYN_REPLY) Name() string <span class="cov8" title="1">{
        return "SYN_REPLY"
}</span>

func (frame *SYN_REPLY) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 14)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _SYN_REPLY, common.FLAG_FIN)
        if err != nil </span><span class="cov0" title="0">{
                return 14, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 8 </span><span class="cov0" title="0">{
                return 14, common.IncorrectDataLength(length, 8)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 14, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-6)
        if err != nil </span><span class="cov0" title="0">{
                return 14, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.rawHeader = header

        return int64(length + 8), nil</span>
}

func (frame *SYN_REPLY) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("SYN_REPLY {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Header:               %v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *SYN_REPLY) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Header not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 6 + len(header)
        out := make([]byte, 14)

        out[0] = 128                  // Control bit and Version
        out[1] = 2                    // Version
        out[2] = 0                    // Type
        out[3] = 2                    // Type
        out[4] = byte(frame.Flags)    // Flags
        out[5] = byte(length &gt;&gt; 16)   // Length
        out[6] = byte(length &gt;&gt; 8)    // Length
        out[7] = byte(length)         // Length
        out[8] = frame.StreamID.B1()  // Stream ID
        out[9] = frame.StreamID.B2()  // Stream ID
        out[10] = frame.StreamID.B3() // Stream ID
        out[11] = frame.StreamID.B4() // Stream ID
        out[12] = 0                   // Unused
        out[13] = 0                   // Unused

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 14, err
        }</span>

        <span class="cov8" title="1">return int64(len(header) + 14), nil</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
)

type SYN_STREAM struct {
        Flags         common.Flags
        StreamID      common.StreamID
        AssocStreamID common.StreamID
        Priority      common.Priority
        Header        http.Header
        rawHeader     []byte
}

func (frame *SYN_STREAM) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *SYN_STREAM) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *SYN_STREAM) Name() string <span class="cov8" title="1">{
        return "SYN_STREAM"
}</span>

func (frame *SYN_STREAM) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 18)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _SYN_STREAM, common.FLAG_FIN|common.FLAG_UNIDIRECTIONAL)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 12 </span><span class="cov0" title="0">{
                return 18, common.IncorrectDataLength(length, 12)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-18 </span><span class="cov0" title="0">{
                return 18, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-10)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.AssocStreamID = common.StreamID(common.BytesToUint32(data[12:16]))
        frame.Priority = common.Priority(data[16] &gt;&gt; 6)
        frame.rawHeader = header

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 18, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 18, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if !frame.AssocStreamID.Valid() </span><span class="cov0" title="0">{
                return 18, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}

func (frame *SYN_STREAM) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if frame.Flags.UNIDIRECTIONAL() </span><span class="cov0" title="0">{
                flags += " FLAG_UNIDIRECTIONAL"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("SYN_STREAM {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Associated Stream ID: %d\n\t", frame.AssocStreamID))
        buf.WriteString(fmt.Sprintf("Priority:             %d\n\t", frame.Priority))
        buf.WriteString(fmt.Sprintf("Header:               %v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *SYN_STREAM) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Headers not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if !frame.AssocStreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 10 + len(header)
        out := make([]byte, 18)

        out[0] = 128                       // Control bit and Version
        out[1] = 2                         // Version
        out[2] = 0                         // Type
        out[3] = 1                         // Type
        out[4] = byte(frame.Flags)         // Flags
        out[5] = byte(length &gt;&gt; 16)        // Length
        out[6] = byte(length &gt;&gt; 8)         // Length
        out[7] = byte(length)              // Length
        out[8] = frame.StreamID.B1()       // Stream ID
        out[9] = frame.StreamID.B2()       // Stream ID
        out[10] = frame.StreamID.B3()      // Stream ID
        out[11] = frame.StreamID.B4()      // Stream ID
        out[12] = frame.AssocStreamID.B1() // Associated Stream ID
        out[13] = frame.AssocStreamID.B2() // Associated Stream ID
        out[14] = frame.AssocStreamID.B3() // Associated Stream ID
        out[15] = frame.AssocStreamID.B4() // Associated Stream ID
        out[16] = frame.Priority.Byte(2)   // Priority and Unused
        out[17] = 0                        // Unused

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        <span class="cov8" title="1">return int64(len(header) + 18), nil</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type WINDOW_UPDATE struct {
        StreamID        common.StreamID
        DeltaWindowSize uint32
}

func (frame *WINDOW_UPDATE) Compress(comp common.Compressor) error <span class="cov0" title="0">{
        return nil
}</span>

func (frame *WINDOW_UPDATE) Decompress(decomp common.Decompressor) error <span class="cov0" title="0">{
        return nil
}</span>

func (frame *WINDOW_UPDATE) Name() string <span class="cov8" title="1">{
        return "WINDOW_UPDATE"
}</span>

func (frame *WINDOW_UPDATE) ReadFrom(reader io.Reader) (int64, error) <span class="cov0" title="0">{
        data, err := common.ReadExactly(reader, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = controlFrameCommonProcessing(data[:5], _WINDOW_UPDATE, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 16, err
        }</span>

        // Get and check length.
        <span class="cov0" title="0">length := int(common.BytesToUint24(data[5:8]))
        if length != 8 </span><span class="cov0" title="0">{
                return 16, common.IncorrectDataLength(length, 8)
        }</span>

        <span class="cov0" title="0">frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.DeltaWindowSize = common.BytesToUint32(data[12:16])

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 16, common.StreamIdTooLarge
        }</span>
        <span class="cov0" title="0">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 16, common.StreamIdIsZero
        }</span>
        <span class="cov0" title="0">if frame.DeltaWindowSize &gt; common.MAX_DELTA_WINDOW_SIZE </span><span class="cov0" title="0">{
                return 16, errors.New("Error: Delta Window Size too large.")
        }</span>

        <span class="cov0" title="0">return 16, nil</span>
}

func (frame *WINDOW_UPDATE) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("WINDOW_UPDATE {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              2\n\t"))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Delta window size:    %d\n}\n", frame.DeltaWindowSize))

        return buf.String()
}</span>

func (frame *WINDOW_UPDATE) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        return 0, nil
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">package spdy2

import (
        "net"
        "time"
)

func (c *Conn) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return c.stop
}</span>

func (c *Conn) Conn() net.Conn <span class="cov0" title="0">{
        return c.conn
}</span>

func (c *Conn) SetReadTimeout(d time.Duration) <span class="cov3" title="3">{
        c.timeoutLock.Lock()
        c.readTimeout = d
        c.timeoutLock.Unlock()
}</span>

func (c *Conn) SetWriteTimeout(d time.Duration) <span class="cov3" title="3">{
        c.timeoutLock.Lock()
        c.writeTimeout = d
        c.timeoutLock.Unlock()
}</span>

func (c *Conn) refreshReadTimeout() <span class="cov10" title="34">{
        c.timeoutLock.Lock()
        if d := c.readTimeout; d != 0 &amp;&amp; c.conn != nil </span><span class="cov7" title="15">{
                c.conn.SetReadDeadline(time.Now().Add(d))
        }</span>
        <span class="cov10" title="34">c.timeoutLock.Unlock()</span>
}

func (c *Conn) refreshWriteTimeout() <span class="cov9" title="31">{
        c.timeoutLock.Lock()
        if d := c.writeTimeout; d != 0 &amp;&amp; c.conn != nil </span><span class="cov8" title="19">{
                c.conn.SetWriteDeadline(time.Now().Add(d))
        }</span>
        <span class="cov9" title="31">c.timeoutLock.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">package spdy2

import (
        "runtime"
)

import (
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// readFrames is the main processing loop, where frames
// are read from the connection and processed individually.
// Returning from readFrames begins the cleanup and exit
// process for this connection.
func (c *Conn) readFrames() <span class="cov4" title="6">{
        // Ensure no panics happen.
        defer func() </span><span class="cov4" title="6">{
                if v := recover(); v != nil </span><span class="cov0" title="0">{
                        if !c.Closed() </span><span class="cov0" title="0">{
                                log.Printf("Encountered receive error: %v (%[1]T)\n", v)
                        }</span>
                }
        }()

        <span class="cov4" title="6">for </span><span class="cov7" title="34">{

                // This is the mechanism for handling too many benign errors.
                // By default MaxBenignErrors is 0, which ignores errors.
                if c.numBenignErrors &gt; common.MaxBenignErrors &amp;&amp; common.MaxBenignErrors &gt; 0 </span><span class="cov0" title="0">{
                        log.Println("Warning: Too many invalid stream IDs received. Ending connection.")
                        c.protocolError(0)
                        return
                }</span>

                // ReadFrame takes care of the frame parsing for us.
                <span class="cov7" title="34">c.refreshReadTimeout()
                frame, err := frames.ReadFrame(c.buf)
                if err != nil </span><span class="cov4" title="6">{
                        c.handleReadWriteError(err)
                        return
                }</span>

                // Print frame type.
                <span class="cov7" title="28">debug.Printf("Receiving %s:\n", frame.Name())

                // Decompress the frame's headers, if there are any.
                err = frame.Decompress(c.decompressor)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error in decompression: %v (%T).\n", err, frame)
                        c.protocolError(0)
                        return
                }</span>

                // Print frame once the content's been decompressed.
                <span class="cov7" title="28">debug.Println(frame)

                // This is the main frame handling.
                if c.processFrame(frame) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// send is run in a separate goroutine. It's used
// to ensure clear interleaving of frames and to
// provide assurances of priority and structure.
func (c *Conn) send() <span class="cov4" title="6">{
        // Catch any panics.
        defer func() </span><span class="cov4" title="5">{
                if v := recover(); v != nil </span><span class="cov0" title="0">{
                        if !c.Closed() </span><span class="cov0" title="0">{
                                log.Printf("Encountered send error: %v (%[1]T)\n", v)
                        }</span>
                }
        }()

        // Enter the processing loop.
        <span class="cov4" title="6">i := 1
        for </span><span class="cov7" title="34">{

                // Once per 5 frames, pick randomly.
                var frame common.Frame
                if i == 0 </span><span class="cov3" title="4">{ // Ignore priority.
                        frame = c.selectFrameToSend(false)
                }</span> <span class="cov7" title="30">else { // Normal selection.
                        frame = c.selectFrameToSend(true)
                }</span>

                <span class="cov7" title="32">i++
                if i &gt;= 5 </span><span class="cov4" title="5">{
                        i = 0
                }</span>

                <span class="cov7" title="32">if frame == nil </span><span class="cov1" title="1">{
                        c.Close()
                        return
                }</span>

                // Compress any name/value header blocks.
                <span class="cov7" title="31">err := frame.Compress(c.compressor)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error in compression: %v (%T).\n", err, frame)
                        return
                }</span>

                <span class="cov7" title="31">debug.Printf("Sending %s:\n", frame.Name())
                debug.Println(frame)

                // Leave the specifics of writing to the
                // connection up to the frame.
                c.refreshWriteTimeout()
                _, err = frame.WriteTo(c.conn)
                if err != nil </span><span class="cov3" title="3">{
                        c.handleReadWriteError(err)
                        return
                }</span>
        }
}

// selectFrameToSend follows the specification's guidance
// on frame priority, sending frames with higher priority
// (a smaller number) first. If the given boolean is false,
// this priority is temporarily ignored, which can be used
// when high load is ignoring low-priority frames.
func (c *Conn) selectFrameToSend(prioritise bool) (frame common.Frame) <span class="cov7" title="34">{
        if c.Closed() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try in priority order first.
        <span class="cov7" title="34">if prioritise </span><span class="cov7" title="30">{
                for i := 0; i &lt; 8; i++ </span><span class="cov10" title="123">{
                        select </span>{
                        <span class="cov6" title="19">case frame = &lt;-c.output[i]:
                                return frame</span>
                        <span class="cov9" title="104">default:</span>
                        }
                }

                // No frames are immediately pending, so if the
                // connection is being closed, cease sending
                // safely.
                <span class="cov5" title="11">c.sendingLock.Lock()
                if c.sending != nil </span><span class="cov2" title="2">{
                        close(c.sending)
                        c.sendingLock.Unlock()
                        runtime.Goexit()
                }</span>
                <span class="cov5" title="9">c.sendingLock.Unlock()</span>
        }

        // Wait for any frame.
        <span class="cov5" title="13">select </span>{
        <span class="cov5" title="9">case frame = &lt;-c.output[0]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[1]:
                return frame</span>
        <span class="cov2" title="2">case frame = &lt;-c.output[2]:
                return frame</span>
        <span class="cov2" title="2">case frame = &lt;-c.output[3]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[4]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[5]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[6]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[7]:
                return frame</span>
        <span class="cov0" title="0">case _ = &lt;-c.stop:
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file192" style="display: none">package spdy2

import (
        "net/url"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// processFrame handles the initial processing of the given
// frame, before passing it on to the relevant helper func,
// if necessary. The returned boolean indicates whether the
// connection is closing.
func (c *Conn) processFrame(frame common.Frame) bool <span class="cov10" title="28">{
        switch frame := frame.(type) </span>{

        <span class="cov4" title="4">case *frames.SYN_STREAM:
                if c.server == nil </span><span class="cov1" title="1">{
                        c.handlePush(frame)
                }</span> <span class="cov3" title="3">else {
                        c.handleRequest(frame)
                }</span>

        <span class="cov3" title="3">case *frames.SYN_REPLY:
                c.handleSynReply(frame)</span>

        <span class="cov0" title="0">case *frames.RST_STREAM:
                if frame.Status.IsFatal() </span><span class="cov0" title="0">{
                        code := frame.Status.String()
                        c.check(true, "Received %s on stream %d. Closing connection", code, frame.StreamID)
                        c.shutdownError = frame
                        c.Close()
                        return true
                }</span>
                <span class="cov0" title="0">c.handleRstStream(frame)</span>

        <span class="cov5" title="6">case *frames.SETTINGS:
                for _, setting := range frame.Settings </span><span class="cov5" title="6">{
                        c.receivedSettings[setting.ID] = setting
                        switch setting.ID </span>{
                        <span class="cov0" title="0">case common.SETTINGS_INITIAL_WINDOW_SIZE:
                                c.initialWindowSizeLock.Lock()
                                c.initialWindowSize = setting.Value
                                c.initialWindowSizeLock.Unlock()</span>

                        <span class="cov5" title="6">case common.SETTINGS_MAX_CONCURRENT_STREAMS:
                                if c.server == nil </span><span class="cov3" title="3">{
                                        c.requestStreamLimit.SetLimit(setting.Value)
                                }</span> <span class="cov3" title="3">else {
                                        c.pushStreamLimit.SetLimit(setting.Value)
                                }</span>
                        }
                }

        <span class="cov0" title="0">case *frames.NOOP:</span>
                // Ignore.

        <span class="cov4" title="4">case *frames.PING:
                // Check whether Ping ID is a response.
                c.nextPingIDLock.Lock()
                next := c.nextPingID
                c.nextPingIDLock.Unlock()
                if frame.PingID&amp;1 == next&amp;1 </span><span class="cov2" title="2">{
                        c.pingsLock.Lock()
                        if c.check(c.pings[frame.PingID] == nil, "Ignored unrequested PING %d", frame.PingID) </span><span class="cov0" title="0">{
                                c.pingsLock.Unlock()
                                return false
                        }</span>
                        <span class="cov2" title="2">c.pings[frame.PingID] &lt;- true
                        close(c.pings[frame.PingID])
                        delete(c.pings, frame.PingID)
                        c.pingsLock.Unlock()</span>
                } <span class="cov2" title="2">else {
                        debug.Println("Received PING. Replying...")
                        c.output[0] &lt;- frame
                }</span>

        <span class="cov3" title="3">case *frames.GOAWAY:
                lastProcessed := frame.LastGoodStreamID
                c.streamsLock.Lock()
                for streamID, stream := range c.streams </span><span class="cov4" title="4">{
                        if streamID&amp;1 == c.oddity &amp;&amp; streamID &gt; lastProcessed </span><span class="cov0" title="0">{
                                // Stream is locally-sent and has not been processed.
                                // TODO: Inform the server that the push has not been successful.
                                stream.Close()
                        }</span>
                }
                <span class="cov3" title="3">c.streamsLock.Unlock()
                c.goawayLock.Lock()
                c.goawayReceived = true
                c.goawayLock.Unlock()</span>

        <span class="cov1" title="1">case *frames.HEADERS:
                c.handleHeaders(frame)</span>

        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:</span>
                // Ignore.

        <span class="cov6" title="7">case *frames.DATA:
                if c.server == nil </span><span class="cov5" title="6">{
                        c.handleServerData(frame)
                }</span> <span class="cov1" title="1">else {
                        c.handleClientData(frame)
                }</span>

        <span class="cov0" title="0">default:
                c.check(true, "Ignored unexpected frame type %T", frame)</span>
        }
        <span class="cov10" title="28">return false</span>
}

// handleClientData performs the processing of DATA frames sent by the client.
func (c *Conn) handleClientData(frame *frames.DATA) <span class="cov1" title="1">{
        sid := frame.StreamID

        if c.check(c.server == nil, "Requests can only be received by the server") </span><span class="cov0" title="0">{
                return
        }</span>

        // Handle push data.
        <span class="cov1" title="1">if c.check(sid&amp;1 == 0, "Received DATA with even Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check stream ID is valid.
        <span class="cov1" title="1">if c.criticalCheck(!sid.Valid(), sid, "Received DATA with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check stream is open.
        <span class="cov1" title="1">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received DATA with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.
        <span class="cov1" title="1">stream.ReceiveFrame(frame)</span>
}

// handleHeaders performs the processing of HEADERS frames.
func (c *Conn) handleHeaders(frame *frames.HEADERS) <span class="cov1" title="1">{
        sid := frame.StreamID

        // Handle push headers.
        if sid&amp;1 == 0 &amp;&amp; c.server == nil </span><span class="cov1" title="1">{
                // Ignore refused push headers.
                if req := c.pushRequests[sid]; req != nil &amp;&amp; c.PushReceiver != nil </span><span class="cov1" title="1">{
                        c.PushReceiver.ReceiveHeader(req, frame.Header)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        // Check stream is open.
        <span class="cov0" title="0">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received HEADERS with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.
        <span class="cov0" title="0">stream.ReceiveFrame(frame)</span>
}

// handlePush performs the processing of SYN_STREAM frames forming a server push.
func (c *Conn) handlePush(frame *frames.SYN_STREAM) <span class="cov1" title="1">{

        // Check stream creation is allowed.
        c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway || c.Closed() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">sid := frame.StreamID

        // Push.
        if c.check(c.server != nil, "Only clients can receive server pushes") </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is even.
        <span class="cov1" title="1">if c.check(sid&amp;1 != 0, "Received SYN_STREAM with odd Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is the right number.
        <span class="cov1" title="1">c.lastPushStreamIDLock.Lock()
        lsid := c.lastPushStreamID
        c.lastPushStreamIDLock.Unlock()
        if c.check(sid &lt;= lsid, "Received SYN_STREAM with Stream ID %d, less than %d", sid, lsid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is not out of bounds.
        <span class="cov1" title="1">if c.criticalCheck(!sid.Valid(), sid, "Received SYN_STREAM with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.

        // Check stream limit would allow the new stream.
        <span class="cov1" title="1">if !c.pushStreamLimit.Add() </span><span class="cov0" title="0">{
                c._RST_STREAM(sid, common.RST_STREAM_REFUSED_STREAM)
                return
        }</span>

        <span class="cov1" title="1">ok := frame.Priority.Valid(2)
        if c.criticalCheck(!ok, sid, "Received SYN_STREAM with invalid priority %d", frame.Priority) </span><span class="cov0" title="0">{
                return
        }</span>

        // Parse the request.
        <span class="cov1" title="1">header := frame.Header
        rawUrl := header.Get("scheme") + "://" + header.Get("host") + header.Get("url")
        url, err := url.Parse(rawUrl)
        if c.check(err != nil, "Received SYN_STREAM with invalid request URL (%v)", err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">vers := header.Get("version")
        major, minor, ok := http.ParseHTTPVersion(vers)
        if c.check(!ok, "Invalid HTTP version: "+vers) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">method := header.Get("method")

        request := &amp;http.Request{
                Method:     method,
                URL:        url,
                Proto:      vers,
                ProtoMajor: major,
                ProtoMinor: minor,
                RemoteAddr: c.remoteAddr,
                Header:     header,
                Host:       url.Host,
                RequestURI: url.RequestURI(),
                TLS:        c.tlsState,
        }

        // Check whether the receiver wants this resource.
        if c.PushReceiver != nil &amp;&amp; !c.PushReceiver.ReceiveRequest(request) </span><span class="cov0" title="0">{
                c._RST_STREAM(sid, common.RST_STREAM_REFUSED_STREAM)
                return
        }</span>

        // Create and start new stream.
        <span class="cov1" title="1">if c.PushReceiver != nil </span><span class="cov1" title="1">{
                c.pushRequests[sid] = request
                c.lastPushStreamIDLock.Lock()
                c.lastPushStreamID = sid
                c.lastPushStreamIDLock.Unlock()
                c.PushReceiver.ReceiveHeader(request, frame.Header)
        }</span>
}

// handleRequest performs the processing of SYN_STREAM request frames.
func (c *Conn) handleRequest(frame *frames.SYN_STREAM) <span class="cov3" title="3">{
        // Check stream creation is allowed.
        c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway || c.Closed() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">sid := frame.StreamID

        if c.check(c.server == nil, "Only servers can receive requests") </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is odd.
        <span class="cov3" title="3">if c.check(sid&amp;1 == 0, "Received SYN_STREAM with even Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is the right number.
        <span class="cov3" title="3">c.lastRequestStreamIDLock.Lock()
        lsid := c.lastRequestStreamID
        c.lastRequestStreamIDLock.Unlock()
        if c.check(sid &lt;= lsid &amp;&amp; lsid != 0, "Received SYN_STREAM with Stream ID %d, less than %d", sid, lsid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is not out of bounds.
        <span class="cov3" title="3">if c.criticalCheck(!sid.Valid(), sid, "Received SYN_STREAM with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.

        // Check stream limit would allow the new stream.
        <span class="cov3" title="3">if !c.requestStreamLimit.Add() </span><span class="cov0" title="0">{
                c._RST_STREAM(sid, common.RST_STREAM_REFUSED_STREAM)
                return
        }</span>

        // Check request priority.
        <span class="cov3" title="3">ok := frame.Priority.Valid(2)
        if c.criticalCheck(!ok, sid, "Received SYN_STREAM with invalid priority %d.\n", frame.Priority) </span><span class="cov0" title="0">{
                return
        }</span>

        // Create and start new stream.
        <span class="cov3" title="3">nextStream := c.newStream(frame)
        // Make sure an error didn't occur when making the stream.
        if nextStream == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Set and prepare.
        <span class="cov3" title="3">c.streamsLock.Lock()
        c.streams[sid] = nextStream
        c.streamsLock.Unlock()
        c.lastRequestStreamIDLock.Lock()
        c.lastRequestStreamID = sid
        c.lastRequestStreamIDLock.Unlock()

        // Start the stream.
        go nextStream.Run()</span>
}

// handleRstStream performs the processing of RST_STREAM frames.
func (c *Conn) handleRstStream(frame *frames.RST_STREAM) <span class="cov0" title="0">{
        sid := frame.StreamID
        c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()

        // Determine the status code and react accordingly.
        switch frame.Status </span>{
        <span class="cov0" title="0">case common.RST_STREAM_INVALID_STREAM,
                common.RST_STREAM_STREAM_ALREADY_CLOSED:
                if stream != nil </span><span class="cov0" title="0">{
                        go stream.Close()
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        <span class="cov0" title="0">case common.RST_STREAM_FLOW_CONTROL_ERROR,
                common.RST_STREAM_STREAM_IN_USE,
                common.RST_STREAM_INVALID_CREDENTIALS:
                c.check(true, "Received %s for stream ID %d", frame.Status, sid)</span>

        <span class="cov0" title="0">case common.RST_STREAM_CANCEL:
                if c.check(sid&amp;1 == c.oddity &amp;&amp; stream == nil, "Cannot cancel locally-sent streams") </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        <span class="cov0" title="0">case common.RST_STREAM_REFUSED_STREAM:
                if stream != nil </span><span class="cov0" title="0">{
                        go stream.Close()
                }</span>

        <span class="cov0" title="0">default:
                c.criticalCheck(true, sid, "Received unknown RST_STREAM status code %d.\n", frame.Status)</span>
        }
}

// handleServerData performs the processing of DATA frames sent by the server.
func (c *Conn) handleServerData(frame *frames.DATA) <span class="cov5" title="6">{
        sid := frame.StreamID

        // Handle push data.
        if sid&amp;1 == 0 </span><span class="cov2" title="2">{
                // Ignore refused push data.
                if req := c.pushRequests[sid]; req != nil &amp;&amp; c.PushReceiver != nil </span><span class="cov2" title="2">{
                        c.PushReceiver.ReceiveData(req, frame.Data, frame.Flags.FIN())
                }</span>
                <span class="cov2" title="2">return</span>
        }

        // Check stream is open.
        <span class="cov4" title="4">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received DATA with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.
        <span class="cov4" title="4">stream.ReceiveFrame(frame)</span>
}

// handleSynReply performs the processing of SYN_REPLY frames.
func (c *Conn) handleSynReply(frame *frames.SYN_REPLY) <span class="cov3" title="3">{
        sid := frame.StreamID

        if c.check(c.server != nil, "Only clients can receive SYN_REPLY frames") </span><span class="cov0" title="0">{
                return
        }</span>

        // Check Stream ID is odd.
        <span class="cov3" title="3">if c.check(sid&amp;1 == 0, "Received SYN_REPLY with even Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">if c.criticalCheck(!sid.Valid(), sid, "Received SYN_REPLY with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check stream is open.
        <span class="cov3" title="3">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received SYN_REPLY with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.
        <span class="cov3" title="3">stream.ReceiveFrame(frame)</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy2

import (
        "errors"
        "fmt"
        "sync"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// PushStream is a structure that implements the
// Stream and PushWriter interfaces. this is used
// for performing server pushes.
type PushStream struct {
        sync.Mutex
        shutdownOnce sync.Once
        conn         *Conn
        streamID     common.StreamID
        origin       common.Stream
        state        *common.StreamState
        output       chan&lt;- common.Frame
        header       http.Header
        stop         &lt;-chan bool
}

func NewPushStream(conn *Conn, streamID common.StreamID, origin common.Stream, output chan&lt;- common.Frame) *PushStream <span class="cov1" title="1">{
        out := new(PushStream)
        out.conn = conn
        out.streamID = streamID
        out.origin = origin
        out.output = output
        out.stop = conn.stop
        out.state = new(common.StreamState)
        out.header = make(http.Header)
        return out
}</span>

/***********************
 * http.ResponseWriter *
 ***********************/

func (p *PushStream) Header() http.Header <span class="cov1" title="1">{
        return p.header
}</span>

// Write is used for sending data in the push.
func (p *PushStream) Write(inputData []byte) (int, error) <span class="cov1" title="1">{
        if p.closed() || p.state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream already closed.")
        }</span>

        <span class="cov1" title="1">state := p.origin.State()
        if p.origin == nil || state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Origin stream is closed.")
        }</span>

        <span class="cov1" title="1">p.writeHeader()

        // Copy the data locally to avoid any pointer issues.
        data := make([]byte, len(inputData))
        copy(data, inputData)

        // Chunk the response if necessary.
        written := 0
        for len(data) &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                dataFrame := new(frames.DATA)
                dataFrame.StreamID = p.streamID
                dataFrame.Data = data[:common.MAX_DATA_SIZE]
                p.output &lt;- dataFrame

                written += common.MAX_DATA_SIZE
        }</span>

        <span class="cov1" title="1">n := len(data)
        if n == 0 </span><span class="cov0" title="0">{
                return written, nil
        }</span>

        <span class="cov1" title="1">dataFrame := new(frames.DATA)
        dataFrame.StreamID = p.streamID
        dataFrame.Data = data
        p.output &lt;- dataFrame

        return written + n, nil</span>
}

// WriteHeader is provided to satisfy the Stream
// interface, but has no effect.
func (p *PushStream) WriteHeader(int) <span class="cov0" title="0">{
        p.writeHeader()
        return
}</span>

/*****************
 * io.Closer *
 *****************/

func (p *PushStream) Close() error <span class="cov6" title="2">{
        defer common.Recover()
        p.Lock()
        p.shutdownOnce.Do(p.shutdown)
        p.Unlock()
        return nil
}</span>

func (p *PushStream) shutdown() <span class="cov1" title="1">{
        p.writeHeader()
        if p.state != nil </span><span class="cov1" title="1">{
                p.state.Close()
        }</span>
        <span class="cov1" title="1">p.conn.pushStreamLimit.Close()
        p.origin = nil
        p.output = nil
        p.header = nil
        p.stop = nil</span>
}

/**********
 * Stream *
 **********/

func (p *PushStream) Conn() common.Conn <span class="cov0" title="0">{
        return p.conn
}</span>

func (p *PushStream) ReceiveFrame(frame common.Frame) error <span class="cov0" title="0">{
        p.Lock()
        defer p.Unlock()

        if frame == nil </span><span class="cov0" title="0">{
                return errors.New("Error: Nil frame received.")
        }</span>

        // Process the frame depending on its type.
        <span class="cov0" title="0">switch frame := frame.(type) </span>{
        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:</span>
                // Ignore.

        <span class="cov0" title="0">default:
                return errors.New(fmt.Sprintf("Received unexpected frame of type %T.", frame))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (p *PushStream) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return p.stop
}</span>

func (p *PushStream) Run() error <span class="cov0" title="0">{
        return nil
}</span>

func (p *PushStream) State() *common.StreamState <span class="cov0" title="0">{
        return p.state
}</span>

func (p *PushStream) StreamID() common.StreamID <span class="cov0" title="0">{
        return p.streamID
}</span>

/**************
 * PushStream *
 **************/

func (p *PushStream) Finish() <span class="cov1" title="1">{
        p.writeHeader()
        end := new(frames.DATA)
        end.StreamID = p.streamID
        end.Data = []byte{}
        end.Flags = common.FLAG_FIN
        p.output &lt;- end
        p.Close()
}</span>

/**********
 * Others *
 **********/

func (p *PushStream) closed() bool <span class="cov6" title="2">{
        if p.conn == nil || p.state == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov6" title="2">select </span>{
        <span class="cov0" title="0">case _ = &lt;-p.stop:
                return true</span>
        <span class="cov6" title="2">default:
                return false</span>
        }
}

// writeHeader is used to send HTTP headers to
// the client.
func (p *PushStream) writeHeader() <span class="cov10" title="3">{
        if len(p.header) == 0 || p.closed() </span><span class="cov6" title="2">{
                return
        }</span>

        <span class="cov1" title="1">header := new(frames.HEADERS)
        header.StreamID = p.streamID
        header.Header = common.CloneHeader(p.header)
        for name := range header.Header </span><span class="cov1" title="1">{
                p.header.Del(name)
        }</span>
        <span class="cov1" title="1">p.output &lt;- header</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy2

import (
        "errors"
        "fmt"
        "sync"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// RequestStream is a structure that implements
// the Stream and ResponseWriter interfaces. This
// is used for responding to client requests.
type RequestStream struct {
        sync.Mutex
        Request  *http.Request
        Receiver common.Receiver

        recvMutex    sync.Mutex
        shutdownOnce sync.Once
        conn         *Conn
        streamID     common.StreamID
        state        *common.StreamState
        output       chan&lt;- common.Frame
        header       http.Header
        headerChan   chan func()
        responseCode int
        stop         &lt;-chan bool
        finished     chan struct{}
}

func NewRequestStream(conn *Conn, streamID common.StreamID, output chan&lt;- common.Frame) *RequestStream <span class="cov6" title="3">{
        out := new(RequestStream)
        out.conn = conn
        out.streamID = streamID
        out.output = output
        out.stop = conn.stop
        out.state = new(common.StreamState)
        out.state.CloseHere()
        out.header = make(http.Header)
        out.finished = make(chan struct{})
        out.headerChan = make(chan func(), 5)
        go out.processFrames()
        return out
}</span>

/***********************
 * http.ResponseWriter *
 ***********************/

func (s *RequestStream) Header() http.Header <span class="cov0" title="0">{
        return s.header
}</span>

// Write is one method with which request data is sent.
func (s *RequestStream) Write(inputData []byte) (int, error) <span class="cov0" title="0">{
        if s.closed() || s.state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream already closed.")
        }</span>

        // Copy the data locally to avoid any pointer issues.
        <span class="cov0" title="0">data := make([]byte, len(inputData))
        copy(data, inputData)

        // Send any new headers.
        s.writeHeader()

        // Chunk the response if necessary.
        written := 0
        for len(data) &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                dataFrame := new(frames.DATA)
                dataFrame.StreamID = s.streamID
                dataFrame.Data = data[:common.MAX_DATA_SIZE]
                s.output &lt;- dataFrame

                written += common.MAX_DATA_SIZE
        }</span>

        <span class="cov0" title="0">n := len(data)
        if n == 0 </span><span class="cov0" title="0">{
                return written, nil
        }</span>

        <span class="cov0" title="0">dataFrame := new(frames.DATA)
        dataFrame.StreamID = s.streamID
        dataFrame.Data = data
        s.output &lt;- dataFrame

        return written + n, nil</span>
}

// WriteHeader is used to set the HTTP status code.
func (s *RequestStream) WriteHeader(int) <span class="cov0" title="0">{
        s.writeHeader()
}</span>

/*****************
 * io.Closer *
 *****************/

// Close is used to cancel a mid-air
// request.
func (s *RequestStream) Close() error <span class="cov9" title="6">{
        defer common.Recover()
        s.Lock()
        s.shutdownOnce.Do(s.shutdown)
        s.Unlock()
        return nil
}</span>

func (s *RequestStream) shutdown() <span class="cov6" title="3">{
        s.writeHeader()
        if s.state != nil </span><span class="cov6" title="3">{
                if s.state.OpenThere() </span><span class="cov0" title="0">{
                        // Send the RST_STREAM.
                        rst := new(frames.RST_STREAM)
                        rst.StreamID = s.streamID
                        rst.Status = common.RST_STREAM_CANCEL
                        s.output &lt;- rst
                }</span>
                <span class="cov6" title="3">s.state.Close()</span>
        }
        <span class="cov6" title="3">select </span>{
        <span class="cov0" title="0">case &lt;-s.finished:</span>
        <span class="cov6" title="3">default:
                close(s.finished)</span>
        }
        <span class="cov6" title="3">select </span>{
        <span class="cov0" title="0">case &lt;-s.headerChan:</span>
        <span class="cov6" title="3">default:
                close(s.headerChan)</span>
        }
        <span class="cov6" title="3">s.conn.requestStreamLimit.Close()
        s.output = nil
        s.Request = nil
        s.Receiver = nil
        s.header = nil
        s.stop = nil</span>
}

/**********
 * Stream *
 **********/

func (s *RequestStream) Conn() common.Conn <span class="cov0" title="0">{
        return s.conn
}</span>

func (s *RequestStream) ReceiveFrame(frame common.Frame) error <span class="cov10" title="7">{
        s.recvMutex.Lock()
        defer s.recvMutex.Unlock()

        if frame == nil </span><span class="cov0" title="0">{
                return errors.New("Nil frame received.")
        }</span>

        // Process the frame depending on its type.
        <span class="cov10" title="7">switch frame := frame.(type) </span>{
        <span class="cov7" title="4">case *frames.DATA:

                // Extract the data.
                data := frame.Data
                if data == nil </span><span class="cov0" title="0">{
                        data = []byte{}
                }</span>

                // Give to the client.
                <span class="cov7" title="4">s.headerChan &lt;- func() </span><span class="cov7" title="4">{
                        s.Receiver.ReceiveData(s.Request, data, frame.Flags.FIN())

                        if frame.Flags.FIN() </span><span class="cov6" title="3">{
                                s.state.CloseThere()
                                s.Close()
                        }</span>
                }

        <span class="cov6" title="3">case *frames.SYN_REPLY:
                s.headerChan &lt;- func() </span><span class="cov6" title="3">{
                        s.Receiver.ReceiveHeader(s.Request, frame.Header)

                        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                                s.state.CloseThere()
                                s.Close()
                        }</span>
                }

        <span class="cov0" title="0">case *frames.HEADERS:
                s.headerChan &lt;- func() </span><span class="cov0" title="0">{
                        s.Receiver.ReceiveHeader(s.Request, frame.Header)

                        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                                s.state.CloseThere()
                                s.Close()
                        }</span>
                }

        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:</span>
                // Ignore.

        <span class="cov0" title="0">default:
                return errors.New(fmt.Sprintf("Received unknown frame of type %T.", frame))</span>
        }

        <span class="cov10" title="7">return nil</span>
}

func (s *RequestStream) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return s.stop
}</span>

// run is the main control path of
// the stream. Data is recieved,
// processed, and then the stream
// is cleaned up and closed.
func (s *RequestStream) Run() error <span class="cov6" title="3">{
        // Receive and process inbound frames.
        &lt;-s.finished

        // Clean up state.
        s.state.CloseHere()
        return nil
}</span>

func (s *RequestStream) State() *common.StreamState <span class="cov10" title="7">{
        return s.state
}</span>

func (s *RequestStream) StreamID() common.StreamID <span class="cov0" title="0">{
        return s.streamID
}</span>

func (s *RequestStream) closed() bool <span class="cov0" title="0">{
        if s.conn == nil || s.state == nil || s.Receiver == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">select </span>{
        <span class="cov0" title="0">case _ = &lt;-s.stop:
                return true</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}

// writeHeader is used to flush HTTP headers.
func (s *RequestStream) writeHeader() <span class="cov6" title="3">{
        if len(s.header) == 0 </span><span class="cov6" title="3">{
                return
        }</span>

        // Create the HEADERS frame.
        <span class="cov0" title="0">header := new(frames.HEADERS)
        header.StreamID = s.streamID
        header.Header = common.CloneHeader(s.header)

        // Clear the headers that have been sent.
        for name := range header.Header </span><span class="cov0" title="0">{
                s.header.Del(name)
        }</span>

        <span class="cov0" title="0">s.output &lt;- header</span>
}

func (s *RequestStream) processFrames() <span class="cov6" title="3">{
        defer common.Recover()
        for f := range s.headerChan </span><span class="cov10" title="7">{
                f()
        }</span>
}
</pre>
		
		<pre class="file" id="file195" style="display: none">package spdy2

import (
        "errors"
        "fmt"
        "io"
        "strings"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// Request is used to make a client request.
func (c *Conn) Request(request *http.Request, receiver common.Receiver, priority common.Priority) (common.Stream, error) <span class="cov10" title="3">{
        if c.Closed() </span><span class="cov0" title="0">{
                return nil, common.ErrConnClosed
        }</span>
        <span class="cov10" title="3">c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway </span><span class="cov0" title="0">{
                return nil, common.ErrGoaway
        }</span>

        <span class="cov10" title="3">if c.server != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Only clients can send requests.")
        }</span>

        // Check stream limit would allow the new stream.
        <span class="cov10" title="3">if !c.requestStreamLimit.Add() </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Max concurrent streams limit exceeded.")
        }</span>

        <span class="cov10" title="3">if !priority.Valid(2) </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Priority must be in the range 0 - 7.")
        }</span>

        <span class="cov10" title="3">url := request.URL
        if url == nil || url.Scheme == "" || url.Host == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Incomplete path provided to resource.")
        }</span>

        // Prepare the SYN_STREAM.
        <span class="cov10" title="3">path := url.Path
        if url.RawQuery != "" </span><span class="cov0" title="0">{
                path += "?" + url.RawQuery
        }</span>
        <span class="cov10" title="3">if url.Fragment != "" </span><span class="cov0" title="0">{
                path += "#" + url.Fragment
        }</span>
        <span class="cov10" title="3">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>

        <span class="cov10" title="3">host := url.Host
        if request.Host != "" </span><span class="cov10" title="3">{
                host = request.Host
        }</span>

        <span class="cov10" title="3">syn := new(frames.SYN_STREAM)
        syn.Priority = priority
        syn.Header = request.Header
        syn.Header.Set("method", request.Method)
        syn.Header.Set("url", path)
        syn.Header.Set("version", "HTTP/1.1")
        syn.Header.Set("host", host)
        syn.Header.Set("scheme", url.Scheme)

        // Prepare the request body, if any.
        body := make([]*frames.DATA, 0, 1)
        if request.Body != nil </span><span class="cov1" title="1">{
                buf := make([]byte, 32*1024)
                n, err := request.Body.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">total := n
                for n &gt; 0 </span><span class="cov1" title="1">{
                        data := new(frames.DATA)
                        data.Data = make([]byte, n)
                        copy(data.Data, buf[:n])
                        body = append(body, data)
                        n, err = request.Body.Read(buf)
                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov1" title="1">total += n</span>
                }

                // Half-close the stream.
                <span class="cov1" title="1">if len(body) == 0 </span><span class="cov0" title="0">{
                        syn.Flags = common.FLAG_FIN
                }</span> <span class="cov1" title="1">else {
                        syn.Header.Set("Content-Length", fmt.Sprint(total))
                        body[len(body)-1].Flags = common.FLAG_FIN
                }</span>
                <span class="cov1" title="1">request.Body.Close()</span>
        } <span class="cov6" title="2">else {
                syn.Flags = common.FLAG_FIN
        }</span>

        // Send.
        <span class="cov10" title="3">c.streamCreation.Lock()
        defer c.streamCreation.Unlock()

        c.lastRequestStreamIDLock.Lock()
        if c.lastRequestStreamID == 0 </span><span class="cov6" title="2">{
                c.lastRequestStreamID = 1
        }</span> <span class="cov1" title="1">else {
                c.lastRequestStreamID += 2
        }</span>
        <span class="cov10" title="3">syn.StreamID = c.lastRequestStreamID
        c.lastRequestStreamIDLock.Unlock()
        if syn.StreamID &gt; common.MAX_STREAM_ID </span><span class="cov0" title="0">{
                return nil, errors.New("Error: All client streams exhausted.")
        }</span>
        <span class="cov10" title="3">c.output[0] &lt;- syn
        for _, frame := range body </span><span class="cov1" title="1">{
                frame.StreamID = syn.StreamID
                c.output[0] &lt;- frame
        }</span>

        // // Create the request stream.
        <span class="cov10" title="3">out := NewRequestStream(c, syn.StreamID, c.output[0])
        out.Request = request
        out.Receiver = receiver

        // Store in the connection map.
        c.streamsLock.Lock()
        c.streams[syn.StreamID] = out
        c.streamsLock.Unlock()

        return out, nil</span>
}

func (c *Conn) RequestResponse(request *http.Request, receiver common.Receiver, priority common.Priority) (*http.Response, error) <span class="cov10" title="3">{
        res := common.NewResponse(request, receiver)

        // Send the request.
        stream, err := c.Request(request, res, priority)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Let the request run its course.
        <span class="cov10" title="3">stream.Run()

        return res.Response(), c.shutdownError</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy2

import (
        "bytes"
        "errors"
        "fmt"
        "strconv"
        "sync"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// ResponseStream is a structure that implements the
// Stream interface. This is used for responding to
// client requests.
type ResponseStream struct {
        sync.Mutex

        shutdownOnce   sync.Once
        conn           *Conn
        streamID       common.StreamID
        requestBody    *bytes.Buffer
        state          *common.StreamState
        output         chan&lt;- common.Frame
        request        *http.Request
        handler        http.ServerHandler
        header         http.Header
        priority       common.Priority
        unidirectional bool
        responseCode   int
        ready          chan struct{}
        stop           chan bool
        wroteHeader    bool
}

func NewResponseStream(conn *Conn, frame *frames.SYN_STREAM, output chan&lt;- common.Frame, handler http.ServerHandler, request *http.Request) *ResponseStream <span class="cov5" title="3">{
        out := new(ResponseStream)
        out.conn = conn
        out.streamID = frame.StreamID
        out.output = output
        out.handler = handler
        if out.handler == nil </span><span class="cov0" title="0">{
                //out.handler = http.DefaultServeMux
        }</span>
        <span class="cov5" title="3">out.request = request
        out.priority = frame.Priority
        out.stop = conn.stop
        out.unidirectional = frame.Flags.UNIDIRECTIONAL()
        out.requestBody = new(bytes.Buffer)
        out.state = new(common.StreamState)
        out.header = make(http.Header)
        out.responseCode = 0
        out.ready = make(chan struct{})
        out.wroteHeader = false
        if frame.Flags.FIN() </span><span class="cov3" title="2">{
                close(out.ready)
                out.state.CloseThere()
        }</span>
        <span class="cov5" title="3">out.request.Body = &amp;common.ReadCloser{out.requestBody}
        return out</span>
}

/***********************
 * http.ResponseWriter *
 ***********************/

func (s *ResponseStream) Header() http.Header <span class="cov5" title="3">{
        return s.header
}</span>

// Write is the main method with which data is sent.
func (s *ResponseStream) Write(inputData []byte) (int, error) <span class="cov1" title="1">{
        if s.unidirectional </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream is unidirectional.")
        }</span>

        <span class="cov1" title="1">if s.closed() || s.state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream already closed.")
        }</span>

        // Copy the data locally to avoid any pointer issues.
        <span class="cov1" title="1">data := make([]byte, len(inputData))
        copy(data, inputData)

        // Default to 200 response.
        if !s.wroteHeader </span><span class="cov0" title="0">{
                s.WriteHeader(http.StatusOK)
        }</span>

        // Send any new headers.
        <span class="cov1" title="1">s.writeHeader()

        // Chunk the response if necessary.
        written := 0
        for len(data) &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                dataFrame := new(frames.DATA)
                dataFrame.StreamID = s.streamID
                dataFrame.Data = data[:common.MAX_DATA_SIZE]
                s.output &lt;- dataFrame

                written += common.MAX_DATA_SIZE
        }</span>

        <span class="cov1" title="1">n := len(data)
        if n == 0 </span><span class="cov0" title="0">{
                return written, nil
        }</span>

        <span class="cov1" title="1">dataFrame := new(frames.DATA)
        dataFrame.StreamID = s.streamID
        dataFrame.Data = data
        s.output &lt;- dataFrame

        return written + n, nil</span>
}

// WriteHeader is used to set the HTTP status code.
func (s *ResponseStream) WriteHeader(code int) <span class="cov5" title="3">{
        if s.unidirectional </span><span class="cov0" title="0">{
                log.Println("Error: Stream is unidirectional.")
                return
        }</span>

        <span class="cov5" title="3">if s.wroteHeader </span><span class="cov0" title="0">{
                log.Println("Error: Multiple calls to ResponseWriter.WriteHeader.")
                return
        }</span>

        <span class="cov5" title="3">s.wroteHeader = true
        s.responseCode = code
        s.header.Set("status", strconv.Itoa(code))
        s.header.Set("version", "HTTP/1.1")

        // Create the response SYN_REPLY.
        synReply := new(frames.SYN_REPLY)
        synReply.StreamID = s.streamID
        synReply.Header = common.CloneHeader(s.header)

        // Clear the headers that have been sent.
        for name := range synReply.Header </span><span class="cov10" title="9">{
                s.header.Del(name)
        }</span>

        // These responses have no body, so close the stream now.
        <span class="cov5" title="3">if code == 204 || code == 304 || code/100 == 1 </span><span class="cov0" title="0">{
                synReply.Flags = common.FLAG_FIN
                s.state.CloseHere()
        }</span>

        <span class="cov5" title="3">s.output &lt;- synReply</span>
}

/*****************
 * io.Closer *
 *****************/

func (s *ResponseStream) Close() error <span class="cov8" title="6">{
        defer common.Recover()
        s.Lock()
        s.shutdownOnce.Do(s.shutdown)
        s.Unlock()
        return nil
}</span>

func (s *ResponseStream) shutdown() <span class="cov5" title="3">{
        s.writeHeader()
        if s.state != nil </span><span class="cov5" title="3">{
                s.state.Close()
        }</span>
        <span class="cov5" title="3">if s.requestBody != nil </span><span class="cov5" title="3">{
                s.requestBody.Reset()
                s.requestBody = nil
        }</span>
        <span class="cov5" title="3">s.conn.requestStreamLimit.Close()
        s.output = nil
        s.request = nil
        s.handler = nil
        s.header = nil
        s.stop = nil</span>
}

/**********
 * Stream *
 **********/

func (s *ResponseStream) Conn() common.Conn <span class="cov0" title="0">{
        return s.conn
}</span>

func (s *ResponseStream) ReceiveFrame(frame common.Frame) error <span class="cov1" title="1">{
        s.Lock()
        defer s.Unlock()

        if frame == nil </span><span class="cov0" title="0">{
                return errors.New("Error: Nil frame received.")
        }</span>

        // Process the frame depending on its type.
        <span class="cov1" title="1">switch frame := frame.(type) </span>{
        <span class="cov1" title="1">case *frames.DATA:
                s.requestBody.Write(frame.Data)
                if frame.Flags.FIN() </span><span class="cov1" title="1">{
                        select </span>{
                        <span class="cov0" title="0">case &lt;-s.ready:</span>
                        <span class="cov1" title="1">default:
                                close(s.ready)</span>
                        }
                        <span class="cov1" title="1">s.state.CloseThere()</span>
                }

        <span class="cov0" title="0">case *frames.SYN_REPLY:
                common.UpdateHeader(s.header, frame.Header)
                if frame.Flags.FIN() </span><span class="cov0" title="0">{
                        select </span>{
                        <span class="cov0" title="0">case &lt;-s.ready:</span>
                        <span class="cov0" title="0">default:
                                close(s.ready)</span>
                        }
                        <span class="cov0" title="0">s.state.CloseThere()</span>
                }

        <span class="cov0" title="0">case *frames.HEADERS:
                common.UpdateHeader(s.header, frame.Header)</span>

        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:</span>
                // Ignore.

        <span class="cov0" title="0">default:
                return errors.New(fmt.Sprintf("Received unknown frame of type %T.", frame))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (s *ResponseStream) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return s.stop
}</span>

// run is the main control path of
// the stream. It is prepared, the
// registered handler is called,
// and then the stream is cleaned
// up and closed.
func (s *ResponseStream) Run() error <span class="cov5" title="3">{
        // Catch any panics.
        defer func() </span><span class="cov5" title="3">{
                if v := recover(); v != nil </span><span class="cov0" title="0">{
                        if s != nil &amp;&amp; s.state != nil &amp;&amp; !s.state.Closed() </span><span class="cov0" title="0">{
                                log.Printf("Encountered stream error: %v (%[1]T)\n", v)
                        }</span>
                }
        }()

        // Make sure Request is prepared.
        <span class="cov5" title="3">if s.requestBody == nil || s.request.Body == nil </span><span class="cov0" title="0">{
                s.requestBody = new(bytes.Buffer)
                s.request.Body = &amp;common.ReadCloser{s.requestBody}
        }</span>

        // Wait until the full request has been received.
        <span class="cov5" title="3">&lt;-s.ready

        /***************
         *** HANDLER ***
         ***************/
        s.handler.ServeHTTP(s, s.request)

        // Close the stream with a SYN_REPLY if
        // none has been sent, or an empty DATA
        // frame, if a SYN_REPLY has been sent
        // already.
        // If the stream is already closed at
        // this end, then nothing happens.
        if !s.unidirectional </span><span class="cov5" title="3">{
                if s.state.OpenHere() &amp;&amp; !s.wroteHeader </span><span class="cov0" title="0">{
                        s.header.Set("status", "200")
                        s.header.Set("version", "HTTP/1.1")

                        // Create the response SYN_REPLY.
                        synReply := new(frames.SYN_REPLY)
                        synReply.Flags = common.FLAG_FIN
                        synReply.StreamID = s.streamID
                        synReply.Header = s.header

                        s.output &lt;- synReply
                }</span> <span class="cov5" title="3">else if s.state.OpenHere() </span><span class="cov5" title="3">{
                        // Create the DATA.
                        data := new(frames.DATA)
                        data.StreamID = s.streamID
                        data.Flags = common.FLAG_FIN
                        data.Data = []byte{}

                        s.output &lt;- data
                }</span>
        }

        // Clean up state.
        <span class="cov5" title="3">s.state.CloseHere()

        if s.state.Closed() </span><span class="cov5" title="3">{
                return s.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ResponseStream) State() *common.StreamState <span class="cov3" title="2">{
        return s.state
}</span>

func (s *ResponseStream) StreamID() common.StreamID <span class="cov1" title="1">{
        return s.streamID
}</span>

func (s *ResponseStream) closed() bool <span class="cov1" title="1">{
        if s.conn == nil || s.state == nil || s.handler == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov1" title="1">select </span>{
        <span class="cov0" title="0">case _ = &lt;-s.stop:
                return true</span>
        <span class="cov1" title="1">default:
                return false</span>
        }
}

// writeHeader is used to flush HTTP headers.
func (s *ResponseStream) writeHeader() <span class="cov6" title="4">{
        if len(s.header) == 0 || s.unidirectional </span><span class="cov6" title="4">{
                return
        }</span>

        // Create the HEADERS frame.
        <span class="cov0" title="0">header := new(frames.HEADERS)
        header.StreamID = s.streamID
        header.Header = common.CloneHeader(s.header)

        // Clear the headers that have been sent.
        for name := range header.Header </span><span class="cov0" title="0">{
                s.header.Del(name)
        }</span>

        <span class="cov0" title="0">s.output &lt;- header</span>
}

/******************
 * PriorityStream *
 ******************/

func (s *ResponseStream) Priority() common.Priority <span class="cov0" title="0">{
        return s.priority
}</span>
</pre>
		
		<pre class="file" id="file197" style="display: none">package spdy2

import (
        "time"

        "bfe_spdy/spdy2/frames"
)

// Close ends the connection, cleaning up relevant resources.
// Close can be called multiple times safely.
func (c *Conn) Close() (err error) <span class="cov7" title="16">{
        c.shutdownOnce.Do(c.shutdown)
        return nil
}</span>

// Closed indicates whether the connection has
// been closed.
func (c *Conn) Closed() bool <span class="cov10" title="55">{
        select </span>{
        <span class="cov5" title="6">case _ = &lt;-c.stop:
                return true</span>
        <span class="cov9" title="49">default:
                return false</span>
        }
}

func (c *Conn) shutdown() <span class="cov5" title="6">{
        if c.Closed() </span><span class="cov0" title="0">{
                return
        }</span>

        // Try to inform the other endpoint that the connection is closing.
        <span class="cov5" title="6">c.sendingLock.Lock()
        isSending := c.sending != nil
        c.sendingLock.Unlock()
        c.goawayLock.Lock()
        sent := c.goawaySent
        c.goawayReceived = true
        c.goawayLock.Unlock()
        if !sent &amp;&amp; !isSending </span><span class="cov5" title="6">{
                goaway := new(frames.GOAWAY)
                if c.server != nil </span><span class="cov3" title="3">{
                        c.lastRequestStreamIDLock.Lock()
                        goaway.LastGoodStreamID = c.lastRequestStreamID
                        c.lastRequestStreamIDLock.Unlock()
                }</span> <span class="cov3" title="3">else {
                        c.lastPushStreamIDLock.Lock()
                        goaway.LastGoodStreamID = c.lastPushStreamID
                        c.lastPushStreamIDLock.Unlock()
                }</span>
                <span class="cov5" title="6">select </span>{
                <span class="cov5" title="6">case c.output[0] &lt;- goaway:
                        c.goawayLock.Lock()
                        c.goawaySent = true
                        c.goawayLock.Unlock()</span>
                <span class="cov0" title="0">case &lt;-time.After(100 * time.Millisecond):
                        debug.Println("Failed to send closing GOAWAY.")</span>
                }
        }

        <span class="cov5" title="6">c.streamsLock.Lock()
        for _, stream := range c.streams </span><span class="cov5" title="7">{
                if err := stream.Close(); err != nil </span><span class="cov0" title="0">{
                        debug.Println(err)
                }</span>
        }
        <span class="cov5" title="6">c.streams = nil
        c.streamsLock.Unlock()

        // Give any pending frames 200ms to send.
        c.sendingLock.Lock()
        if c.sending == nil </span><span class="cov5" title="6">{
                c.sending = make(chan struct{})
                c.sendingLock.Unlock()
                select </span>{
                <span class="cov2" title="2">case &lt;-c.sending:</span>
                <span class="cov4" title="4">case &lt;-time.After(200 * time.Millisecond):</span>
                }
                <span class="cov5" title="6">c.sendingLock.Lock()</span>
        }
        <span class="cov5" title="6">c.sending = nil
        c.sendingLock.Unlock()

        select </span>{
        <span class="cov0" title="0">case _, ok := &lt;-c.stop:
                if ok </span><span class="cov0" title="0">{
                        close(c.stop)
                }</span>
        <span class="cov5" title="6">default:
                close(c.stop)</span>
        }

        <span class="cov5" title="6">c.connLock.Lock()
        if c.conn != nil </span><span class="cov5" title="6">{
                c.conn.Close()
                c.conn = nil
        }</span>
        <span class="cov5" title="6">c.connLock.Unlock()

        if c.compressor != nil </span><span class="cov5" title="6">{
                c.compressor.Close()
                c.compressor = nil
        }</span>
        <span class="cov5" title="6">c.decompressor = nil

        c.pushedResources = nil

        for _, stream := range c.output </span><span class="cov9" title="48">{
                select </span>{
                <span class="cov0" title="0">case _, ok := &lt;-stream:
                        if ok </span><span class="cov0" title="0">{
                                close(stream)
                        }</span>
                <span class="cov9" title="48">default:
                        close(stream)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file198" style="display: none">package spdy2

import (
        "errors"
        "net/url"
        "strings"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy2/frames"
)

// Ping is used by spdy.PingServer and spdy.PingClient to send
// SPDY PINGs.
func (c *Conn) Ping() (&lt;-chan bool, error) <span class="cov10" title="2">{
        if c.Closed() </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Conn has been closed.")
        }</span>

        <span class="cov10" title="2">ping := new(frames.PING)
        c.nextPingIDLock.Lock()
        pid := c.nextPingID
        if pid+2 &lt; pid </span><span class="cov0" title="0">{
                if pid&amp;1 == 0 </span><span class="cov0" title="0">{
                        c.nextPingID = 2
                }</span> <span class="cov0" title="0">else {
                        c.nextPingID = 1
                }</span>
        } <span class="cov10" title="2">else {
                c.nextPingID += 2
        }</span>
        <span class="cov10" title="2">c.nextPingIDLock.Unlock()
        ping.PingID = pid
        c.output[0] &lt;- ping
        ch := make(chan bool, 1)
        c.pingsLock.Lock()
        c.pings[pid] = ch
        c.pingsLock.Unlock()

        return ch, nil</span>
}

// Push is used to issue a server push to the client. Note that this cannot be performed
// by clients.
func (c *Conn) Push(resource string, origin common.Stream) (common.PushStream, error) <span class="cov1" title="1">{
        c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway </span><span class="cov0" title="0">{
                return nil, common.ErrGoaway
        }</span>

        <span class="cov1" title="1">if c.server == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Only servers can send pushes.")
        }</span>

        // Parse and check URL.
        <span class="cov1" title="1">url, err := url.Parse(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if url.Scheme == "" || url.Host == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Incomplete path provided to resource.")
        }</span>
        <span class="cov1" title="1">resource = url.String()

        // Ensure the resource hasn't been pushed on the given stream already.
        if c.pushedResources[origin] == nil </span><span class="cov1" title="1">{
                c.pushedResources[origin] = map[string]struct{}{
                        resource: struct{}{},
                }
        }</span> <span class="cov0" title="0">else if _, ok := c.pushedResources[origin][url.String()]; !ok </span><span class="cov0" title="0">{
                c.pushedResources[origin][resource] = struct{}{}
        }</span> <span class="cov0" title="0">else {
                return nil, errors.New("Error: Resource already pushed to this stream.")
        }</span>

        // Check stream limit would allow the new stream.
        <span class="cov1" title="1">if !c.pushStreamLimit.Add() </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Max concurrent streams limit exceeded.")
        }</span>

        // Verify that path is prefixed with / as required by spec.
        <span class="cov1" title="1">path := url.Path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>

        // Prepare the SYN_STREAM.
        <span class="cov1" title="1">push := new(frames.SYN_STREAM)
        push.Flags = common.FLAG_UNIDIRECTIONAL
        push.AssocStreamID = origin.StreamID()
        push.Priority = 3
        push.Header = make(http.Header)
        push.Header.Set("scheme", url.Scheme)
        push.Header.Set("host", url.Host)
        push.Header.Set("url", path)
        push.Header.Set("version", "HTTP/1.1")

        // Send.
        c.streamCreation.Lock()
        defer c.streamCreation.Unlock()

        c.lastPushStreamIDLock.Lock()
        c.lastPushStreamID += 2
        newID := c.lastPushStreamID
        c.lastPushStreamIDLock.Unlock()
        if newID &gt; common.MAX_STREAM_ID </span><span class="cov0" title="0">{
                return nil, errors.New("Error: All server streams exhausted.")
        }</span>
        <span class="cov1" title="1">push.StreamID = newID
        c.output[0] &lt;- push

        // Create the PushStream.
        out := NewPushStream(c, newID, origin, c.output[3])

        // Store in the connection map.
        c.streamsLock.Lock()
        c.streams[newID] = out
        c.streamsLock.Unlock()

        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file199" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy2

import (
        "bfe_spdy/common"
)

// defaultServerSettings are used in initialising the connection.
// It takes the max concurrent streams.
func defaultServerSettings(m uint32) common.Settings <span class="cov10" title="3">{
        return common.Settings{
                common.SETTINGS_MAX_CONCURRENT_STREAMS: &amp;common.Setting{
                        Flags: common.FLAG_SETTINGS_PERSIST_VALUE,
                        ID:    common.SETTINGS_MAX_CONCURRENT_STREAMS,
                        Value: m,
                },
        }
}</span>

// defaultClientSettings are used in initialising the connection.
// It takes the max concurrent streams.
func defaultClientSettings(m uint32) common.Settings <span class="cov10" title="3">{
        return common.Settings{
                common.SETTINGS_MAX_CONCURRENT_STREAMS: &amp;common.Setting{
                        ID:    common.SETTINGS_MAX_CONCURRENT_STREAMS,
                        Value: m,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file200" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy3

import (
        "bufio"
        "crypto/x509"
        "net"
        "net/url"
        "sync"
        "time"
)

import (
        http "bfe_http"
        tls "bfe_tls"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// Conn is a spdy.Conn implementing SPDY/3. This is used in both
// servers and clients, and is created with either NewServerConn,
// or NewClientConn.
type Conn struct {
        PushReceiver common.Receiver // Receiver to call for server Pushes.
        Subversion   int             // SPDY 3 subversion (eg 0 for SPDY/3, 1 for SPDY/3.1).

        // SPDY/3.1
        connectionWindowLock      sync.Mutex
        dataBuffer                []*frames.DATA // used to store frames witheld for flow control.
        connectionWindowSize      int64
        initialWindowSizeThere    uint32
        connectionWindowSizeThere int64

        // network state
        remoteAddr  string
        server      http.ServerHandler                // nil if client connection.
        conn        net.Conn                          // underlying network (TLS) connection.
        connLock    sync.Mutex                        // protects the interface value of the above conn.
        buf         *bufio.Reader                     // buffered reader on conn.
        tlsState    *tls.ConnectionState              // underlying TLS connection state.
        streams     map[common.StreamID]common.Stream // map of active streams.
        streamsLock sync.Mutex                        // protects streams.
        output      [8]chan common.Frame              // one output channel per priority level.

        // other state
        compressor       common.Compressor              // outbound compression state.
        decompressor     common.Decompressor            // inbound decompression state.
        receivedSettings common.Settings                // settings sent by client.
        goawayReceived   bool                           // goaway has been received.
        goawaySent       bool                           // goaway has been sent.
        goawayLock       sync.Mutex                     // protects goawaySent and goawayReceived.
        numBenignErrors  int                            // number of non-serious errors encountered.
        readTimeout      time.Duration                  // optional timeout for network reads.
        writeTimeout     time.Duration                  // optional timeout for network writes.
        timeoutLock      sync.Mutex                     // protects changes to readTimeout and writeTimeout.
        vectorIndex      uint16                         // current limit on the credential vector size.
        certificates     map[uint16][]*x509.Certificate // certificates from CREDENTIALs and TLS handshake.
        flowControl      common.FlowControl             // flow control module.
        flowControlLock  sync.Mutex                     // protects flowControl.

        // SPDY features
        pings                map[uint32]chan&lt;- bool                // response channel for pings.
        pingsLock            sync.Mutex                            // protects pings.
        nextPingID           uint32                                // next outbound ping ID.
        nextPingIDLock       sync.Mutex                            // protects nextPingID.
        pushStreamLimit      *common.StreamLimit                   // Limit on streams started by the server.
        pushRequests         map[common.StreamID]*http.Request     // map of requests sent in server pushes.
        lastPushStreamID     common.StreamID                       // last push stream ID. (even)
        lastPushStreamIDLock sync.Mutex                            // protects lastPushStreamID.
        pushedResources      map[common.Stream]map[string]struct{} // prevents duplicate headers being pushed.

        // requests
        lastRequestStreamID     common.StreamID     // last request stream ID. (odd)
        lastRequestStreamIDLock sync.Mutex          // protects lastRequestStreamID.
        streamCreation          sync.Mutex          // ensures new streams are sent in order.
        oddity                  common.StreamID     // whether locally-sent streams are odd or even.
        initialWindowSize       uint32              // initial transport window.
        initialWindowSizeLock   sync.Mutex          // lock for initialWindowSize
        requestStreamLimit      *common.StreamLimit // Limit on streams started by the client.

        // startup and shutdown
        stop          chan bool     // this channel is closed when the connection closes.
        sending       chan struct{} // this channel is used to ensure pending frames are sent.
        sendingLock   sync.Mutex    // protects changes to sending's value.
        init          func()        // this function is called before the connection begins.
        shutdownOnce  sync.Once     // used to ensure clean shutdown.
        shutdownError error         // error that caused shutdown if non-nil
}

// NewConn produces an initialised spdy3 connection.
func NewConn(conn net.Conn, server http.ServerHandler, subversion int) *Conn <span class="cov10" title="16">{
        out := new(Conn)

        // Common ground.
        out.remoteAddr = conn.RemoteAddr().String()
        out.server = server
        out.conn = conn
        out.buf = bufio.NewReader(conn)
        if tlsConn, ok := conn.(*tls.Conn); ok </span><span class="cov0" title="0">{
                out.tlsState = new(tls.ConnectionState)
                *out.tlsState = tlsConn.ConnectionState()
        }</span>
        <span class="cov10" title="16">out.streams = make(map[common.StreamID]common.Stream)
        out.output[0] = make(chan common.Frame)
        out.output[1] = make(chan common.Frame)
        out.output[2] = make(chan common.Frame)
        out.output[3] = make(chan common.Frame)
        out.output[4] = make(chan common.Frame)
        out.output[5] = make(chan common.Frame)
        out.output[6] = make(chan common.Frame)
        out.output[7] = make(chan common.Frame)
        out.pings = make(map[uint32]chan&lt;- bool)
        out.compressor = common.NewCompressor(3)
        out.decompressor = common.NewDecompressor(3)
        out.receivedSettings = make(common.Settings)
        out.lastPushStreamID = 0
        out.lastRequestStreamID = 0
        out.stop = make(chan bool)
        out.Subversion = subversion

        // Server/client specific.
        if server != nil </span><span class="cov7" title="8">{ // servers
                out.nextPingID = 2
                out.oddity = 0
                out.initialWindowSize = common.DEFAULT_INITIAL_WINDOW_SIZE
                out.requestStreamLimit = common.NewStreamLimit(common.DEFAULT_STREAM_LIMIT)
                out.pushStreamLimit = common.NewStreamLimit(common.NO_STREAM_LIMIT)
                out.vectorIndex = 8
                out.init = func() </span><span class="cov7" title="8">{
                        // Initialise the connection by sending the connection settings.
                        settings := new(frames.SETTINGS)
                        settings.Settings = defaultServerSettings(common.DEFAULT_STREAM_LIMIT)
                        out.output[0] &lt;- settings
                }</span>
                <span class="cov7" title="8">if d := server.GetReadTimeout(); d != 0 </span><span class="cov7" title="8">{
                        out.SetReadTimeout(d)
                }</span>
                <span class="cov7" title="8">if d := server.GetWriteTimeout(); d != 0 </span><span class="cov7" title="8">{
                        out.SetWriteTimeout(d)
                }</span>
                <span class="cov7" title="8">out.flowControl = DefaultFlowControl(common.DEFAULT_INITIAL_WINDOW_SIZE)
                out.pushedResources = make(map[common.Stream]map[string]struct{})

                if subversion == 0 </span><span class="cov5" title="4">{
                        out.certificates = make(map[uint16][]*x509.Certificate, 8)
                        if out.tlsState != nil &amp;&amp; out.tlsState.PeerCertificates != nil </span><span class="cov0" title="0">{
                                out.certificates[1] = out.tlsState.PeerCertificates
                        }</span>
                } <span class="cov5" title="4">else if subversion == 1 </span><span class="cov5" title="4">{
                        out.connectionWindowSize = common.DEFAULT_INITIAL_WINDOW_SIZE
                }</span>

        } <span class="cov7" title="8">else { // clients
                out.nextPingID = 1
                out.oddity = 1
                out.initialWindowSize = common.DEFAULT_INITIAL_CLIENT_WINDOW_SIZE
                out.requestStreamLimit = common.NewStreamLimit(common.NO_STREAM_LIMIT)
                out.pushStreamLimit = common.NewStreamLimit(common.DEFAULT_STREAM_LIMIT)
                out.pushRequests = make(map[common.StreamID]*http.Request)
                out.init = func() </span><span class="cov7" title="8">{
                        // Initialise the connection by sending the connection settings.
                        settings := new(frames.SETTINGS)
                        settings.Settings = defaultClientSettings(common.DEFAULT_STREAM_LIMIT)
                        out.output[0] &lt;- settings
                }</span>
                <span class="cov7" title="8">out.flowControl = DefaultFlowControl(common.DEFAULT_INITIAL_CLIENT_WINDOW_SIZE)

                if subversion == 1 </span><span class="cov5" title="4">{
                        out.connectionWindowSize = common.DEFAULT_INITIAL_CLIENT_WINDOW_SIZE
                }</span>
        }

        <span class="cov10" title="16">if subversion == 1 </span><span class="cov7" title="8">{
                out.initialWindowSizeThere = out.flowControl.InitialWindowSize()
                out.connectionWindowSizeThere = int64(out.initialWindowSizeThere)
        }</span>
        <span class="cov10" title="16">return out</span>
}

// NextProto is intended for use in http.Server.TLSNextProto,
// using SPDY/3 for the connection.
func NextProto(s http.ServerHandler, tlsConn *tls.Conn) <span class="cov0" title="0">{
        NewConn(tlsConn, s, 0).Run()
}</span>

// NextProto1 is intended for use in http.Server.TLSNextProto,
// using SPDY/3.1 for the connection.
func NextProto1(s http.ServerHandler, tlsConn *tls.Conn) <span class="cov0" title="0">{
        NewConn(tlsConn, s, 1).Run()
}</span>

func (c *Conn) Run() error <span class="cov10" title="16">{
        defer common.Recover()
        go c.send()        // Start the send loop.
        if c.init != nil </span><span class="cov10" title="16">{ // Must be after sending is enabled.
                c.init() // Prepare any initialisation frames.
        }</span>
        <span class="cov10" title="16">go c.readFrames() // Start the main loop.
        &lt;-c.stop          // Run until the connection ends.
        return nil</span>
}

// newStream is used to create a new serverStream from a SYN_STREAM frame.
func (c *Conn) newStream(frame *frames.SYN_STREAM) *ResponseStream <span class="cov6" title="6">{
        header := frame.Header
        rawUrl := header.Get(":scheme") + "://" + header.Get(":host") + header.Get(":path")

        url, err := url.Parse(rawUrl)
        if c.check(err != nil, "Received SYN_STREAM with invalid request URL (%v)", err) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="6">vers := header.Get(":version")
        major, minor, ok := http.ParseHTTPVersion(vers)
        if c.check(!ok, "Invalid HTTP version: "+vers) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="6">method := header.Get(":method")

        // Build this into a request to present to the Handler.
        request := &amp;http.Request{
                Method:     method,
                URL:        url,
                Proto:      vers,
                ProtoMajor: major,
                ProtoMinor: minor,
                RemoteAddr: c.remoteAddr,
                Header:     header,
                Host:       url.Host,
                RequestURI: url.RequestURI(),
                TLS:        c.tlsState,
        }

        output := c.output[frame.Priority]
        c.streamCreation.Lock()
        out := NewResponseStream(c, frame, output, c.server, request)
        c.streamCreation.Unlock()
        c.flowControlLock.Lock()
        f := c.flowControl
        c.flowControlLock.Unlock()
        out.AddFlowControl(f)

        return out</span>
}
</pre>
		
		<pre class="file" id="file201" style="display: none">package spdy3

import (
        "io"
        "net"
        "time"
)

import (
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// check returns the error condition and
// updates the connection accordingly.
func (c *Conn) check(condition bool, format string, v ...interface{}) bool <span class="cov8" title="68">{
        if !condition </span><span class="cov8" title="68">{
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Error: "+format+".\n", v...)
        c.numBenignErrors++
        return true</span>
}

// criticalCheck returns the error condition
// and ends the connection accordingly.
func (c *Conn) criticalCheck(condition bool, sid common.StreamID, format string, v ...interface{}) bool <span class="cov10" title="186">{
        if !condition </span><span class="cov10" title="186">{
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("Error: "+format+".\n", v...)
        c.protocolError(sid)
        return true</span>
}

func (c *Conn) _RST_STREAM(streamID common.StreamID, status common.StatusCode) <span class="cov0" title="0">{
        rst := new(frames.RST_STREAM)
        rst.StreamID = streamID
        rst.Status = status
        c.output[0] &lt;- rst
}</span>

func (c *Conn) _GOAWAY(status common.StatusCode) <span class="cov2" title="2">{
        goaway := new(frames.GOAWAY)
        goaway.Status = status
        c.output[0] &lt;- goaway
        c.Close()
}</span>

// handleReadWriteError differentiates between normal and
// unexpected errors when performing I/O with the network,
// then shuts down the connection.
func (c *Conn) handleReadWriteError(err error) <span class="cov6" title="22">{
        if _, ok := err.(*net.OpError); ok || err == io.EOF || err == common.ErrConnNil ||
                err.Error() == "use of closed network connection" </span><span class="cov4" title="8">{
                // Client has closed the TCP connection.
                debug.Println("Note: Endpoint has disconnected.")
        }</span> <span class="cov5" title="14">else {
                // Unexpected error which prevented a read/write.
                log.Printf("Error: Encountered error: %q (%T)\n", err.Error(), err)
        }</span>

        // Make sure c.Close succeeds and sending stops.
        <span class="cov6" title="22">c.sendingLock.Lock()
        if c.sending == nil </span><span class="cov4" title="10">{
                c.sending = make(chan struct{})
        }</span>
        <span class="cov6" title="22">c.sendingLock.Unlock()

        c.Close()</span>
}

// protocolError informs the other endpoint that a protocol error has
// occurred, stops all running streams, and ends the connection.
func (c *Conn) protocolError(streamID common.StreamID) <span class="cov0" title="0">{
        reply := new(frames.RST_STREAM)
        reply.StreamID = streamID
        reply.Status = common.RST_STREAM_PROTOCOL_ERROR
        select </span>{
        <span class="cov0" title="0">case c.output[0] &lt;- reply:</span>
        <span class="cov0" title="0">case &lt;-time.After(100 * time.Millisecond):
                debug.Println("Failed to send PROTOCOL_ERROR RST_STREAM.")</span>
        }
        <span class="cov0" title="0">if c.shutdownError == nil </span><span class="cov0" title="0">{
                c.shutdownError = reply
        }</span>
        <span class="cov0" title="0">c.Close()</span>
}
</pre>
		
		<pre class="file" id="file202" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy3

import (
        "errors"
        "sync"
)

import (
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

type DefaultFlowControl uint32

func (f DefaultFlowControl) InitialWindowSize() uint32 <span class="cov8" title="14">{
        return uint32(f)
}</span>

func (f DefaultFlowControl) ReceiveData(_ common.StreamID, initialWindowSize uint32, newWindowSize int64) uint32 <span class="cov8" title="14">{
        if newWindowSize &lt; (int64(initialWindowSize) / 2) </span><span class="cov0" title="0">{
                return uint32(int64(initialWindowSize) - newWindowSize)
        }</span>

        <span class="cov8" title="14">return 0</span>
}

// flowControl is used by Streams to ensure that
// they abide by SPDY's flow control rules. For
// versions of SPDY before 3, this has no effect.
type flowControl struct {
        sync.Mutex
        conn                *Conn
        stream              common.Stream
        streamID            common.StreamID
        output              chan&lt;- common.Frame
        initialWindow       uint32
        transferWindow      int64
        sent                uint32
        buffer              [][]byte
        constrained         bool
        initialWindowThere  uint32
        transferWindowThere int64
        flowControl         common.FlowControl
        waiting             chan bool
}

// AddFlowControl initialises flow control for
// the Stream. If the Stream is running at an
// older SPDY version than SPDY/3, the flow
// control has no effect. Multiple calls to
// AddFlowControl are safe.
func (s *PushStream) AddFlowControl(f common.FlowControl) <span class="cov3" title="2">{
        if s.flow != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="2">s.flow = new(flowControl)
        s.flow.conn = s.conn
        s.conn.initialWindowSizeLock.Lock()
        initialWindow := s.conn.initialWindowSize
        s.conn.initialWindowSizeLock.Unlock()
        s.flow.streamID = s.streamID
        s.flow.output = s.output
        s.flow.buffer = make([][]byte, 0, 10)
        s.flow.initialWindow = initialWindow
        s.flow.transferWindow = int64(initialWindow)
        s.flow.stream = s
        s.flow.flowControl = f
        s.flow.initialWindowThere = f.InitialWindowSize()
        s.flow.transferWindowThere = int64(s.flow.transferWindowThere)</span>
}

// AddFlowControl initialises flow control for
// the Stream. If the Stream is running at an
// older SPDY version than SPDY/3, the flow
// control has no effect. Multiple calls to
// AddFlowControl are safe.
func (s *RequestStream) AddFlowControl(f common.FlowControl) <span class="cov6" title="6">{
        if s.flow != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="6">s.flow = new(flowControl)
        s.flow.conn = s.conn
        s.conn.initialWindowSizeLock.Lock()
        initialWindow := s.conn.initialWindowSize
        s.conn.initialWindowSizeLock.Unlock()
        s.flow.streamID = s.streamID
        s.flow.output = s.output
        s.flow.buffer = make([][]byte, 0, 10)
        s.flow.initialWindow = initialWindow
        s.flow.transferWindow = int64(initialWindow)
        s.flow.stream = s
        s.flow.flowControl = f
        s.flow.initialWindowThere = f.InitialWindowSize()
        s.flow.transferWindowThere = int64(s.flow.initialWindowThere)</span>
}

// AddFlowControl initialises flow control for
// the Stream. If the Stream is running at an
// older SPDY version than SPDY/3, the flow
// control has no effect. Multiple calls to
// AddFlowControl are safe.
func (s *ResponseStream) AddFlowControl(f common.FlowControl) <span class="cov6" title="6">{
        if s.flow != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="6">s.flow = new(flowControl)
        s.flow.conn = s.conn
        s.conn.initialWindowSizeLock.Lock()
        initialWindow := s.conn.initialWindowSize
        s.conn.initialWindowSizeLock.Unlock()
        s.flow.streamID = s.streamID
        s.flow.output = s.output
        s.flow.buffer = make([][]byte, 0, 10)
        s.flow.initialWindow = initialWindow
        s.flow.transferWindow = int64(initialWindow)
        s.flow.stream = s
        s.flow.flowControl = f
        s.flow.initialWindowThere = f.InitialWindowSize()
        s.flow.transferWindowThere = int64(s.flow.initialWindowThere)</span>
}

// CheckInitialWindow is used to handle the race
// condition where the flow control is initialised
// before the server has received any updates to
// the initial tranfer window sent by the client.
//
// The transfer window is updated retroactively,
// if necessary.
func (f *flowControl) CheckInitialWindow() <span class="cov10" title="22">{
        if f.stream == nil || f.stream.Conn() == nil </span><span class="cov6" title="6">{
                return
        }</span>

        <span class="cov9" title="16">f.conn.initialWindowSizeLock.Lock()
        newWindow := f.conn.initialWindowSize
        f.conn.initialWindowSizeLock.Unlock()

        if f.initialWindow != newWindow </span><span class="cov5" title="4">{
                if f.initialWindow &gt; newWindow </span><span class="cov0" title="0">{
                        f.transferWindow = int64(newWindow - f.sent)
                }</span> <span class="cov5" title="4">else if f.initialWindow &lt; newWindow </span><span class="cov5" title="4">{
                        f.transferWindow += int64(newWindow - f.initialWindow)
                }</span>
                <span class="cov5" title="4">if f.transferWindow &lt;= 0 </span><span class="cov0" title="0">{
                        f.constrained = true
                }</span>
                <span class="cov5" title="4">f.initialWindow = newWindow</span>
        }
}

// Close nils any references held by the flowControl.
func (f *flowControl) Close() <span class="cov8" title="14">{
        f.buffer = nil
        f.stream = nil
}</span>

// Flush is used to send buffered data to
// the connection, if the transfer window
// will allow. Flush does not guarantee
// that any or all buffered data will be
// sent with a single flush.
func (f *flowControl) Flush() <span class="cov6" title="6">{
        f.CheckInitialWindow()
        if !f.constrained || f.transferWindow == 0 </span><span class="cov6" title="6">{
                return
        }</span>

        <span class="cov0" title="0">out := make([]byte, 0, f.transferWindow)
        left := f.transferWindow
        for i := 0; i &lt; len(f.buffer); i++ </span><span class="cov0" title="0">{
                if l := int64(len(f.buffer[i])); l &lt;= left </span><span class="cov0" title="0">{
                        out = append(out, f.buffer[i]...)
                        left -= l
                        f.buffer = f.buffer[1:]
                }</span> <span class="cov0" title="0">else {
                        out = append(out, f.buffer[i][:left]...)
                        f.buffer[i] = f.buffer[i][left:]
                        left = 0
                }</span>

                <span class="cov0" title="0">if left == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">f.transferWindow -= int64(len(out))

        if f.transferWindow &gt; 0 </span><span class="cov0" title="0">{
                f.constrained = false
                debug.Printf("Stream %d is no longer constrained.\n", f.streamID)
        }</span>

        <span class="cov0" title="0">dataFrame := new(frames.DATA)
        dataFrame.StreamID = f.streamID
        dataFrame.Data = out

        f.output &lt;- dataFrame</span>
}

// Paused indicates whether there is data buffered.
// A Stream should not be closed until after the
// last data has been sent and then Paused returns
// false.
func (f *flowControl) Paused() bool <span class="cov8" title="12">{
        f.CheckInitialWindow()
        return f.constrained
}</span>

// Receive is called when data is received from
// the other endpoint. This ensures that they
// conform to the transfer window, regrows the
// window, and sends errors if necessary.
func (f *flowControl) Receive(data []byte) <span class="cov7" title="10">{
        // The transfer window shouldn't already be negative.
        if f.transferWindowThere &lt; 0 </span><span class="cov0" title="0">{
                rst := new(frames.RST_STREAM)
                rst.StreamID = f.streamID
                rst.Status = common.RST_STREAM_FLOW_CONTROL_ERROR
                f.output &lt;- rst
        }</span>

        // Update the window.
        <span class="cov7" title="10">f.transferWindowThere -= int64(len(data))

        // Regrow the window if it's half-empty.
        delta := f.flowControl.ReceiveData(f.streamID, f.initialWindowThere, f.transferWindowThere)
        if delta != 0 </span><span class="cov3" title="2">{
                grow := new(frames.WINDOW_UPDATE)
                grow.StreamID = f.streamID
                grow.DeltaWindowSize = delta
                f.output &lt;- grow
                f.transferWindowThere += int64(grow.DeltaWindowSize)
        }</span>
}

// UpdateWindow is called when an UPDATE_WINDOW frame is received,
// and performs the growing of the transfer window.
func (f *flowControl) UpdateWindow(deltaWindowSize uint32) error <span class="cov0" title="0">{
        f.Lock()
        defer f.Unlock()

        if int64(deltaWindowSize)+f.transferWindow &gt; common.MAX_TRANSFER_WINDOW_SIZE </span><span class="cov0" title="0">{
                return errors.New("Error: WINDOW_UPDATE delta window size overflows transfer window size.")
        }</span>

        // Grow window and flush queue.
        <span class="cov0" title="0">debug.Printf("Flow: Growing window in stream %d by %d bytes.\n", f.streamID, deltaWindowSize)
        f.transferWindow += int64(deltaWindowSize)

        f.Flush()
        select </span>{
        <span class="cov0" title="0">case f.waiting &lt;- true:</span>
        <span class="cov0" title="0">default:</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Wait blocks until any buffered data has been sent.
// This may involve waiting for a window update from
// the peer.
func (f *flowControl) Wait() error <span class="cov6" title="6">{
        f.Lock()
        f.Flush()
        if !f.Paused() </span><span class="cov6" title="6">{
                f.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">if f.waiting != nil </span><span class="cov0" title="0">{
                f.Unlock()
                return errors.New("waiting for flow control twice")
        }</span>

        <span class="cov0" title="0">f.waiting = make(chan bool)
        f.Unlock()

        for </span><span class="cov0" title="0">{
                &lt;-f.waiting
                f.Flush()
                if !f.Paused() </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
}

// Write is used to send data to the connection. This
// takes care of the windowing. Although data may be
// buffered, rather than actually sent, this is not
// visible to the caller.
func (f *flowControl) Write(data []byte) (int, error) <span class="cov5" title="4">{
        l := len(data)
        if l == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov5" title="4">if f.buffer == nil || f.stream == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream closed.")
        }</span>

        // Transfer window processing.
        <span class="cov5" title="4">f.CheckInitialWindow()
        if f.constrained </span><span class="cov0" title="0">{
                f.Flush()
        }</span>

        <span class="cov5" title="4">f.Lock()
        var window uint32
        if f.transferWindow &lt; 0 </span><span class="cov0" title="0">{
                window = 0
        }</span> <span class="cov5" title="4">else {
                window = uint32(f.transferWindow)
        }</span>

        <span class="cov5" title="4">constrained := false
        sending := uint32(len(data))
        if sending &gt; window </span><span class="cov0" title="0">{
                sending = window
                constrained = true
        }</span>

        <span class="cov5" title="4">f.sent += sending
        f.transferWindow -= int64(sending)

        if constrained </span><span class="cov0" title="0">{
                f.buffer = append(f.buffer, data[window:])
                data = data[:window]
                f.constrained = true
                debug.Printf("Stream %d is now constrained.\n", f.streamID)
        }</span>
        <span class="cov5" title="4">f.Unlock()

        if len(data) == 0 </span><span class="cov0" title="0">{
                return l, nil
        }</span>

        <span class="cov5" title="4">dataFrame := new(frames.DATA)
        dataFrame.StreamID = f.streamID
        dataFrame.Data = data

        f.output &lt;- dataFrame
        return l, nil</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bufio"
        "errors"
        "fmt"

        "bfe_spdy/common"
)

// ReadFrame reads and parses a frame from reader.
func ReadFrame(reader *bufio.Reader, subversion int) (frame common.Frame, err error) <span class="cov0" title="0">{
        start, err := reader.Peek(4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if start[0] != 128 </span><span class="cov0" title="0">{
                frame = new(DATA)
                _, err = frame.ReadFrom(reader)
                return frame, err
        }</span>

        <span class="cov0" title="0">switch common.BytesToUint16(start[2:4]) </span>{
        <span class="cov0" title="0">case _SYN_STREAM:
                switch subversion </span>{
                <span class="cov0" title="0">case 0:
                        frame = new(SYN_STREAM)</span>
                <span class="cov0" title="0">case 1:
                        frame = new(SYN_STREAMV3_1)</span>
                <span class="cov0" title="0">default:
                        return nil, fmt.Errorf("Error: Given subversion %d is unrecognised.", subversion)</span>
                }
        <span class="cov0" title="0">case _SYN_REPLY:
                frame = new(SYN_REPLY)</span>
        <span class="cov0" title="0">case _RST_STREAM:
                frame = new(RST_STREAM)</span>
        <span class="cov0" title="0">case _SETTINGS:
                frame = new(SETTINGS)</span>
        <span class="cov0" title="0">case _PING:
                frame = new(PING)</span>
        <span class="cov0" title="0">case _GOAWAY:
                frame = new(GOAWAY)</span>
        <span class="cov0" title="0">case _HEADERS:
                frame = new(HEADERS)</span>
        <span class="cov0" title="0">case _WINDOW_UPDATE:
                frame = &amp;WINDOW_UPDATE{subversion: subversion}</span>
        <span class="cov0" title="0">case _CREDENTIAL:
                frame = new(CREDENTIAL)</span>

        <span class="cov0" title="0">default:
                return nil, errors.New("Error Failed to parse frame type.")</span>
        }

        <span class="cov0" title="0">_, err = frame.ReadFrom(reader)
        return frame, err</span>
}

// controlFrameCommonProcessing performs checks identical between
// all control frames. This includes the control bit, the version
// number, the type byte (which is checked against the byte
// provided), and the flags (which are checked against the bitwise
// OR of valid flags provided).
func controlFrameCommonProcessing(data []byte, frameType uint16, flags byte) error <span class="cov10" title="10">{
        // Check it's a control frame.
        if data[0] != 128 </span><span class="cov0" title="0">{
                return common.IncorrectFrame(_DATA_FRAME, int(frameType), 3)
        }</span>

        // Check version.
        <span class="cov10" title="10">version := (uint16(data[0]&amp;0x7f) &lt;&lt; 8) + uint16(data[1])
        if version != 3 </span><span class="cov0" title="0">{
                return common.UnsupportedVersion(version)
        }</span>

        // Check its type.
        <span class="cov10" title="10">realType := common.BytesToUint16(data[2:])
        if realType != frameType </span><span class="cov0" title="0">{
                return common.IncorrectFrame(int(realType), int(frameType), 3)
        }</span>

        // Check the flags.
        <span class="cov10" title="10">if data[4] &amp; ^flags != 0 </span><span class="cov0" title="0">{
                return common.InvalidField("flags", int(data[4]), int(flags))
        }</span>

        <span class="cov10" title="10">return nil</span>
}

// Frame types in SPDY/3
const (
        _SYN_STREAM    = 1
        _SYN_REPLY     = 2
        _RST_STREAM    = 3
        _SETTINGS      = 4
        _PING          = 6
        _GOAWAY        = 7
        _HEADERS       = 8
        _WINDOW_UPDATE = 9
        _CREDENTIAL    = 10
        _CONTROL_FRAME = -1
        _DATA_FRAME    = -2
)

// frameNames provides the name for a particular SPDY/3
// frame type.
var frameNames = map[int]string{
        _SYN_STREAM:    "SYN_STREAM",
        _SYN_REPLY:     "SYN_REPLY",
        _RST_STREAM:    "RST_STREAM",
        _SETTINGS:      "SETTINGS",
        _PING:          "PING",
        _GOAWAY:        "GOAWAY",
        _HEADERS:       "HEADERS",
        _WINDOW_UPDATE: "WINDOW_UPDATE",
        _CREDENTIAL:    "CREDENTIAL",
        _CONTROL_FRAME: "CONTROL_FRAME",
        _DATA_FRAME:    "DATA_FRAME",
}
</pre>
		
		<pre class="file" id="file204" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "crypto/x509"
    "encoding/binary"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type CREDENTIAL struct {
        Slot         uint16
        Proof        []byte
        Certificates []*x509.Certificate
}

func (frame *CREDENTIAL) Compress(comp common.Compressor) error <span class="cov1" title="1">{
        return nil
}</span>

func (frame *CREDENTIAL) Decompress(decomp common.Decompressor) error <span class="cov1" title="1">{
        return nil
}</span>

func (frame *CREDENTIAL) Name() string <span class="cov1" title="1">{
        return "CREDENTIAL"
}</span>

/* ReadFrom - read and parse CREDENTIAL frame
 *
 * Note: format of CREDENTIAL
 *  +----------------------------------+
 *  |1|000000000000011|0000000000001010|
 *  +----------------------------------+
 *  | flags (8)  |  Length (24 bits)   |
 *  +----------------------------------+
 *  |  Slot (16 bits) |                |
 *  +-----------------+                |
 *  |      Proof Length (32 bits)      |
 *  +----------------------------------+
 *  |               Proof              |
 *  +----------------------------------+ &lt;+
 *  |   Certificate Length (32 bits)   |  |
 *  +----------------------------------+  | Repeated until end of frame
 *  |            Certificate           |  |
 *  +----------------------------------+ &lt;+
 */
func (frame *CREDENTIAL) ReadFrom(reader io.Reader) (int64, error) <span class="cov1" title="1">{
        data, err := common.ReadExactly(reader, 14)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">err = controlFrameCommonProcessing(data[:5], _CREDENTIAL, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 14, err
        }</span>

        // Get and check length.
        <span class="cov1" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 6 </span><span class="cov0" title="0">{
                return 14, common.IncorrectDataLength(length, 6)
        }</span> <span class="cov1" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 14, common.FrameTooLarge
        }</span>

    // Read in proof
        <span class="cov1" title="1">frame.Slot = common.BytesToUint16(data[8:10])
        proofLen := int(common.BytesToUint32(data[10:14]))
        if proofLen &gt; 0 </span><span class="cov1" title="1">{
                frame.Proof, err = common.ReadExactly(reader, proofLen)
        if err != nil </span><span class="cov0" title="0">{
                    return 14, err
        }</span>
        } <span class="cov0" title="0">else {
                frame.Proof = []byte{}
        }</span>

        // Read in data.
        <span class="cov1" title="1">certs, err := common.ReadExactly(reader, length-6-proofLen)
        if err != nil </span><span class="cov0" title="0">{
                return int64(14 + proofLen), err
        }</span>

        <span class="cov1" title="1">numCerts := 0
        for offset := 0; offset &lt; length-6-proofLen; </span><span class="cov10" title="2">{
                offset += int(common.BytesToUint32(certs[offset:offset+4])) + 4
                numCerts++
        }</span>

        <span class="cov1" title="1">frame.Certificates = make([]*x509.Certificate, numCerts)
        for i, offset := 0, 0; offset &lt; length-6-proofLen; i++ </span><span class="cov10" title="2">{
                length := int(common.BytesToUint32(certs[offset : offset+4]))
                rawCert := certs[offset+4 : offset+4+length]
                frame.Certificates[i], err = x509.ParseCertificate(rawCert)
                if err != nil </span><span class="cov0" title="0">{
                        return int64(length + 8), err
                }</span>
                <span class="cov10" title="2">offset += length + 4</span>
        }

        <span class="cov1" title="1">return int64(length + 8), nil</span>
}

func (frame *CREDENTIAL) String() string <span class="cov1" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("CREDENTIAL {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Slot:                 %d\n\t", frame.Slot))
        buf.WriteString(fmt.Sprintf("Proof:                %v\n\t", frame.Proof))
        buf.WriteString(fmt.Sprintf("Certificates:         %v\n}\n", frame.Certificates))

        return buf.String()
}</span>

func (frame *CREDENTIAL) WriteTo(writer io.Writer) (int64, error) <span class="cov1" title="1">{
        proofLength := len(frame.Proof)
        certsLength := 0
        for _, cert := range frame.Certificates </span><span class="cov10" title="2">{
                certsLength += len(cert.Raw)
        }</span>

        <span class="cov1" title="1">length := 6 + proofLength + 4 * len(frame.Certificates) + certsLength
        out := make([]byte, 14)

        out[0] = 128                      // Control bit and Version
        out[1] = 3                        // Version
        out[2] = 0                        // Type
        out[3] = 10                       // Type
        out[4] = 0                        // common.Flags
        out[5] = byte(length &gt;&gt; 16)       // Length
        out[6] = byte(length &gt;&gt; 8)        // Length
        out[7] = byte(length)             // Length
        out[8] = byte(frame.Slot &gt;&gt; 8)    // Slot
        out[9] = byte(frame.Slot)         // Slot
        out[10] = byte(proofLength &gt;&gt; 24) // Proof Length
        out[11] = byte(proofLength &gt;&gt; 16) // Proof Length
        out[12] = byte(proofLength &gt;&gt; 8)  // Proof Length
        out[13] = byte(proofLength)       // Proof Length

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">if len(frame.Proof) &gt; 0 </span><span class="cov1" title="1">{
                err = common.WriteExactly(writer, frame.Proof)
                if err != nil </span><span class="cov0" title="0">{
                        return 14, err
                }</span>
        }

        <span class="cov1" title="1">written := int64(14 + len(frame.Proof))
        for _, cert := range frame.Certificates </span><span class="cov10" title="2">{
        // lenght of cert (4 bytes)
        certLen := uint32(len(cert.Raw))
        err = binary.Write(writer, binary.BigEndian, certLen)
                if err != nil </span><span class="cov0" title="0">{
                        return written, err
                }</span>
        <span class="cov10" title="2">written += 4

        // raw data of cert
                err = common.WriteExactly(writer, cert.Raw)
                if err != nil </span><span class="cov0" title="0">{
                        return written, err
                }</span>
                <span class="cov10" title="2">written += int64(len(cert.Raw))</span>
        }

        <span class="cov1" title="1">return written, nil</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type DATA struct {
        StreamID common.StreamID
        Flags    common.Flags
        Data     []byte
}

func (frame *DATA) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *DATA) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *DATA) Name() string <span class="cov8" title="1">{
        return "DATA"
}</span>

func (frame *DATA) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 8)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Check it's a data frame.
        <span class="cov8" title="1">if data[0]&amp;0x80 == 1 </span><span class="cov0" title="0">{
                return 8, common.IncorrectFrame(_CONTROL_FRAME, _DATA_FRAME, 3)
        }</span>

        // Check flags.
        <span class="cov8" title="1">if data[4] &amp; ^byte(common.FLAG_FIN) != 0 </span><span class="cov0" title="0">{
                return 8, common.InvalidField("flags", int(data[4]), common.FLAG_FIN)
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length == 0 &amp;&amp; data[4] == 0 </span><span class="cov0" title="0">{
                return 8, common.IncorrectDataLength(length, 1)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 8, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">if length != 0 </span><span class="cov8" title="1">{
                frame.Data, err = common.ReadExactly(reader, length)
                if err != nil </span><span class="cov0" title="0">{
                        return 8, err
                }</span>
        }

        <span class="cov8" title="1">frame.StreamID = common.StreamID(common.BytesToUint32(data[0:4]))
        frame.Flags = common.Flags(data[4])
        if frame.Data == nil </span><span class="cov0" title="0">{
                frame.Data = []byte{}
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}

func (frame *DATA) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("DATA {\n\t")
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Length:               %d\n\t", len(frame.Data)))
        if common.VerboseLogging || len(frame.Data) &lt;= 21 </span><span class="cov0" title="0">{
                buf.WriteString(fmt.Sprintf("Data:                 [% x]\n}\n", frame.Data))
        }</span> <span class="cov8" title="1">else {
                buf.WriteString(fmt.Sprintf("Data:                 [% x ... % x]\n}\n", frame.Data[:9],
                        frame.Data[len(frame.Data)-9:]))
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}

func (frame *DATA) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        length := len(frame.Data)
        if length &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Data size too large.")
        }</span>
        <span class="cov8" title="1">if length == 0 &amp;&amp; !frame.Flags.FIN() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Data is empty.")
        }</span>

        <span class="cov8" title="1">out := make([]byte, 8)

        out[0] = frame.StreamID.B1() // Control bit and Stream ID
        out[1] = frame.StreamID.B2() // Stream ID
        out[2] = frame.StreamID.B3() // Stream ID
        out[3] = frame.StreamID.B4() // Stream ID
        out[4] = byte(frame.Flags)   // Flags
        out[5] = byte(length &gt;&gt; 16)  // Length
        out[6] = byte(length &gt;&gt; 8)   // Length
        out[7] = byte(length)        // Length

        if err := common.WriteExactly(writer, out); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if err := common.WriteExactly(writer, frame.Data); err != nil </span><span class="cov0" title="0">{
                return 8, err
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}
</pre>
		
		<pre class="file" id="file206" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type GOAWAY struct {
        LastGoodStreamID common.StreamID
        Status           common.StatusCode
}

func (frame *GOAWAY) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *GOAWAY) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *GOAWAY) Error() string <span class="cov0" title="0">{
        if err := frame.Status.String(); err != "" </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("[unknown status code %d]", frame.Status)</span>
}

func (frame *GOAWAY) Name() string <span class="cov8" title="1">{
        return "GOAWAY"
}</span>

func (frame *GOAWAY) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _GOAWAY, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 16, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 8 </span><span class="cov0" title="0">{
                return 16, common.IncorrectDataLength(length, 8)
        }</span>

        <span class="cov8" title="1">frame.LastGoodStreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.Status = common.StatusCode(common.BytesToUint32(data[12:16]))

        if !frame.LastGoodStreamID.Valid() </span><span class="cov0" title="0">{
                return 16, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}

func (frame *GOAWAY) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("GOAWAY {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Last good stream ID:  %d\n\t", frame.LastGoodStreamID))
        buf.WriteString(fmt.Sprintf("Status code:          %s (%d)\n}\n", frame.Status, frame.Status))

        return buf.String()
}</span>

func (frame *GOAWAY) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if !frame.LastGoodStreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">out := make([]byte, 16)

        out[0] = 128                          // Control bit and Version
        out[1] = 3                            // Version
        out[2] = 0                            // Type
        out[3] = 7                            // Type
        out[4] = 0                            // Flags
        out[5] = 0                            // Length
        out[6] = 0                            // Length
        out[7] = 8                            // Length
        out[8] = frame.LastGoodStreamID.B1()  // Last Good Stream ID
        out[9] = frame.LastGoodStreamID.B2()  // Last Good Stream ID
        out[10] = frame.LastGoodStreamID.B3() // Last Good Stream ID
        out[11] = frame.LastGoodStreamID.B4() // Last Good Stream ID
        out[12] = byte(frame.Status &gt;&gt; 24)    // Status Code
        out[13] = byte(frame.Status &gt;&gt; 16)    // Status Code
        out[14] = byte(frame.Status &gt;&gt; 8)     // Status Code
        out[15] = byte(frame.Status)          // Status Code

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}
</pre>
		
		<pre class="file" id="file207" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
)

type HEADERS struct {
        Flags     common.Flags
        StreamID  common.StreamID
        Header    http.Header
        rawHeader []byte
}

func (frame *HEADERS) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *HEADERS) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *HEADERS) Name() string <span class="cov8" title="1">{
        return "HEADERS"
}</span>

func (frame *HEADERS) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _HEADERS, common.FLAG_FIN)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 12, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-4)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.rawHeader = header

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return int64(length) + 8, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return int64(length) + 8, common.StreamIdIsZero
        }</span>

        <span class="cov8" title="1">return int64(length) + 8, nil</span>
}

func (frame *HEADERS) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("HEADERS {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Header:               %#v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *HEADERS) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Headers not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 4 + len(header)
        out := make([]byte, 12)

        out[0] = 128                  // Control bit and Version
        out[1] = 3                    // Version
        out[2] = 0                    // Type
        out[3] = 8                    // Type
        out[4] = byte(frame.Flags)    // Flags
        out[5] = byte(length &gt;&gt; 16)   // Length
        out[6] = byte(length &gt;&gt; 8)    // Length
        out[7] = byte(length)         // Length
        out[8] = frame.StreamID.B1()  // Stream ID
        out[9] = frame.StreamID.B2()  // Stream ID
        out[10] = frame.StreamID.B3() // Stream ID
        out[11] = frame.StreamID.B4() // Stream ID

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}
</pre>
		
		<pre class="file" id="file208" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "fmt"
        "io"
)

import (
        "bfe_spdy/common"
)

type PING struct {
        PingID uint32
}

func (frame *PING) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *PING) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *PING) Name() string <span class="cov8" title="1">{
        return "PING"
}</span>

func (frame *PING) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _PING, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4)
        }</span>

        <span class="cov8" title="1">frame.PingID = common.BytesToUint32(data[8:12])

        return 12, nil</span>
}

func (frame *PING) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("PING {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Ping ID:              %d\n}\n", frame.PingID))

        return buf.String()
}</span>

func (frame *PING) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        out := make([]byte, 12)

        out[0] = 128                      // Control bit and Version
        out[1] = 3                        // Version
        out[2] = 0                        // Type
        out[3] = 6                        // Type
        out[4] = 0                        // common.Flags
        out[5] = 0                        // Length
        out[6] = 0                        // Length
        out[7] = 4                        // Length
        out[8] = byte(frame.PingID &gt;&gt; 24) // Ping ID
        out[9] = byte(frame.PingID &gt;&gt; 16) // Ping ID
        out[10] = byte(frame.PingID &gt;&gt; 8) // Ping ID
        out[11] = byte(frame.PingID)      // Ping ID

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 12, nil</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type RST_STREAM struct {
        StreamID common.StreamID
        Status   common.StatusCode
}

func (frame *RST_STREAM) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *RST_STREAM) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *RST_STREAM) Error() string <span class="cov0" title="0">{
        if err := frame.Status.String(); err != "" </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("[unknown status code %d]", frame.Status)</span>
}

func (frame *RST_STREAM) Name() string <span class="cov8" title="1">{
        return "RST_STREAM"
}</span>

func (frame *RST_STREAM) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _RST_STREAM, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 16, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 8 </span><span class="cov0" title="0">{
                return 16, common.IncorrectDataLength(length, 8)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 16, common.FrameTooLarge
        }</span>

        <span class="cov8" title="1">frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.Status = common.StatusCode(common.BytesToUint32(data[12:16]))

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 16, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}

func (frame *RST_STREAM) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("RST_STREAM {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Status code:          %s\n}\n", frame.Status))

        return buf.String()
}</span>

func (frame *RST_STREAM) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">out := make([]byte, 16)

        out[0] = 128                  // Control bit and Version
        out[1] = 3                    // Version
        out[2] = 0                    // Type
        out[3] = 3                    // Type
        out[4] = 0                    // Flags
        out[5] = 0                    // Length
        out[6] = 0                    // Length
        out[7] = 8                    // Length
        out[8] = frame.StreamID.B1()  // Stream ID
        out[9] = frame.StreamID.B2()  // Stream ID
        out[10] = frame.StreamID.B3() // Stream ID
        out[11] = frame.StreamID.B4() // Stream ID
        out[12] = frame.Status.B1()   // Status
        out[13] = frame.Status.B2()   // Status
        out[14] = frame.Status.B3()   // Status
        out[15] = frame.Status.B4()   // Status

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}
</pre>
		
		<pre class="file" id="file210" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "sort"

        "bfe_spdy/common"
)

type SETTINGS struct {
        Flags    common.Flags
        Settings common.Settings
}

func (frame *SETTINGS) Add(flags common.Flags, id uint32, value uint32) <span class="cov0" title="0">{
        frame.Settings[id] = &amp;common.Setting{flags, id, value}
}</span>

func (frame *SETTINGS) Compress(comp common.Compressor) error <span class="cov1" title="1">{
        return nil
}</span>

func (frame *SETTINGS) Decompress(decomp common.Decompressor) error <span class="cov1" title="1">{
        return nil
}</span>

func (frame *SETTINGS) Name() string <span class="cov1" title="1">{
        return "SETTINGS"
}</span>

func (frame *SETTINGS) ReadFrom(reader io.Reader) (int64, error) <span class="cov1" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">err = controlFrameCommonProcessing(data[:5], _SETTINGS, common.FLAG_SETTINGS_CLEAR_SETTINGS)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov1" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 8)
        }</span> <span class="cov1" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 12, common.FrameTooLarge
        }</span>

        // Check size.
        <span class="cov1" title="1">numSettings := int(common.BytesToUint32(data[8:12]))
        if length != 4+(8*numSettings) </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4+(8*numSettings))
        }</span>

        // Read in data.
        <span class="cov1" title="1">settings, err := common.ReadExactly(reader, 8*numSettings)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov1" title="1">frame.Flags = common.Flags(data[4])
        frame.Settings = make(common.Settings)
        for i := 0; i &lt; numSettings; i++ </span><span class="cov10" title="2">{
                j := i * 8
                setting := decodeSetting(settings[j:])
                if setting == nil </span><span class="cov0" title="0">{
                        return int64(length), errors.New("Error: Failed to parse settings.")
                }</span>
                <span class="cov10" title="2">frame.Settings[setting.ID] = setting</span>
        }

        <span class="cov1" title="1">return int64(length + 8), nil</span>
}

func (frame *SETTINGS) String() string <span class="cov1" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.CLEAR_SETTINGS() </span><span class="cov0" title="0">{
                flags += " FLAG_SETTINGS_CLEAR_SETTINGS"
        }</span>
        <span class="cov1" title="1">if flags == "" </span><span class="cov1" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov1" title="1">buf.WriteString("SETTINGS {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Settings:\n"))
        settings := frame.Settings.Settings()
        for _, setting := range settings </span><span class="cov10" title="2">{
                buf.WriteString("\t\t" + setting.String() + "\n")
        }</span>
        <span class="cov1" title="1">buf.WriteString("}\n")

        return buf.String()</span>
}

func (frame *SETTINGS) WriteTo(writer io.Writer) (int64, error) <span class="cov1" title="1">{
        settings := encodeSettings(frame.Settings)
        numSettings := uint32(len(frame.Settings))
        length := 4 + len(settings)
        out := make([]byte, 12)

        out[0] = 128                     // Control bit and Version
        out[1] = 3                       // Version
        out[2] = 0                       // Type
        out[3] = 4                       // Type
        out[4] = byte(frame.Flags)       // Flags
        out[5] = byte(length &gt;&gt; 16)      // Length
        out[6] = byte(length &gt;&gt; 8)       // Length
        out[7] = byte(length)            // Length
        out[8] = byte(numSettings &gt;&gt; 24) // Number of Entries
        out[9] = byte(numSettings &gt;&gt; 16) // Number of Entries
        out[10] = byte(numSettings &gt;&gt; 8) // Number of Entries
        out[11] = byte(numSettings)      // Number of Entries

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">err = common.WriteExactly(writer, settings)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov1" title="1">return int64(length + 8), nil</span>
}

func decodeSetting(data []byte) *common.Setting <span class="cov10" title="2">{
        if len(data) &lt; 8 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="2">setting := new(common.Setting)
        setting.Flags = common.Flags(data[0])
        setting.ID = common.BytesToUint24(data[1:])
        setting.Value = common.BytesToUint32(data[4:])

        return setting</span>
}

func encodeSettings(s common.Settings) []byte <span class="cov1" title="1">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return []byte{}
        }</span>

        <span class="cov1" title="1">ids := make([]int, 0, len(s))
        for id := range s </span><span class="cov10" title="2">{
                ids = append(ids, int(id))
        }</span>

        <span class="cov1" title="1">sort.Sort(sort.IntSlice(ids))

        out := make([]byte, 8*len(s))

        offset := 0
        for _, id := range ids </span><span class="cov10" title="2">{
                setting := s[uint32(id)]
                out[offset] = byte(setting.Flags)
                out[offset+1] = byte(setting.ID &gt;&gt; 16)
                out[offset+2] = byte(setting.ID &gt;&gt; 8)
                out[offset+3] = byte(setting.ID)
                out[offset+4] = byte(setting.Value &gt;&gt; 24)
                out[offset+5] = byte(setting.Value &gt;&gt; 16)
                out[offset+6] = byte(setting.Value &gt;&gt; 8)
                out[offset+7] = byte(setting.Value)
                offset += 8
        }</span>

        <span class="cov1" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file211" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
)

type SYN_REPLY struct {
        Flags     common.Flags
        StreamID  common.StreamID
        Header    http.Header
        rawHeader []byte
}

func (frame *SYN_REPLY) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *SYN_REPLY) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *SYN_REPLY) Name() string <span class="cov8" title="1">{
        return "SYN_REPLY"
}</span>

func (frame *SYN_REPLY) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 12)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _SYN_REPLY, common.FLAG_FIN)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 4 </span><span class="cov0" title="0">{
                return 12, common.IncorrectDataLength(length, 4)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-8 </span><span class="cov0" title="0">{
                return 12, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-4)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.rawHeader = header

        return int64(length + 8), nil</span>
}

func (frame *SYN_REPLY) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("SYN_REPLY {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Header:               %#v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *SYN_REPLY) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Header not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 4 + len(header)
        out := make([]byte, 12)

        out[0] = 128                  // Control bit and Version
        out[1] = 3                    // Version
        out[2] = 0                    // Type
        out[3] = 2                    // Type
        out[4] = byte(frame.Flags)    // Flags
        out[5] = byte(length &gt;&gt; 16)   // Length
        out[6] = byte(length &gt;&gt; 8)    // Length
        out[7] = byte(length)         // Length
        out[8] = frame.StreamID.B1()  // Stream ID
        out[9] = frame.StreamID.B2()  // Stream ID
        out[10] = frame.StreamID.B3() // Stream ID
        out[11] = frame.StreamID.B4() // Stream ID

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 12, err
        }</span>

        <span class="cov8" title="1">return int64(len(header) + 12), nil</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
)

type SYN_STREAM struct {
        Flags         common.Flags
        StreamID      common.StreamID
        AssocStreamID common.StreamID
        Priority      common.Priority
        Slot          byte
        Header        http.Header
        rawHeader     []byte
}

func (frame *SYN_STREAM) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *SYN_STREAM) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *SYN_STREAM) Name() string <span class="cov8" title="1">{
        return "SYN_STREAM"
}</span>

func (frame *SYN_STREAM) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 18)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _SYN_STREAM, common.FLAG_FIN|common.FLAG_UNIDIRECTIONAL)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 10 </span><span class="cov0" title="0">{
                return 18, common.IncorrectDataLength(length, 10)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-18 </span><span class="cov0" title="0">{
                return 18, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-10)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.AssocStreamID = common.StreamID(common.BytesToUint32(data[12:16]))
        frame.Priority = common.Priority(data[16] &gt;&gt; 5)
        frame.Slot = data[17]
        frame.rawHeader = header

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 18, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 18, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if !frame.AssocStreamID.Valid() </span><span class="cov0" title="0">{
                return 18, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}

func (frame *SYN_STREAM) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if frame.Flags.UNIDIRECTIONAL() </span><span class="cov0" title="0">{
                flags += " FLAG_UNIDIRECTIONAL"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("SYN_STREAM {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Associated Stream ID: %d\n\t", frame.AssocStreamID))
        buf.WriteString(fmt.Sprintf("Priority:             %d\n\t", frame.Priority))
        buf.WriteString(fmt.Sprintf("Slot:                 %d\n\t", frame.Slot))
        buf.WriteString(fmt.Sprintf("Header:               %#v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *SYN_STREAM) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Headers not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if !frame.AssocStreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 10 + len(header)
        out := make([]byte, 18)

        out[0] = 128                       // Control bit and Version
        out[1] = 3                         // Version
        out[2] = 0                         // Type
        out[3] = 1                         // Type
        out[4] = byte(frame.Flags)         // Flags
        out[5] = byte(length &gt;&gt; 16)        // Length
        out[6] = byte(length &gt;&gt; 8)         // Length
        out[7] = byte(length)              // Length
        out[8] = frame.StreamID.B1()       // Stream ID
        out[9] = frame.StreamID.B2()       // Stream ID
        out[10] = frame.StreamID.B3()      // Stream ID
        out[11] = frame.StreamID.B4()      // Stream ID
        out[12] = frame.AssocStreamID.B1() // Associated Stream ID
        out[13] = frame.AssocStreamID.B2() // Associated Stream ID
        out[14] = frame.AssocStreamID.B3() // Associated Stream ID
        out[15] = frame.AssocStreamID.B4() // Associated Stream ID
        out[16] = frame.Priority.Byte(3)   // Priority and unused
        out[17] = frame.Slot               // Slot

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        <span class="cov8" title="1">return int64(len(header) + 18), nil</span>
}

// SPDY/3.1
type SYN_STREAMV3_1 struct {
        Flags         common.Flags
        StreamID      common.StreamID
        AssocStreamID common.StreamID
        Priority      common.Priority
        Header        http.Header
        rawHeader     []byte
}

func (frame *SYN_STREAMV3_1) Compress(com common.Compressor) error <span class="cov8" title="1">{
        if frame.rawHeader != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := com.Compress(frame.Header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.rawHeader = data
        return nil</span>
}

func (frame *SYN_STREAMV3_1) Decompress(decom common.Decompressor) error <span class="cov8" title="1">{
        if frame.Header != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header, err := decom.Decompress(frame.rawHeader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">frame.Header = header
        frame.rawHeader = nil
        return nil</span>
}

func (frame *SYN_STREAMV3_1) Name() string <span class="cov8" title="1">{
        return "SYN_STREAM"
}</span>

func (frame *SYN_STREAMV3_1) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 18)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _SYN_STREAM, common.FLAG_FIN|common.FLAG_UNIDIRECTIONAL)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length &lt; 10 </span><span class="cov0" title="0">{
                return 18, common.IncorrectDataLength(length, 10)
        }</span> <span class="cov8" title="1">else if length &gt; common.MAX_FRAME_SIZE-18 </span><span class="cov0" title="0">{
                return 18, common.FrameTooLarge
        }</span>

        // Read in data.
        <span class="cov8" title="1">header, err := common.ReadExactly(reader, length-10)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        <span class="cov8" title="1">frame.Flags = common.Flags(data[4])
        frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.AssocStreamID = common.StreamID(common.BytesToUint32(data[12:16]))
        frame.Priority = common.Priority(data[16] &gt;&gt; 5)
        frame.rawHeader = header

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 18, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 18, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if !frame.AssocStreamID.Valid() </span><span class="cov0" title="0">{
                return 18, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">return int64(length + 8), nil</span>
}

func (frame *SYN_STREAMV3_1) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        flags := ""
        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                flags += " common.FLAG_FIN"
        }</span>
        <span class="cov8" title="1">if frame.Flags.UNIDIRECTIONAL() </span><span class="cov0" title="0">{
                flags += " FLAG_UNIDIRECTIONAL"
        }</span>
        <span class="cov8" title="1">if flags == "" </span><span class="cov8" title="1">{
                flags = "[NONE]"
        }</span> <span class="cov0" title="0">else {
                flags = flags[1:]
        }</span>

        <span class="cov8" title="1">buf.WriteString("SYN_STREAM {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Flags:                %s\n\t", flags))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Associated Stream ID: %d\n\t", frame.AssocStreamID))
        buf.WriteString(fmt.Sprintf("Priority:             %d\n\t", frame.Priority))
        buf.WriteString(fmt.Sprintf("Header:               %#v\n}\n", frame.Header))

        return buf.String()</span>
}

func (frame *SYN_STREAMV3_1) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        if frame.rawHeader == nil </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Headers not written.")
        }</span>
        <span class="cov8" title="1">if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() </span><span class="cov0" title="0">{
                return 0, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if !frame.AssocStreamID.Valid() </span><span class="cov0" title="0">{
                return 0, common.StreamIdTooLarge
        }</span>

        <span class="cov8" title="1">header := frame.rawHeader
        length := 10 + len(header)
        out := make([]byte, 18)

        out[0] = 128                       // Control bit and Version
        out[1] = 3                         // Version
        out[2] = 0                         // Type
        out[3] = 1                         // Type
        out[4] = byte(frame.Flags)         // Flags
        out[5] = byte(length &gt;&gt; 16)        // Length
        out[6] = byte(length &gt;&gt; 8)         // Length
        out[7] = byte(length)              // Length
        out[8] = frame.StreamID.B1()       // Stream ID
        out[9] = frame.StreamID.B2()       // Stream ID
        out[10] = frame.StreamID.B3()      // Stream ID
        out[11] = frame.StreamID.B4()      // Stream ID
        out[12] = frame.AssocStreamID.B1() // Associated Stream ID
        out[13] = frame.AssocStreamID.B2() // Associated Stream ID
        out[14] = frame.AssocStreamID.B3() // Associated Stream ID
        out[15] = frame.AssocStreamID.B4() // Associated Stream ID
        out[16] = frame.Priority.Byte(3)   // Priority and unused
        out[17] = 0                        // Reserved

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = common.WriteExactly(writer, header)
        if err != nil </span><span class="cov0" title="0">{
                return 18, err
        }</span>

        <span class="cov8" title="1">return int64(len(header) + 18), nil</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package frames

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "bfe_spdy/common"
)

type WINDOW_UPDATE struct {
        StreamID        common.StreamID
        DeltaWindowSize uint32
        subversion      int
}

func (frame *WINDOW_UPDATE) Compress(comp common.Compressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *WINDOW_UPDATE) Decompress(decomp common.Decompressor) error <span class="cov8" title="1">{
        return nil
}</span>

func (frame *WINDOW_UPDATE) Name() string <span class="cov8" title="1">{
        return "WINDOW_UPDATE"
}</span>

func (frame *WINDOW_UPDATE) ReadFrom(reader io.Reader) (int64, error) <span class="cov8" title="1">{
        data, err := common.ReadExactly(reader, 16)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">err = controlFrameCommonProcessing(data[:5], _WINDOW_UPDATE, 0)
        if err != nil </span><span class="cov0" title="0">{
                return 16, err
        }</span>

        // Get and check length.
        <span class="cov8" title="1">length := int(common.BytesToUint24(data[5:8]))
        if length != 8 </span><span class="cov0" title="0">{
                return 16, common.IncorrectDataLength(length, 8)
        }</span>

        <span class="cov8" title="1">frame.StreamID = common.StreamID(common.BytesToUint32(data[8:12]))
        frame.DeltaWindowSize = common.BytesToUint32(data[12:16])

        if !frame.StreamID.Valid() </span><span class="cov0" title="0">{
                return 16, common.StreamIdTooLarge
        }</span>
        <span class="cov8" title="1">if frame.StreamID.Zero() &amp;&amp; frame.subversion == 0 </span><span class="cov0" title="0">{
                return 16, common.StreamIdIsZero
        }</span>
        <span class="cov8" title="1">if frame.DeltaWindowSize &gt; common.MAX_DELTA_WINDOW_SIZE </span><span class="cov0" title="0">{
                return 16, errors.New("Error: Delta Window Size too large.")
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}

func (frame *WINDOW_UPDATE) String() string <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        buf.WriteString("WINDOW_UPDATE {\n\t")
        buf.WriteString(fmt.Sprintf("Version:              3\n\t"))
        buf.WriteString(fmt.Sprintf("Stream ID:            %d\n\t", frame.StreamID))
        buf.WriteString(fmt.Sprintf("Delta window size:    %d\n}\n", frame.DeltaWindowSize))

        return buf.String()
}</span>

func (frame *WINDOW_UPDATE) WriteTo(writer io.Writer) (int64, error) <span class="cov8" title="1">{
        out := make([]byte, 16)

        out[0] = 128                                     // Control bit and Version
        out[1] = 3                                       // Version
        out[2] = 0                                       // Type
        out[3] = 9                                       // Type
        out[4] = 0                                       // Flags
        out[5] = 0                                       // Length
        out[6] = 0                                       // Length
        out[7] = 8                                       // Length
        out[8] = frame.StreamID.B1()                     // Stream ID
        out[9] = frame.StreamID.B2()                     // Stream ID
        out[10] = frame.StreamID.B3()                    // Stream ID
        out[11] = frame.StreamID.B4()                    // Stream ID
        out[12] = byte(frame.DeltaWindowSize&gt;&gt;24) &amp; 0x7f // Delta Window Size
        out[13] = byte(frame.DeltaWindowSize &gt;&gt; 16)      // Delta Window Size
        out[14] = byte(frame.DeltaWindowSize &gt;&gt; 8)       // Delta Window Size
        out[15] = byte(frame.DeltaWindowSize)            // Delta Window Size

        err := common.WriteExactly(writer, out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return 16, nil</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">package spdy3

import (
        "net"
        "time"
)

func (c *Conn) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return c.stop
}</span>

func (c *Conn) Conn() net.Conn <span class="cov0" title="0">{
        return c.conn
}</span>

func (c *Conn) SetReadTimeout(d time.Duration) <span class="cov5" title="8">{
        c.timeoutLock.Lock()
        c.readTimeout = d
        c.timeoutLock.Unlock()
}</span>

func (c *Conn) SetWriteTimeout(d time.Duration) <span class="cov5" title="8">{
        c.timeoutLock.Lock()
        c.writeTimeout = d
        c.timeoutLock.Unlock()
}</span>

func (c *Conn) refreshReadTimeout() <span class="cov10" title="83">{
        c.timeoutLock.Lock()
        if d := c.readTimeout; d != 0 &amp;&amp; c.conn != nil </span><span class="cov8" title="34">{
                c.conn.SetReadDeadline(time.Now().Add(d))
        }</span>
        <span class="cov10" title="83">c.timeoutLock.Unlock()</span>
}

func (c *Conn) refreshWriteTimeout() <span class="cov9" title="73">{
        c.timeoutLock.Lock()
        if d := c.writeTimeout; d != 0 &amp;&amp; c.conn != nil </span><span class="cov8" title="47">{
                c.conn.SetWriteDeadline(time.Now().Add(d))
        }</span>
        <span class="cov9" title="73">c.timeoutLock.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file215" style="display: none">package spdy3

import (
        "runtime"
)

import (
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// readFrames is the main processing loop, where frames
// are read from the connection and processed individually.
// Returning from readFrames begins the cleanup and exit
// process for this connection.
func (c *Conn) readFrames() <span class="cov5" title="16">{
        // Ensure no panics happen.
        defer func() </span><span class="cov5" title="16">{
                if v := recover(); v != nil </span><span class="cov0" title="0">{
                        if !c.Closed() </span><span class="cov0" title="0">{
                                log.Printf("Encountered receive error: %v (%[1]T)\n", v)
                        }</span>
                }
        }()

        <span class="cov5" title="16">for </span><span class="cov7" title="83">{
                // This is the mechanism for handling too many benign errors.
                // By default MaxBenignErrors is 0, which ignores errors.
                too_many := c.numBenignErrors &gt; common.MaxBenignErrors &amp;&amp; common.MaxBenignErrors &gt; 0
                if c.criticalCheck(too_many, 0, "Ending connection for benign error buildup") </span><span class="cov0" title="0">{
                        return
                }</span>

                // ReadFrame takes care of the frame parsing for us.
                <span class="cov7" title="83">c.refreshReadTimeout()
                frame, err := frames.ReadFrame(c.buf, c.Subversion)
                if err != nil </span><span class="cov5" title="16">{
                        c.handleReadWriteError(err)
                        return
                }</span>

                <span class="cov7" title="67">debug.Printf("Receiving %s:\n", frame.Name()) // Print frame type.

                // Decompress the frame's headers, if there are any.
                err = frame.Decompress(c.decompressor)
                if c.criticalCheck(err != nil, 0, "Decompression: %v", err) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov7" title="67">debug.Println(frame) // Print frame once the content's been decompressed.

                if c.processFrame(frame) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// send is run in a separate goroutine. It's used
// to ensure clear interleaving of frames and to
// provide assurances of priority and structure.
func (c *Conn) send() <span class="cov5" title="16">{
        // Catch any panics.
        defer func() </span><span class="cov5" title="16">{
                if v := recover(); v != nil </span><span class="cov0" title="0">{
                        if !c.Closed() </span><span class="cov0" title="0">{
                                log.Printf("Encountered send error: %v (%[1]T)\n", v)
                        }</span>
                }
        }()

        <span class="cov5" title="16">for i := 1; ; i++ </span><span class="cov7" title="83">{
                if i &gt;= 5 </span><span class="cov4" title="8">{
                        i = 0 // Once per 5 frames, pick randomly.
                }</span>

                <span class="cov7" title="83">var frame common.Frame
                if i == 0 </span><span class="cov4" title="8">{ // Ignore priority.
                        frame = c.selectFrameToSend(false)
                }</span> <span class="cov7" title="75">else { // Normal selection.
                        frame = c.selectFrameToSend(true)
                }</span>

                <span class="cov7" title="77">if frame == nil </span><span class="cov3" title="4">{
                        c.Close()
                        return
                }</span>

                // Process connection-level flow control.
                <span class="cov7" title="73">if c.Subversion &gt; 0 </span><span class="cov6" title="37">{
                        c.connectionWindowLock.Lock()
                        if frame, ok := frame.(*frames.DATA); ok </span><span class="cov4" title="7">{
                                size := int64(len(frame.Data))
                                constrained := false
                                sending := size
                                if sending &gt; c.connectionWindowSize </span><span class="cov0" title="0">{
                                        sending = c.connectionWindowSize
                                        constrained = true
                                }</span>
                                <span class="cov4" title="7">if sending &lt; 0 </span><span class="cov0" title="0">{
                                        sending = 0
                                }</span>

                                <span class="cov4" title="7">c.connectionWindowSize -= sending

                                if constrained </span><span class="cov0" title="0">{
                                        // Chop off what we can send now.
                                        partial := new(frames.DATA)
                                        partial.Flags = frame.Flags
                                        partial.StreamID = frame.StreamID
                                        partial.Data = make([]byte, int(sending))
                                        copy(partial.Data, frame.Data[:sending])
                                        frame.Data = frame.Data[sending:]

                                        // Buffer this frame and try again.
                                        if c.dataBuffer == nil </span><span class="cov0" title="0">{
                                                c.dataBuffer = []*frames.DATA{frame}
                                        }</span> <span class="cov0" title="0">else {
                                                buffer := make([]*frames.DATA, 1, len(c.dataBuffer)+1)
                                                buffer[0] = frame
                                                buffer = append(buffer, c.dataBuffer...)
                                                c.dataBuffer = buffer
                                        }</span>

                                        <span class="cov0" title="0">frame = partial</span>
                                }
                        }
                        <span class="cov6" title="37">c.connectionWindowLock.Unlock()</span>
                }

                // Compress any name/value header blocks.
                <span class="cov7" title="73">err := frame.Compress(c.compressor)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error in compression: %v (type %T).\n", err, frame)
                        c.Close()
                        return
                }</span>

                <span class="cov7" title="73">debug.Printf("Sending %s:\n", frame.Name())
                debug.Println(frame)

                // Leave the specifics of writing to the
                // connection up to the frame.
                c.refreshWriteTimeout()
                if _, err = frame.WriteTo(c.conn); err != nil </span><span class="cov3" title="6">{
                        c.handleReadWriteError(err)
                        return
                }</span>
        }
}

// selectFrameToSend follows the specification's guidance
// on frame priority, sending frames with higher priority
// (a smaller number) first. If the given boolean is false,
// this priority is temporarily ignored, which can be used
// when high load is ignoring low-priority frames.
func (c *Conn) selectFrameToSend(prioritise bool) (frame common.Frame) <span class="cov7" title="83">{
        if c.Closed() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try buffered DATA frames first.
        <span class="cov7" title="83">if c.Subversion &gt; 0 </span><span class="cov6" title="42">{
                if c.dataBuffer != nil </span><span class="cov0" title="0">{
                        if len(c.dataBuffer) == 0 </span><span class="cov0" title="0">{
                                c.dataBuffer = nil
                        }</span> <span class="cov0" title="0">else {
                                first := c.dataBuffer[0]
                                if c.connectionWindowSize &gt;= int64(8+len(first.Data)) </span><span class="cov0" title="0">{
                                        if len(c.dataBuffer) &gt; 1 </span><span class="cov0" title="0">{
                                                c.dataBuffer = c.dataBuffer[1:]
                                        }</span> <span class="cov0" title="0">else {
                                                c.dataBuffer = nil
                                        }</span>
                                        <span class="cov0" title="0">return first</span>
                                }
                        }
                }
        }

        // Then in priority order.
        <span class="cov7" title="83">if prioritise </span><span class="cov7" title="75">{
                for i := 0; i &lt; 8; i++ </span><span class="cov10" title="315">{
                        select </span>{
                        <span class="cov7" title="49">case frame = &lt;-c.output[i]:
                                return frame</span>
                        <span class="cov9" title="266">default:</span>
                        }
                }

                // No frames are immediately pending, so if the
                // cection is being closed, cease sending
                // safely.
                <span class="cov6" title="26">c.sendingLock.Lock()
                if c.sending != nil </span><span class="cov3" title="6">{
                        close(c.sending)
                        c.sendingLock.Unlock()
                        runtime.Goexit()
                }</span>
                <span class="cov5" title="20">c.sendingLock.Unlock()</span>
        }

        // Wait for any frame.
        <span class="cov6" title="28">select </span>{
        <span class="cov5" title="19">case frame = &lt;-c.output[0]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[1]:
                return frame</span>
        <span class="cov3" title="4">case frame = &lt;-c.output[2]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[3]:
                return frame</span>
        <span class="cov1" title="1">case frame = &lt;-c.output[4]:
                return frame</span>
        <span class="cov0" title="0">case frame = &lt;-c.output[5]:
                return frame</span>
        <span class="cov1" title="1">case frame = &lt;-c.output[6]:
                return frame</span>
        <span class="cov2" title="3">case frame = &lt;-c.output[7]:
                return frame</span>
        <span class="cov0" title="0">case _ = &lt;-c.stop:
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file216" style="display: none">package spdy3

import (
        "fmt"
        "net/url"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// processFrame handles the initial processing of the given
// frame, before passing it on to the relevant helper func,
// if necessary. The returned boolean indicates whether the
// connection is closing.
func (c *Conn) processFrame(frame common.Frame) bool <span class="cov10" title="67">{
        switch frame := frame.(type) </span>{

        <span class="cov3" title="4">case *frames.SYN_STREAM:
                if c.server == nil </span><span class="cov1" title="1">{
                        c.handlePush(frame)
                }</span> <span class="cov3" title="3">else {
                        c.handleRequest(frame)
                }</span>
        <span class="cov3" title="4">case *frames.SYN_STREAMV3_1:
                f3 := new(frames.SYN_STREAM)
                f3.Flags = frame.Flags
                f3.StreamID = frame.StreamID
                f3.AssocStreamID = frame.AssocStreamID
                f3.Priority = frame.Priority
                f3.Slot = 0
                f3.Header = frame.Header
                if c.server == nil </span><span class="cov1" title="1">{
                        c.handlePush(f3)
                }</span> <span class="cov3" title="3">else {
                        c.handleRequest(f3)
                }</span>

        <span class="cov4" title="6">case *frames.SYN_REPLY:
                c.handleSynReply(frame)</span>

        <span class="cov0" title="0">case *frames.RST_STREAM:
                if frame.Status.IsFatal() </span><span class="cov0" title="0">{
                        code := frame.Status.String()
                        log.Printf("Warning: Received %s on stream %d. Closing connection.\n", code, frame.StreamID)
                        c.shutdownError = frame
                        c.Close()
                        return true
                }</span>
                <span class="cov0" title="0">c.handleRstStream(frame)</span>

        <span class="cov6" title="16">case *frames.SETTINGS:
                for _, setting := range frame.Settings </span><span class="cov8" title="32">{
                        c.receivedSettings[setting.ID] = setting
                        switch setting.ID </span>{
                        <span class="cov6" title="16">case common.SETTINGS_INITIAL_WINDOW_SIZE:
                                c.initialWindowSizeLock.Lock()
                                initial := int64(c.initialWindowSize)
                                current := c.connectionWindowSize
                                inbound := int64(setting.Value)
                                if initial != inbound </span><span class="cov6" title="16">{
                                        if initial &gt; inbound </span><span class="cov5" title="8">{
                                                c.connectionWindowSize = inbound - (initial - current)
                                        }</span> <span class="cov5" title="8">else {
                                                c.connectionWindowSize += (inbound - initial)
                                        }</span>
                                        <span class="cov6" title="16">c.initialWindowSize = setting.Value</span>
                                }
                                <span class="cov6" title="16">c.initialWindowSizeLock.Unlock()</span>

                        <span class="cov6" title="16">case common.SETTINGS_MAX_CONCURRENT_STREAMS:
                                if c.server == nil </span><span class="cov5" title="8">{
                                        c.requestStreamLimit.SetLimit(setting.Value)
                                }</span> <span class="cov5" title="8">else {
                                        c.pushStreamLimit.SetLimit(setting.Value)
                                }</span>
                        }
                }

        <span class="cov5" title="8">case *frames.PING:
                // Check whether Ping ID is a response.
                c.nextPingIDLock.Lock()
                next := c.nextPingID
                c.nextPingIDLock.Unlock()
                if frame.PingID&amp;1 == next&amp;1 </span><span class="cov3" title="4">{
                        c.pingsLock.Lock()
                        if c.check(c.pings[frame.PingID] == nil, "Ignored unrequested PING %d", frame.PingID) </span><span class="cov0" title="0">{
                                c.pingsLock.Unlock()
                                return false
                        }</span>
                        <span class="cov3" title="4">c.pings[frame.PingID] &lt;- true
                        close(c.pings[frame.PingID])
                        delete(c.pings, frame.PingID)
                        c.pingsLock.Unlock()</span>
                } <span class="cov3" title="4">else {
                        debug.Println("Received PING. Replying...")
                        c.output[0] &lt;- frame
                }</span>

        <span class="cov5" title="10">case *frames.GOAWAY:
                lastProcessed := frame.LastGoodStreamID
                c.streamsLock.Lock()
                for streamID, stream := range c.streams </span><span class="cov5" title="8">{
                        if streamID&amp;1 == c.oddity &amp;&amp; streamID &gt; lastProcessed </span><span class="cov0" title="0">{
                                // Stream is locally-sent and has not been processed.
                                // TODO: Inform the server that the push has not been successful.
                                stream.Close()
                        }</span>
                }
                <span class="cov5" title="10">c.streamsLock.Unlock()
                c.shutdownError = frame
                c.goawayLock.Lock()
                c.goawayReceived = true
                c.goawayLock.Unlock()</span>

        <span class="cov2" title="2">case *frames.HEADERS:
                c.handleHeaders(frame)</span>

        <span class="cov3" title="3">case *frames.WINDOW_UPDATE:
                c.handleWindowUpdate(frame)</span>

        <span class="cov0" title="0">case *frames.CREDENTIAL:
                if c.Subversion &gt; 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if c.server == nil || c.certificates == nil </span><span class="cov0" title="0">{
                        log.Println("Ignored unexpected CREDENTIAL.")
                        return false
                }</span>
                <span class="cov0" title="0">if frame.Slot &gt;= c.vectorIndex </span><span class="cov0" title="0">{
                        setting := new(frames.SETTINGS)
                        setting.Settings = common.Settings{
                                common.SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE: &amp;common.Setting{
                                        ID:    common.SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE,
                                        Value: uint32(frame.Slot + 4),
                                },
                        }
                        c.output[0] &lt;- setting
                        c.vectorIndex += 4
                }</span>
                <span class="cov0" title="0">c.certificates[frame.Slot] = frame.Certificates</span>

        <span class="cov6" title="14">case *frames.DATA:
                if c.Subversion &gt; 0 </span><span class="cov5" title="7">{
                        // The transfer window shouldn't already be negative.
                        if c.connectionWindowSizeThere &lt; 0 </span><span class="cov0" title="0">{
                                c._GOAWAY(common.GOAWAY_FLOW_CONTROL_ERROR)
                                return false
                        }</span>

                        <span class="cov5" title="7">c.connectionWindowSizeThere -= int64(len(frame.Data))

                        c.flowControlLock.Lock()
                        f := c.flowControl
                        c.flowControlLock.Unlock()
                        delta := f.ReceiveData(0, c.initialWindowSizeThere, c.connectionWindowSizeThere)
                        if delta != 0 </span><span class="cov1" title="1">{
                                grow := new(frames.WINDOW_UPDATE)
                                grow.StreamID = 0
                                grow.DeltaWindowSize = delta
                                c.output[0] &lt;- grow
                                c.connectionWindowSizeThere += int64(grow.DeltaWindowSize)
                        }</span>
                }
                <span class="cov6" title="14">if c.server == nil </span><span class="cov6" title="12">{
                        c.handleServerData(frame)
                }</span> <span class="cov2" title="2">else {
                        c.handleClientData(frame)
                }</span>

        <span class="cov0" title="0">default:
                log.Println(fmt.Sprintf("Ignored unexpected frame type %T", frame))</span>
        }
        <span class="cov10" title="67">return false</span>
}

// handleClientData performs the processing of DATA frames sent by the client.
func (c *Conn) handleClientData(frame *frames.DATA) <span class="cov2" title="2">{
        sid := frame.StreamID

        if c.check(c.server == nil, "Client received request") </span><span class="cov0" title="0">{
                return
        }</span>

        // Handle request data.
        <span class="cov2" title="2">if c.check(sid&amp;1 == 0, "Received DATA with even Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check stream ID is valid.
        <span class="cov2" title="2">if c.criticalCheck(!sid.Valid(), sid, "Received DATA with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Check stream is open.
        <span class="cov2" title="2">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received DATA with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">stream.ReceiveFrame(frame)</span> // Send data to stream.
}

// handleHeaders performs the processing of HEADERS frames.
func (c *Conn) handleHeaders(frame *frames.HEADERS) <span class="cov2" title="2">{
        sid := frame.StreamID

        // Handle push headers.
        if sid&amp;1 == 0 &amp;&amp; c.server == nil </span><span class="cov2" title="2">{
                // Ignore refused push headers.
                if req := c.pushRequests[sid]; req != nil &amp;&amp; c.PushReceiver != nil </span><span class="cov2" title="2">{
                        c.PushReceiver.ReceiveHeader(req, frame.Header)
                }</span>
                <span class="cov2" title="2">return</span>
        }

        // Check stream is open.
        <span class="cov0" title="0">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received HEADERS with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">stream.ReceiveFrame(frame)</span> // Send headers to stream.
}

// handlePush performs the processing of SYN_STREAM frames forming a server push.
func (c *Conn) handlePush(frame *frames.SYN_STREAM) <span class="cov2" title="2">{
        sid := frame.StreamID

        // Check stream creation is allowed.
        c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway || c.Closed() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">if c.server != nil </span><span class="cov0" title="0">{
                log.Println("Error: Only clients can receive server pushes.")
                return
        }</span>

        <span class="cov2" title="2">if c.check(sid&amp;1 != 0, "Received SYN_STREAM with odd Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">c.lastPushStreamIDLock.Lock()
        lsid := c.lastPushStreamID
        c.lastPushStreamIDLock.Unlock()
        if c.check(sid &lt;= lsid, "Received SYN_STREAM with Stream ID %d, less than %d", sid, lsid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">if c.criticalCheck(!sid.Valid(), sid, "Received SYN_STREAM with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.

        // Check stream limit would allow the new stream.
        <span class="cov2" title="2">if !c.pushStreamLimit.Add() </span><span class="cov0" title="0">{
                c._RST_STREAM(sid, common.RST_STREAM_REFUSED_STREAM)
                return
        }</span>

        <span class="cov2" title="2">ok := frame.Priority.Valid(3)
        if c.criticalCheck(!ok, sid, "Received SYN_STREAM with invalid priority %d", frame.Priority) </span><span class="cov0" title="0">{
                return
        }</span>

        // Parse the request.
        <span class="cov2" title="2">header := frame.Header
        rawUrl := header.Get(":scheme") + "://" + header.Get(":host") + header.Get(":path")
        url, err := url.Parse(rawUrl)
        if c.check(err != nil, "Received SYN_STREAM with invalid request URL (%v)", err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">vers := header.Get(":version")
        major, minor, ok := http.ParseHTTPVersion(vers)
        if c.check(!ok, "Invalid HTTP version: "+vers) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">method := header.Get(":method")
        request := &amp;http.Request{
                Method:     method,
                URL:        url,
                Proto:      vers,
                ProtoMajor: major,
                ProtoMinor: minor,
                RemoteAddr: c.remoteAddr,
                Header:     header,
                Host:       url.Host,
                RequestURI: url.RequestURI(),
                TLS:        c.tlsState,
        }

        // Check whether the receiver wants this resource.
        if c.PushReceiver != nil &amp;&amp; !c.PushReceiver.ReceiveRequest(request) </span><span class="cov0" title="0">{
                c._RST_STREAM(sid, common.RST_STREAM_REFUSED_STREAM)
                return
        }</span>

        <span class="cov2" title="2">if c.PushReceiver != nil </span><span class="cov2" title="2">{
                c.pushRequests[sid] = request
                c.lastPushStreamIDLock.Lock()
                c.lastPushStreamID = sid
                c.lastPushStreamIDLock.Unlock()
                c.PushReceiver.ReceiveHeader(request, frame.Header)
        }</span>
}

// handleRequest performs the processing of SYN_STREAM request frames.
func (c *Conn) handleRequest(frame *frames.SYN_STREAM) <span class="cov4" title="6">{
        // Check stream creation is allowed.
        c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway || c.Closed() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">sid := frame.StreamID

        if c.criticalCheck(c.server == nil, sid, "Client received request") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">if c.check(sid&amp;1 == 0, "Received SYN_STREAM with even Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">c.lastRequestStreamIDLock.Lock()
        lsid := c.lastRequestStreamID
        c.lastRequestStreamIDLock.Unlock()
        if c.check(sid &lt;= lsid &amp;&amp; lsid != 0, "Received SYN_STREAM with Stream ID %d, less than %d", sid, lsid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">if c.criticalCheck(!sid.Valid(), sid, "Received SYN_STREAM with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.

        // Check stream limit would allow the new stream.
        <span class="cov4" title="6">if !c.requestStreamLimit.Add() </span><span class="cov0" title="0">{
                c._RST_STREAM(sid, common.RST_STREAM_REFUSED_STREAM)
                return
        }</span>

        <span class="cov4" title="6">p := frame.Priority
        if c.criticalCheck(!p.Valid(3), sid, "Received SYN_STREAM with bad priority %d.\n", p) </span><span class="cov0" title="0">{
                return
        }</span>

        // Create and start new stream.
        <span class="cov4" title="6">nextStream := c.newStream(frame)
        if nextStream == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">c.streamsLock.Lock()
        c.streams[sid] = nextStream
        c.streamsLock.Unlock()
        c.lastRequestStreamIDLock.Lock()
        c.lastRequestStreamID = sid
        c.lastRequestStreamIDLock.Unlock()
        go nextStream.Run()</span>
}

// handleRstStream performs the processing of RST_STREAM frames.
func (c *Conn) handleRstStream(frame *frames.RST_STREAM) <span class="cov0" title="0">{
        sid := frame.StreamID
        c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()

        // Determine the status code and react accordingly.
        switch frame.Status </span>{
        <span class="cov0" title="0">case common.RST_STREAM_INVALID_STREAM,
                common.RST_STREAM_STREAM_ALREADY_CLOSED:
                if stream != nil </span><span class="cov0" title="0">{
                        go stream.Close()
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        <span class="cov0" title="0">case common.RST_STREAM_STREAM_IN_USE:
                c.check(true, "Received %s for stream ID %d", frame.Status, sid)</span>

        <span class="cov0" title="0">case common.RST_STREAM_CANCEL: // Allow cancelling of pushes.
                if c.check(sid&amp;1 == c.oddity &amp;&amp; stream == nil, "Cannot cancel locally-sent streams") </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        <span class="cov0" title="0">case common.RST_STREAM_REFUSED_STREAM:
                if stream != nil </span><span class="cov0" title="0">{
                        go stream.Close()
                }</span>

        <span class="cov0" title="0">case common.RST_STREAM_FLOW_CONTROL_ERROR:
                c.numBenignErrors++</span>

        <span class="cov0" title="0">case common.RST_STREAM_INVALID_CREDENTIALS:
                if c.Subversion &gt; 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">c.check(true, "Received INVALID_CREDENTIALS for stream ID %d.\n", sid)</span>

        <span class="cov0" title="0">default:
                c.criticalCheck(true, sid, "Received unknown RST_STREAM status code %d", frame.Status)</span>
        }
}

// handleServerData performs the processing of DATA frames sent by the server.
func (c *Conn) handleServerData(frame *frames.DATA) <span class="cov6" title="12">{
        sid := frame.StreamID

        if sid&amp;1 == 0 </span><span class="cov3" title="4">{ // Handle push data.
                // Ignore refused push data.
                if req := c.pushRequests[sid]; req != nil &amp;&amp; c.PushReceiver != nil </span><span class="cov3" title="4">{
                        c.PushReceiver.ReceiveData(req, frame.Data, frame.Flags.FIN())
                }</span>
                <span class="cov3" title="4">return</span>
        }

        // Check stream is open.
        <span class="cov5" title="8">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received DATA with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.
        <span class="cov5" title="8">stream.ReceiveFrame(frame)</span>
}

// handleSynReply performs the processing of SYN_REPLY frames.
func (c *Conn) handleSynReply(frame *frames.SYN_REPLY) <span class="cov4" title="6">{
        sid := frame.StreamID

        if c.check(c.server != nil, "Only clients can receive SYN_REPLY frames") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">if c.check(sid&amp;1 == 0, "Received SYN_REPLY with even Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">if c.criticalCheck(!sid.Valid(), sid, "Received SYN_REPLY with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="6">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        closed := stream == nil || stream.State().ClosedThere()
        if c.check(closed, "Received SYN_REPLY with unopened or closed Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        // Stream ID is fine.
        <span class="cov4" title="6">stream.ReceiveFrame(frame)</span>
}

// handleWindowUpdate performs the processing of WINDOW_UPDATE frames.
func (c *Conn) handleWindowUpdate(frame *frames.WINDOW_UPDATE) <span class="cov3" title="3">{
        sid := frame.StreamID

        if c.criticalCheck(!sid.Valid(), sid, "Received WINDOW_UPDATE with excessive Stream ID %d", sid) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">delta := frame.DeltaWindowSize
        bad := delta &gt; common.MAX_DELTA_WINDOW_SIZE || delta &lt; 1
        if c.criticalCheck(bad, sid, "Received WINDOW_UPDATE with invalid delta window size %d", delta) </span><span class="cov0" title="0">{
                return
        }</span>

        // Handle connection-level flow control.
        <span class="cov3" title="3">if sid.Zero() &amp;&amp; c.Subversion &gt; 0 </span><span class="cov1" title="1">{
                c.connectionWindowLock.Lock()
                defer c.connectionWindowLock.Unlock()

                if int64(delta)+c.connectionWindowSize &gt; common.MAX_TRANSFER_WINDOW_SIZE </span><span class="cov0" title="0">{
                        goaway := new(frames.GOAWAY)
                        if c.server != nil </span><span class="cov0" title="0">{
                                c.lastRequestStreamIDLock.Lock()
                                goaway.LastGoodStreamID = c.lastRequestStreamID
                                c.lastRequestStreamIDLock.Unlock()
                        }</span> <span class="cov0" title="0">else {
                                c.lastPushStreamIDLock.Lock()
                                goaway.LastGoodStreamID = c.lastPushStreamID
                                c.lastPushStreamIDLock.Unlock()
                        }</span>
                        <span class="cov0" title="0">goaway.Status = common.GOAWAY_FLOW_CONTROL_ERROR
                        c.output[0] &lt;- goaway
                        return</span>
                }
                <span class="cov1" title="1">c.connectionWindowSize += int64(delta)
                return</span>
        }

        // Check stream is open.
        <span class="cov2" title="2">c.streamsLock.Lock()
        stream := c.streams[sid]
        c.streamsLock.Unlock()
        if stream == nil || stream.State().ClosedHere() </span><span class="cov2" title="2">{
                // This is almost certainly benign
                return
        }</span>

        // Stream ID is fine.
        <span class="cov0" title="0">stream.ReceiveFrame(frame)</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy3

import (
        "errors"
        "fmt"
        "sync"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// PushStream is a structure that implements the
// Stream and PushWriter interfaces. this is used
// for performing server pushes.
type PushStream struct {
        sync.Mutex

        shutdownOnce sync.Once
        conn         *Conn
        streamID     common.StreamID
        flow         *flowControl
        origin       common.Stream
        state        *common.StreamState
        output       chan&lt;- common.Frame
        header       http.Header
        stop         &lt;-chan bool
}

func NewPushStream(conn *Conn, streamID common.StreamID, origin common.Stream, output chan&lt;- common.Frame) *PushStream <span class="cov4" title="2">{
        out := new(PushStream)
        out.conn = conn
        out.streamID = streamID
        out.origin = origin
        out.output = output
        out.stop = conn.stop
        out.state = new(common.StreamState)
        out.header = make(http.Header)
        return out
}</span>

/***********************
 * http.ResponseWriter *
 ***********************/

func (p *PushStream) Header() http.Header <span class="cov4" title="2">{
        return p.header
}</span>

// Write is used for sending data in the push.
func (p *PushStream) Write(inputData []byte) (int, error) <span class="cov4" title="2">{
        if p.closed() || p.state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream already closed.")
        }</span>

        <span class="cov4" title="2">state := p.origin.State()
        if p.origin == nil || state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Origin stream is closed.")
        }</span>

        <span class="cov4" title="2">p.writeHeader()

        // Copy the data locally to avoid any pointer issues.
        data := make([]byte, len(inputData))
        copy(data, inputData)

        // Chunk the response if necessary.
        // Data is sent to the flow control to
        // ensure that the protocol is followed.
        written := 0
        for len(data) &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                n, err := p.flow.Write(data[:common.MAX_DATA_SIZE])
                if err != nil </span><span class="cov0" title="0">{
                        return written, err
                }</span>
                <span class="cov0" title="0">written += n
                data = data[common.MAX_DATA_SIZE:]</span>
        }

        <span class="cov4" title="2">n, err := p.flow.Write(data)
        written += n

        return written, err</span>
}

// WriteHeader is provided to satisfy the Stream
// interface, but has no effect.
func (p *PushStream) WriteHeader(int) <span class="cov0" title="0">{
        p.writeHeader()
        return
}</span>

/*****************
 * io.Closer *
 *****************/

func (p *PushStream) Close() error <span class="cov7" title="4">{
        defer common.Recover()
        p.Lock()
        p.shutdownOnce.Do(p.shutdown)
        p.Unlock()
        return nil
}</span>

func (p *PushStream) shutdown() <span class="cov4" title="2">{
        p.writeHeader()
        if p.state != nil </span><span class="cov4" title="2">{
                p.state.Close()
        }</span>
        <span class="cov4" title="2">if p.flow != nil </span><span class="cov4" title="2">{
                p.flow.Close()
        }</span>
        <span class="cov4" title="2">p.conn.pushStreamLimit.Close()
        p.origin = nil
        p.output = nil
        p.header = nil
        p.stop = nil</span>
}

/**********
 * Stream *
 **********/

func (p *PushStream) Conn() common.Conn <span class="cov4" title="2">{
        return p.conn
}</span>

func (p *PushStream) ReceiveFrame(frame common.Frame) error <span class="cov0" title="0">{
        p.Lock()
        defer p.Unlock()

        if frame == nil </span><span class="cov0" title="0">{
                return errors.New("Error: Nil frame received.")
        }</span>

        // Process the frame depending on its type.
        <span class="cov0" title="0">switch frame := frame.(type) </span>{
        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:
                err := p.flow.UpdateWindow(frame.DeltaWindowSize)
                if err != nil </span><span class="cov0" title="0">{
                        reply := new(frames.RST_STREAM)
                        reply.StreamID = p.streamID
                        reply.Status = common.RST_STREAM_FLOW_CONTROL_ERROR
                        p.output &lt;- reply
                        return err
                }</span>

        <span class="cov0" title="0">default:
                return errors.New(fmt.Sprintf("Received unexpected frame of type %T.", frame))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (p *PushStream) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return p.stop
}</span>

func (p *PushStream) Run() error <span class="cov0" title="0">{
        return nil
}</span>

func (p *PushStream) State() *common.StreamState <span class="cov0" title="0">{
        return p.state
}</span>

func (p *PushStream) StreamID() common.StreamID <span class="cov0" title="0">{
        return p.streamID
}</span>

/**************
 * PushStream *
 **************/

func (p *PushStream) Finish() <span class="cov4" title="2">{
        p.writeHeader()
        end := new(frames.DATA)
        end.StreamID = p.streamID
        end.Data = []byte{}
        end.Flags = common.FLAG_FIN
        p.output &lt;- end
        p.Close()
}</span>

/**********
 * Others *
 **********/

func (p *PushStream) closed() bool <span class="cov7" title="4">{
        if p.conn == nil || p.state == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov7" title="4">select </span>{
        <span class="cov0" title="0">case _ = &lt;-p.stop:
                return true</span>
        <span class="cov7" title="4">default:
                return false</span>
        }
}

// writeHeader is used to send HTTP headers to
// the client.
func (p *PushStream) writeHeader() <span class="cov10" title="6">{
        if len(p.header) == 0 || p.closed() </span><span class="cov7" title="4">{
                return
        }</span>

        <span class="cov4" title="2">header := new(frames.HEADERS)
        header.StreamID = p.streamID
        header.Header = make(http.Header)

        for name, values := range p.header </span><span class="cov4" title="2">{
                for _, value := range values </span><span class="cov4" title="2">{
                        header.Header.Add(name, value)
                }</span>
                <span class="cov4" title="2">p.header.Del(name)</span>
        }

        <span class="cov4" title="2">if len(header.Header) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="2">p.output &lt;- header</span>
}
</pre>
		
		<pre class="file" id="file218" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy3

import (
        "errors"
        "fmt"
        "sync"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// RequestStream is a structure that implements
// the Stream and ResponseWriter interfaces. This
// is used for responding to client requests.
type RequestStream struct {
        sync.Mutex
        Request  *http.Request
        Receiver common.Receiver

        recvMutex    sync.Mutex
        shutdownOnce sync.Once
        conn         *Conn
        streamID     common.StreamID
        flow         *flowControl
        state        *common.StreamState
        output       chan&lt;- common.Frame
        header       http.Header
        headerChan   chan func()
        responseCode int
        stop         &lt;-chan bool
        finished     chan struct{}
}

func NewRequestStream(conn *Conn, streamID common.StreamID, output chan&lt;- common.Frame) *RequestStream <span class="cov6" title="6">{
        out := new(RequestStream)
        out.conn = conn
        out.streamID = streamID
        out.output = output
        out.stop = conn.stop
        out.state = new(common.StreamState)
        out.state.CloseHere()
        out.header = make(http.Header)
        out.finished = make(chan struct{})
        out.headerChan = make(chan func(), 5)
        go out.processFrames()
        return out
}</span>

/***********************
 * http.ResponseWriter *
 ***********************/

func (s *RequestStream) Header() http.Header <span class="cov0" title="0">{
        return s.header
}</span>

// Write is one method with which request data is sent.
func (s *RequestStream) Write(inputData []byte) (int, error) <span class="cov0" title="0">{
        if s.closed() || s.state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream already closed.")
        }</span>

        // Copy the data locally to avoid any pointer issues.
        <span class="cov0" title="0">data := make([]byte, len(inputData))
        copy(data, inputData)

        // Send any new headers.
        s.writeHeader()

        // Chunk the response if necessary.
        // Data is sent to the flow control to
        // ensure that the protocol is followed.
        written := 0
        for len(data) &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                n, err := s.flow.Write(data[:common.MAX_DATA_SIZE])
                if err != nil </span><span class="cov0" title="0">{
                        return written, err
                }</span>
                <span class="cov0" title="0">written += n
                data = data[common.MAX_DATA_SIZE:]</span>
        }

        <span class="cov0" title="0">if len(data) &gt; 0 </span><span class="cov0" title="0">{
                n, err := s.flow.Write(data)
                written += n
                if err != nil </span><span class="cov0" title="0">{
                        return written, err
                }</span>
        }

        <span class="cov0" title="0">return written, nil</span>
}

// WriteHeader is used to set the HTTP status code.
func (s *RequestStream) WriteHeader(int) <span class="cov0" title="0">{
        s.writeHeader()
}</span>

/*****************
 * io.Closer *
 *****************/

// Close is used to stop the stream safely.
func (s *RequestStream) Close() error <span class="cov9" title="12">{
        defer common.Recover()
        s.Lock()
        s.shutdownOnce.Do(s.shutdown)
        s.Unlock()
        return nil
}</span>

func (s *RequestStream) shutdown() <span class="cov6" title="6">{
        s.writeHeader()
        if s.state != nil </span><span class="cov6" title="6">{
                if s.state.OpenThere() </span><span class="cov0" title="0">{
                        // Send the RST_STREAM.
                        rst := new(frames.RST_STREAM)
                        rst.StreamID = s.streamID
                        rst.Status = common.RST_STREAM_CANCEL
                        s.output &lt;- rst
                }</span>
                <span class="cov6" title="6">s.state.Close()</span>
        }
        <span class="cov6" title="6">if s.flow != nil </span><span class="cov6" title="6">{
                s.flow.Close()
        }</span>
        <span class="cov6" title="6">select </span>{
        <span class="cov0" title="0">case &lt;-s.finished:</span>
        <span class="cov6" title="6">default:
                close(s.finished)</span>
        }
        <span class="cov6" title="6">select </span>{
        <span class="cov0" title="0">case &lt;-s.headerChan:</span>
        <span class="cov6" title="6">default:
                close(s.headerChan)</span>
        }
        <span class="cov6" title="6">s.conn.requestStreamLimit.Close()
        s.output = nil
        s.Request = nil
        s.Receiver = nil
        s.header = nil
        s.stop = nil</span>
}

/**********
 * Stream *
 **********/

func (s *RequestStream) Conn() common.Conn <span class="cov0" title="0">{
        return s.conn
}</span>

func (s *RequestStream) ReceiveFrame(frame common.Frame) error <span class="cov9" title="14">{
        s.recvMutex.Lock()
        defer s.recvMutex.Unlock()

        if frame == nil </span><span class="cov0" title="0">{
                return errors.New("Nil frame received.")
        }</span>

        // Process the frame depending on its type.
        <span class="cov9" title="14">switch frame := frame.(type) </span>{
        <span class="cov7" title="8">case *frames.DATA:

                // Extract the data.
                data := frame.Data
                if data == nil </span><span class="cov0" title="0">{
                        data = []byte{}
                }</span>

                // Give to the client.
                <span class="cov7" title="8">s.flow.Receive(frame.Data)
                s.headerChan &lt;- func() </span><span class="cov7" title="8">{
                        s.Receiver.ReceiveData(s.Request, data, frame.Flags.FIN())

                        if frame.Flags.FIN() </span><span class="cov6" title="6">{
                                s.state.CloseThere()
                                s.Close()
                        }</span>
                }

        <span class="cov6" title="6">case *frames.SYN_REPLY:
                s.headerChan &lt;- func() </span><span class="cov6" title="6">{
                        s.Receiver.ReceiveHeader(s.Request, frame.Header)

                        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                                s.state.CloseThere()
                                s.Close()
                        }</span>
                }

        <span class="cov0" title="0">case *frames.HEADERS:
                s.headerChan &lt;- func() </span><span class="cov0" title="0">{
                        s.Receiver.ReceiveHeader(s.Request, frame.Header)

                        if frame.Flags.FIN() </span><span class="cov0" title="0">{
                                s.state.CloseThere()
                                s.Close()
                        }</span>
                }

        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:
                err := s.flow.UpdateWindow(frame.DeltaWindowSize)
                if err != nil </span><span class="cov0" title="0">{
                        reply := new(frames.RST_STREAM)
                        reply.StreamID = s.streamID
                        reply.Status = common.RST_STREAM_FLOW_CONTROL_ERROR
                        s.output &lt;- reply
                }</span>

        <span class="cov0" title="0">default:
                return errors.New(fmt.Sprintf("Received unknown frame of type %T.", frame))</span>
        }

        <span class="cov9" title="14">return nil</span>
}

func (s *RequestStream) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return s.stop
}</span>

// run is the main control path of
// the stream. Data is recieved,
// processed, and then the stream
// is cleaned up and closed.
func (s *RequestStream) Run() error <span class="cov6" title="6">{
        // Receive and process inbound frames.
        &lt;-s.finished

        // Make sure any queued data has been sent.
        if s.flow.Paused() </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("Error: Stream %d has been closed with data still buffered.\n", s.streamID))
        }</span>

        // Clean up state.
        <span class="cov6" title="6">s.state.CloseHere()
        return nil</span>
}

func (s *RequestStream) State() *common.StreamState <span class="cov10" title="16">{
        return s.state
}</span>

func (s *RequestStream) StreamID() common.StreamID <span class="cov0" title="0">{
        return s.streamID
}</span>

func (s *RequestStream) closed() bool <span class="cov0" title="0">{
        if s.conn == nil || s.state == nil || s.Receiver == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">select </span>{
        <span class="cov0" title="0">case _ = &lt;-s.stop:
                return true</span>
        <span class="cov0" title="0">default:
                return false</span>
        }
}

// writeHeader is used to flush HTTP headers.
func (s *RequestStream) writeHeader() <span class="cov6" title="6">{
        if len(s.header) == 0 </span><span class="cov6" title="6">{
                return
        }</span>

        // Create the HEADERS frame.
        <span class="cov0" title="0">header := new(frames.HEADERS)
        header.StreamID = s.streamID
        header.Header = make(http.Header)

        // Clear the headers that have been sent.
        for name, values := range s.header </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        header.Header.Add(name, value)
                }</span>
                <span class="cov0" title="0">s.header.Del(name)</span>
        }

        <span class="cov0" title="0">s.output &lt;- header</span>
}

func (s *RequestStream) processFrames() <span class="cov6" title="6">{
        defer common.Recover()
        for f := range s.headerChan </span><span class="cov9" title="14">{
                f()
        }</span>
}
</pre>
		
		<pre class="file" id="file219" style="display: none">package spdy3

import (
        "errors"
        "fmt"
        "io"
        "strings"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// Request is used to make a client request.
func (c *Conn) Request(request *http.Request, receiver common.Receiver, priority common.Priority) (common.Stream, error) <span class="cov10" title="6">{
        if c.Closed() </span><span class="cov0" title="0">{
                return nil, common.ErrConnClosed
        }</span>
        <span class="cov10" title="6">c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway </span><span class="cov0" title="0">{
                return nil, common.ErrGoaway
        }</span>

        <span class="cov10" title="6">if c.server != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Only clients can send requests.")
        }</span>

        // Check stream limit would allow the new stream.
        <span class="cov10" title="6">if !c.requestStreamLimit.Add() </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Max concurrent streams limit exceeded.")
        }</span>

        <span class="cov10" title="6">if !priority.Valid(3) </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Priority must be in the range 0 - 7.")
        }</span>

        <span class="cov10" title="6">url := request.URL
        if url == nil || url.Scheme == "" || url.Host == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Incomplete path provided to resource.")
        }</span>

        // Prepare the SYN_STREAM.
        <span class="cov10" title="6">path := url.Path
        if url.RawQuery != "" </span><span class="cov0" title="0">{
                path += "?" + url.RawQuery
        }</span>
        <span class="cov10" title="6">if url.Fragment != "" </span><span class="cov0" title="0">{
                path += "#" + url.Fragment
        }</span>
        <span class="cov10" title="6">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>

        <span class="cov10" title="6">host := url.Host
        if len(request.Host) &gt; 0 </span><span class="cov10" title="6">{
                host = request.Host
        }</span>
        <span class="cov10" title="6">syn := new(frames.SYN_STREAM)
        syn.Priority = priority
        syn.Header = request.Header
        syn.Header.Set(":method", request.Method)
        syn.Header.Set(":path", path)
        syn.Header.Set(":version", "HTTP/1.1")
        syn.Header.Set(":host", host)
        syn.Header.Set(":scheme", url.Scheme)

        // Prepare the request body, if any.
        body := make([]*frames.DATA, 0, 1)
        if request.Body != nil </span><span class="cov4" title="2">{
                buf := make([]byte, 32*1024)
                n, err := request.Body.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="2">total := n
                for n &gt; 0 </span><span class="cov4" title="2">{
                        data := new(frames.DATA)
                        data.Data = make([]byte, n)
                        copy(data.Data, buf[:n])
                        body = append(body, data)
                        n, err = request.Body.Read(buf)
                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov4" title="2">total += n</span>
                }

                // Half-close the stream.
                <span class="cov4" title="2">if len(body) == 0 </span><span class="cov0" title="0">{
                        syn.Flags = common.FLAG_FIN
                }</span> <span class="cov4" title="2">else {
                        syn.Header.Set("Content-Length", fmt.Sprint(total))
                        body[len(body)-1].Flags = common.FLAG_FIN
                }</span>
                <span class="cov4" title="2">request.Body.Close()</span>
        } <span class="cov7" title="4">else {
                syn.Flags = common.FLAG_FIN
        }</span>

        // Send.
        <span class="cov10" title="6">c.streamCreation.Lock()
        defer c.streamCreation.Unlock()

        c.lastRequestStreamIDLock.Lock()
        if c.lastRequestStreamID == 0 </span><span class="cov7" title="4">{
                c.lastRequestStreamID = 1
        }</span> <span class="cov4" title="2">else {
                c.lastRequestStreamID += 2
        }</span>
        <span class="cov10" title="6">syn.StreamID = c.lastRequestStreamID
        c.lastRequestStreamIDLock.Unlock()
        if syn.StreamID &gt; common.MAX_STREAM_ID </span><span class="cov0" title="0">{
                return nil, errors.New("Error: All client streams exhausted.")
        }</span>
        <span class="cov10" title="6">c.output[0] &lt;- syn
        for _, frame := range body </span><span class="cov4" title="2">{
                frame.StreamID = syn.StreamID
                c.output[0] &lt;- frame
        }</span>

        // Create the request stream.
        <span class="cov10" title="6">out := NewRequestStream(c, syn.StreamID, c.output[0])
        out.Request = request
        out.Receiver = receiver
        out.AddFlowControl(c.flowControl)
        c.streamsLock.Lock()
        c.streams[syn.StreamID] = out // Store in the connection map.
        c.streamsLock.Unlock()

        return out, nil</span>
}

func (c *Conn) RequestResponse(request *http.Request, receiver common.Receiver, priority common.Priority) (*http.Response, error) <span class="cov10" title="6">{
        res := common.NewResponse(request, receiver)

        // Send the request.
        stream, err := c.Request(request, res, priority)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Let the request run its course.
        <span class="cov10" title="6">stream.Run()

        return res.Response(), c.shutdownError</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">// Copyright 2013 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy3

import (
        "bytes"
        "errors"
        "fmt"
    "runtime"
        "strconv"
        "sync"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// ResponseStream is a structure that implements the
// Stream interface. This is used for responding to
// client requests.
type ResponseStream struct {
        sync.Mutex

        shutdownOnce   sync.Once
        conn           *Conn
        streamID       common.StreamID
        flow           *flowControl
        requestBody    *bytes.Buffer
        state          *common.StreamState
        output         chan&lt;- common.Frame
        request        *http.Request
        handler        http.ServerHandler
        header         http.Header
        priority       common.Priority
        unidirectional bool
        responseCode   int
        stop           chan bool
        ready          chan struct{}
        wroteHeader    bool
}

func NewResponseStream(conn *Conn, frame *frames.SYN_STREAM, output chan&lt;- common.Frame, handler http.ServerHandler, request *http.Request) *ResponseStream <span class="cov6" title="6">{
        out := new(ResponseStream)
        out.conn = conn
        out.streamID = frame.StreamID
        out.output = output
        out.handler = handler
        if out.handler == nil </span><span class="cov0" title="0">{
                //out.handler = http.DefaultServeMux
        }</span>
        <span class="cov6" title="6">out.request = request
        out.priority = frame.Priority
        out.stop = conn.stop
        out.unidirectional = frame.Flags.UNIDIRECTIONAL()
        out.requestBody = new(bytes.Buffer)
        out.state = new(common.StreamState)
        out.header = make(http.Header)
        out.responseCode = 0
        out.ready = make(chan struct{})
        out.wroteHeader = false
        if frame.Flags.FIN() </span><span class="cov5" title="4">{
                close(out.ready)
                out.state.CloseThere()
        }</span>
        <span class="cov6" title="6">out.request.Body = &amp;common.ReadCloser{out.requestBody}
        return out</span>
}

func (s *ResponseStream) getConn() *Conn <span class="cov0" title="0">{
    return s.conn
}</span>

/***********************
 * http.ResponseWriter *
 ***********************/

func (s *ResponseStream) Header() http.Header <span class="cov6" title="6">{
        return s.header
}</span>

// Write is the main method with which data is sent.
func (s *ResponseStream) Write(inputData []byte) (int, error) <span class="cov3" title="2">{
        if s.unidirectional </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream is unidirectional.")
        }</span>

        <span class="cov3" title="2">if s.closed() || s.state.ClosedHere() </span><span class="cov0" title="0">{
                return 0, errors.New("Error: Stream already closed.")
        }</span>

        // Copy the data locally to avoid any pointer issues.
        <span class="cov3" title="2">data := make([]byte, len(inputData))
        copy(data, inputData)

        // Default to 200 response.
        if !s.wroteHeader </span><span class="cov0" title="0">{
                s.WriteHeader(http.StatusOK)
        }</span>

        // Send any new headers.
        <span class="cov3" title="2">s.writeHeader()

        // Chunk the response if necessary.
        // Data is sent to the flow control to
        // ensure that the protocol is followed.
        written := 0
        for len(data) &gt; common.MAX_DATA_SIZE </span><span class="cov0" title="0">{
                n, err := s.flow.Write(data[:common.MAX_DATA_SIZE])
                if err != nil </span><span class="cov0" title="0">{
                        return written, err
                }</span>
                <span class="cov0" title="0">written += n
                data = data[common.MAX_DATA_SIZE:]</span>
        }

        <span class="cov3" title="2">n, err := s.flow.Write(data)
        written += n

        return written, err</span>
}

// WriteHeader is used to set the HTTP status code.
func (s *ResponseStream) WriteHeader(code int) <span class="cov6" title="6">{
        if s.unidirectional </span><span class="cov0" title="0">{
                log.Println("Error: Stream is unidirectional.")
                return
        }</span>

        <span class="cov6" title="6">if s.wroteHeader </span><span class="cov0" title="0">{
                log.Println("Error: Multiple calls to ResponseWriter.WriteHeader.")
                return
        }</span>

        <span class="cov6" title="6">s.wroteHeader = true
        s.responseCode = code
        s.header.Set(":status", strconv.Itoa(code))
        s.header.Set(":version", "HTTP/1.1")

        // Create the response SYN_REPLY.
        synReply := new(frames.SYN_REPLY)
        synReply.StreamID = s.streamID
        synReply.Header = make(http.Header)

        // Clear the headers that have been sent.
        for name, values := range s.header </span><span class="cov10" title="18">{
                for _, value := range values </span><span class="cov10" title="18">{
                        synReply.Header.Add(name, value)
                }</span>
                <span class="cov10" title="18">s.header.Del(name)</span>
        }

        // These responses have no body, so close the stream now.
        <span class="cov6" title="6">if code == 204 || code == 304 || code/100 == 1 </span><span class="cov0" title="0">{
                synReply.Flags = common.FLAG_FIN
                s.state.CloseHere()
        }</span>

        <span class="cov6" title="6">s.output &lt;- synReply</span>
}

/*****************
 * io.Closer *
 *****************/

func (s *ResponseStream) Close() error <span class="cov8" title="12">{
        defer common.Recover()
        s.Lock()
        s.shutdownOnce.Do(s.shutdown)
        s.Unlock()
        return nil
}</span>

func (s *ResponseStream) shutdown() <span class="cov6" title="6">{
        s.writeHeader()
        if s.state != nil </span><span class="cov6" title="6">{
                s.state.Close()
        }</span>
        <span class="cov6" title="6">if s.flow != nil </span><span class="cov6" title="6">{
                s.flow.Close()
        }</span>
        <span class="cov6" title="6">if s.requestBody != nil </span><span class="cov6" title="6">{
                s.requestBody.Reset()
                s.requestBody = nil
        }</span>
        <span class="cov6" title="6">s.conn.requestStreamLimit.Close()
        s.output = nil
        s.request = nil
        s.handler = nil
        s.header = nil
        s.stop = nil</span>
}

/**********
 * Stream *
 **********/

func (s *ResponseStream) Conn() common.Conn <span class="cov9" title="14">{
        return s.conn
}</span>

func (s *ResponseStream) ReceiveFrame(frame common.Frame) error <span class="cov3" title="2">{
        s.Lock()
        defer s.Unlock()

        if frame == nil </span><span class="cov0" title="0">{
                return errors.New("Error: Nil frame received.")
        }</span>

        // Process the frame depending on its type.
        <span class="cov3" title="2">switch frame := frame.(type) </span>{
        <span class="cov3" title="2">case *frames.DATA:
                s.requestBody.Write(frame.Data)
                s.flow.Receive(frame.Data)
                if frame.Flags.FIN() </span><span class="cov3" title="2">{
                        select </span>{
                        <span class="cov0" title="0">case &lt;-s.ready:</span>
                        <span class="cov3" title="2">default:
                                close(s.ready)</span>
                        }
                        <span class="cov3" title="2">s.state.CloseThere()</span>
                }

        <span class="cov0" title="0">case *frames.SYN_REPLY:
                common.UpdateHeader(s.header, frame.Header)
                if frame.Flags.FIN() </span><span class="cov0" title="0">{
                        select </span>{
                        <span class="cov0" title="0">case &lt;-s.ready:</span>
                        <span class="cov0" title="0">default:
                                close(s.ready)</span>
                        }
                        <span class="cov0" title="0">s.state.CloseThere()</span>
                }

        <span class="cov0" title="0">case *frames.HEADERS:
                common.UpdateHeader(s.header, frame.Header)</span>

        <span class="cov0" title="0">case *frames.WINDOW_UPDATE:
                err := s.flow.UpdateWindow(frame.DeltaWindowSize)
                if err != nil </span><span class="cov0" title="0">{
                        reply := new(frames.RST_STREAM)
                        reply.StreamID = s.streamID
                        reply.Status = common.RST_STREAM_FLOW_CONTROL_ERROR
                        s.output &lt;- reply
                        return err
                }</span>

        <span class="cov0" title="0">default:
                return errors.New(fmt.Sprintf("Received unknown frame of type %T.", frame))</span>
        }

        <span class="cov3" title="2">return nil</span>
}

func (s *ResponseStream) CloseNotify() &lt;-chan bool <span class="cov0" title="0">{
        return s.stop
}</span>

// run is the main control path of
// the stream. It is prepared, the
// registered handler is called,
// and then the stream is cleaned
// up and closed.
func (s *ResponseStream) Run() error <span class="cov6" title="6">{
        // Catch any panics.
        defer func() </span><span class="cov6" title="6">{
                if v := recover(); v != nil </span><span class="cov0" title="0">{
            const size = 4096
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
                        if s != nil &amp;&amp; s.state != nil &amp;&amp; !s.state.Closed() </span><span class="cov0" title="0">{
                                log.Printf("Encountered stream error: %v (%[1]T)\n%s", v, buf)
                        }</span>
                }
        }()

        // Make sure Request is prepared.
        <span class="cov6" title="6">if s.requestBody == nil || s.request.Body == nil </span><span class="cov0" title="0">{
                s.requestBody = new(bytes.Buffer)
                s.request.Body = &amp;common.ReadCloser{s.requestBody}
        }</span>

        // Wait until the full request has been received.
        <span class="cov6" title="6">&lt;-s.ready

        /***************
         *** HANDLER ***
         ***************/
        s.handler.ServeHTTP(s, s.request)

        // Make sure any queued data has been sent.
        if err := s.flow.Wait(); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        // Close the stream with a SYN_REPLY if
        // none has been sent, or an empty DATA
        // frame, if a SYN_REPLY has been sent
        // already.
        // If the stream is already closed at
        // this end, then nothing happens.
        <span class="cov6" title="6">if !s.unidirectional </span><span class="cov6" title="6">{
                if s.state.OpenHere() &amp;&amp; !s.wroteHeader </span><span class="cov0" title="0">{
                        s.header.Set(":status", "200")
                        s.header.Set(":version", "HTTP/1.1")

                        // Create the response SYN_REPLY.
                        synReply := new(frames.SYN_REPLY)
                        synReply.Flags = common.FLAG_FIN
                        synReply.StreamID = s.streamID
                        synReply.Header = make(http.Header)

                        for name, values := range s.header </span><span class="cov0" title="0">{
                                for _, value := range values </span><span class="cov0" title="0">{
                                        synReply.Header.Add(name, value)
                                }</span>
                                <span class="cov0" title="0">s.header.Del(name)</span>
                        }

                        <span class="cov0" title="0">s.output &lt;- synReply</span>
                } <span class="cov6" title="6">else if s.state.OpenHere() </span><span class="cov6" title="6">{
                        // Create the DATA.
                        data := new(frames.DATA)
                        data.StreamID = s.streamID
                        data.Flags = common.FLAG_FIN
                        data.Data = []byte{}

                        s.output &lt;- data
                }</span>
        }

        // Clean up state.
        <span class="cov6" title="6">s.state.CloseHere()

        if s.state.Closed() </span><span class="cov6" title="6">{
                return s.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ResponseStream) State() *common.StreamState <span class="cov5" title="4">{
        return s.state
}</span>

func (s *ResponseStream) StreamID() common.StreamID <span class="cov3" title="2">{
        return s.streamID
}</span>

func (s *ResponseStream) closed() bool <span class="cov3" title="2">{
        if s.conn == nil || s.state == nil || s.handler == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov3" title="2">select </span>{
        <span class="cov0" title="0">case _ = &lt;-s.stop:
                return true</span>
        <span class="cov3" title="2">default:
                return false</span>
        }
}

// writeHeader is used to flush HTTP headers.
func (s *ResponseStream) writeHeader() <span class="cov7" title="8">{
        if len(s.header) == 0 || s.unidirectional </span><span class="cov7" title="8">{
                return
        }</span>

        // Create the HEADERS frame.
        <span class="cov0" title="0">header := new(frames.HEADERS)
        header.StreamID = s.streamID
        header.Header = make(http.Header)

        // Clear the headers that have been sent.
        for name, values := range s.header </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        header.Header.Add(name, value)
                }</span>
                <span class="cov0" title="0">s.header.Del(name)</span>
        }

        <span class="cov0" title="0">s.output &lt;- header</span>
}

/******************
 * PriorityStream *
 ******************/

func (s *ResponseStream) Priority() common.Priority <span class="cov0" title="0">{
        return s.priority
}</span>
</pre>
		
		<pre class="file" id="file221" style="display: none">package spdy3

import (
        "time"
)

import (
        "bfe_spdy/spdy3/frames"
)

// Close ends the connection, cleaning up relevant resources.
// Close can be called multiple times safely.
func (c *Conn) Close() (err error) <span class="cov7" title="44">{
        c.shutdownOnce.Do(c.shutdown)
        return nil
}</span>

// Closed indicates whether the connection has
// been closed.
func (c *Conn) Closed() bool <span class="cov10" title="133">{
        select </span>{
        <span class="cov6" title="16">case &lt;-c.stop:
                return true</span>
        <span class="cov9" title="117">default:
                return false</span>
        }
}

func (c *Conn) shutdown() <span class="cov6" title="16">{
        if c.Closed() </span><span class="cov0" title="0">{
                return
        }</span>

        // Try to inform the other endpoint that the connection is closing.
        <span class="cov6" title="16">c.sendingLock.Lock()
        isSending := c.sending != nil
        c.sendingLock.Unlock()
        c.goawayLock.Lock()
        sent := c.goawaySent
        c.goawayReceived = true
        c.goawayLock.Unlock()
        if !sent &amp;&amp; !isSending </span><span class="cov5" title="14">{
                goaway := new(frames.GOAWAY)
                if c.server != nil </span><span class="cov4" title="8">{
                        c.lastRequestStreamIDLock.Lock()
                        goaway.LastGoodStreamID = c.lastRequestStreamID
                        c.lastRequestStreamIDLock.Unlock()
                }</span> <span class="cov4" title="6">else {
                        c.lastPushStreamIDLock.Lock()
                        goaway.LastGoodStreamID = c.lastPushStreamID
                        c.lastPushStreamIDLock.Unlock()
                }</span>
                <span class="cov5" title="14">select </span>{
                <span class="cov5" title="14">case c.output[0] &lt;- goaway:
                        c.goawayLock.Lock()
                        c.goawaySent = true
                        c.goawayLock.Unlock()</span>
                <span class="cov0" title="0">case &lt;-time.After(100 * time.Millisecond):
                        debug.Println("Failed to send closing GOAWAY.")</span>
                }
        }

        <span class="cov6" title="16">c.streamsLock.Lock()
        for _, stream := range c.streams </span><span class="cov5" title="14">{
                stream.Close()
        }</span>
        <span class="cov6" title="16">c.streams = nil
        c.streamsLock.Unlock()

        // Ensure any pending frames are sent.
        c.sendingLock.Lock()
        if c.sending == nil </span><span class="cov5" title="14">{
                c.sending = make(chan struct{})
                c.sendingLock.Unlock()
                select </span>{
                <span class="cov4" title="6">case &lt;-c.sending:</span>
                <span class="cov4" title="8">case &lt;-time.After(200 * time.Millisecond):</span>
                }
                <span class="cov5" title="14">c.sendingLock.Lock()</span>
        }
        <span class="cov6" title="16">c.sending = nil
        c.sendingLock.Unlock()

        select </span>{
        <span class="cov0" title="0">case _, ok := &lt;-c.stop:
                if ok </span><span class="cov0" title="0">{
                        close(c.stop)
                }</span>
        <span class="cov6" title="16">default:
                close(c.stop)</span>
        }

        <span class="cov6" title="16">if c.conn != nil </span><span class="cov6" title="16">{
                c.conn.Close()
                c.conn = nil
        }</span>

        <span class="cov6" title="16">if c.compressor != nil </span><span class="cov6" title="16">{
                c.compressor.Close()
                c.compressor = nil
        }</span>
        <span class="cov6" title="16">c.decompressor = nil

        c.pushedResources = nil

        for _, stream := range c.output </span><span class="cov9" title="128">{
                select </span>{
                <span class="cov0" title="0">case _, ok := &lt;-stream:
                        if ok </span><span class="cov0" title="0">{
                                close(stream)
                        }</span>
                <span class="cov9" title="128">default:
                        close(stream)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file222" style="display: none">package spdy3

import (
        "errors"
        "net/url"
        "strings"
)

import (
        http "bfe_http"
        "bfe_spdy/common"
        "bfe_spdy/spdy3/frames"
)

// Ping is used by spdy.PingServer and spdy.PingClient to send
// SPDY PINGs.
func (c *Conn) Ping() (&lt;-chan bool, error) <span class="cov7" title="4">{
        if c.Closed() </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Conn has been closed.")
        }</span>

        <span class="cov7" title="4">ping := new(frames.PING)
        c.nextPingIDLock.Lock()
        pid := c.nextPingID
        if pid+2 &lt; pid </span><span class="cov0" title="0">{
                if pid&amp;1 == 0 </span><span class="cov0" title="0">{
                        c.nextPingID = 2
                }</span> <span class="cov0" title="0">else {
                        c.nextPingID = 1
                }</span>
        } <span class="cov7" title="4">else {
                c.nextPingID += 2
        }</span>
        <span class="cov7" title="4">c.nextPingIDLock.Unlock()

        ping.PingID = pid
        c.output[0] &lt;- ping
        ch := make(chan bool, 1)
        c.pingsLock.Lock()
        c.pings[pid] = ch
        c.pingsLock.Unlock()

        return ch, nil</span>
}

// Push is used to issue a server push to the client. Note that this cannot be performed
// by clients.
func (c *Conn) Push(resource string, origin common.Stream) (common.PushStream, error) <span class="cov4" title="2">{
        c.goawayLock.Lock()
        goaway := c.goawayReceived || c.goawaySent
        c.goawayLock.Unlock()
        if goaway </span><span class="cov0" title="0">{
                return nil, common.ErrGoaway
        }</span>

        <span class="cov4" title="2">if c.server == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Only servers can send pushes.")
        }</span>

        // Parse and check URL.
        <span class="cov4" title="2">url, err := url.Parse(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if url.Scheme == "" || url.Host == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Incomplete path provided to resource.")
        }</span>
        <span class="cov4" title="2">resource = url.String()

        // Ensure the resource hasn't been pushed on the given stream already.
        if c.pushedResources[origin] == nil </span><span class="cov4" title="2">{
                c.pushedResources[origin] = map[string]struct{}{
                        resource: struct{}{},
                }
        }</span> <span class="cov0" title="0">else if _, ok := c.pushedResources[origin][url.String()]; !ok </span><span class="cov0" title="0">{
                c.pushedResources[origin][resource] = struct{}{}
        }</span> <span class="cov0" title="0">else {
                return nil, errors.New("Error: Resource already pushed to this stream.")
        }</span>

        // Check stream limit would allow the new stream.
        <span class="cov4" title="2">if !c.pushStreamLimit.Add() </span><span class="cov0" title="0">{
                return nil, errors.New("Error: Max concurrent streams limit exceeded.")
        }</span>

        // Verify that path is prefixed with / as required by spec.
        <span class="cov4" title="2">path := url.Path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>

        // Prepare the SYN_STREAM.
        <span class="cov4" title="2">push := new(frames.SYN_STREAM)
        push.Flags = common.FLAG_UNIDIRECTIONAL
        push.AssocStreamID = origin.StreamID()
        push.Priority = 7
        push.Header = make(http.Header)
        push.Header.Set(":scheme", url.Scheme)
        push.Header.Set(":host", url.Host)
        push.Header.Set(":path", path)
        push.Header.Set(":version", "HTTP/1.1")

        // Send.
        c.streamCreation.Lock()
        defer c.streamCreation.Unlock()

        c.lastPushStreamIDLock.Lock()
        c.lastPushStreamID += 2
        newID := c.lastPushStreamID
        c.lastPushStreamIDLock.Unlock()
        if newID &gt; common.MAX_STREAM_ID </span><span class="cov0" title="0">{
                return nil, errors.New("Error: All server streams exhausted.")
        }</span>
        <span class="cov4" title="2">push.StreamID = newID
        c.output[0] &lt;- push

        // Create the pushStream.
        out := NewPushStream(c, newID, origin, c.output[7])
        out.AddFlowControl(c.flowControl)

        // Store in the connection map.
        c.streamsLock.Lock()
        c.streams[newID] = out
        c.streamsLock.Unlock()

        return out, nil</span>
}

func (c *Conn) SetFlowControl(f common.FlowControl) <span class="cov10" title="8">{
        c.flowControlLock.Lock()
        c.flowControl = f
        c.flowControlLock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file223" style="display: none">// Copyright 2014 Jamie Hall. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package spdy3

import (
        "bfe_spdy/common"
)

// defaultServerSettings are used in initialising the connection.
// It takes the max concurrent streams.
func defaultServerSettings(m uint32) common.Settings <span class="cov10" title="8">{
        return common.Settings{
                common.SETTINGS_INITIAL_WINDOW_SIZE: &amp;common.Setting{
                        Flags: common.FLAG_SETTINGS_PERSIST_VALUE,
                        ID:    common.SETTINGS_INITIAL_WINDOW_SIZE,
                        Value: common.DEFAULT_INITIAL_WINDOW_SIZE,
                },
                common.SETTINGS_MAX_CONCURRENT_STREAMS: &amp;common.Setting{
                        Flags: common.FLAG_SETTINGS_PERSIST_VALUE,
                        ID:    common.SETTINGS_MAX_CONCURRENT_STREAMS,
                        Value: m,
                },
        }
}</span>

// defaultClientSettings are used in initialising the connection.
// It takes the max concurrent streams.
func defaultClientSettings(m uint32) common.Settings <span class="cov10" title="8">{
        return common.Settings{
                common.SETTINGS_INITIAL_WINDOW_SIZE: &amp;common.Setting{
                        ID:    common.SETTINGS_INITIAL_WINDOW_SIZE,
                        Value: common.DEFAULT_INITIAL_CLIENT_WINDOW_SIZE,
                },
                common.SETTINGS_MAX_CONCURRENT_STREAMS: &amp;common.Setting{
                        ID:    common.SETTINGS_MAX_CONCURRENT_STREAMS,
                        Value: m,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file224" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import "strconv"

type alert uint8

const (
        // alert level
        alertLevelWarning = 1
        alertLevelError   = 2
)

const (
        alertCloseNotify            alert = 0
        alertUnexpectedMessage      alert = 10
        alertBadRecordMAC           alert = 20
        alertDecryptionFailed       alert = 21
        alertRecordOverflow         alert = 22
        alertDecompressionFailure   alert = 30
        alertHandshakeFailure       alert = 40
        alertBadCertificate         alert = 42
        alertUnsupportedCertificate alert = 43
        alertCertificateRevoked     alert = 44
        alertCertificateExpired     alert = 45
        alertCertificateUnknown     alert = 46
        alertIllegalParameter       alert = 47
        alertUnknownCA              alert = 48
        alertAccessDenied           alert = 49
        alertDecodeError            alert = 50
        alertDecryptError           alert = 51
        alertProtocolVersion        alert = 70
        alertInsufficientSecurity   alert = 71
        alertInternalError          alert = 80
        alertInappropriateFallback  alert = 86
        alertUserCanceled           alert = 90
        alertNoRenegotiation        alert = 100
)

var alertText = map[alert]string{
        alertCloseNotify:            "close notify",
        alertUnexpectedMessage:      "unexpected message",
        alertBadRecordMAC:           "bad record MAC",
        alertDecryptionFailed:       "decryption failed",
        alertRecordOverflow:         "record overflow",
        alertDecompressionFailure:   "decompression failure",
        alertHandshakeFailure:       "handshake failure",
        alertBadCertificate:         "bad certificate",
        alertUnsupportedCertificate: "unsupported certificate",
        alertCertificateRevoked:     "revoked certificate",
        alertCertificateExpired:     "expired certificate",
        alertCertificateUnknown:     "unknown certificate",
        alertIllegalParameter:       "illegal parameter",
        alertUnknownCA:              "unknown certificate authority",
        alertAccessDenied:           "access denied",
        alertDecodeError:            "error decoding message",
        alertDecryptError:           "error decrypting message",
        alertProtocolVersion:        "protocol version not supported",
        alertInsufficientSecurity:   "insufficient security level",
        alertInternalError:          "internal error",
        alertInappropriateFallback:  "inappropriate fallback",
        alertUserCanceled:           "user canceled",
        alertNoRenegotiation:        "no renegotiation",
}

func (e alert) String() string <span class="cov0" title="0">{
        s, ok := alertText[e]
        if ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return "alert(" + strconv.Itoa(int(e)) + ")"</span>
}

func (e alert) Error() string <span class="cov0" title="0">{
        return e.String()
}</span>
</pre>
		
		<pre class="file" id="file225" style="display: none">/* anti_tlsdos_engine.go - interface of anti TLS DOS engine */

/*
modification history
--------------------
2015/6/10, by Xiong Zongtao, create
*/
/*
DESCRIPTION
*/

package bfe_tls

import (
        "sync"
)

type IAntiTlsDosEngine interface {
        // check client-hello random if match defined one
        IsMatchDosRandom([]byte) bool

        // after-handshake process
        // log handshake related info(such as ip, client-hello and so on)
        LogHandshakeInfo(hs *HandshakeInfo)
        
        // select a acceptable cipher suite from preferenceList and supportedList 
        TryCipherSuite(preferenceList, supportedList []uint16, handshakeState interface{}) interface{}
}

var antiTlsDosEngine IAntiTlsDosEngine

var engineLock sync.Mutex

func SetAntiDosEngine(engine IAntiTlsDosEngine) <span class="cov0" title="0">{
        engineLock.Lock()
        defer engineLock.Unlock()

        antiTlsDosEngine = engine
}</span>
</pre>
		
		<pre class="file" id="file226" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/des"
        "crypto/hmac"
        "crypto/rc4"
        "crypto/sha1"
        "crypto/x509"
        "fmt"
        "hash"
)

// a keyAgreement implements the client and server side of a TLS key agreement
// protocol by generating and processing key exchange messages.
type keyAgreement interface {
        // On the server side, the first two methods are called in order.

        // In the case that the key agreement protocol doesn't use a
        // ServerKeyExchange message, generateServerKeyExchange can return nil,
        // nil.
        generateServerKeyExchange(*Config, *Certificate, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, error)
        processClientKeyExchange(*Config, *Certificate, *clientKeyExchangeMsg, uint16) ([]byte, error)

        // On the client side, the next two methods are called in order.

        // This method may not be called if the server doesn't send a
        // ServerKeyExchange message.
        processServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) error
        generateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)
}

const (
        // suiteECDH indicates that the cipher suite involves elliptic curve
        // Diffie-Hellman. This means that it should only be selected when the
        // client indicates that it supports ECC with a curve and point format
        // that we're happy with.
        suiteECDHE = 1 &lt;&lt; iota
        // suiteECDSA indicates that the cipher suite involves an ECDSA
        // signature and therefore may only be selected when the server's
        // certificate is ECDSA. If this is not set then the cipher suite is
        // RSA based.
        suiteECDSA
        // suiteTLS12 indicates that the cipher suite should only be advertised
        // and accepted when using TLS 1.2.
        suiteTLS12
)

// A cipherSuite is a specific combination of key agreement, cipher and MAC
// function. All cipher suites currently assume RSA key agreement.
type cipherSuite struct {
        id uint16
        // the lengths, in bytes, of the key material needed for each component.
        keyLen int
        macLen int
        ivLen  int
        ka     func(version uint16) keyAgreement
        // flags is a bitmask of the suite* values, above.
        flags  int
        cipher func(key, iv []byte, isRead bool) interface{}
        mac    func(version uint16, macKey []byte) macFunction
        aead   func(key, fixedNonce []byte) cipher.AEAD
}

var cipherSuites = []*cipherSuite{
        // Ciphersuite order is chosen so that ECDHE comes before plain RSA
        // and RC4 comes before AES (because of the Lucky13 attack).
        {TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},
        {TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECDSA | suiteTLS12, nil, nil, aeadAESGCM},
        {TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE, cipherRC4, macSHA1, nil},
        {TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherRC4, macSHA1, nil},
        {TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},
        {TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},
        {TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},
        {TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECDSA, cipherAES, macSHA1, nil},
        {TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, 0, cipherRC4, macSHA1, nil},
        {TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},
        {TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},
        {TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},
        {TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, 0, cipher3DES, macSHA1, nil},
}

func CheckSuiteECDHE(id uint16) bool <span class="cov1" title="1">{
    switch id </span>{
        <span class="cov0" title="0">case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
        return true</span>
        <span class="cov0" title="0">case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
        return true</span>
    }
    <span class="cov1" title="1">return false</span>
}

func cipherRC4(key, iv []byte, isRead bool) interface{} <span class="cov8" title="72">{
        cipher, _ := rc4.NewCipher(key)
        return cipher
}</span>

func cipher3DES(key, iv []byte, isRead bool) interface{} <span class="cov4" title="6">{
        block, _ := des.NewTripleDESCipher(key)
        if isRead </span><span class="cov2" title="3">{
                return cipher.NewCBCDecrypter(block, iv)
        }</span>
        <span class="cov2" title="3">return cipher.NewCBCEncrypter(block, iv)</span>
}

func cipherAES(key, iv []byte, isRead bool) interface{} <span class="cov7" title="44">{
        block, _ := aes.NewCipher(key)
        if isRead </span><span class="cov6" title="22">{
                return cipher.NewCBCDecrypter(block, iv)
        }</span>
        <span class="cov6" title="22">return cipher.NewCBCEncrypter(block, iv)</span>
}

// macSHA1 returns a macFunction for the given protocol version.
func macSHA1(version uint16, key []byte) macFunction <span class="cov9" title="122">{
        if version == VersionSSL30 </span><span class="cov4" title="6">{
                mac := ssl30MAC{
                        h:   sha1.New(),
                        key: make([]byte, len(key)),
                }
                copy(mac.key, key)
                return mac
        }</span>
        <span class="cov9" title="116">return tls10MAC{hmac.New(sha1.New, key)}</span>
}

type macFunction interface {
        Size() int
        MAC(digestBuf, seq, header, data []byte) []byte
}

// fixedNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to
// each call.
type fixedNonceAEAD struct {
        // sealNonce and openNonce are buffers where the larger nonce will be
        // constructed. Since a seal and open operation may be running
        // concurrently, there is a separate buffer for each.
        sealNonce, openNonce []byte
        aead                 cipher.AEAD
}

func (f *fixedNonceAEAD) NonceSize() int <span class="cov0" title="0">{ return 8 }</span>
func (f *fixedNonceAEAD) Overhead() int  <span class="cov6" title="19">{ return f.aead.Overhead() }</span>

func (f *fixedNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte <span class="cov5" title="12">{
        copy(f.sealNonce[len(f.sealNonce)-8:], nonce)
        return f.aead.Seal(out, f.sealNonce, plaintext, additionalData)
}</span>

func (f *fixedNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]byte, error) <span class="cov4" title="7">{
        copy(f.openNonce[len(f.openNonce)-8:], nonce)
        return f.aead.Open(out, f.openNonce, plaintext, additionalData)
}</span>

func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD <span class="cov4" title="8">{
        aes, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)
        }</span>
        <span class="cov4" title="8">aead, err := cipher.NewGCM(aes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)
        }</span>

        <span class="cov4" title="8">nonce1, nonce2 := make([]byte, 12), make([]byte, 12)
        copy(nonce1, fixedNonce)
        copy(nonce2, fixedNonce)

        return &amp;fixedNonceAEAD{nonce1, nonce2, aead}</span>
}

// ssl30MAC implements the SSLv3 MAC function, as defined in
// www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 5.2.3.1
type ssl30MAC struct {
        h   hash.Hash
        key []byte
}

func (s ssl30MAC) Size() int <span class="cov2" title="3">{
        return s.h.Size()
}</span>

var ssl30Pad1 = [48]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36}

var ssl30Pad2 = [48]byte{0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c}

func (s ssl30MAC) MAC(digestBuf, seq, header, data []byte) []byte <span class="cov5" title="14">{
        padLength := 48
        if s.h.Size() == 20 </span><span class="cov5" title="14">{
                padLength = 40
        }</span>

        <span class="cov5" title="14">s.h.Reset()
        s.h.Write(s.key)
        s.h.Write(ssl30Pad1[:padLength])
        s.h.Write(seq)
        s.h.Write(header[:1])
        s.h.Write(header[3:5])
        s.h.Write(data)
        digestBuf = s.h.Sum(digestBuf[:0])

        s.h.Reset()
        s.h.Write(s.key)
        s.h.Write(ssl30Pad2[:padLength])
        s.h.Write(digestBuf)
        return s.h.Sum(digestBuf[:0])</span>
}

// tls10MAC implements the TLS 1.0 MAC function. RFC 2246, section 6.2.3.
type tls10MAC struct {
        h hash.Hash
}

func (s tls10MAC) Size() int <span class="cov7" title="58">{
        return s.h.Size()
}</span>

func (s tls10MAC) MAC(digestBuf, seq, header, data []byte) []byte <span class="cov10" title="199">{
        s.h.Reset()
        s.h.Write(seq)
        s.h.Write(header)
        s.h.Write(data)
        return s.h.Sum(digestBuf[:0])
}</span>

func rsaKA(version uint16) keyAgreement <span class="cov6" title="33">{
        return rsaKeyAgreement{}
}</span>

func ecdheECDSAKA(version uint16) keyAgreement <span class="cov5" title="11">{
        return &amp;ecdheKeyAgreement{
                sigType: signatureECDSA,
                version: version,
        }
}</span>

func ecdheRSAKA(version uint16) keyAgreement <span class="cov5" title="15">{
        return &amp;ecdheKeyAgreement{
                sigType: signatureRSA,
                version: version,
        }
}</span>

// mutualCipherSuite returns a cipherSuite given a list of supported
// ciphersuites and the id requested by the peer.
func mutualCipherSuite(have []uint16, want uint16) *cipherSuite <span class="cov6" title="29">{
        for _, id := range have </span><span class="cov9" title="136">{
                if id == want </span><span class="cov6" title="29">{
                        for _, suite := range cipherSuites </span><span class="cov9" title="190">{
                                if suite.id == want </span><span class="cov6" title="29">{
                                        return suite
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// A list of the possible cipher suite ids. Taken from
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml
const (
        TLS_RSA_WITH_RC4_128_SHA                uint16 = 0x0005
        TLS_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0x000a
        TLS_RSA_WITH_AES_128_CBC_SHA            uint16 = 0x002f
        TLS_RSA_WITH_AES_256_CBC_SHA            uint16 = 0x0035
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA        uint16 = 0xc007
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    uint16 = 0xc009
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    uint16 = 0xc00a
        TLS_ECDHE_RSA_WITH_RC4_128_SHA          uint16 = 0xc011
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0xc012
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0xc013
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b

        // TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator
        // that the client is doing version fallback. See
        // https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.
        TLS_FALLBACK_SCSV uint16 = 0x5600
)

var cipherSuiteTextMap = map[uint16]string{
        TLS_RSA_WITH_RC4_128_SHA:                "TLS_RSA_WITH_RC4_128_SHA",
        TLS_RSA_WITH_3DES_EDE_CBC_SHA:           "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
        TLS_RSA_WITH_AES_128_CBC_SHA:            "TLS_RSA_WITH_AES_128_CBC_SHA",
        TLS_RSA_WITH_AES_256_CBC_SHA:            "TLS_RSA_WITH_AES_256_CBC_SHA",
        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:        "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:    "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:    "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
        TLS_ECDHE_RSA_WITH_RC4_128_SHA:          "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:     "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:   "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
}

func CipherSuiteText(suite uint16) string <span class="cov7" title="40">{
        if text, ok := cipherSuiteTextMap[suite]; ok </span><span class="cov7" title="40">{
                return text
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TLS_CIPHER_SUITE_%x", suite)</span>
}
</pre>
		
		<pre class="file" id="file227" style="display: none">/* common.go - tls commons */
/*
modification history
--------------------
2015/4/11, by Sijie Yang, modify
    - merge from session cache demo written by Weiwei Zhang
    - add SessionCacheDisabled to disable session cache
    - update SessionServerCache interface for thirdparty implementation

2015/4/16, by Sijie Yang, modify
    - make record size configurable and dynamic

2015/5/30, by Sijie Yang, modify
    - support SessionTicketKeyName to be compatible with OpenSSL

2015/7/21, by Sijie Yang, modify
    - support thirdparty policy for choice of certificates

2015/9/7, by Weiwei Zhang, modify
    - add cert type definition 

2015/9/24, by Siije Yang, modify
    - support SSLv2 ClientHello to be compatible with ancient TLS-capable clients
*/
/*
DESCRIPTION
*/

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "container/list"
        "crypto"
        "crypto/rand"
        "crypto/x509"
        "fmt"
        "io"
        "math/big"
        "strings"
        "sync"
        "time"
)

const (
        VersionSSL30 = 0x0300
        VersionTLS10 = 0x0301
        VersionTLS11 = 0x0302
        VersionTLS12 = 0x0303
)

const (
        minPlaintext    = 1024         // length plaintext payload that fit into a signle TCP segment
        maxPlaintext    = 16384        // maximum plaintext payload length
        maxCiphertext   = 16384 + 2048 // maximum ciphertext payload length
        recordHeaderLen = 5            // record header length
        maxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)

        minVersion = VersionSSL30
        maxVersion = VersionTLS12

        ticketKeyNameLen = 16 // length for session ticket key name
)

/*
 * Note: Google's servers use small TLS records that fit into a sing TCP segment
 * for the first ~1 MB of data, increase record size to 16 KB after that to optimize throughput,
 * and then reset record size back to a single segment after ~1 second of inactivity
 * - lather, rinse, repeat.
 *
 * For more information, see:
 *     http://chimera.labs.oreilly.com/books/1230000000545/ch04.html#TLS_RECORD_SIZE
 */
var (
        initPlaintext   int           = minPlaintext                   // initial length of plaintext payload
        bytesThreshold  int           = 1024 * 1024                    // 1 MB
        inactiveSeconds time.Duration = time.Duration(1 * time.Second) // 1 second
)

// set parameters for tls record protocol
func SetRecordParams(initPlainSize, sentThreshold, inactiveSecs int) <span class="cov0" title="0">{
        if initPlainSize &gt;= minPlaintext &amp;&amp; initPlainSize &lt;= maxPlaintext </span><span class="cov0" title="0">{
                initPlaintext = initPlainSize
        }</span>
        <span class="cov0" title="0">bytesThreshold = sentThreshold
        inactiveSeconds = time.Duration(inactiveSecs) * time.Second</span>
}

// TLS record types.
type recordType uint8

const (
        recordTypeChangeCipherSpec recordType = 20
        recordTypeAlert            recordType = 21
        recordTypeHandshake        recordType = 22
        recordTypeApplicationData  recordType = 23
)

// TLS handshake message types.
const (
        typeClientHello        uint8 = 1
        typeServerHello        uint8 = 2
        typeNewSessionTicket   uint8 = 4
        typeCertificate        uint8 = 11
        typeServerKeyExchange  uint8 = 12
        typeCertificateRequest uint8 = 13
        typeServerHelloDone    uint8 = 14
        typeCertificateVerify  uint8 = 15
        typeClientKeyExchange  uint8 = 16
        typeFinished           uint8 = 20
        typeCertificateStatus  uint8 = 22
        typeNextProtocol       uint8 = 67 // Not IANA assigned
)

// TLS compression types.
const (
        compressionNone uint8 = 0
)

// TLS extension numbers
const (
        extensionServerName          uint16 = 0
        extensionStatusRequest       uint16 = 5
        extensionSupportedCurves     uint16 = 10
        extensionSupportedPoints     uint16 = 11
        extensionSignatureAlgorithms uint16 = 13
        extensionALPN                uint16 = 16
        extensionSessionTicket       uint16 = 35
        extensionNextProtoNeg        uint16 = 13172 // not IANA assigned
        extensionRenegotiationInfo   uint16 = 0xff01
)

// TLS signaling cipher suite values
const (
        scsvRenegotiation uint16 = 0x00ff
)

// CurveID is the type of a TLS identifier for an elliptic curve. See
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8
type CurveID uint16

const (
        CurveP256 CurveID = 23
        CurveP384 CurveID = 24
        CurveP521 CurveID = 25
)

// TLS Elliptic Curve Point Formats
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9
const (
        pointFormatUncompressed uint8 = 0
)

// TLS CertificateStatusType (RFC 3546)
const (
        statusTypeOCSP uint8 = 1
)

// Certificate types (for certificateRequestMsg)
const (
        certTypeRSASign    = 1 // A certificate containing an RSA key
        certTypeDSSSign    = 2 // A certificate containing a DSA key
        certTypeRSAFixedDH = 3 // A certificate containing a static DH key
        certTypeDSSFixedDH = 4 // A certificate containing a static DH key

        // See RFC4492 sections 3 and 5.5.
        certTypeECDSASign      = 64 // A certificate containing an ECDSA-capable public key, signed with ECDSA.
        certTypeRSAFixedECDH   = 65 // A certificate containing an ECDH-capable public key, signed with RSA.
        certTypeECDSAFixedECDH = 66 // A certificate containing an ECDH-capable public key, signed with ECDSA.

        // Rest of these are reserved by the TLS spec
)

// Hash functions for TLS 1.2 (See RFC 5246, section A.4.1)
const (
        hashSHA1   uint8 = 2
        hashSHA256 uint8 = 4
)

// Certificate type (for certificate auto-selection)
const (
    CertTypeSha1 = "SHA1"
    CertTypeSha256 = "SHA256"
    CertTypeUnsure = "UNSURE"
)

// Signature algorithms for TLS 1.2 (See RFC 5246, section A.4.1)
const (
        signatureRSA   uint8 = 1
        signatureECDSA uint8 = 3
)

// signatureAndHash mirrors the TLS 1.2, SignatureAndHashAlgorithm struct. See
// RFC 5246, section A.4.1.
type signatureAndHash struct {
        hash, signature uint8
}

// supportedSKXSignatureAlgorithms contains the signature and hash algorithms
// that the code advertises as supported in a TLS 1.2 ClientHello.
var supportedSKXSignatureAlgorithms = []signatureAndHash{
        {hashSHA256, signatureRSA},
        {hashSHA256, signatureECDSA},
        {hashSHA1, signatureRSA},
        {hashSHA1, signatureECDSA},
}

// supportedClientCertSignatureAlgorithms contains the signature and hash
// algorithms that the code advertises as supported in a TLS 1.2
// CertificateRequest.
var supportedClientCertSignatureAlgorithms = []signatureAndHash{
        {hashSHA256, signatureRSA},
        {hashSHA256, signatureECDSA},
}

// ConnectionState records basic TLS details about the connection.
type ConnectionState struct {
        Version                    uint16                // TLS version used by the connection (e.g. VersionTLS12)
        HandshakeComplete          bool                  // TLS handshake is complete
        DidResume                  bool                  // connection resumes a previous TLS connection
        CipherSuite                uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)
        NegotiatedProtocol         string                // negotiated next protocol (from Config.NextProtos)
        NegotiatedProtocolIsMutual bool                  // negotiated protocol was advertised by server
        ServerName                 string                // server name requested by client, if any (server side only)
        PeerCertificates           []*x509.Certificate   // certificate chain presented by remote peer
        VerifiedChains             [][]*x509.Certificate // verified chains built from PeerCertificates
}

// ClientAuthType declares the policy the server will follow for
// TLS Client Authentication.
type ClientAuthType int

const (
        NoClientCert ClientAuthType = iota
        RequestClientCert
        RequireAnyClientCert
        VerifyClientCertIfGiven
        RequireAndVerifyClientCert
)

// ClientSessionState contains the state needed by clients to resume TLS
// sessions.
type ClientSessionState struct {
        sessionTicket      []uint8             // Encrypted ticket used for session resumption with server
        vers               uint16              // SSL/TLS version negotiated for the session
        cipherSuite        uint16              // Ciphersuite negotiated for the session
        masterSecret       []byte              // MasterSecret generated by client on a full handshake
        serverCertificates []*x509.Certificate // Certificate chain presented by the server
}

// ClientSessionCache is a cache of ClientSessionState objects that can be used
// by a client to resume a TLS session with a given server. ClientSessionCache
// implementations should expect to be called concurrently from different
// goroutines.
type ClientSessionCache interface {
        // Get searches for a ClientSessionState associated with the given key.
        // On return, ok is true if one was found.
        Get(sessionKey string) (session *ClientSessionState, ok bool)

        // Put adds the ClientSessionState to the cache with the given key.
        Put(sessionKey string, cs *ClientSessionState)
}

type ServerSessionCache interface {
        // Get searches for a sessionState associated with the given key.
        // On return, ok is true if one was found.
        Get(sessionKey string) (sessionState []byte, ok bool)

        // Put adds the sessionState to the cache with the given key.
        Put(sessionKey string, sessionState []byte) error
}

type MultiCertificate interface {
    // Get certificate for the given conn
    Get(c *Conn) *Certificate
}

type NextProtoNegotiate interface {
    // Get next protos for the given conn
    NextProtos(c *Conn) []string
}

// A Config structure is used to configure a TLS client or server.
// After one has been passed to a TLS function it must not be
// modified. A Config may be reused; the tls package will also not
// modify it.
type Config struct {
        // Rand provides the source of entropy for nonces and RSA blinding.
        // If Rand is nil, TLS uses the cryptographic random reader in package
        // crypto/rand.
        // The Reader must be safe for use by multiple goroutines.
        Rand io.Reader

        // Time returns the current time as the number of seconds since the epoch.
        // If Time is nil, TLS uses time.Now.
        Time func() time.Time

        // Certificates contains one or more certificate chains
        // to present to the other side of the connection.
        // Server configurations must include at least one certificate.
        Certificates []Certificate

        // NameToCertificate maps from a certificate name to an element of
        // Certificates. Note that a certificate name can be of the form
        // '*.example.com' and so doesn't have to be a domain name as such.
        // See Config.BuildNameToCertificate
        // The nil value causes the first element of Certificates to be used
        // for all connections.
        NameToCertificate map[string]*Certificate

    // multiply certificates for server side
    MultiCert MultiCertificate

        // RootCAs defines the set of root certificate authorities
        // that clients use when verifying server certificates.
        // If RootCAs is nil, TLS uses the host's root CA set.
        RootCAs *x509.CertPool

        // NextProtos is a list of supported, application level protocols.
        NextProtos []string

    // next protocol for server side
    NextProtoNeg NextProtoNegotiate

        // ServerName is used to verify the hostname on the returned
        // certificates unless InsecureSkipVerify is given. It is also included
        // in the client's handshake to support virtual hosting.
        ServerName string

        // ClientAuth determines the server's policy for
        // TLS Client Authentication. The default is NoClientCert.
        ClientAuth ClientAuthType

        // ClientCAs defines the set of root certificate authorities
        // that servers use if required to verify a client certificate
        // by the policy in ClientAuth.
        ClientCAs *x509.CertPool

        // InsecureSkipVerify controls whether a client verifies the
        // server's certificate chain and host name.
        // If InsecureSkipVerify is true, TLS accepts any certificate
        // presented by the server and any host name in that certificate.
        // In this mode, TLS is susceptible to man-in-the-middle attacks.
        // This should be used only for testing.
        InsecureSkipVerify bool

        // CipherSuites is a list of supported cipher suites. If CipherSuites
        // is nil, TLS uses a list of suites supported by the implementation.
        CipherSuites []uint16

        // PreferServerCipherSuites controls whether the server selects the
        // client's most preferred ciphersuite, or the server's most preferred
        // ciphersuite. If true then the server's preference, as expressed in
        // the order of elements in CipherSuites, is used.
        PreferServerCipherSuites bool

        // SessionTicketsDisabled may be set to true to disable session ticket
        // (resumption) support.
        SessionTicketsDisabled bool

        // SessionTicketKey is used by TLS servers to provide session
        // resumption. See RFC 5077. If zero, it will be filled with
        // random data before the first server handshake.
        //
        // If multiple servers are terminating connections for the same host
        // they should all have the same SessionTicketKey. If the
        // SessionTicketKey leaks, previously recorded and future TLS
        // connections using that key are compromised.
        SessionTicketKey [32]byte

        // SessionTicketKeyName is used as an identifier for SessionTicketKey
        // in SessionTicket
        SessionTicketKeyName [16]byte

        // SessionCache is a cache of ClientSessionState entries for TLS session
        // resumption.
        ClientSessionCache ClientSessionCache

        // SessionCache is a cache of sessionState entries for TLS session
        // resumption.
        ServerSessionCache ServerSessionCache

        // SessionCacheDisabled may be set to true to disable session cache
        // (resumption) support.
        SessionCacheDisabled bool

        // MinVersion contains the minimum SSL/TLS version that is acceptable.
        // If zero, then SSLv3 is taken as the minimum.
        MinVersion uint16

        // MaxVersion contains the maximum SSL/TLS version that is acceptable.
        // If zero, then the maximum version supported by this package is used,
        // which is currently TLS 1.2.
        MaxVersion uint16

        // CurvePreferences contains the elliptic curves that will be used in
        // an ECDHE handshake, in preference order. If empty, the default will
        // be used.
        CurvePreferences []CurveID

    // Support SSLv2 ClientHello for backward compatibility with ancient
    // TLS-capable clients.
    EnableSslv2ClientHello bool

        serverInitOnce sync.Once // guards calling (*Config).serverInit
}

func (c *Config) serverInit() <span class="cov3" title="4">{
        if c.SessionTicketsDisabled </span><span class="cov0" title="0">{
                return
        }</span>

        // If the key has already been set then we have nothing to do.
        <span class="cov3" title="4">for _, b := range c.SessionTicketKey </span><span class="cov8" title="128">{
                if b != 0 </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov3" title="4">if _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil </span><span class="cov0" title="0">{
                c.SessionTicketsDisabled = true
        }</span>
}

func (c *Config) rand() io.Reader <span class="cov10" title="242">{
        r := c.Rand
        if r == nil </span><span class="cov7" title="63">{
                return rand.Reader
        }</span>
        <span class="cov9" title="179">return r</span>
}

func (c *Config) time() time.Time <span class="cov0" title="0">{
        t := c.Time
        if t == nil </span><span class="cov0" title="0">{
                t = time.Now
        }</span>
        <span class="cov0" title="0">return t()</span>
}

func (c *Config) cipherSuites() []uint16 <span class="cov8" title="98">{
        s := c.CipherSuites
        if s == nil </span><span class="cov7" title="68">{
                s = defaultCipherSuites()
        }</span>
        <span class="cov8" title="98">return s</span>
}

func (c *Config) minVersion() uint16 <span class="cov8" title="84">{
        if c == nil || c.MinVersion == 0 </span><span class="cov6" title="28">{
                return minVersion
        }</span>
        <span class="cov7" title="56">return c.MinVersion</span>
}

func (c *Config) maxVersion() uint16 <span class="cov8" title="114">{
        if c == nil || c.MaxVersion == 0 </span><span class="cov6" title="36">{
                return maxVersion
        }</span>
        <span class="cov8" title="78">return c.MaxVersion</span>
}

var defaultCurvePreferences = []CurveID{CurveP256, CurveP384, CurveP521}

func (c *Config) curvePreferences() []CurveID <span class="cov8" title="81">{
        if c == nil || len(c.CurvePreferences) == 0 </span><span class="cov8" title="81">{
                return defaultCurvePreferences
        }</span>
        <span class="cov0" title="0">return c.CurvePreferences</span>
}

// mutualVersion returns the protocol version to use given the advertised
// version of the peer.
func (c *Config) mutualVersion(vers uint16) (uint16, bool) <span class="cov8" title="79">{
        minVersion := c.minVersion()
        maxVersion := c.maxVersion()

        if vers &lt; minVersion </span><span class="cov3" title="6">{
                return 0, false
        }</span>
        <span class="cov8" title="73">if vers &gt; maxVersion </span><span class="cov2" title="3">{
                vers = maxVersion
        }</span>
        <span class="cov8" title="73">return vers, true</span>
}

// getCertificateForName returns the best certificate for the given name,
// defaulting to the first element of c.Certificates if there are no good
// options.
func (c *Config) getCertificateForName(name string) *Certificate <span class="cov4" title="7">{
        if len(c.Certificates) == 1 || c.NameToCertificate == nil </span><span class="cov0" title="0">{
                // There's only one choice, so no point doing any work.
                return &amp;c.Certificates[0]
        }</span>

        <span class="cov4" title="7">name = strings.ToLower(name)
        for len(name) &gt; 0 &amp;&amp; name[len(name)-1] == '.' </span><span class="cov0" title="0">{
                name = name[:len(name)-1]
        }</span>

        <span class="cov4" title="7">if cert, ok := c.NameToCertificate[name]; ok </span><span class="cov2" title="3">{
                return cert
        }</span>

        // try replacing labels in the name with wildcards until we get a
        // match.
        <span class="cov3" title="4">labels := strings.Split(name, ".")
        for i := range labels </span><span class="cov5" title="12">{
                labels[i] = "*"
                candidate := strings.Join(labels, ".")
                if cert, ok := c.NameToCertificate[candidate]; ok </span><span class="cov2" title="2">{
                        return cert
                }</span>
        }

        // If nothing matches, return the first certificate.
        <span class="cov2" title="2">return &amp;c.Certificates[0]</span>
}

// BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate
// from the CommonName and SubjectAlternateName fields of each of the leaf
// certificates.
func (c *Config) BuildNameToCertificate() <span class="cov3" title="4">{
        c.NameToCertificate = make(map[string]*Certificate)
        for i := range c.Certificates </span><span class="cov4" title="8">{
                cert := &amp;c.Certificates[i]
                x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">if len(x509Cert.Subject.CommonName) &gt; 0 </span><span class="cov1" title="1">{
                        c.NameToCertificate[x509Cert.Subject.CommonName] = cert
                }</span>
                <span class="cov4" title="8">for _, san := range x509Cert.DNSNames </span><span class="cov3" title="4">{
                        c.NameToCertificate[san] = cert
                }</span>
        }
}

// getNextProtos return next protos for server side 
func (c *Config) getNextProtos(conn *Conn) []string <span class="cov7" title="39">{
    if c.NextProtoNeg != nil </span><span class="cov0" title="0">{
        return c.NextProtoNeg.NextProtos(conn)
    }</span>
    <span class="cov7" title="39">return c.NextProtos</span>
}

// A Certificate is a chain of one or more certificates, leaf first.
type Certificate struct {
        Certificate [][]byte
        PrivateKey  crypto.PrivateKey // supported types: *rsa.PrivateKey, *ecdsa.PrivateKey
        // OCSPStaple contains an optional OCSP response which will be served
        // to clients that request it.
        OCSPStaple []byte
        // Leaf is the parsed form of the leaf certificate, which may be
        // initialized using x509.ParseCertificate to reduce per-handshake
        // processing for TLS clients doing client authentication. If nil, the
        // leaf certificate will be parsed as needed.
        Leaf *x509.Certificate
}

// A TLS record.
type record struct {
        contentType  recordType
        major, minor uint8
        payload      []byte
}

type handshakeMessage interface {
        marshal() []byte
        unmarshal([]byte) bool
}

// lruSessionCache is a ClientSessionCache implementation that uses an LRU
// caching strategy.
type lruSessionCache struct {
        sync.Mutex

        m        map[string]*list.Element
        q        *list.List
        capacity int
}

type lruSessionCacheEntry struct {
        sessionKey string
        state      *ClientSessionState
}

// NewLRUClientSessionCache returns a ClientSessionCache with the given
// capacity that uses an LRU strategy. If capacity is &lt; 1, a default capacity
// is used instead.
func NewLRUClientSessionCache(capacity int) ClientSessionCache <span class="cov2" title="2">{
        const defaultSessionCacheCapacity = 64

        if capacity &lt; 1 </span><span class="cov0" title="0">{
                capacity = defaultSessionCacheCapacity
        }</span>
        <span class="cov2" title="2">return &amp;lruSessionCache{
                m:        make(map[string]*list.Element),
                q:        list.New(),
                capacity: capacity,
        }</span>
}

// Put adds the provided (sessionKey, cs) pair to the cache.
func (c *lruSessionCache) Put(sessionKey string, cs *ClientSessionState) <span class="cov5" title="12">{
        c.Lock()
        defer c.Unlock()

        if elem, ok := c.m[sessionKey]; ok </span><span class="cov3" title="4">{
                entry := elem.Value.(*lruSessionCacheEntry)
                entry.state = cs
                c.q.MoveToFront(elem)
                return
        }</span>

        <span class="cov4" title="8">if c.q.Len() &lt; c.capacity </span><span class="cov3" title="5">{
                entry := &amp;lruSessionCacheEntry{sessionKey, cs}
                c.m[sessionKey] = c.q.PushFront(entry)
                return
        }</span>

        <span class="cov2" title="3">elem := c.q.Back()
        entry := elem.Value.(*lruSessionCacheEntry)
        delete(c.m, entry.sessionKey)
        entry.sessionKey = sessionKey
        entry.state = cs
        c.q.MoveToFront(elem)
        c.m[sessionKey] = elem</span>
}

// Get returns the ClientSessionState value associated with a given key. It
// returns (nil, false) if no value is found.
func (c *lruSessionCache) Get(sessionKey string) (*ClientSessionState, bool) <span class="cov5" title="16">{
        c.Lock()
        defer c.Unlock()

        if elem, ok := c.m[sessionKey]; ok </span><span class="cov5" title="12">{
                c.q.MoveToFront(elem)
                return elem.Value.(*lruSessionCacheEntry).state, true
        }</span>
        <span class="cov3" title="4">return nil, false</span>
}

// TODO(jsing): Make these available to both crypto/x509 and crypto/tls.
type dsaSignature struct {
        R, S *big.Int
}

type ecdsaSignature dsaSignature

var emptyConfig Config

func defaultConfig() *Config <span class="cov1" title="1">{
        return &amp;emptyConfig
}</span>

var (
        once                   sync.Once
        varDefaultCipherSuites []uint16
)

func defaultCipherSuites() []uint16 <span class="cov7" title="68">{
        once.Do(initDefaultCipherSuites)
        return varDefaultCipherSuites
}</span>

func initDefaultCipherSuites() <span class="cov1" title="1">{
        varDefaultCipherSuites = make([]uint16, len(cipherSuites))
        for i, suite := range cipherSuites </span><span class="cov5" title="13">{
                varDefaultCipherSuites[i] = suite.id
        }</span>
}

func unexpectedMessageError(wanted, got interface{}) error <span class="cov1" title="1">{
        stateInc(ERR_UNEXPECTED_MESSAGE, 1)
        return fmt.Errorf("tls: received unexpected handshake message of type %T when waiting for %T", got, wanted)
}</span>

var versionTextMap = map[uint16]string{
        VersionSSL30: "TLS_VERSION_SSL30",
        VersionTLS10: "TLS_VERSION_TLS10",
        VersionTLS11: "TLS_VERSION_TLS11",
        VersionTLS12: "TLS_VERSION_TLS12",
}

func VersionText(ver uint16) string <span class="cov7" title="40">{
        if text, ok := versionTextMap[ver]; ok </span><span class="cov7" title="40">{
                return text
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("TLS_VERSION_%x", ver)</span>
}

var alpnTextMap = map[string]string {
    "http/1.1": "TLS_ALPN_HTTP/1.1",
    "spdy/1"  : "TLS_ALPN_SPDY/1",
    "spdy/2"  : "TLS_ALPN_SPDY/2",
    "spdy/3"  : "TLS_ALPN_SPDY/3",
    "spdy/3.1": "TLS_ALPN_SPDY/3.1",
    "h2"      : "TLS_ALPN_H2",
}

func alpnProtoText(proto string) string <span class="cov3" title="4">{
    if text, ok := alpnTextMap[proto]; ok </span><span class="cov0" title="0">{
        return text
    }</span>
    <span class="cov3" title="4">if strings.HasPrefix(proto, "h2-") </span><span class="cov0" title="0">{
        return "TLS_ALPN_H2_DRAFT"
    }</span>
    <span class="cov3" title="4">return fmt.Sprintf("TLS_ALPN_UNKNOWN")</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// TLS low level connection and record layer

package bfe_tls

import (
        "bytes"
        "crypto/cipher"
        "crypto/subtle"
        "crypto/x509"
        "errors"
        "fmt"
        "io"
        "net"
        "sync"
        "time"
)

// A Conn represents a secured connection.
// It implements the net.Conn interface.
type Conn struct {
        // constant
        conn     net.Conn
        isClient bool

        // constant after handshake; protected by handshakeMutex
        handshakeMutex    sync.Mutex // handshakeMutex &lt; in.Mutex, out.Mutex, errMutex
        handshakeErr      error      // error resulting from handshake
        vers              uint16     // TLS version
        haveVers          bool       // version has been negotiated
        config            *Config    // configuration passed to constructor
        handshakeComplete bool
        didResume         bool // whether this connection was a session resumption
        cipherSuite       uint16
        ocspResponse      []byte // stapled OCSP response
        peerCertificates  []*x509.Certificate
        // verifiedChains contains the certificate chains that we built, as
        // opposed to the ones presented by the server.
        verifiedChains [][]*x509.Certificate
        // serverName contains the server name indicated by the client, if any.
        serverName string

        clientProtocol         string
        clientProtocolFallback bool

    // cert type, like sha1/sha256...
    certType    string

        // input/output
        in, out  halfConn     // in.Mutex &lt; out.Mutex
        rawInput *block       // raw input, right off the wire
        input    *block       // application data waiting to be read
        hand     bytes.Buffer // handshake data waiting to be read

        // total bytes of application data sent recently
        // byteOut will be reset to zero after inactivity
        byteOut int

        // finish time of last writeRecord()
        lastOut time.Time

        tmp [16]byte

    // for sslv2 client hello
    sslv2Data []byte
}

// Access to net.Conn methods.
// Cannot just embed net.Conn because that would
// export the struct field too.

// LocalAddr returns the local network address.
func (c *Conn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.LocalAddr()
}</span>

// RemoteAddr returns the remote network address.
func (c *Conn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.RemoteAddr()
}</span>

// GetNetConn returns the underlying connection.
func (c *Conn) GetNetConn() net.Conn <span class="cov0" title="0">{
        return c.conn
}</span>

// GetServerName returns server name indicated by the client, if any.
func (c *Conn) GetServerName() string <span class="cov0" title="0">{
    return c.serverName
}</span>

// GetCertType returns preferred cert type for the connection
func (c *Conn) GetCertType() string <span class="cov0" title="0">{
    return c.certType
}</span>

// SetDeadline sets the read and write deadlines associated with the connection.
// A zero value for t means Read and Write will not time out.
// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
func (c *Conn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetDeadline(t)
}</span>

// SetReadDeadline sets the read deadline on the underlying connection.
// A zero value for t means Read will not time out.
func (c *Conn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetReadDeadline(t)
}</span>

// SetWriteDeadline sets the write deadline on the underlying connection.
// A zero value for t means Write will not time out.
// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
func (c *Conn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetWriteDeadline(t)
}</span>

// Whether this connection did resume or not
func (c *Conn) IsResume() bool <span class="cov0" title="0">{
        return c.didResume
}</span>

// A halfConn represents one direction of the record layer
// connection, either sending or receiving.
type halfConn struct {
        sync.Mutex

        err     error       // first permanent error
        version uint16      // protocol version
        cipher  interface{} // cipher algorithm
        mac     macFunction
        seq     [8]byte // 64-bit sequence number
        bfree   *block  // list of free blocks

        nextCipher interface{} // next encryption state
        nextMac    macFunction // next MAC algorithm

        // used to save allocating a new buffer for each MAC.
        inDigestBuf, outDigestBuf []byte
}

func (hc *halfConn) setErrorLocked(err error) error <span class="cov6" title="61">{
        hc.err = err
        return err
}</span>

func (hc *halfConn) error() error <span class="cov6" title="65">{
        hc.Lock()
        err := hc.err
        hc.Unlock()
        return err
}</span>

// prepareCipherSpec sets the encryption and MAC states
// that a subsequent changeCipherSpec will use.
func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac macFunction) <span class="cov7" title="130">{
        hc.version = version
        hc.nextCipher = cipher
        hc.nextMac = mac
}</span>

// changeCipherSpec changes the encryption and MAC states
// to the ones previously passed to prepareCipherSpec.
func (hc *halfConn) changeCipherSpec() error <span class="cov7" title="130">{
        if hc.nextCipher == nil </span><span class="cov0" title="0">{
                return alertInternalError
        }</span>
        <span class="cov7" title="130">hc.cipher = hc.nextCipher
        hc.mac = hc.nextMac
        hc.nextCipher = nil
        hc.nextMac = nil
        for i := range hc.seq </span><span class="cov9" title="1040">{
                hc.seq[i] = 0
        }</span>
        <span class="cov7" title="130">return nil</span>
}

// incSeq increments the sequence number.
func (hc *halfConn) incSeq() <span class="cov9" title="764">{
        for i := 7; i &gt;= 0; i-- </span><span class="cov9" title="764">{
                hc.seq[i]++
                if hc.seq[i] != 0 </span><span class="cov9" title="764">{
                        return
                }</span>
        }

        // Not allowed to let sequence number wrap.
        // Instead, must renegotiate before it does.
        // Not likely enough to bother.
        <span class="cov0" title="0">panic("TLS: sequence number wraparound")</span>
}

// resetSeq resets the sequence number to zero.
func (hc *halfConn) resetSeq() <span class="cov0" title="0">{
        for i := range hc.seq </span><span class="cov0" title="0">{
                hc.seq[i] = 0
        }</span>
}

// removePadding returns an unpadded slice, in constant time, which is a prefix
// of the input. It also returns a byte which is equal to 255 if the padding
// was valid and 0 otherwise. See RFC 2246, section 6.2.3.2
func removePadding(payload []byte) ([]byte, byte) <span class="cov5" title="33">{
        if len(payload) &lt; 1 </span><span class="cov0" title="0">{
                return payload, 0
        }</span>

        <span class="cov5" title="33">paddingLen := payload[len(payload)-1]
        t := uint(len(payload)-1) - uint(paddingLen)
        // if len(payload) &gt;= (paddingLen - 1) then the MSB of t is zero
        good := byte(int32(^t) &gt;&gt; 31)

        toCheck := 255 // the maximum possible padding length
        // The length of the padded data is public, so we can use an if here
        if toCheck+1 &gt; len(payload) </span><span class="cov5" title="33">{
                toCheck = len(payload) - 1
        }</span>

        <span class="cov5" title="33">for i := 0; i &lt; toCheck; i++ </span><span class="cov9" title="1114">{
                t := uint(paddingLen) - uint(i)
                // if i &lt;= paddingLen then the MSB of t is zero
                mask := byte(int32(^t) &gt;&gt; 31)
                b := payload[len(payload)-1-i]
                good &amp;^= mask&amp;paddingLen ^ mask&amp;b
        }</span>

        // We AND together the bits of good and replicate the result across
        // all the bits.
        <span class="cov5" title="33">good &amp;= good &lt;&lt; 4
        good &amp;= good &lt;&lt; 2
        good &amp;= good &lt;&lt; 1
        good = uint8(int8(good) &gt;&gt; 7)

        toRemove := good&amp;paddingLen + 1
        return payload[:len(payload)-int(toRemove)], good</span>
}

// removePaddingSSL30 is a replacement for removePadding in the case that the
// protocol version is SSLv3. In this version, the contents of the padding
// are random and cannot be checked.
func removePaddingSSL30(payload []byte) ([]byte, byte) <span class="cov1" title="2">{
        if len(payload) &lt; 1 </span><span class="cov0" title="0">{
                return payload, 0
        }</span>

        <span class="cov1" title="2">paddingLen := int(payload[len(payload)-1]) + 1
        if paddingLen &gt; len(payload) </span><span class="cov0" title="0">{
                return payload, 0
        }</span>

        <span class="cov1" title="2">return payload[:len(payload)-paddingLen], 255</span>
}

func roundUp(a, b int) int <span class="cov5" title="30">{
        return a + (b-a%b)%b
}</span>

// cbcMode is an interface for block ciphers using cipher block chaining.
type cbcMode interface {
        cipher.BlockMode
        SetIV([]byte)
}

// decrypt checks and strips the mac and decrypts the data in b. Returns a
// success boolean, the number of bytes to skip from the start of the record in
// order to get the application payload, and an optional alert value.
func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert) <span class="cov8" title="318">{
        // pull out payload
        payload := b.data[recordHeaderLen:]

        macSize := 0
        if hc.mac != nil </span><span class="cov6" title="61">{
                macSize = hc.mac.Size()
        }</span>

        <span class="cov8" title="318">paddingGood := byte(255)
        explicitIVLen := 0

        // decrypt
        if hc.cipher != nil </span><span class="cov6" title="68">{
                switch c := hc.cipher.(type) </span>{
                <span class="cov5" title="36">case cipher.Stream:
                        c.XORKeyStream(payload, payload)</span>
                <span class="cov3" title="7">case cipher.AEAD:
                        explicitIVLen = 8
                        if len(payload) &lt; explicitIVLen </span><span class="cov0" title="0">{
                                return false, 0, alertBadRecordMAC
                        }</span>
                        <span class="cov3" title="7">nonce := payload[:8]
                        payload = payload[8:]

                        var additionalData [13]byte
                        copy(additionalData[:], hc.seq[:])
                        copy(additionalData[8:], b.data[:3])
                        n := len(payload) - c.Overhead()
                        additionalData[11] = byte(n &gt;&gt; 8)
                        additionalData[12] = byte(n)
                        var err error
                        payload, err = c.Open(payload[:0], nonce, payload, additionalData[:])
                        if err != nil </span><span class="cov0" title="0">{
                                return false, 0, alertBadRecordMAC
                        }</span>
                        <span class="cov3" title="7">b.resize(recordHeaderLen + explicitIVLen + len(payload))</span>
                <span class="cov4" title="25">case cbcMode:
                        blockSize := c.BlockSize()
                        if hc.version &gt;= VersionTLS11 </span><span class="cov4" title="16">{
                                explicitIVLen = blockSize
                        }</span>

                        <span class="cov4" title="25">if len(payload)%blockSize != 0 || len(payload) &lt; roundUp(explicitIVLen+macSize+1, blockSize) </span><span class="cov0" title="0">{
                                return false, 0, alertBadRecordMAC
                        }</span>

                        <span class="cov4" title="25">if explicitIVLen &gt; 0 </span><span class="cov4" title="16">{
                                c.SetIV(payload[:explicitIVLen])
                                payload = payload[explicitIVLen:]
                        }</span>
                        <span class="cov4" title="25">c.CryptBlocks(payload, payload)
                        if hc.version == VersionSSL30 </span><span class="cov1" title="2">{
                                payload, paddingGood = removePaddingSSL30(payload)
                        }</span> <span class="cov4" title="23">else {
                                payload, paddingGood = removePadding(payload)
                        }</span>
                        <span class="cov4" title="25">b.resize(recordHeaderLen + explicitIVLen + len(payload))</span>

                        // note that we still have a timing side-channel in the
                        // MAC check, below. An attacker can align the record
                        // so that a correct padding will cause one less hash
                        // block to be calculated. Then they can iteratively
                        // decrypt a record by breaking each byte. See
                        // "Password Interception in a SSL/TLS Channel", Brice
                        // Canvel et al.
                        //
                        // However, our behavior matches OpenSSL, so we leak
                        // only as much as they do.
                <span class="cov0" title="0">default:
                        panic("unknown cipher type")</span>
                }
        }

        // check, strip mac
        <span class="cov8" title="318">if hc.mac != nil </span><span class="cov6" title="61">{
                if len(payload) &lt; macSize </span><span class="cov0" title="0">{
                        return false, 0, alertBadRecordMAC
                }</span>

                // strip mac off payload, b.data
                <span class="cov6" title="61">n := len(payload) - macSize
                b.data[3] = byte(n &gt;&gt; 8)
                b.data[4] = byte(n)
                b.resize(recordHeaderLen + explicitIVLen + n)
                remoteMAC := payload[n:]
                localMAC := hc.mac.MAC(hc.inDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], payload[:n])

                if subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 </span><span class="cov0" title="0">{
                        return false, 0, alertBadRecordMAC
                }</span>
                <span class="cov6" title="61">hc.inDigestBuf = localMAC</span>
        }
        <span class="cov8" title="318">hc.incSeq()

        return true, recordHeaderLen + explicitIVLen, 0</span>
}

// padToBlockSize calculates the needed padding block, if any, for a payload.
// On exit, prefix aliases payload and extends to the end of the last full
// block of payload. finalBlock is a fresh slice which contains the contents of
// any suffix of payload as well as the needed padding to make finalBlock a
// full block.
func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) <span class="cov6" title="80">{
        overrun := len(payload) % blockSize
        paddingLen := blockSize - overrun
        prefix = payload[:len(payload)-overrun]
        finalBlock = make([]byte, blockSize)
        copy(finalBlock, payload[len(payload)-overrun:])
        for i := overrun; i &lt; blockSize; i++ </span><span class="cov9" title="797">{
                finalBlock[i] = byte(paddingLen - 1)
        }</span>
        <span class="cov6" title="80">return</span>
}

// encrypt encrypts and macs the data in b.
func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) <span class="cov8" title="446">{
        // mac
        if hc.mac != nil </span><span class="cov7" title="152">{
                mac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:])

                n := len(b.data)
                b.resize(n + len(mac))
                copy(b.data[n:], mac)
                hc.outDigestBuf = mac
        }</span>

        <span class="cov8" title="446">payload := b.data[recordHeaderLen:]

        // encrypt
        if hc.cipher != nil </span><span class="cov7" title="164">{
                switch c := hc.cipher.(type) </span>{
                <span class="cov6" title="72">case cipher.Stream:
                        c.XORKeyStream(payload, payload)</span>
                <span class="cov4" title="12">case cipher.AEAD:
                        payloadLen := len(b.data) - recordHeaderLen - explicitIVLen
                        b.resize(len(b.data) + c.Overhead())
                        nonce := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
                        payload := b.data[recordHeaderLen+explicitIVLen:]
                        payload = payload[:payloadLen]

                        var additionalData [13]byte
                        copy(additionalData[:], hc.seq[:])
                        copy(additionalData[8:], b.data[:3])
                        additionalData[11] = byte(payloadLen &gt;&gt; 8)
                        additionalData[12] = byte(payloadLen)

                        c.Seal(payload[:0], nonce, payload, additionalData[:])</span>
                <span class="cov6" title="80">case cbcMode:
                        blockSize := c.BlockSize()
                        if explicitIVLen &gt; 0 </span><span class="cov5" title="44">{
                                c.SetIV(payload[:explicitIVLen])
                                payload = payload[explicitIVLen:]
                        }</span>
                        <span class="cov6" title="80">prefix, finalBlock := padToBlockSize(payload, blockSize)
                        b.resize(recordHeaderLen + explicitIVLen + len(prefix) + len(finalBlock))
                        c.CryptBlocks(b.data[recordHeaderLen+explicitIVLen:], prefix)
                        c.CryptBlocks(b.data[recordHeaderLen+explicitIVLen+len(prefix):], finalBlock)</span>
                <span class="cov0" title="0">default:
                        panic("unknown cipher type")</span>
                }
        }

        // update length to include MAC and any block padding needed.
        <span class="cov8" title="446">n := len(b.data) - recordHeaderLen
        b.data[3] = byte(n &gt;&gt; 8)
        b.data[4] = byte(n)
        hc.incSeq()

        return true, 0</span>
}

// A block is a simple data buffer.
type block struct {
        data []byte
        off  int // index for Read
        link *block
}

// resize resizes block to be n bytes, growing if necessary.
func (b *block) resize(n int) <span class="cov10" title="1463">{
        if n &gt; cap(b.data) </span><span class="cov7" title="133">{
                b.reserve(n)
        }</span>
        <span class="cov10" title="1463">b.data = b.data[0:n]</span>
}

// reserve makes sure that block contains a capacity of at least n bytes.
func (b *block) reserve(n int) <span class="cov8" title="328">{
        if cap(b.data) &gt;= n </span><span class="cov6" title="115">{
                return
        }</span>
        <span class="cov7" title="213">m := cap(b.data)
        if m == 0 </span><span class="cov7" title="213">{
                m = 1024
        }</span>
        <span class="cov7" title="213">for m &lt; n </span><span class="cov0" title="0">{
                m *= 2
        }</span>
        <span class="cov7" title="213">data := make([]byte, len(b.data), m)
        copy(data, b.data)
        b.data = data</span>
}

// readFromUntil reads from r into b until b contains at least n bytes
// or else returns an error.
func (b *block) readFromUntil(r io.Reader, n int) error <span class="cov8" title="639">{
        // quick case
        if len(b.data) &gt;= n </span><span class="cov8" title="444">{
                return nil
        }</span>

        // read until have enough.
        <span class="cov7" title="195">b.reserve(n)
        for </span><span class="cov7" title="195">{
                m, err := r.Read(b.data[len(b.data):cap(b.data)])
                b.data = b.data[0 : len(b.data)+m]
                if len(b.data) &gt;= n </span><span class="cov7" title="192">{
                        // TODO(bradfitz,agl): slightly suspicious
                        // that we're throwing away r.Read's err here.
                        break</span>
                }
                <span class="cov2" title="3">if err != nil </span><span class="cov2" title="3">{
                        return err
                }</span>
        }
        <span class="cov7" title="192">return nil</span>
}

func (b *block) Read(p []byte) (n int, err error) <span class="cov1" title="2">{
        n = copy(p, b.data[b.off:])
        b.off += n
        return
}</span>

// newBlock allocates a new block, from hc's free list if possible.
func (hc *halfConn) newBlock() *block <span class="cov9" title="767">{
        b := hc.bfree
        if b == nil </span><span class="cov7" title="213">{
                return new(block)
        }</span>
        <span class="cov8" title="554">hc.bfree = b.link
        b.link = nil
        b.resize(0)
        return b</span>
}

// freeBlock returns a block to hc's free list.
// The protocol is such that each side only has a block or two on
// its free list at a time, so there's no need to worry about
// trimming the list, etc.
func (hc *halfConn) freeBlock(b *block) <span class="cov9" title="764">{
        b.link = hc.bfree
        hc.bfree = b
}</span>

// splitBlock splits a block after the first n bytes,
// returning a block with those n bytes and a
// block with the remainder.  the latter may be nil.
func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) <span class="cov8" title="318">{
        if len(b.data) &lt;= n </span><span class="cov7" title="192">{
                return b, nil
        }</span>
        <span class="cov6" title="126">bb := hc.newBlock()
        bb.resize(len(b.data) - n)
        copy(bb.data, b.data[n:])
        b.data = b.data[0:n]
        return b, bb</span>
}

/* convertSSLv2ClientHello - convert SSLv2 ClientHello to TLS ClientHello
 *
 * Note: 
 * 1. TLS clients that wish to support SSLv2 servers must send 
 *    SSLv2 CLIENT-HELLO messages.
 * 2. Even TLS servers that do not support SSLv2 may accept SSLv2 
 *    CLIENT-HELLO messages.
 * 3. For negotiation purposes, SSLv2 CLIENT-HELLO is interpreted 
 *    the same way as a TLS ClientHello
 *
 * For more details, see:
 * - tls1.2 https://tools.ietf.org/html/rfc5246#appendix-E
 * - tls1.1 https://tools.ietf.org/html/rfc4346#appendix-E
 * - tls1.0 https://tools.ietf.org/html/rfc2246#appendix-E
 * - sslv3  https://tools.ietf.org/html/draft-ietf-tls-ssl-version3-00
 * - sslv2  http://www-archive.mozilla.org/projects/security/pki/nss/ssl/draft02.html
 *
 * SSLv2 compatible CLIENT-HEELO message
 *
 *   0                                 16 bit
 *   +----------------------------------+
 *   |              MsgLength           |   (Highest bit MUST be 1)
 *   +----------------+-----------------+
 *   |    MsgType     |                     (Must be 1, ClientHello)
 *   +----------------+-----------------+
 *   |  MajorVersion  |  MinorVersion   |  
 *   +----------------+-----------------+
 *   |           CipherSpecLen          |   (Must be multiply of 3)
 *   +----------------+-----------------+
 *   |           SessionIdLen           |   (Must be zero or 16 bytes for tls1.0 client, 
 *   +----------------+-----------------+    Must be zero for tls1.1/tls1.2 client)
 *   |           ChallengeLen           |
 *   +----------------+-----------------+
 *   |            CipherSpec            |   
 *   .       (CipherSpecLen bytes)      .
 *   .                                  .
 *   +----------------+-----------------+
 *   |            Session Id            |
 *   .       (SessionIdLen bytes)       .
 *   .                                  .
 *   +----------------------------------+
 *   |            Challenge             |   (Client Hello random)
 *   .       (ChallengeLen bytes)       .
 *   .                                  .
 *   +----------------------------------+
 */
func convertSSLv2ClientHello(c *Conn, b *block) error <span class="cov0" title="0">{
   // high bit must be 1 for SSLv2 compatible client hello
   if (uint8(b.data[0]) &amp; 128) != 128 </span><span class="cov0" title="0">{
       return c.sendAlert(alertUnexpectedMessage)
   }</span>

   <span class="cov0" title="0">msgLength := (uint16(b.data[0]&amp;0x7f) &lt;&lt; 8) | uint16(b.data[1])
   if msgLength &lt; 12 </span><span class="cov0" title="0">{
       return c.sendAlert(alertHandshakeFailure)
   }</span>

   // check if this is an SSLv2 client-hello but TLS is supported
   <span class="cov0" title="0">msgType := uint8(b.data[2])
   majorVer := uint8(b.data[3])
   minorVer := uint8(b.data[4])
   version := uint16(majorVer)&lt;&lt;8 | uint16(minorVer)
   if !(msgType == typeClientHello &amp;&amp; version &gt;= VersionSSL30) </span><span class="cov0" title="0">{
           c.sendAlert(alertProtocolVersion)
           stateInc(ERR_SSLV2_NOT_SUPPORT, 1)
           return c.in.setErrorLocked(errors.New("tls: unsupported SSLv2 handshake received"))
   }</span>
   <span class="cov0" title="0">stateInc(HANDSHAKE_ACCEPT_SSLV2_CLIENT_HEELO, 1)

   // read the rest of the bytes for client hello
   if err := b.readFromUntil(c.conn, int(2+msgLength)); err != nil </span><span class="cov0" title="0">{
       if err == io.EOF </span><span class="cov0" title="0">{
           err = io.ErrUnexpectedEOF
       }</span>
       <span class="cov0" title="0">if e, ok := err.(net.Error); !ok || !e.Temporary() </span><span class="cov0" title="0">{
           c.in.setErrorLocked(err)
       }</span>
       <span class="cov0" title="0">return err</span>
   }

   // get the cipher spec length
   <span class="cov0" title="0">cipherSpecLength := uint16(b.data[5])&lt;&lt;8 | uint16(b.data[6])
   if cipherSpecLength &lt;= 0 || (cipherSpecLength % 3) != 0 </span><span class="cov0" title="0">{
       return c.sendAlert(alertHandshakeFailure)
   }</span>

   // get the session id length
   <span class="cov0" title="0">sessionIdLength := uint16(b.data[7])&lt;&lt;8 | uint16(b.data[8])
   if sessionIdLength != 0 &amp;&amp; sessionIdLength != 16 </span><span class="cov0" title="0">{
       return c.sendAlert(alertHandshakeFailure)
   }</span>

   <span class="cov0" title="0">if len(b.data) &lt; 11 + int(cipherSpecLength+sessionIdLength) </span><span class="cov0" title="0">{
       return c.sendAlert(alertHandshakeFailure)
   }</span>

   // read the cipher specs
   <span class="cov0" title="0">cipherSpecs := b.data[11: 11+cipherSpecLength]

   // read the rest of the data
   challengeData := b.data[11+cipherSpecLength+sessionIdLength:]

   // mark this data as read?
   b, c.rawInput = c.in.splitBlock(b, int(2+msgLength))
   b.off = 2

   // create tls clientHello message 
   helloMsg := clientHelloMsg{}
   helloMsg.vers = version
   helloMsg.sessionId = []byte{0}
   helloMsg.compressionMethods = []uint8{compressionNone}

   if len(challengeData) &gt;= 32 </span><span class="cov0" title="0">{
       helloMsg.random = challengeData[:32]
   }</span> <span class="cov0" title="0">else {
       helloMsg.random = make([]byte, 32-len(challengeData))
       helloMsg.random = append(helloMsg.random, challengeData...)
   }</span>

   <span class="cov0" title="0">helloMsg.cipherSuites = make([]uint16, 0, 0)
   for i := 0; i &lt; len(cipherSpecs); i += 3 </span><span class="cov0" title="0">{
       // we can only support cipher specs starting with a high bit
       if cipherSpecs[i] == 0 </span><span class="cov0" title="0">{
           cipher := uint16(cipherSpecs[i+1])&lt;&lt;8 | uint16(cipherSpecs[i+2])
           helloMsg.cipherSuites = append(helloMsg.cipherSuites, cipher)
       }</span>
   }

   // write clientHello message to the handshake buffer
   <span class="cov0" title="0">c.hand.Write(helloMsg.marshal())

   c.sslv2Data = b.data[2:]
   c.in.freeBlock(b)
   return nil</span>
}

// readRecord reads the next TLS record from the connection
// and updates the record layer state.
// c.in.Mutex &lt;= L; c.input == nil.
func (c *Conn) readRecord(want recordType) error <span class="cov8" title="321">{
        // Caller must be in sync with connection:
        // handshake data if handshake not yet completed,
        // else application data.  (We don't support renegotiation.)
        switch want </span>{
        <span class="cov0" title="0">default:
                c.sendAlert(alertInternalError)
                stateInc(ERR_UNKNOWN_RECORD_TYPE, 1)
                return c.in.setErrorLocked(errors.New("tls: unknown record type requested"))</span>
        <span class="cov8" title="318">case recordTypeHandshake, recordTypeChangeCipherSpec:
                if c.handshakeComplete </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        stateInc(ERR_WRONG_RECORD_TYPE_AFTER_HS_COMPLETE, 1)
                        return c.in.setErrorLocked(errors.New("tls: handshake or ChangeCipherSpec requested after handshake complete"))
                }</span>
        <span class="cov2" title="3">case recordTypeApplicationData:
                if !c.handshakeComplete </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        stateInc(ERR_WRONG_RECORD_TYPE_BEFORE_HS_COMPLETE, 1)
                        return c.in.setErrorLocked(errors.New("tls: application data record requested before handshake complete"))
                }</span>
        }

<span class="cov8" title="321">Again:
        if c.rawInput == nil </span><span class="cov7" title="195">{
                c.rawInput = c.in.newBlock()
        }</span>
        <span class="cov8" title="321">b := c.rawInput

        // Read header, payload.
        if err := b.readFromUntil(c.conn, recordHeaderLen); err != nil </span><span class="cov2" title="3">{
                // RFC suggests that EOF without an alertCloseNotify is
                // an error, but popular web sites seem to do this,
                // so we can't make it an error.
                // if err == io.EOF {
                //         err = io.ErrUnexpectedEOF
                // }
                if e, ok := err.(net.Error); !ok || !e.Temporary() </span><span class="cov2" title="3">{
                        c.in.setErrorLocked(err)
                }</span>
                <span class="cov2" title="3">return err</span>
        }
        <span class="cov8" title="318">typ := recordType(b.data[0])

        // No valid TLS record has a type of 0x80, however SSLv2 handshakes
        // start with a uint16 length where the MSB is set and the first record
        // is always &lt; 256 bytes long. Therefore typ == 0x80 strongly suggests
        // an SSLv2 client.
        if want == recordTypeHandshake &amp;&amp; typ == 0x80 </span><span class="cov0" title="0">{
        // if this is an SSLv2 header, lets see if we can upgrade to TLS
        if c.config.EnableSslv2ClientHello </span><span class="cov0" title="0">{
            return convertSSLv2ClientHello(c, b)
        }</span> <span class="cov0" title="0">else {
            c.sendAlert(alertProtocolVersion)
            stateInc(ERR_SSLV2_NOT_SUPPORT, 1)
            return c.in.setErrorLocked(errors.New("tls: unsupported SSLv2 handshake received"))
        }</span>
        }

        <span class="cov8" title="318">vers := uint16(b.data[1])&lt;&lt;8 | uint16(b.data[2])
        n := int(b.data[3])&lt;&lt;8 | int(b.data[4])
        if c.haveVers &amp;&amp; vers != c.vers </span><span class="cov0" title="0">{
                c.sendAlert(alertProtocolVersion)
                stateInc(ERR_VERSION_NOT_EXPECTED, 1)
                return c.in.setErrorLocked(fmt.Errorf("tls: received record with version %x when expecting version %x", vers, c.vers))
        }</span>
        <span class="cov8" title="318">if n &gt; maxCiphertext </span><span class="cov0" title="0">{
                c.sendAlert(alertRecordOverflow)
                stateInc(ERR_RECORD_OVERFLOW, 1)
                return c.in.setErrorLocked(fmt.Errorf("tls: oversized record received with length %d", n))
        }</span>
        <span class="cov8" title="318">if !c.haveVers </span><span class="cov6" title="78">{
                // First message, be extra suspicious:
                // this might not be a TLS client.
                // Bail out before reading a full 'body', if possible.
                // The current max version is 3.1.
                // If the version is &gt;= 16.0, it's probably not real.
                // Similarly, a clientHello message encodes in
                // well under a kilobyte.  If the length is &gt;= 12 kB,
                // it's probably not real.
                if (typ != recordTypeAlert &amp;&amp; typ != want) || vers &gt;= 0x1000 || n &gt;= 0x3000 </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        stateInc(ERR_UNEXPECTED_MESSAGE, 1)
                        return c.in.setErrorLocked(fmt.Errorf("tls: first record does not look like a TLS handshake"))
                }</span>
        }
        <span class="cov8" title="318">if err := b.readFromUntil(c.conn, recordHeaderLen+n); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        stateInc(ERR_UNEXPECTED_EOF, 1)
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">if e, ok := err.(net.Error); !ok || !e.Temporary() </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Process message.
        <span class="cov8" title="318">b, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)
        ok, off, err := c.in.decrypt(b)
        if !ok </span><span class="cov0" title="0">{
                c.in.setErrorLocked(c.sendAlert(err))
        }</span>
        <span class="cov8" title="318">b.off = off
        data := b.data[b.off:]
        if len(data) &gt; maxPlaintext </span><span class="cov0" title="0">{
                err := c.sendAlert(alertRecordOverflow)
                c.in.freeBlock(b)
                stateInc(ERR_ALERT_RECORD_OVERFLOW, 1)
                return c.in.setErrorLocked(err)
        }</span>

        <span class="cov8" title="318">switch typ </span>{
        <span class="cov0" title="0">default:
                stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))</span>

        <span class="cov1" title="2">case recordTypeAlert:
                if len(data) != 2 </span><span class="cov0" title="0">{
                        stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
                        break</span>
                }
                <span class="cov1" title="2">if alert(data[1]) == alertCloseNotify </span><span class="cov1" title="1">{
                        stateInc(ERR_ALERT_CLOSE_NOTIFY, 1)
                        c.in.setErrorLocked(io.EOF)
                        break</span>
                }
                <span class="cov1" title="1">switch data[0] </span>{
                <span class="cov0" title="0">case alertLevelWarning:
                        // drop on the floor
                        c.in.freeBlock(b)
                        goto Again</span>
                <span class="cov1" title="1">case alertLevelError:
                        c.in.setErrorLocked(&amp;net.OpError{Op: "remote error", Err: alert(data[1])})</span>
                <span class="cov0" title="0">default:
                        stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))</span>
                }

        <span class="cov6" title="65">case recordTypeChangeCipherSpec:
                if typ != want || len(data) != 1 || data[0] != 1 </span><span class="cov0" title="0">{
                        stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
                        break</span>
                }
                <span class="cov6" title="65">err := c.in.changeCipherSpec()
                if err != nil </span><span class="cov0" title="0">{
                        c.in.setErrorLocked(c.sendAlert(err.(alert)))
                }</span>

        <span class="cov1" title="2">case recordTypeApplicationData:
                if typ != want </span><span class="cov0" title="0">{
                        stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                        c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
                        break</span>
                }
                <span class="cov1" title="2">c.input = b
                b = nil</span>

        <span class="cov7" title="249">case recordTypeHandshake:
                // TODO(rsc): Should at least pick off connection close.
                if typ != want </span><span class="cov0" title="0">{
                        stateInc(ERR_ALERT_NO_RENEGOTIATION, 1)
                        return c.in.setErrorLocked(c.sendAlert(alertNoRenegotiation))
                }</span>
                <span class="cov7" title="249">c.hand.Write(data)</span>
        }

        <span class="cov8" title="318">if b != nil </span><span class="cov8" title="316">{
                c.in.freeBlock(b)
        }</span>
        <span class="cov8" title="318">return c.in.err</span>
}

// sendAlert sends a TLS alert message.
// c.out.Mutex &lt;= L.
func (c *Conn) sendAlertLocked(err alert) error <span class="cov5" title="56">{
        switch err </span>{
        <span class="cov5" title="45">case alertNoRenegotiation, alertCloseNotify:
                c.tmp[0] = alertLevelWarning</span>
        <span class="cov3" title="11">default:
                c.tmp[0] = alertLevelError</span>
        }
        <span class="cov5" title="56">c.tmp[1] = byte(err)
        c.writeRecord(recordTypeAlert, c.tmp[0:2])
        // closeNotify is a special case in that it isn't an error:
        if err != alertCloseNotify </span><span class="cov3" title="11">{
                return c.out.setErrorLocked(&amp;net.OpError{Op: "local error", Err: err})
        }</span>
        <span class="cov5" title="45">return nil</span>
}

// sendAlert sends a TLS alert message.
// L &lt; c.out.Mutex.
func (c *Conn) sendAlert(err alert) error <span class="cov5" title="56">{
        c.out.Lock()
        defer c.out.Unlock()
        return c.sendAlertLocked(err)
}</span>

/* choosePlaintextSize - choose size of record plaintext
 *
 * Note:
 * 1. We use small TLS records that fit into a single TCP segment for the
 *    first `bytesThreshold` Byte of data,
 * 2. increase record size to maxPlaintext after that to optimize throughput,
 * 3. and then reset record size back to a single segment
 *    after `inactiveSeconds` second of inactivity,
 * 4. lather, rinse, repeat
 */
func (c *Conn) choosePlaintextSize() int <span class="cov5" title="54">{
        if c.byteOut &lt; bytesThreshold </span><span class="cov5" title="54">{
                return initPlaintext
        }</span>

        <span class="cov0" title="0">if time.Since(c.lastOut) &lt; inactiveSeconds </span><span class="cov0" title="0">{
                return maxPlaintext
        }</span>

        // reset bytes sent recently
        <span class="cov0" title="0">c.byteOut = 0
        return initPlaintext</span>
}

// writeRecord writes a TLS record with the given type and payload
// to the connection and updates the record layer state.
// c.out.Mutex &lt;= L.
func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) <span class="cov8" title="446">{
    // choose appropriate size for record
    // Note: Some IE browsers fail to parse fragmented TLS/SSL handshake message,
    // we just choose dynamic record size for applicate data message. For more informaction,
    // see https://support.microsoft.com/en-us/kb/2541763
    plaintextSize := maxPlaintext
    if typ == recordTypeApplicationData </span><span class="cov5" title="54">{
        plaintextSize = c.choosePlaintextSize()
    }</span>

        <span class="cov8" title="446">b := c.out.newBlock()
        for len(data) &gt; 0 </span><span class="cov8" title="446">{
                m := len(data)
                // split data into segment of size 'plaintextSize'
                if m &gt; plaintextSize </span><span class="cov0" title="0">{
                        m = plaintextSize
                }</span>
                <span class="cov8" title="446">explicitIVLen := 0
                explicitIVIsSeq := false

                var cbc cbcMode
                if c.out.version &gt;= VersionTLS11 </span><span class="cov7" title="171">{
                        var ok bool
                        if cbc, ok = c.out.cipher.(cbcMode); ok </span><span class="cov5" title="44">{
                                explicitIVLen = cbc.BlockSize()
                        }</span>
                }
                <span class="cov8" title="446">if explicitIVLen == 0 </span><span class="cov8" title="402">{
                        if _, ok := c.out.cipher.(cipher.AEAD); ok </span><span class="cov4" title="12">{
                                explicitIVLen = 8
                                // The AES-GCM construction in TLS has an
                                // explicit nonce so that the nonce can be
                                // random. However, the nonce is only 8 bytes
                                // which is too small for a secure, random
                                // nonce. Therefore we use the sequence number
                                // as the nonce.
                                explicitIVIsSeq = true
                        }</span>
                }
                <span class="cov8" title="446">b.resize(recordHeaderLen + explicitIVLen + m)
                b.data[0] = byte(typ)
                vers := c.vers
                if vers == 0 </span><span class="cov5" title="40">{
                        // Some TLS servers fail if the record version is
                        // greater than TLS 1.0 for the initial ClientHello.
                        vers = VersionTLS10
                }</span>
                <span class="cov8" title="446">b.data[1] = byte(vers &gt;&gt; 8)
                b.data[2] = byte(vers)
                b.data[3] = byte(m &gt;&gt; 8)
                b.data[4] = byte(m)
                if explicitIVLen &gt; 0 </span><span class="cov5" title="56">{
                        explicitIV := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
                        if explicitIVIsSeq </span><span class="cov4" title="12">{
                                copy(explicitIV, c.out.seq[:])
                        }</span> <span class="cov5" title="44">else {
                                if _, err = io.ReadFull(c.config.rand(), explicitIV); err != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="446">copy(b.data[recordHeaderLen+explicitIVLen:], data)
                c.out.encrypt(b, explicitIVLen)
                _, err = c.conn.Write(b.data)
                if err != nil </span><span class="cov3" title="11">{
                        break</span>
                }
                <span class="cov8" title="435">n += m
                data = data[m:]</span>
        }
        <span class="cov8" title="446">c.out.freeBlock(b)

        if typ == recordTypeChangeCipherSpec </span><span class="cov6" title="65">{
                err = c.out.changeCipherSpec()
                if err != nil </span><span class="cov0" title="0">{
                        // Cannot call sendAlert directly,
                        // because we already hold c.out.Mutex.
                        c.tmp[0] = alertLevelError
                        c.tmp[1] = byte(err.(alert))
                        c.writeRecord(recordTypeAlert, c.tmp[0:2])
                        return n, c.out.setErrorLocked(&amp;net.OpError{Op: "local error", Err: err})
                }</span>
        }

        // update total bytes of application data sent
        <span class="cov8" title="446">if typ == recordTypeApplicationData </span><span class="cov5" title="54">{
                c.byteOut += n
                c.lastOut = time.Now()
        }</span>
        <span class="cov8" title="446">return</span>
}

// readHandshake reads the next handshake message from
// the record layer.
// c.in.Mutex &lt; L; c.out.Mutex &lt; L.
func (c *Conn) readHandshake() (interface{}, error) <span class="cov7" title="261">{
        for c.hand.Len() &lt; 4 </span><span class="cov7" title="253">{
                if err := c.in.err; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="253">if err := c.readRecord(recordTypeHandshake); err != nil </span><span class="cov2" title="4">{
                        return nil, err
                }</span>
        }

        <span class="cov7" title="257">data := c.hand.Bytes()
        n := int(data[1])&lt;&lt;16 | int(data[2])&lt;&lt;8 | int(data[3])
        if n &gt; maxHandshake </span><span class="cov0" title="0">{
                stateInc(ERR_ALERT_INTERNAL_ERROR, 1)
                return nil, c.in.setErrorLocked(c.sendAlert(alertInternalError))
        }</span>
        <span class="cov7" title="257">for c.hand.Len() &lt; 4+n </span><span class="cov0" title="0">{
                if err := c.in.err; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := c.readRecord(recordTypeHandshake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov7" title="257">data = c.hand.Next(4 + n)
        var m handshakeMessage
        switch data[0] </span>{
        <span class="cov5" title="46">case typeClientHello:
                m = new(clientHelloMsg)</span>
        <span class="cov5" title="30">case typeServerHello:
                m = new(serverHelloMsg)</span>
        <span class="cov2" title="3">case typeNewSessionTicket:
                m = new(newSessionTicketMsg)</span>
        <span class="cov5" title="29">case typeCertificate:
                m = new(certificateMsg)</span>
        <span class="cov3" title="8">case typeCertificateRequest:
                m = &amp;certificateRequestMsg{
                        hasSignatureAndHash: c.vers &gt;= VersionTLS12,
                }</span>
        <span class="cov0" title="0">case typeCertificateStatus:
                m = new(certificateStatusMsg)</span>
        <span class="cov4" title="15">case typeServerKeyExchange:
                m = new(serverKeyExchangeMsg)</span>
        <span class="cov5" title="27">case typeServerHelloDone:
                m = new(serverHelloDoneMsg)</span>
        <span class="cov5" title="32">case typeClientKeyExchange:
                m = new(clientKeyExchangeMsg)</span>
        <span class="cov1" title="2">case typeCertificateVerify:
                m = &amp;certificateVerifyMsg{
                        hasSignatureAndHash: c.vers &gt;= VersionTLS12,
                }</span>
        <span class="cov0" title="0">case typeNextProtocol:
                m = new(nextProtoMsg)</span>
        <span class="cov6" title="65">case typeFinished:
                m = new(finishedMsg)</span>
        <span class="cov0" title="0">default:
                stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))</span>
        }

        // The handshake message unmarshallers
        // expect to be able to keep references to data,
        // so pass in a fresh copy that won't be overwritten.
        <span class="cov7" title="257">data = append([]byte(nil), data...)

        if !m.unmarshal(data) </span><span class="cov0" title="0">{
                stateInc(ERR_ALERT_UNEXPECTED_MESSAGE, 1)
                return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
        }</span>
        <span class="cov7" title="257">return m, nil</span>
}

// Write writes data to the connection.
func (c *Conn) Write(b []byte) (int, error) <span class="cov5" title="46">{
        if err := c.Handshake(); err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov5" title="45">c.out.Lock()
        defer c.out.Unlock()

        if err := c.out.err; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov5" title="45">if !c.handshakeComplete </span><span class="cov0" title="0">{
                return 0, alertInternalError
        }</span>

        // SSL 3.0 and TLS 1.0 are susceptible to a chosen-plaintext
        // attack when using block mode ciphers due to predictable IVs.
        // This can be prevented by splitting each Application Data
        // record into two records, effectively randomizing the IV.
        //
        // http://www.openssl.org/~bodo/tls-cbc.txt
        // https://bugzilla.mozilla.org/show_bug.cgi?id=665814
        // http://www.imperialviolet.org/2012/01/15/beastfollowup.html

        <span class="cov5" title="45">var m int
        if len(b) &gt; 1 &amp;&amp; c.vers &lt;= VersionTLS10 </span><span class="cov4" title="14">{
                if _, ok := c.out.cipher.(cipher.BlockMode); ok </span><span class="cov3" title="9">{
                        n, err := c.writeRecord(recordTypeApplicationData, b[:1])
                        if err != nil </span><span class="cov0" title="0">{
                                return n, c.out.setErrorLocked(err)
                        }</span>
                        <span class="cov3" title="9">m, b = 1, b[1:]</span>
                }
        }

        <span class="cov5" title="45">n, err := c.writeRecord(recordTypeApplicationData, b)
        return n + m, c.out.setErrorLocked(err)</span>
}

// Read can be made to time out and return a net.Error with Timeout() == true
// after a fixed time limit; see SetDeadline and SetReadDeadline.
func (c *Conn) Read(b []byte) (n int, err error) <span class="cov1" title="2">{
        if err = c.Handshake(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="2">if len(b) == 0 </span><span class="cov0" title="0">{
                // Put this after Handshake, in case people were calling
                // Read(nil) for the side effect of the Handshake.
                return
        }</span>

        <span class="cov1" title="2">c.in.Lock()
        defer c.in.Unlock()

        // Some OpenSSL servers send empty records in order to randomize the
        // CBC IV. So this loop ignores a limited number of empty records.
        const maxConsecutiveEmptyRecords = 100
        for emptyRecordCount := 0; emptyRecordCount &lt;= maxConsecutiveEmptyRecords; emptyRecordCount++ </span><span class="cov1" title="2">{
                for c.input == nil &amp;&amp; c.in.err == nil </span><span class="cov1" title="2">{
                        if err := c.readRecord(recordTypeApplicationData); err != nil </span><span class="cov0" title="0">{
                                // Soft error, like EAGAIN
                                return 0, err
                        }</span>
                }
                <span class="cov1" title="2">if err := c.in.err; err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov1" title="2">n, err = c.input.Read(b)
                if c.input.off &gt;= len(c.input.data) </span><span class="cov1" title="2">{
                        c.in.freeBlock(c.input)
                        c.input = nil
                }</span>

                // If a close-notify alert is waiting, read it so that
                // we can return (n, EOF) instead of (n, nil), to signal
                // to the HTTP response reading goroutine that the
                // connection is now closed. This eliminates a race
                // where the HTTP response reading goroutine would
                // otherwise not observe the EOF until its next read,
                // by which time a client goroutine might have already
                // tried to reuse the HTTP connection for a new
                // request.
                // See https://codereview.appspot.com/76400046
                // and http://golang.org/issue/3514
                <span class="cov1" title="2">if ri := c.rawInput; ri != nil &amp;&amp;
                        n != 0 &amp;&amp; err == nil &amp;&amp;
                        c.input == nil &amp;&amp; len(ri.data) &gt; 0 &amp;&amp; recordType(ri.data[0]) == recordTypeAlert </span><span class="cov1" title="1">{
                        if recErr := c.readRecord(recordTypeApplicationData); recErr != nil </span><span class="cov1" title="1">{
                                err = recErr // will be io.EOF on closeNotify
                        }</span>
                }

                <span class="cov1" title="2">if n != 0 || err != nil </span><span class="cov1" title="2">{
                        return n, err
                }</span>
        }

        <span class="cov0" title="0">return 0, io.ErrNoProgress</span>
}

// Close closes the connection.
func (c *Conn) Close() error <span class="cov5" title="46">{
        var alertErr error

        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()
        if c.handshakeComplete </span><span class="cov5" title="45">{
                stateInc(ERR_ALERT_CLOSE_NOTIFY, 1)
                alertErr = c.sendAlert(alertCloseNotify)
        }</span>

        <span class="cov5" title="46">if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="46">return alertErr</span>
}

// Handshake runs the client or server handshake
// protocol if it has not yet been run.
// Most uses of this package need not call Handshake
// explicitly: the first Read or Write will call it automatically.
func (c *Conn) Handshake() error <span class="cov6" title="83">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()
        if err := c.handshakeErr; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="83">if c.handshakeComplete </span><span class="cov2" title="4">{
                return nil
        }</span>

        <span class="cov6" title="79">if c.isClient </span><span class="cov5" title="30">{
                c.handshakeErr = c.clientHandshake()
        }</span> <span class="cov5" title="49">else {
                c.handshakeErr = c.serverHandshake()
        }</span>
        <span class="cov6" title="79">return c.handshakeErr</span>
}

// ConnectionState returns basic TLS details about the connection.
func (c *Conn) ConnectionState() ConnectionState <span class="cov5" title="36">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()

        var state ConnectionState
        state.HandshakeComplete = c.handshakeComplete
        if c.handshakeComplete </span><span class="cov5" title="35">{
                state.Version = c.vers
                state.NegotiatedProtocol = c.clientProtocol
                state.DidResume = c.didResume
                state.NegotiatedProtocolIsMutual = !c.clientProtocolFallback
                state.CipherSuite = c.cipherSuite
                state.PeerCertificates = c.peerCertificates
                state.VerifiedChains = c.verifiedChains
                state.ServerName = c.serverName
        }</span>

        <span class="cov5" title="36">return state</span>
}

// OCSPResponse returns the stapled OCSP response from the TLS server, if
// any. (Only valid for client connections.)
func (c *Conn) OCSPResponse() []byte <span class="cov0" title="0">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()

        return c.ocspResponse
}</span>

// VerifyHostname checks that the peer certificate chain is valid for
// connecting to host.  If so, it returns nil; if not, it returns an error
// describing the problem.
func (c *Conn) VerifyHostname(host string) error <span class="cov0" title="0">{
        c.handshakeMutex.Lock()
        defer c.handshakeMutex.Unlock()
        if !c.isClient </span><span class="cov0" title="0">{
                stateInc(ERR_SERVER_SHOULD_NOT_VERIFY_HOSTNAME, 1)
                return errors.New("tls: VerifyHostname called on TLS server connection")
        }</span>
        <span class="cov0" title="0">if !c.handshakeComplete </span><span class="cov0" title="0">{
                stateInc(ERR_CLIENT_HANDSHAKE_NOT_PERFORMED, 1)
                return errors.New("tls: handshake has not yet been performed")
        }</span>
        <span class="cov0" title="0">return c.peerCertificates[0].VerifyHostname(host)</span>
}
</pre>
		
		<pre class="file" id="file229" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "bytes"
        "crypto/ecdsa"
        "crypto/rsa"
        "crypto/subtle"
        "crypto/x509"
        "encoding/asn1"
        "errors"
        "fmt"
        "io"
        "net"
        "strconv"
)

type clientHandshakeState struct {
        c            *Conn
        serverHello  *serverHelloMsg
        hello        *clientHelloMsg
        suite        *cipherSuite
        finishedHash finishedHash
        masterSecret []byte
        session      *ClientSessionState
}

func (c *Conn) clientHandshake() error <span class="cov5" title="30">{
        if c.config == nil </span><span class="cov0" title="0">{
                c.config = defaultConfig()
        }</span>

        <span class="cov5" title="30">if len(c.config.ServerName) == 0 &amp;&amp; !c.config.InsecureSkipVerify </span><span class="cov0" title="0">{
                return errors.New("tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config")
        }</span>

        <span class="cov5" title="30">hello := &amp;clientHelloMsg{
                vers:                c.config.maxVersion(),
                compressionMethods:  []uint8{compressionNone},
                random:              make([]byte, 32),
                ocspStapling:        true,
                serverName:          c.config.ServerName,
                supportedCurves:     c.config.curvePreferences(),
                supportedPoints:     []uint8{pointFormatUncompressed},
                nextProtoNeg:        len(c.config.NextProtos) &gt; 0,
                secureRenegotiation: true,
        }

        possibleCipherSuites := c.config.cipherSuites()
        hello.cipherSuites = make([]uint16, 0, len(possibleCipherSuites))

NextCipherSuite:
        for _, suiteId := range possibleCipherSuites </span><span class="cov7" title="284">{
                for _, suite := range cipherSuites </span><span class="cov10" title="1994">{
                        if suite.id != suiteId </span><span class="cov9" title="1710">{
                                continue</span>
                        }
                        // Don't advertise TLS 1.2-only cipher suites unless
                        // we're attempting TLS 1.2.
                        <span class="cov7" title="284">if hello.vers &lt; VersionTLS12 &amp;&amp; suite.flags&amp;suiteTLS12 != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov7" title="284">hello.cipherSuites = append(hello.cipherSuites, suiteId)
                        continue NextCipherSuite</span>
                }
        }

        <span class="cov5" title="30">_, err := io.ReadFull(c.config.rand(), hello.random)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                return errors.New("tls: short read from Rand: " + err.Error())
        }</span>

        <span class="cov5" title="30">if hello.vers &gt;= VersionTLS12 </span><span class="cov5" title="30">{
                hello.signatureAndHashes = supportedSKXSignatureAlgorithms
        }</span>

        <span class="cov5" title="30">var session *ClientSessionState
        var cacheKey string
        sessionCache := c.config.ClientSessionCache
        if c.config.SessionTicketsDisabled </span><span class="cov0" title="0">{
                sessionCache = nil
        }</span>

        <span class="cov5" title="30">if sessionCache != nil </span><span class="cov3" title="6">{
                hello.ticketSupported = true

                // Try to resume a previously negotiated TLS session, if
                // available.
                cacheKey = clientSessionCacheKey(c.conn.RemoteAddr(), c.config)
                candidateSession, ok := sessionCache.Get(cacheKey)
                if ok </span><span class="cov2" title="5">{
                        // Check that the ciphersuite/version used for the
                        // previous session are still valid.
                        cipherSuiteOk := false
                        for _, id := range hello.cipherSuites </span><span class="cov2" title="5">{
                                if id == candidateSession.cipherSuite </span><span class="cov2" title="4">{
                                        cipherSuiteOk = true
                                        break</span>
                                }
                        }

                        <span class="cov2" title="5">versOk := candidateSession.vers &gt;= c.config.minVersion() &amp;&amp;
                                candidateSession.vers &lt;= c.config.maxVersion()
                        if versOk &amp;&amp; cipherSuiteOk </span><span class="cov2" title="4">{
                                session = candidateSession
                        }</span>
                }
        }

        <span class="cov5" title="30">if session != nil </span><span class="cov2" title="4">{
                hello.sessionTicket = session.sessionTicket
                // A random session ID is used to detect when the
                // server accepted the ticket and is resuming a session
                // (see RFC 5077).
                hello.sessionId = make([]byte, 16)
                if _, err := io.ReadFull(c.config.rand(), hello.sessionId); err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return errors.New("tls: short read from Rand: " + err.Error())
                }</span>
        }

        <span class="cov5" title="30">c.writeRecord(recordTypeHandshake, hello.marshal())

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="29">serverHello, ok := msg.(*serverHelloMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(serverHello, msg)
        }</span>

        <span class="cov4" title="29">vers, ok := c.config.mutualVersion(serverHello.vers)
        if !ok || vers &lt; VersionTLS10 </span><span class="cov0" title="0">{
                // TLS 1.0 is the minimum version supported as a client.
                c.sendAlert(alertProtocolVersion)
                return fmt.Errorf("tls: server selected unsupported protocol version %x", serverHello.vers)
        }</span>
        <span class="cov4" title="29">c.vers = vers
        c.haveVers = true

        suite := mutualCipherSuite(c.config.cipherSuites(), serverHello.cipherSuite)
        if suite == nil </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return fmt.Errorf("tls: server selected an unsupported cipher suite")
        }</span>

        <span class="cov4" title="29">hs := &amp;clientHandshakeState{
                c:            c,
                serverHello:  serverHello,
                hello:        hello,
                suite:        suite,
                finishedHash: newFinishedHash(c.vers),
                session:      session,
        }

        hs.finishedHash.Write(hs.hello.marshal())
        hs.finishedHash.Write(hs.serverHello.marshal())

        isResume, err := hs.processServerHello()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="29">if isResume </span><span class="cov2" title="3">{
                if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="3">if err := hs.readSessionTicket(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="3">if err := hs.readFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="3">if err := hs.sendFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } <span class="cov4" title="26">else {
                if err := hs.doFullHandshake(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="26">if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="26">if err := hs.sendFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="26">if err := hs.readSessionTicket(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="26">if err := hs.readFinished(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="29">if sessionCache != nil &amp;&amp; hs.session != nil &amp;&amp; session != hs.session </span><span class="cov2" title="3">{
                sessionCache.Put(cacheKey, hs.session)
        }</span>

        <span class="cov4" title="29">c.didResume = isResume
        c.handshakeComplete = true
        c.cipherSuite = suite.id
        return nil</span>
}

func (hs *clientHandshakeState) doFullHandshake() error <span class="cov4" title="26">{
        c := hs.c

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="26">certMsg, ok := msg.(*certificateMsg)
        if !ok || len(certMsg.certificates) == 0 </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(certMsg, msg)
        }</span>
        <span class="cov4" title="26">hs.finishedHash.Write(certMsg.marshal())

        certs := make([]*x509.Certificate, len(certMsg.certificates))
        for i, asn1Data := range certMsg.certificates </span><span class="cov4" title="26">{
                cert, err := x509.ParseCertificate(asn1Data)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return errors.New("tls: failed to parse certificate from server: " + err.Error())
                }</span>
                <span class="cov4" title="26">certs[i] = cert</span>
        }

        <span class="cov4" title="26">if !c.config.InsecureSkipVerify </span><span class="cov0" title="0">{
                opts := x509.VerifyOptions{
                        Roots:         c.config.RootCAs,
                        CurrentTime:   c.config.time(),
                        DNSName:       c.config.ServerName,
                        Intermediates: x509.NewCertPool(),
                }

                for i, cert := range certs </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">opts.Intermediates.AddCert(cert)</span>
                }
                <span class="cov0" title="0">c.verifiedChains, err = certs[0].Verify(opts)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        return err
                }</span>
        }

        <span class="cov4" title="26">switch certs[0].PublicKey.(type) </span>{
        <span class="cov4" title="26">case *rsa.PublicKey, *ecdsa.PublicKey:
                break</span>
        <span class="cov0" title="0">default:
                c.sendAlert(alertUnsupportedCertificate)
                return fmt.Errorf("tls: server's certificate contains an unsupported type of public key: %T", certs[0].PublicKey)</span>
        }

        <span class="cov4" title="26">c.peerCertificates = certs

        if hs.serverHello.ocspStapling </span><span class="cov0" title="0">{
                msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cs, ok := msg.(*certificateStatusMsg)
                if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(cs, msg)
                }</span>
                <span class="cov0" title="0">hs.finishedHash.Write(cs.marshal())

                if cs.statusType == statusTypeOCSP </span><span class="cov0" title="0">{
                        c.ocspResponse = cs.response
                }</span>
        }

        <span class="cov4" title="26">msg, err = c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="26">keyAgreement := hs.suite.ka(c.vers)

        skx, ok := msg.(*serverKeyExchangeMsg)
        if ok </span><span class="cov4" title="15">{
                hs.finishedHash.Write(skx.marshal())
                err = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, certs[0], skx)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return err
                }</span>

                <span class="cov4" title="15">msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="26">var chainToSend *Certificate
        var certRequested bool
        certReq, ok := msg.(*certificateRequestMsg)
        if ok </span><span class="cov3" title="8">{
                certRequested = true

                // RFC 4346 on the certificateAuthorities field:
                // A list of the distinguished names of acceptable certificate
                // authorities. These distinguished names may specify a desired
                // distinguished name for a root CA or for a subordinate CA;
                // thus, this message can be used to describe both known roots
                // and a desired authorization space. If the
                // certificate_authorities list is empty then the client MAY
                // send any certificate of the appropriate
                // ClientCertificateType, unless there is some external
                // arrangement to the contrary.

                hs.finishedHash.Write(certReq.marshal())

                var rsaAvail, ecdsaAvail bool
                for _, certType := range certReq.certificateTypes </span><span class="cov4" title="24">{
                        switch certType </span>{
                        <span class="cov3" title="8">case certTypeRSASign:
                                rsaAvail = true</span>
                        <span class="cov3" title="8">case certTypeECDSASign:
                                ecdsaAvail = true</span>
                        }
                }

                // We need to search our list of client certs for one
                // where SignatureAlgorithm is RSA and the Issuer is in
                // certReq.certificateAuthorities
        <span class="cov3" title="8">findCert:
                for i, chain := range c.config.Certificates </span><span class="cov3" title="8">{
                        if !rsaAvail &amp;&amp; !ecdsaAvail </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov3" title="8">for j, cert := range chain.Certificate </span><span class="cov3" title="8">{
                                x509Cert := chain.Leaf
                                // parse the certificate if this isn't the leaf
                                // node, or if chain.Leaf was nil
                                if j != 0 || x509Cert == nil </span><span class="cov3" title="8">{
                                        if x509Cert, err = x509.ParseCertificate(cert); err != nil </span><span class="cov0" title="0">{
                                                c.sendAlert(alertInternalError)
                                                return errors.New("tls: failed to parse client certificate #" + strconv.Itoa(i) + ": " + err.Error())
                                        }</span>
                                }

                                <span class="cov3" title="8">switch </span>{
                                <span class="cov2" title="4">case rsaAvail &amp;&amp; x509Cert.PublicKeyAlgorithm == x509.RSA:</span>
                                <span class="cov2" title="4">case ecdsaAvail &amp;&amp; x509Cert.PublicKeyAlgorithm == x509.ECDSA:</span>
                                <span class="cov0" title="0">default:
                                        continue findCert</span>
                                }

                                <span class="cov3" title="8">if len(certReq.certificateAuthorities) == 0 </span><span class="cov3" title="8">{
                                        // they gave us an empty list, so just take the
                                        // first RSA cert from c.config.Certificates
                                        chainToSend = &amp;chain
                                        break findCert</span>
                                }

                                <span class="cov0" title="0">for _, ca := range certReq.certificateAuthorities </span><span class="cov0" title="0">{
                                        if bytes.Equal(x509Cert.RawIssuer, ca) </span><span class="cov0" title="0">{
                                                chainToSend = &amp;chain
                                                break findCert</span>
                                        }
                                }
                        }
                }

                <span class="cov3" title="8">msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="26">shd, ok := msg.(*serverHelloDoneMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(shd, msg)
        }</span>
        <span class="cov4" title="26">hs.finishedHash.Write(shd.marshal())

        // If the server requested a certificate then we have to send a
        // Certificate message, even if it's empty because we don't have a
        // certificate to send.
        if certRequested </span><span class="cov3" title="8">{
                certMsg = new(certificateMsg)
                if chainToSend != nil </span><span class="cov3" title="8">{
                        certMsg.certificates = chainToSend.Certificate
                }</span>
                <span class="cov3" title="8">hs.finishedHash.Write(certMsg.marshal())
                c.writeRecord(recordTypeHandshake, certMsg.marshal())</span>
        }

        <span class="cov4" title="26">preMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, certs[0])
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                return err
        }</span>
        <span class="cov4" title="26">if ckx != nil </span><span class="cov4" title="26">{
                hs.finishedHash.Write(ckx.marshal())
                c.writeRecord(recordTypeHandshake, ckx.marshal())
        }</span>

        <span class="cov4" title="26">if chainToSend != nil </span><span class="cov3" title="8">{
                var signed []byte
                certVerify := &amp;certificateVerifyMsg{
                        hasSignatureAndHash: c.vers &gt;= VersionTLS12,
                }

                switch key := c.config.Certificates[0].PrivateKey.(type) </span>{
                <span class="cov2" title="4">case *ecdsa.PrivateKey:
                        digest, _, hashId := hs.finishedHash.hashForClientCertificate(signatureECDSA)
                        r, s, err := ecdsa.Sign(c.config.rand(), key, digest)
                        if err == nil </span><span class="cov2" title="4">{
                                signed, err = asn1.Marshal(ecdsaSignature{r, s})
                        }</span>
                        <span class="cov2" title="4">certVerify.signatureAndHash.signature = signatureECDSA
                        certVerify.signatureAndHash.hash = hashId</span>
                <span class="cov2" title="4">case *rsa.PrivateKey:
                        digest, hashFunc, hashId := hs.finishedHash.hashForClientCertificate(signatureRSA)
                        signed, err = rsa.SignPKCS1v15(c.config.rand(), key, hashFunc, digest)
                        certVerify.signatureAndHash.signature = signatureRSA
                        certVerify.signatureAndHash.hash = hashId</span>
                <span class="cov0" title="0">default:
                        err = errors.New("unknown private key type")</span>
                }
                <span class="cov3" title="8">if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        return errors.New("tls: failed to sign handshake with client certificate: " + err.Error())
                }</span>
                <span class="cov3" title="8">certVerify.signature = signed

                hs.finishedHash.Write(certVerify.marshal())
                c.writeRecord(recordTypeHandshake, certVerify.marshal())</span>
        }

        <span class="cov4" title="26">hs.masterSecret = masterFromPreMasterSecret(c.vers, preMasterSecret, hs.hello.random, hs.serverHello.random)
        return nil</span>
}

func (hs *clientHandshakeState) establishKeys() error <span class="cov4" title="29">{
        c := hs.c

        clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
                keysFromMasterSecret(c.vers, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
        var clientCipher, serverCipher interface{}
        var clientHash, serverHash macFunction
        if hs.suite.cipher != nil </span><span class="cov4" title="27">{
                clientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */)
                clientHash = hs.suite.mac(c.vers, clientMAC)
                serverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */)
                serverHash = hs.suite.mac(c.vers, serverMAC)
        }</span> <span class="cov1" title="2">else {
                clientCipher = hs.suite.aead(clientKey, clientIV)
                serverCipher = hs.suite.aead(serverKey, serverIV)
        }</span>

        <span class="cov4" title="29">c.in.prepareCipherSpec(c.vers, serverCipher, serverHash)
        c.out.prepareCipherSpec(c.vers, clientCipher, clientHash)
        return nil</span>
}

func (hs *clientHandshakeState) serverResumedSession() bool <span class="cov4" title="29">{
        // If the server responded with the same sessionId then it means the
        // sessionTicket is being used to resume a TLS session.
        return hs.session != nil &amp;&amp; hs.hello.sessionId != nil &amp;&amp;
                bytes.Equal(hs.serverHello.sessionId, hs.hello.sessionId)
}</span>

func (hs *clientHandshakeState) processServerHello() (bool, error) <span class="cov4" title="29">{
        c := hs.c

        if hs.serverHello.compressionMethod != compressionNone </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return false, errors.New("tls: server selected unsupported compression format")
        }</span>

        <span class="cov4" title="29">if !hs.hello.nextProtoNeg &amp;&amp; hs.serverHello.nextProtoNeg </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return false, errors.New("server advertised unrequested NPN extension")
        }</span>

        <span class="cov4" title="29">if hs.serverResumedSession() </span><span class="cov2" title="3">{
                // Restore masterSecret and peerCerts from previous state
                hs.masterSecret = hs.session.masterSecret
                c.peerCertificates = hs.session.serverCertificates
                return true, nil
        }</span>
        <span class="cov4" title="26">return false, nil</span>
}

func (hs *clientHandshakeState) readFinished() error <span class="cov4" title="29">{
        c := hs.c

        c.readRecord(recordTypeChangeCipherSpec)
        if err := c.in.error(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="29">msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="29">serverFinished, ok := msg.(*finishedMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(serverFinished, msg)
        }</span>

        <span class="cov4" title="29">verify := hs.finishedHash.serverSum(hs.masterSecret)
        if len(verify) != len(serverFinished.verifyData) ||
                subtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                return errors.New("tls: server's Finished message was incorrect")
        }</span>
        <span class="cov4" title="29">hs.finishedHash.Write(serverFinished.marshal())
        return nil</span>
}

func (hs *clientHandshakeState) readSessionTicket() error <span class="cov4" title="29">{
        if !hs.serverHello.ticketSupported </span><span class="cov4" title="26">{
                return nil
        }</span>

        <span class="cov2" title="3">c := hs.c
        msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="3">sessionTicketMsg, ok := msg.(*newSessionTicketMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(sessionTicketMsg, msg)
        }</span>
        <span class="cov2" title="3">hs.finishedHash.Write(sessionTicketMsg.marshal())

        hs.session = &amp;ClientSessionState{
                sessionTicket:      sessionTicketMsg.ticket,
                vers:               c.vers,
                cipherSuite:        hs.suite.id,
                masterSecret:       hs.masterSecret,
                serverCertificates: c.peerCertificates,
        }

        return nil</span>
}

func (hs *clientHandshakeState) sendFinished() error <span class="cov4" title="29">{
        c := hs.c

        c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
        if hs.serverHello.nextProtoNeg </span><span class="cov0" title="0">{
                nextProto := new(nextProtoMsg)
                proto, fallback := mutualProtocol(c.config.NextProtos, hs.serverHello.nextProtos)
                nextProto.proto = proto
                c.clientProtocol = proto
                c.clientProtocolFallback = fallback

                hs.finishedHash.Write(nextProto.marshal())
                c.writeRecord(recordTypeHandshake, nextProto.marshal())
        }</span>

        <span class="cov4" title="29">finished := new(finishedMsg)
        finished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)
        hs.finishedHash.Write(finished.marshal())
        c.writeRecord(recordTypeHandshake, finished.marshal())
        return nil</span>
}

// clientSessionCacheKey returns a key used to cache sessionTickets that could
// be used to resume previously negotiated TLS sessions with a server.
func clientSessionCacheKey(serverAddr net.Addr, config *Config) string <span class="cov3" title="6">{
        if len(config.ServerName) &gt; 0 </span><span class="cov0" title="0">{
                return config.ServerName
        }</span>
        <span class="cov3" title="6">return serverAddr.String()</span>
}

// mutualProtocol finds the mutual Next Protocol Negotiation protocol given the
// set of client and server supported protocols. The set of client supported
// protocols must not be empty. It returns the resulting protocol and flag
// indicating if the fallback case was reached.
func mutualProtocol(clientProtos, serverProtos []string) (string, bool) <span class="cov1" title="2">{
        for _, s := range serverProtos </span><span class="cov1" title="2">{
                for _, c := range clientProtos </span><span class="cov2" title="4">{
                        if s == c </span><span class="cov1" title="1">{
                                return s, false
                        }</span>
                }
        }

        <span class="cov1" title="1">return clientProtos[0], true</span>
}
</pre>
		
		<pre class="file" id="file230" style="display: none">/* handshake_info.go - module for handshake info intended for Log */
/*
modification history
--------------------
2015/6/17, by Xiong Zongtao, create
*/
/*
DESCRIPTION
*/
package bfe_tls

import (
        "net"
)

type HandshakeInfo struct {
        HandshakeComplete        bool      // handshake fail or success
        ClientIp            string    // client ip who issued handshake
        ClientHello       []byte      // marshaled client hello
}

// extract some info from serverHandshakeState to construct HandshakeInfo
func NewHandshakeInfo(hs *serverHandshakeState) *HandshakeInfo <span class="cov0" title="0">{
        hi := new(HandshakeInfo)
        
        // set handshake state
        hi.HandshakeComplete = hs.c.handshakeComplete

        //get ip from tcp addr
        hi.ClientIp = ""
        if tcpAddr, ok := hs.c.conn.RemoteAddr().(*net.TCPAddr); ok </span><span class="cov0" title="0">{
                hi.ClientIp = tcpAddr.IP.String()        
        }</span>

        // marshal client-hello to []byte
        <span class="cov0" title="0">if hs.clientHello != nil </span><span class="cov0" title="0">{
                hi.ClientHello = hs.clientHello.marshal()
        }</span>
        
        <span class="cov0" title="0">return hi</span>
}
</pre>
		
		<pre class="file" id="file231" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import "bytes"

type clientHelloMsg struct {
        raw                 []byte
        vers                uint16
        random              []byte
        sessionId           []byte
        cipherSuites        []uint16
        compressionMethods  []uint8
        nextProtoNeg        bool
        serverName          string
        ocspStapling        bool
        supportedCurves     []CurveID
        supportedPoints     []uint8
        ticketSupported     bool
        sessionTicket       []uint8
        signatureAndHashes  []signatureAndHash
        secureRenegotiation bool
        alpnProtocols       []string
}

func (m *clientHelloMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*clientHelloMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.vers == m1.vers &amp;&amp;
                bytes.Equal(m.random, m1.random) &amp;&amp;
                bytes.Equal(m.sessionId, m1.sessionId) &amp;&amp;
                eqUint16s(m.cipherSuites, m1.cipherSuites) &amp;&amp;
                bytes.Equal(m.compressionMethods, m1.compressionMethods) &amp;&amp;
                m.nextProtoNeg == m1.nextProtoNeg &amp;&amp;
                m.serverName == m1.serverName &amp;&amp;
                m.ocspStapling == m1.ocspStapling &amp;&amp;
                eqCurveIDs(m.supportedCurves, m1.supportedCurves) &amp;&amp;
                bytes.Equal(m.supportedPoints, m1.supportedPoints) &amp;&amp;
                m.ticketSupported == m1.ticketSupported &amp;&amp;
                bytes.Equal(m.sessionTicket, m1.sessionTicket) &amp;&amp;
                eqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes) &amp;&amp;
                m.secureRenegotiation == m1.secureRenegotiation &amp;&amp;
                eqStrings(m.alpnProtocols, m1.alpnProtocols)</span>
}

func (m *clientHelloMsg) marshal() []byte <span class="cov5" title="308">{
        if m.raw != nil </span><span class="cov5" title="169">{
                return m.raw
        }</span>

        <span class="cov5" title="139">length := 2 + 32 + 1 + len(m.sessionId) + 2 + len(m.cipherSuites)*2 + 1 + len(m.compressionMethods)
        numExtensions := 0
        extensionsLength := 0
        if m.nextProtoNeg </span><span class="cov4" title="41">{
                numExtensions++
        }</span>
        <span class="cov5" title="139">if m.ocspStapling </span><span class="cov4" title="72">{
                extensionsLength += 1 + 2 + 2
                numExtensions++
        }</span>
        <span class="cov5" title="139">if len(m.serverName) &gt; 0 </span><span class="cov4" title="42">{
                extensionsLength += 5 + len(m.serverName)
                numExtensions++
        }</span>
        <span class="cov5" title="139">if len(m.supportedCurves) &gt; 0 </span><span class="cov5" title="131">{
                extensionsLength += 2 + 2*len(m.supportedCurves)
                numExtensions++
        }</span>
        <span class="cov5" title="139">if len(m.supportedPoints) &gt; 0 </span><span class="cov5" title="131">{
                extensionsLength += 1 + len(m.supportedPoints)
                numExtensions++
        }</span>
        <span class="cov5" title="139">if m.ticketSupported </span><span class="cov4" title="44">{
                extensionsLength += len(m.sessionTicket)
                numExtensions++
        }</span>
        <span class="cov5" title="139">if len(m.signatureAndHashes) &gt; 0 </span><span class="cov4" title="64">{
                extensionsLength += 2 + 2*len(m.signatureAndHashes)
                numExtensions++
        }</span>
        <span class="cov5" title="139">if m.secureRenegotiation </span><span class="cov3" title="30">{
                extensionsLength += 1
                numExtensions++
        }</span>
        <span class="cov5" title="139">if len(m.alpnProtocols) &gt; 0 </span><span class="cov4" title="77">{
                extensionsLength += 2
                for _, s := range m.alpnProtocols </span><span class="cov5" title="195">{
                        if l := len(s); l == 0 || l &gt; 255 </span><span class="cov0" title="0">{
                                panic("invalid ALPN protocol")
                        }</span>
                        <span class="cov5" title="195">extensionsLength++
                        extensionsLength += len(s)</span>
                }
                <span class="cov4" title="77">numExtensions++</span>
        }
        <span class="cov5" title="139">if numExtensions &gt; 0 </span><span class="cov5" title="131">{
                extensionsLength += 4 * numExtensions
                length += 2 + extensionsLength
        }</span>

        <span class="cov5" title="139">x := make([]byte, 4+length)
        x[0] = typeClientHello
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        x[4] = uint8(m.vers &gt;&gt; 8)
        x[5] = uint8(m.vers)
        copy(x[6:38], m.random)
        x[38] = uint8(len(m.sessionId))
        copy(x[39:39+len(m.sessionId)], m.sessionId)
        y := x[39+len(m.sessionId):]
        y[0] = uint8(len(m.cipherSuites) &gt;&gt; 7)
        y[1] = uint8(len(m.cipherSuites) &lt;&lt; 1)
        for i, suite := range m.cipherSuites </span><span class="cov7" title="3676">{
                y[2+i*2] = uint8(suite &gt;&gt; 8)
                y[3+i*2] = uint8(suite)
        }</span>
        <span class="cov5" title="139">z := y[2+len(m.cipherSuites)*2:]
        z[0] = uint8(len(m.compressionMethods))
        copy(z[1:], m.compressionMethods)

        z = z[1+len(m.compressionMethods):]
        if numExtensions &gt; 0 </span><span class="cov5" title="131">{
                z[0] = byte(extensionsLength &gt;&gt; 8)
                z[1] = byte(extensionsLength)
                z = z[2:]
        }</span>
        <span class="cov5" title="139">if m.nextProtoNeg </span><span class="cov4" title="41">{
                z[0] = byte(extensionNextProtoNeg &gt;&gt; 8)
                z[1] = byte(extensionNextProtoNeg &amp; 0xff)
                // The length is always 0
                z = z[4:]
        }</span>
        <span class="cov5" title="139">if len(m.serverName) &gt; 0 </span><span class="cov4" title="42">{
                z[0] = byte(extensionServerName &gt;&gt; 8)
                z[1] = byte(extensionServerName &amp; 0xff)
                l := len(m.serverName) + 5
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                z = z[4:]

                // RFC 3546, section 3.1
                //
                // struct {
                //     NameType name_type;
                //     select (name_type) {
                //         case host_name: HostName;
                //     } name;
                // } ServerName;
                //
                // enum {
                //     host_name(0), (255)
                // } NameType;
                //
                // opaque HostName&lt;1..2^16-1&gt;;
                //
                // struct {
                //     ServerName server_name_list&lt;1..2^16-1&gt;
                // } ServerNameList;

                z[0] = byte((len(m.serverName) + 3) &gt;&gt; 8)
                z[1] = byte(len(m.serverName) + 3)
                z[3] = byte(len(m.serverName) &gt;&gt; 8)
                z[4] = byte(len(m.serverName))
                copy(z[5:], []byte(m.serverName))
                z = z[l:]
        }</span>
        <span class="cov5" title="139">if m.ocspStapling </span><span class="cov4" title="72">{
                // RFC 4366, section 3.6
                z[0] = byte(extensionStatusRequest &gt;&gt; 8)
                z[1] = byte(extensionStatusRequest)
                z[2] = 0
                z[3] = 5
                z[4] = 1 // OCSP type
                // Two zero valued uint16s for the two lengths.
                z = z[9:]
        }</span>
        <span class="cov5" title="139">if len(m.supportedCurves) &gt; 0 </span><span class="cov5" title="131">{
                // http://tools.ietf.org/html/rfc4492#section-5.5.1
                z[0] = byte(extensionSupportedCurves &gt;&gt; 8)
                z[1] = byte(extensionSupportedCurves)
                l := 2 + 2*len(m.supportedCurves)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                l -= 2
                z[4] = byte(l &gt;&gt; 8)
                z[5] = byte(l)
                z = z[6:]
                for _, curve := range m.supportedCurves </span><span class="cov5" title="404">{
                        z[0] = byte(curve &gt;&gt; 8)
                        z[1] = byte(curve)
                        z = z[2:]
                }</span>
        }
        <span class="cov5" title="139">if len(m.supportedPoints) &gt; 0 </span><span class="cov5" title="131">{
                // http://tools.ietf.org/html/rfc4492#section-5.5.2
                z[0] = byte(extensionSupportedPoints &gt;&gt; 8)
                z[1] = byte(extensionSupportedPoints)
                l := 1 + len(m.supportedPoints)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                l--
                z[4] = byte(l)
                z = z[5:]
                for _, pointFormat := range m.supportedPoints </span><span class="cov5" title="335">{
                        z[0] = byte(pointFormat)
                        z = z[1:]
                }</span>
        }
        <span class="cov5" title="139">if m.ticketSupported </span><span class="cov4" title="44">{
                // http://tools.ietf.org/html/rfc5077#section-3.2
                z[0] = byte(extensionSessionTicket &gt;&gt; 8)
                z[1] = byte(extensionSessionTicket)
                l := len(m.sessionTicket)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                z = z[4:]
                copy(z, m.sessionTicket)
                z = z[len(m.sessionTicket):]
        }</span>
        <span class="cov5" title="139">if len(m.signatureAndHashes) &gt; 0 </span><span class="cov4" title="64">{
                // https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
                z[0] = byte(extensionSignatureAlgorithms &gt;&gt; 8)
                z[1] = byte(extensionSignatureAlgorithms)
                l := 2 + 2*len(m.signatureAndHashes)
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                z = z[4:]

                l -= 2
                z[0] = byte(l &gt;&gt; 8)
                z[1] = byte(l)
                z = z[2:]
                for _, sigAndHash := range m.signatureAndHashes </span><span class="cov5" title="256">{
                        z[0] = sigAndHash.hash
                        z[1] = sigAndHash.signature
                        z = z[2:]
                }</span>
        }
        <span class="cov5" title="139">if m.secureRenegotiation </span><span class="cov3" title="30">{
                z[0] = byte(extensionRenegotiationInfo &gt;&gt; 8)
                z[1] = byte(extensionRenegotiationInfo &amp; 0xff)
                z[2] = 0
                z[3] = 1
                z = z[5:]
        }</span>
        <span class="cov5" title="139">if len(m.alpnProtocols) &gt; 0 </span><span class="cov4" title="77">{
                z[0] = byte(extensionALPN &gt;&gt; 8)
                z[1] = byte(extensionALPN &amp; 0xff)
                lengths := z[2:]
                z = z[6:]

                stringsLength := 0
                for _, s := range m.alpnProtocols </span><span class="cov5" title="195">{
                        l := len(s)
                        z[0] = byte(l)
                        copy(z[1:], s)
                        z = z[1+l:]
                        stringsLength += 1 + l
                }</span>

                <span class="cov4" title="77">lengths[2] = byte(stringsLength &gt;&gt; 8)
                lengths[3] = byte(stringsLength)
                stringsLength += 2
                lengths[0] = byte(stringsLength &gt;&gt; 8)
                lengths[1] = byte(stringsLength)</span>
        }

        <span class="cov5" title="139">m.raw = x

        return x</span>
}

func (m *clientHelloMsg) unmarshal(data []byte) bool <span class="cov6" title="1146">{
        if len(data) &lt; 42 </span><span class="cov5" title="395">{
                return false
        }</span>
        <span class="cov6" title="751">m.raw = data
        m.vers = uint16(data[4])&lt;&lt;8 | uint16(data[5])
        m.random = data[6:38]
        sessionIdLen := int(data[38])
        if sessionIdLen &gt; 32 || len(data) &lt; 39+sessionIdLen </span><span class="cov6" title="561">{
                return false
        }</span>
        <span class="cov5" title="190">m.sessionId = data[39 : 39+sessionIdLen]
        data = data[39+sessionIdLen:]
        if len(data) &lt; 2 </span><span class="cov1" title="1">{
                return false
        }</span>
        // cipherSuiteLen is the number of bytes of cipher suite numbers. Since
        // they are uint16s, the number must be even.
        <span class="cov5" title="189">cipherSuiteLen := int(data[0])&lt;&lt;8 | int(data[1])
        if cipherSuiteLen%2 == 1 || len(data) &lt; 2+cipherSuiteLen </span><span class="cov4" title="43">{
                return false
        }</span>
        <span class="cov5" title="146">numCipherSuites := cipherSuiteLen / 2
        m.cipherSuites = make([]uint16, numCipherSuites)
        for i := 0; i &lt; numCipherSuites; i++ </span><span class="cov7" title="3782">{
                m.cipherSuites[i] = uint16(data[2+2*i])&lt;&lt;8 | uint16(data[3+2*i])
                if m.cipherSuites[i] == scsvRenegotiation </span><span class="cov3" title="24">{
                        m.secureRenegotiation = true
                }</span>
        }
        <span class="cov5" title="146">data = data[2+cipherSuiteLen:]
        if len(data) &lt; 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="146">compressionMethodsLen := int(data[0])
        if len(data) &lt; 1+compressionMethodsLen </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="146">m.compressionMethods = data[1 : 1+compressionMethodsLen]

        data = data[1+compressionMethodsLen:]

        m.nextProtoNeg = false
        m.serverName = ""
        m.ocspStapling = false
        m.ticketSupported = false
        m.sessionTicket = nil
        m.signatureAndHashes = nil
        m.alpnProtocols = nil

        if len(data) == 0 </span><span class="cov2" title="11">{
                // ClientHello is optionally followed by extension data
                return true
        }</span>
        <span class="cov5" title="135">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="135">extensionsLength := int(data[0])&lt;&lt;8 | int(data[1])
        data = data[2:]
        if extensionsLength != len(data) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="135">for len(data) != 0 </span><span class="cov6" title="602">{
                if len(data) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="602">extension := uint16(data[0])&lt;&lt;8 | uint16(data[1])
                length := int(data[2])&lt;&lt;8 | int(data[3])
                data = data[4:]
                if len(data) &lt; length </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov6" title="602">switch extension </span>{
                <span class="cov4" title="42">case extensionServerName:
                        if length &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="42">numNames := int(data[0])&lt;&lt;8 | int(data[1])
                        d := data[2:]
                        for i := 0; i &lt; numNames; i++ </span><span class="cov4" title="42">{
                                if len(d) &lt; 3 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov4" title="42">nameType := d[0]
                                nameLen := int(d[1])&lt;&lt;8 | int(d[2])
                                d = d[3:]
                                if len(d) &lt; nameLen </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov4" title="42">if nameType == 0 </span><span class="cov4" title="42">{
                                        m.serverName = string(d[0:nameLen])
                                        break</span>
                                }
                                <span class="cov0" title="0">d = d[nameLen:]</span>
                        }
                <span class="cov4" title="41">case extensionNextProtoNeg:
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="41">m.nextProtoNeg = true</span>
                <span class="cov4" title="53">case extensionStatusRequest:
                        m.ocspStapling = length &gt; 0 &amp;&amp; data[0] == statusTypeOCSP</span>
                <span class="cov4" title="120">case extensionSupportedCurves:
                        // http://tools.ietf.org/html/rfc4492#section-5.5.1
                        if length &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="120">l := int(data[0])&lt;&lt;8 | int(data[1])
                        if l%2 == 1 || length != l+2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="120">numCurves := l / 2
                        m.supportedCurves = make([]CurveID, numCurves)
                        d := data[2:]
                        for i := 0; i &lt; numCurves; i++ </span><span class="cov6" title="553">{
                                m.supportedCurves[i] = CurveID(d[0])&lt;&lt;8 | CurveID(d[1])
                                d = d[2:]
                        }</span>
                <span class="cov4" title="120">case extensionSupportedPoints:
                        // http://tools.ietf.org/html/rfc4492#section-5.5.2
                        if length &lt; 1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="120">l := int(data[0])
                        if length != l+1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="120">m.supportedPoints = make([]uint8, l)
                        copy(m.supportedPoints, data[1:])</span>
                <span class="cov4" title="51">case extensionSessionTicket:
                        // http://tools.ietf.org/html/rfc5077#section-3.2
                        m.ticketSupported = true
                        m.sessionTicket = data[:length]</span>
                <span class="cov4" title="62">case extensionSignatureAlgorithms:
                        // https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
                        if length &lt; 2 || length&amp;1 != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="62">l := int(data[0])&lt;&lt;8 | int(data[1])
                        if l != length-2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="62">n := l / 2
                        d := data[2:]
                        m.signatureAndHashes = make([]signatureAndHash, n)
                        for i := range m.signatureAndHashes </span><span class="cov6" title="450">{
                                m.signatureAndHashes[i].hash = d[0]
                                m.signatureAndHashes[i].signature = d[1]
                                d = d[2:]
                        }</span>
                <span class="cov0" title="0">case extensionRenegotiationInfo + 1:
                        if length != 1 || data[0] != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">m.secureRenegotiation = true</span>
                <span class="cov4" title="79">case extensionALPN:
                        if length &lt; 2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="79">l := int(data[0])&lt;&lt;8 | int(data[1])
                        if l != length-2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="79">d := data[2:length]
                        for len(d) != 0 </span><span class="cov5" title="199">{
                                stringLen := int(d[0])
                                d = d[1:]
                                if stringLen == 0 || stringLen &gt; len(d) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov5" title="199">m.alpnProtocols = append(m.alpnProtocols, string(d[:stringLen]))
                                d = d[stringLen:]</span>
                        }
                }
                <span class="cov6" title="602">data = data[length:]</span>
        }

        <span class="cov5" title="135">return true</span>
}

type serverHelloMsg struct {
        raw                 []byte
        vers                uint16
        random              []byte
        sessionId           []byte
        cipherSuite         uint16
        compressionMethod   uint8
        nextProtoNeg        bool
        nextProtos          []string
        ocspStapling        bool
        ticketSupported     bool
        secureRenegotiation bool
        alpnProtocol        string
}

func (m *serverHelloMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*serverHelloMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.vers == m1.vers &amp;&amp;
                bytes.Equal(m.random, m1.random) &amp;&amp;
                bytes.Equal(m.sessionId, m1.sessionId) &amp;&amp;
                m.cipherSuite == m1.cipherSuite &amp;&amp;
                m.compressionMethod == m1.compressionMethod &amp;&amp;
                m.nextProtoNeg == m1.nextProtoNeg &amp;&amp;
                eqStrings(m.nextProtos, m1.nextProtos) &amp;&amp;
                m.ocspStapling == m1.ocspStapling &amp;&amp;
                m.ticketSupported == m1.ticketSupported &amp;&amp;
                m.secureRenegotiation == m1.secureRenegotiation &amp;&amp;
                m.alpnProtocol == m1.alpnProtocol</span>
}

func (m *serverHelloMsg) marshal() []byte <span class="cov5" title="303">{
        if m.raw != nil </span><span class="cov5" title="166">{
                return m.raw
        }</span>

        <span class="cov5" title="137">length := 38 + len(m.sessionId)
        numExtensions := 0
        extensionsLength := 0

        nextProtoLen := 0
        if m.nextProtoNeg </span><span class="cov4" title="41">{
                numExtensions++
                for _, v := range m.nextProtos </span><span class="cov5" title="160">{
                        nextProtoLen += len(v)
                }</span>
                <span class="cov4" title="41">nextProtoLen += len(m.nextProtos)
                extensionsLength += nextProtoLen</span>
        }
        <span class="cov5" title="137">if m.ocspStapling </span><span class="cov4" title="41">{
                numExtensions++
        }</span>
        <span class="cov5" title="137">if m.ticketSupported </span><span class="cov4" title="44">{
                numExtensions++
        }</span>
        <span class="cov5" title="137">if m.secureRenegotiation </span><span class="cov3" title="23">{
                extensionsLength += 1
                numExtensions++
        }</span>
        <span class="cov5" title="137">if alpnLen := len(m.alpnProtocol); alpnLen &gt; 0 </span><span class="cov4" title="101">{
                if alpnLen &gt;= 256 </span><span class="cov0" title="0">{
                        panic("invalid ALPN protocol")
                }</span>
                <span class="cov4" title="101">extensionsLength += 2 + 1 + alpnLen
                numExtensions++</span>
        }

        <span class="cov5" title="137">if numExtensions &gt; 0 </span><span class="cov4" title="126">{
                extensionsLength += 4 * numExtensions
                length += 2 + extensionsLength
        }</span>

        <span class="cov5" title="137">x := make([]byte, 4+length)
        x[0] = typeServerHello
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        x[4] = uint8(m.vers &gt;&gt; 8)
        x[5] = uint8(m.vers)
        copy(x[6:38], m.random)
        x[38] = uint8(len(m.sessionId))
        copy(x[39:39+len(m.sessionId)], m.sessionId)
        z := x[39+len(m.sessionId):]
        z[0] = uint8(m.cipherSuite &gt;&gt; 8)
        z[1] = uint8(m.cipherSuite)
        z[2] = uint8(m.compressionMethod)

        z = z[3:]
        if numExtensions &gt; 0 </span><span class="cov4" title="126">{
                z[0] = byte(extensionsLength &gt;&gt; 8)
                z[1] = byte(extensionsLength)
                z = z[2:]
        }</span>
        <span class="cov5" title="137">if m.nextProtoNeg </span><span class="cov4" title="41">{
                z[0] = byte(extensionNextProtoNeg &gt;&gt; 8)
                z[1] = byte(extensionNextProtoNeg &amp; 0xff)
                z[2] = byte(nextProtoLen &gt;&gt; 8)
                z[3] = byte(nextProtoLen)
                z = z[4:]

                for _, v := range m.nextProtos </span><span class="cov5" title="160">{
                        l := len(v)
                        if l &gt; 255 </span><span class="cov0" title="0">{
                                l = 255
                        }</span>
                        <span class="cov5" title="160">z[0] = byte(l)
                        copy(z[1:], []byte(v[0:l]))
                        z = z[1+l:]</span>
                }
        }
        <span class="cov5" title="137">if m.ocspStapling </span><span class="cov4" title="41">{
                z[0] = byte(extensionStatusRequest &gt;&gt; 8)
                z[1] = byte(extensionStatusRequest)
                z = z[4:]
        }</span>
        <span class="cov5" title="137">if m.ticketSupported </span><span class="cov4" title="44">{
                z[0] = byte(extensionSessionTicket &gt;&gt; 8)
                z[1] = byte(extensionSessionTicket)
                z = z[4:]
        }</span>
        <span class="cov5" title="137">if m.secureRenegotiation </span><span class="cov3" title="23">{
                z[0] = byte(extensionRenegotiationInfo &gt;&gt; 8)
                z[1] = byte(extensionRenegotiationInfo &amp; 0xff)
                z[2] = 0
                z[3] = 1
                z = z[5:]
        }</span>
        <span class="cov5" title="137">if alpnLen := len(m.alpnProtocol); alpnLen &gt; 0 </span><span class="cov4" title="101">{
                z[0] = byte(extensionALPN &gt;&gt; 8)
                z[1] = byte(extensionALPN &amp; 0xff)
                l := 2 + 1 + alpnLen
                z[2] = byte(l &gt;&gt; 8)
                z[3] = byte(l)
                l -= 2
                z[4] = byte(l &gt;&gt; 8)
                z[5] = byte(l)
                l -= 1
                z[6] = byte(l)
                copy(z[7:], []byte(m.alpnProtocol))
                z = z[7+alpnLen:]
        }</span>

        <span class="cov5" title="137">m.raw = x

        return x</span>
}

func (m *serverHelloMsg) unmarshal(data []byte) bool <span class="cov6" title="1130">{
        if len(data) &lt; 42 </span><span class="cov5" title="395">{
                return false
        }</span>
        <span class="cov6" title="735">m.raw = data
        m.vers = uint16(data[4])&lt;&lt;8 | uint16(data[5])
        m.random = data[6:38]
        sessionIdLen := int(data[38])
        if sessionIdLen &gt; 32 || len(data) &lt; 39+sessionIdLen </span><span class="cov6" title="548">{
                return false
        }</span>
        <span class="cov5" title="187">m.sessionId = data[39 : 39+sessionIdLen]
        data = data[39+sessionIdLen:]
        if len(data) &lt; 3 </span><span class="cov2" title="4">{
                return false
        }</span>
        <span class="cov5" title="183">m.cipherSuite = uint16(data[0])&lt;&lt;8 | uint16(data[1])
        m.compressionMethod = data[2]
        data = data[3:]

        m.nextProtoNeg = false
        m.nextProtos = nil
        m.ocspStapling = false
        m.ticketSupported = false
        m.alpnProtocol = ""

        if len(data) == 0 </span><span class="cov2" title="10">{
                // ServerHello is optionally followed by extension data
                return true
        }</span>
        <span class="cov5" title="173">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="173">extensionsLength := int(data[0])&lt;&lt;8 | int(data[1])
        data = data[2:]
        if len(data) != extensionsLength </span><span class="cov4" title="52">{
                return false
        }</span>

        <span class="cov4" title="121">for len(data) != 0 </span><span class="cov5" title="251">{
                if len(data) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov5" title="251">extension := uint16(data[0])&lt;&lt;8 | uint16(data[1])
                length := int(data[2])&lt;&lt;8 | int(data[3])
                data = data[4:]
                if len(data) &lt; length </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov5" title="251">switch extension </span>{
                <span class="cov4" title="41">case extensionNextProtoNeg:
                        m.nextProtoNeg = true
                        d := data[:length]
                        for len(d) &gt; 0 </span><span class="cov5" title="160">{
                                l := int(d[0])
                                d = d[1:]
                                if l == 0 || l &gt; len(d) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov5" title="160">m.nextProtos = append(m.nextProtos, string(d[:l]))
                                d = d[l:]</span>
                        }
                <span class="cov4" title="41">case extensionStatusRequest:
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="41">m.ocspStapling = true</span>
                <span class="cov4" title="40">case extensionSessionTicket:
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="40">m.ticketSupported = true</span>
                <span class="cov3" title="18">case extensionRenegotiationInfo:
                        if length != 1 || data[0] != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov3" title="18">m.secureRenegotiation = true</span>
                <span class="cov4" title="100">case extensionALPN:
                        d := data[:length]
                        if len(d) &lt; 3 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="100">l := int(d[0])&lt;&lt;8 | int(d[1])
                        if l != len(d)-2 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="100">d = d[2:]
                        l = int(d[0])
                        if l != len(d)-1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov4" title="100">d = d[1:]
                        m.alpnProtocol = string(d)</span>
                }
                <span class="cov5" title="251">data = data[length:]</span>
        }

        <span class="cov4" title="121">return true</span>
}

type certificateMsg struct {
        raw          []byte
        certificates [][]byte
}

func (m *certificateMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*certificateMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                eqByteSlices(m.certificates, m1.certificates)</span>
}

func (m *certificateMsg) marshal() (x []byte) <span class="cov5" title="311">{
        if m.raw != nil </span><span class="cov5" title="170">{
                return m.raw
        }</span>

        <span class="cov5" title="141">var i int
        for _, slice := range m.certificates </span><span class="cov6" title="1033">{
                i += len(slice)
        }</span>

        <span class="cov5" title="141">length := 3 + 3*len(m.certificates) + i
        x = make([]byte, 4+length)
        x[0] = typeCertificate
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)

        certificateOctets := length - 3
        x[4] = uint8(certificateOctets &gt;&gt; 16)
        x[5] = uint8(certificateOctets &gt;&gt; 8)
        x[6] = uint8(certificateOctets)

        y := x[7:]
        for _, slice := range m.certificates </span><span class="cov6" title="1033">{
                y[0] = uint8(len(slice) &gt;&gt; 16)
                y[1] = uint8(len(slice) &gt;&gt; 8)
                y[2] = uint8(len(slice))
                copy(y[3:], slice)
                y = y[3+len(slice):]
        }</span>

        <span class="cov5" title="141">m.raw = x
        return</span>
}

func (m *certificateMsg) unmarshal(data []byte) bool <span class="cov8" title="10373">{
        if len(data) &lt; 7 </span><span class="cov6" title="772">{
                return false
        }</span>

        <span class="cov8" title="9601">m.raw = data
        certsLen := uint32(data[4])&lt;&lt;16 | uint32(data[5])&lt;&lt;8 | uint32(data[6])
        if uint32(len(data)) != certsLen+7 </span><span class="cov8" title="9472">{
                return false
        }</span>

        <span class="cov4" title="129">numCerts := 0
        d := data[7:]
        for certsLen &gt; 0 </span><span class="cov6" title="1020">{
                if len(d) &lt; 4 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="1020">certLen := uint32(d[0])&lt;&lt;16 | uint32(d[1])&lt;&lt;8 | uint32(d[2])
                if uint32(len(d)) &lt; 3+certLen </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov6" title="1020">d = d[3+certLen:]
                certsLen -= 3 + certLen
                numCerts++</span>
        }

        <span class="cov4" title="129">m.certificates = make([][]byte, numCerts)
        d = data[7:]
        for i := 0; i &lt; numCerts; i++ </span><span class="cov6" title="1020">{
                certLen := uint32(d[0])&lt;&lt;16 | uint32(d[1])&lt;&lt;8 | uint32(d[2])
                m.certificates[i] = d[3 : 3+certLen]
                d = d[3+certLen:]
        }</span>

        <span class="cov4" title="129">return true</span>
}

type serverKeyExchangeMsg struct {
        raw []byte
        key []byte
}

func (m *serverKeyExchangeMsg) equal(i interface{}) bool <span class="cov0" title="0">{
        m1, ok := i.(*serverKeyExchangeMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.key, m1.key)</span>
}

func (m *serverKeyExchangeMsg) marshal() []byte <span class="cov3" title="37">{
        if m.raw != nil </span><span class="cov3" title="26">{
                return m.raw
        }</span>
        <span class="cov2" title="11">length := len(m.key)
        x := make([]byte, length+4)
        x[0] = typeServerKeyExchange
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        copy(x[4:], m.key)

        m.raw = x
        return x</span>
}

func (m *serverKeyExchangeMsg) unmarshal(data []byte) bool <span class="cov3" title="15">{
        m.raw = data
        if len(data) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="15">m.key = data[4:]
        return true</span>
}

type certificateStatusMsg struct {
        raw        []byte
        statusType uint8
        response   []byte
}

func (m *certificateStatusMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*certificateStatusMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.statusType == m1.statusType &amp;&amp;
                bytes.Equal(m.response, m1.response)</span>
}

func (m *certificateStatusMsg) marshal() []byte <span class="cov5" title="200">{
        if m.raw != nil </span><span class="cov4" title="100">{
                return m.raw
        }</span>

        <span class="cov4" title="100">var x []byte
        if m.statusType == statusTypeOCSP </span><span class="cov4" title="41">{
                x = make([]byte, 4+4+len(m.response))
                x[0] = typeCertificateStatus
                l := len(m.response) + 4
                x[1] = byte(l &gt;&gt; 16)
                x[2] = byte(l &gt;&gt; 8)
                x[3] = byte(l)
                x[4] = statusTypeOCSP

                l -= 4
                x[5] = byte(l &gt;&gt; 16)
                x[6] = byte(l &gt;&gt; 8)
                x[7] = byte(l)
                copy(x[8:], m.response)
        }</span> <span class="cov4" title="59">else {
                x = []byte{typeCertificateStatus, 0, 0, 1, m.statusType}
        }</span>

        <span class="cov4" title="100">m.raw = x
        return x</span>
}

func (m *certificateStatusMsg) unmarshal(data []byte) bool <span class="cov7" title="1923">{
        m.raw = data
        if len(data) &lt; 5 </span><span class="cov6" title="547">{
                return false
        }</span>
        <span class="cov6" title="1376">m.statusType = data[4]

        m.response = nil
        if m.statusType == statusTypeOCSP </span><span class="cov5" title="370">{
                if len(data) &lt; 8 </span><span class="cov4" title="124">{
                        return false
                }</span>
                <span class="cov5" title="246">respLen := uint32(data[5])&lt;&lt;16 | uint32(data[6])&lt;&lt;8 | uint32(data[7])
                if uint32(len(data)) != 4+4+respLen </span><span class="cov5" title="205">{
                        return false
                }</span>
                <span class="cov4" title="41">m.response = data[8:]</span>
        }
        <span class="cov6" title="1047">return true</span>
}

type serverHelloDoneMsg struct{}

func (m *serverHelloDoneMsg) equal(i interface{}) bool <span class="cov0" title="0">{
        _, ok := i.(*serverHelloDoneMsg)
        return ok
}</span>

func (m *serverHelloDoneMsg) marshal() []byte <span class="cov4" title="93">{
        x := make([]byte, 4)
        x[0] = typeServerHelloDone
        return x
}</span>

func (m *serverHelloDoneMsg) unmarshal(data []byte) bool <span class="cov3" title="27">{
        return len(data) == 4
}</span>

type clientKeyExchangeMsg struct {
        raw        []byte
        ciphertext []byte
}

func (m *clientKeyExchangeMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*clientKeyExchangeMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.ciphertext, m1.ciphertext)</span>
}

func (m *clientKeyExchangeMsg) marshal() []byte <span class="cov5" title="284">{
        if m.raw != nil </span><span class="cov5" title="158">{
                return m.raw
        }</span>
        <span class="cov4" title="126">length := len(m.ciphertext)
        x := make([]byte, length+4)
        x[0] = typeClientKeyExchange
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        copy(x[4:], m.ciphertext)

        m.raw = x
        return x</span>
}

func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool <span class="cov10" title="57221">{
        m.raw = data
        if len(data) &lt; 4 </span><span class="cov5" title="434">{
                return false
        }</span>
        <span class="cov9" title="56787">l := int(data[1])&lt;&lt;16 | int(data[2])&lt;&lt;8 | int(data[3])
        if l != len(data)-4 </span><span class="cov9" title="56655">{
                return false
        }</span>
        <span class="cov5" title="132">m.ciphertext = data[4:]
        return true</span>
}

type finishedMsg struct {
        raw        []byte
        verifyData []byte
}

func (m *finishedMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*finishedMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.verifyData, m1.verifyData)</span>
}

func (m *finishedMsg) marshal() (x []byte) <span class="cov5" title="395">{
        if m.raw != nil </span><span class="cov5" title="230">{
                return m.raw
        }</span>

        <span class="cov5" title="165">x = make([]byte, 4+len(m.verifyData))
        x[0] = typeFinished
        x[3] = byte(len(m.verifyData))
        copy(x[4:], m.verifyData)
        m.raw = x
        return</span>
}

func (m *finishedMsg) unmarshal(data []byte) bool <span class="cov6" title="1165">{
        m.raw = data
        if len(data) &lt; 4 </span><span class="cov4" title="44">{
                return false
        }</span>
        <span class="cov6" title="1121">m.verifyData = data[4:]
        return true</span>
}

type nextProtoMsg struct {
        raw   []byte
        proto string
}

func (m *nextProtoMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*nextProtoMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.proto == m1.proto</span>
}

func (m *nextProtoMsg) marshal() []byte <span class="cov5" title="200">{
        if m.raw != nil </span><span class="cov4" title="100">{
                return m.raw
        }</span>
        <span class="cov4" title="100">l := len(m.proto)
        if l &gt; 255 </span><span class="cov0" title="0">{
                l = 255
        }</span>

        <span class="cov4" title="100">padding := 32 - (l+2)%32
        length := l + padding + 2
        x := make([]byte, length+4)
        x[0] = typeNextProtocol
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)

        y := x[4:]
        y[0] = byte(l)
        copy(y[1:], []byte(m.proto[0:l]))
        y = y[1+l:]
        y[0] = byte(padding)

        m.raw = x

        return x</span>
}

func (m *nextProtoMsg) unmarshal(data []byte) bool <span class="cov8" title="15772">{
        m.raw = data

        if len(data) &lt; 5 </span><span class="cov6" title="554">{
                return false
        }</span>
        <span class="cov8" title="15218">data = data[4:]
        protoLen := int(data[0])
        data = data[1:]
        if len(data) &lt; protoLen </span><span class="cov8" title="13325">{
                return false
        }</span>
        <span class="cov7" title="1893">m.proto = string(data[0:protoLen])
        data = data[protoLen:]

        if len(data) &lt; 1 </span><span class="cov4" title="102">{
                return false
        }</span>
        <span class="cov7" title="1791">paddingLen := int(data[0])
        data = data[1:]
        if len(data) != paddingLen </span><span class="cov7" title="1691">{
                return false
        }</span>

        <span class="cov4" title="100">return true</span>
}

type certificateRequestMsg struct {
        raw []byte
        // hasSignatureAndHash indicates whether this message includes a list
        // of signature and hash functions. This change was introduced with TLS
        // 1.2.
        hasSignatureAndHash bool

        certificateTypes       []byte
        signatureAndHashes     []signatureAndHash
        certificateAuthorities [][]byte
}

func (m *certificateRequestMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*certificateRequestMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.certificateTypes, m1.certificateTypes) &amp;&amp;
                eqByteSlices(m.certificateAuthorities, m1.certificateAuthorities) &amp;&amp;
                eqSignatureAndHashes(m.signatureAndHashes, m1.signatureAndHashes)</span>
}

func (m *certificateRequestMsg) marshal() (x []byte) <span class="cov5" title="214">{
        if m.raw != nil </span><span class="cov4" title="111">{
                return m.raw
        }</span>

        // See http://tools.ietf.org/html/rfc4346#section-7.4.4
        <span class="cov4" title="103">length := 1 + len(m.certificateTypes) + 2
        casLength := 0
        for _, ca := range m.certificateAuthorities </span><span class="cov7" title="4434">{
                casLength += 2 + len(ca)
        }</span>
        <span class="cov4" title="103">length += casLength

        if m.hasSignatureAndHash </span><span class="cov1" title="3">{
                length += 2 + 2*len(m.signatureAndHashes)
        }</span>

        <span class="cov4" title="103">x = make([]byte, 4+length)
        x[0] = typeCertificateRequest
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)

        x[4] = uint8(len(m.certificateTypes))

        copy(x[5:], m.certificateTypes)
        y := x[5+len(m.certificateTypes):]

        if m.hasSignatureAndHash </span><span class="cov1" title="3">{
                n := len(m.signatureAndHashes) * 2
                y[0] = uint8(n &gt;&gt; 8)
                y[1] = uint8(n)
                y = y[2:]
                for _, sigAndHash := range m.signatureAndHashes </span><span class="cov2" title="6">{
                        y[0] = sigAndHash.hash
                        y[1] = sigAndHash.signature
                        y = y[2:]
                }</span>
        }

        <span class="cov4" title="103">y[0] = uint8(casLength &gt;&gt; 8)
        y[1] = uint8(casLength)
        y = y[2:]
        for _, ca := range m.certificateAuthorities </span><span class="cov7" title="4434">{
                y[0] = uint8(len(ca) &gt;&gt; 8)
                y[1] = uint8(len(ca))
                y = y[2:]
                copy(y, ca)
                y = y[len(ca):]
        }</span>

        <span class="cov4" title="103">m.raw = x
        return</span>
}

func (m *certificateRequestMsg) unmarshal(data []byte) bool <span class="cov9" title="46134">{
        m.raw = data

        if len(data) &lt; 5 </span><span class="cov6" title="540">{
                return false
        }</span>

        <span class="cov9" title="45594">length := uint32(data[1])&lt;&lt;16 | uint32(data[2])&lt;&lt;8 | uint32(data[3])
        if uint32(len(data))-4 != length </span><span class="cov9" title="45486">{
                return false
        }</span>

        <span class="cov4" title="108">numCertTypes := int(data[4])
        data = data[5:]
        if numCertTypes == 0 || len(data) &lt;= numCertTypes </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="108">m.certificateTypes = make([]byte, numCertTypes)
        if copy(m.certificateTypes, data) != numCertTypes </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="108">data = data[numCertTypes:]

        if m.hasSignatureAndHash </span><span class="cov2" title="4">{
                if len(data) &lt; 2 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov2" title="4">sigAndHashLen := uint16(data[0])&lt;&lt;8 | uint16(data[1])
                data = data[2:]
                if sigAndHashLen&amp;1 != 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov2" title="4">if len(data) &lt; int(sigAndHashLen) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov2" title="4">numSigAndHash := sigAndHashLen / 2
                m.signatureAndHashes = make([]signatureAndHash, numSigAndHash)
                for i := range m.signatureAndHashes </span><span class="cov4" title="64">{
                        m.signatureAndHashes[i].hash = data[0]
                        m.signatureAndHashes[i].signature = data[1]
                        data = data[2:]
                }</span>
        }

        <span class="cov4" title="108">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="108">casLength := uint16(data[0])&lt;&lt;8 | uint16(data[1])
        data = data[2:]
        if len(data) &lt; int(casLength) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="108">cas := make([]byte, casLength)
        copy(cas, data)
        data = data[casLength:]

        m.certificateAuthorities = nil
        for len(cas) &gt; 0 </span><span class="cov7" title="4434">{
                if len(cas) &lt; 2 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov7" title="4434">caLen := uint16(cas[0])&lt;&lt;8 | uint16(cas[1])
                cas = cas[2:]

                if len(cas) &lt; int(caLen) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov7" title="4434">m.certificateAuthorities = append(m.certificateAuthorities, cas[:caLen])
                cas = cas[caLen:]</span>
        }
        <span class="cov4" title="108">if len(data) &gt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="108">return true</span>
}

type certificateVerifyMsg struct {
        raw                 []byte
        hasSignatureAndHash bool
        signatureAndHash    signatureAndHash
        signature           []byte
}

func (m *certificateVerifyMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*certificateVerifyMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                m.hasSignatureAndHash == m1.hasSignatureAndHash &amp;&amp;
                m.signatureAndHash.hash == m1.signatureAndHash.hash &amp;&amp;
                m.signatureAndHash.signature == m1.signatureAndHash.signature &amp;&amp;
                bytes.Equal(m.signature, m1.signature)</span>
}

func (m *certificateVerifyMsg) marshal() (x []byte) <span class="cov5" title="218">{
        if m.raw != nil </span><span class="cov4" title="110">{
                return m.raw
        }</span>

        // See http://tools.ietf.org/html/rfc4346#section-7.4.8
        <span class="cov4" title="108">siglength := len(m.signature)
        length := 2 + siglength
        if m.hasSignatureAndHash </span><span class="cov2" title="4">{
                length += 2
        }</span>
        <span class="cov4" title="108">x = make([]byte, 4+length)
        x[0] = typeCertificateVerify
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        y := x[4:]
        if m.hasSignatureAndHash </span><span class="cov2" title="4">{
                y[0] = m.signatureAndHash.hash
                y[1] = m.signatureAndHash.signature
                y = y[2:]
        }</span>
        <span class="cov4" title="108">y[0] = uint8(siglength &gt;&gt; 8)
        y[1] = uint8(siglength)
        copy(y[2:], m.signature)

        m.raw = x

        return</span>
}

func (m *certificateVerifyMsg) unmarshal(data []byte) bool <span class="cov7" title="2550">{
        m.raw = data

        if len(data) &lt; 6 </span><span class="cov6" title="662">{
                return false
        }</span>

        <span class="cov7" title="1888">length := uint32(data[1])&lt;&lt;16 | uint32(data[2])&lt;&lt;8 | uint32(data[3])
        if uint32(len(data))-4 != length </span><span class="cov7" title="1786">{
                return false
        }</span>

        <span class="cov4" title="102">data = data[4:]
        if m.hasSignatureAndHash </span><span class="cov1" title="2">{
                m.signatureAndHash.hash = data[0]
                m.signatureAndHash.signature = data[1]
                data = data[2:]
        }</span>

        <span class="cov4" title="102">if len(data) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="102">siglength := int(data[0])&lt;&lt;8 + int(data[1])
        data = data[2:]
        if len(data) != siglength </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="102">m.signature = data

        return true</span>
}

type newSessionTicketMsg struct {
        raw    []byte
        ticket []byte
}

func (m *newSessionTicketMsg) equal(i interface{}) bool <span class="cov4" title="100">{
        m1, ok := i.(*newSessionTicketMsg)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">return bytes.Equal(m.raw, m1.raw) &amp;&amp;
                bytes.Equal(m.ticket, m1.ticket)</span>
}

func (m *newSessionTicketMsg) marshal() (x []byte) <span class="cov5" title="217">{
        if m.raw != nil </span><span class="cov4" title="110">{
                return m.raw
        }</span>

        // See http://tools.ietf.org/html/rfc5077#section-3.3
        <span class="cov4" title="107">ticketLen := len(m.ticket)
        length := 2 + 4 + ticketLen
        x = make([]byte, 4+length)
        x[0] = typeNewSessionTicket
        x[1] = uint8(length &gt;&gt; 16)
        x[2] = uint8(length &gt;&gt; 8)
        x[3] = uint8(length)
        x[8] = uint8(ticketLen &gt;&gt; 8)
        x[9] = uint8(ticketLen)
        copy(x[10:], m.ticket)

        m.raw = x

        return</span>
}

func (m *newSessionTicketMsg) unmarshal(data []byte) bool <span class="cov7" title="2257">{
        m.raw = data

        if len(data) &lt; 10 </span><span class="cov6" title="1095">{
                return false
        }</span>

        <span class="cov6" title="1162">length := uint32(data[1])&lt;&lt;16 | uint32(data[2])&lt;&lt;8 | uint32(data[3])
        if uint32(len(data))-4 != length </span><span class="cov6" title="1059">{
                return false
        }</span>

        <span class="cov4" title="103">ticketLen := int(data[8])&lt;&lt;8 + int(data[9])
        if len(data)-10 != ticketLen </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="103">m.ticket = data[10:]

        return true</span>
}

func eqUint16s(x, y []uint16) bool <span class="cov4" title="100">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="100">for i, v := range x </span><span class="cov7" title="3388">{
                if y[i] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov4" title="100">return true</span>
}

func eqCurveIDs(x, y []CurveID) bool <span class="cov4" title="100">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="100">for i, v := range x </span><span class="cov5" title="311">{
                if y[i] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov4" title="100">return true</span>
}

func eqStrings(x, y []string) bool <span class="cov5" title="200">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="200">for i, v := range x </span><span class="cov5" title="355">{
                if y[i] != v </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov5" title="200">return true</span>
}

func eqByteSlices(x, y [][]byte) bool <span class="cov5" title="200">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="200">for i, v := range x </span><span class="cov8" title="5426">{
                if !bytes.Equal(v, y[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov5" title="200">return true</span>
}

func eqSignatureAndHashes(x, y []signatureAndHash) bool <span class="cov5" title="200">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="200">for i, v := range x </span><span class="cov5" title="136">{
                v2 := y[i]
                if v.hash != v2.hash || v.signature != v2.signature </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov5" title="200">return true</span>
}
</pre>
		
		<pre class="file" id="file232" style="display: none">/* handshake_server.go - handshake for server side */
/*
modification history
--------------------
2015/4/11, by Sijie Yang, modify
    - merge from session cache demo written by Weiwei Zhang
2015/5/29, by Xiong Zongtao, modify
    - Ecc fallback to other cipher suite when compute resource
      is not enough.
2015/5/18, by Xiong Zongtao, modify
        - Filter of common DOS by client-hello random
    - Log handshake infomation
2015/09/07, by Weiwei Zhang, modify
    - check server cert type after receiving clientHello, and save to connection
*/
/*
DESCRIPTION
*/

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto"
        "crypto/ecdsa"
        "crypto/rsa"
        "crypto/subtle"
        "crypto/x509"
        "encoding/asn1"
        "errors"
        "fmt"
        "io"
    "strings"
)

// serverHandshakeState contains details of a server handshake in progress.
// It's discarded once the handshake has completed.
type serverHandshakeState struct {
        c               *Conn
        clientHello     *clientHelloMsg
        hello           *serverHelloMsg
        suite           *cipherSuite
        ellipticOk      bool
        ecdsaOk         bool
        sessionState    *sessionState
        finishedHash    finishedHash
        masterSecret    []byte
        certsFromClient [][]byte
        cert            *Certificate
}

// serverHandshake performs a TLS handshake as a server.
func (c *Conn) serverHandshake() error <span class="cov6" title="49">{
        config := c.config

        // If this is the first server handshake, we generate a random key to
        // encrypt the tickets with.
        config.serverInitOnce.Do(config.serverInit)

        hs := serverHandshakeState{
                c: c,
        }
        
        // some process after handshake
        defer hs.postHandshake()

        isResume, err := hs.readClientHello()
        if err != nil </span><span class="cov4" title="12">{
                stateInc(HANDSHAKE_READ_CLIENTHELLO_ERR, 1)
                return err
        }</span>

        <span class="cov6" title="37">if antiTlsDosEngine != nil </span><span class="cov0" title="0">{
                if antiTlsDosEngine.IsMatchDosRandom(hs.clientHello.random) </span><span class="cov0" title="0">{
                        stateInc(ERR_REJECT_CONN_CLIENTHELLO_RANDOM, 1)
                        return errors.New("Hit a DOS random, handshake forbidden")
                }</span>
        }

        // For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3
        <span class="cov6" title="37">if isResume </span><span class="cov3" title="4">{
                stateInc(HANDSHAKE_RESUME_ALL, 1)
                // The client has included a session ticket and so we do an abbreviated handshake.
                if err := hs.doResumeHandshake(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">if err := hs.sendFinished(isResume); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">if err := hs.readFinished(isResume); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="4">c.didResume = true
                stateInc(HANDSHAKE_RESUME_SUCC, 1)</span>
        } <span class="cov6" title="33">else {
                stateInc(HANDSHAKE_FULL_ALL, 1)
                // The client didn't include a session ticket, or it wasn't
                // valid so we do a full handshake.
                if err := hs.doFullHandshake(); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov6" title="32">if err := hs.establishKeys(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="32">if err := hs.readFinished(isResume); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="32">if err := hs.sendSessionTicket(isResume); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="32">if err := hs.sendFinished(isResume); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update session cache
                <span class="cov6" title="32">if !c.config.SessionCacheDisabled &amp;&amp; c.config.ServerSessionCache != nil </span><span class="cov0" title="0">{
                        // If a server is planning on issuing a session ticket to a client that
                        // does not present one, it SHOULD include an empty Session ID in the ServerHello
                        // If the Session Id is not empty, the sever choose stateful resume(session id).
                        if len(hs.hello.sessionId) &gt; 0 </span><span class="cov0" title="0">{
                                state := &amp;sessionState{
                                        vers:         c.vers,
                                        cipherSuite:  hs.suite.id,
                    sessionId:    hs.hello.sessionId,
                                        masterSecret: hs.masterSecret,
                                        certificates: hs.certsFromClient,
                                }
                                c.config.ServerSessionCache.Put(fmt.Sprintf("%x", hs.hello.sessionId),
                                                state.marshal())
                        }</span>
                }
                <span class="cov6" title="32">stateInc(HANDSHAKE_FULL_SUCC, 1)</span>
        }
        <span class="cov6" title="36">c.handshakeComplete = true

        return nil</span>
}

// get the type of server certificate
func (hs *serverHandshakeState) getServerCertType() string <span class="cov6" title="39">{
    alpnProtos := hs.clientHello.alpnProtocols

    // check if the client uses TLS1.2 and supports HTTP2.0
    if hs.hello.vers == VersionTLS12 &amp;&amp; len(alpnProtos) &gt; 0 </span><span class="cov2" title="2">{
        for _, s := range alpnProtos </span><span class="cov3" title="4">{
            if strings.HasPrefix(s, "h2") </span><span class="cov0" title="0">{
                    stateInc(HANDSHAKE_FIND_SHA256_PATTERN, 1)
                return CertTypeSha256
            }</span>
        }
    }
        <span class="cov6" title="39">stateInc(HANDSHAKE_FIND_NO_PATTERN, 1)
    return CertTypeUnsure</span>
}

// readClientHello reads a ClientHello message from the client and decides
// whether we will perform session resumption.
func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) <span class="cov6" title="49">{
        config := hs.c.config
        c := hs.c

    stateInc(SERV_READ_CLIENT_HELLO, 1)
        msg, err := c.readHandshake()
        if err != nil </span><span class="cov2" title="2">{
                return false, err
        }</span>
        <span class="cov6" title="47">var ok bool
        hs.clientHello, ok = msg.(*clientHelloMsg)
        if !ok </span><span class="cov1" title="1">{
                c.sendAlert(alertUnexpectedMessage)
                return false, unexpectedMessageError(hs.clientHello, msg)
        }</span>
        <span class="cov6" title="46">c.vers, ok = config.mutualVersion(hs.clientHello.vers)
        if !ok </span><span class="cov3" title="6">{
                c.sendAlert(alertProtocolVersion)
                stateInc(ERR_CLIENT_VERSION_NOT_SUPPORT, 1)
                return false, fmt.Errorf("tls: client offered an unsupported, maximum protocol version of %x", hs.clientHello.vers)
        }</span>
        <span class="cov6" title="40">stateInc(VersionText(c.vers), 1)
        c.haveVers = true

        hs.finishedHash = newFinishedHash(c.vers)
    if c.sslv2Data == nil </span><span class="cov6" title="40">{
        hs.finishedHash.Write(hs.clientHello.marshal())
    }</span> <span class="cov0" title="0">else {
        hs.finishedHash.Write(c.sslv2Data)
        c.sslv2Data = nil
    }</span>

        <span class="cov6" title="40">hs.hello = new(serverHelloMsg)

        supportedCurve := false
        preferredCurves := config.curvePreferences()
Curves:
        for _, curve := range hs.clientHello.supportedCurves </span><span class="cov6" title="36">{
                for _, supported := range preferredCurves </span><span class="cov7" title="84">{
                        if supported == curve </span><span class="cov5" title="20">{
                                supportedCurve = true
                                break Curves</span>
                        }
                }
        }

        <span class="cov6" title="40">supportedPointFormat := false
        for _, pointFormat := range hs.clientHello.supportedPoints </span><span class="cov5" title="20">{
                if pointFormat == pointFormatUncompressed </span><span class="cov5" title="20">{
                        supportedPointFormat = true
                        break</span>
                }
        }
        <span class="cov6" title="40">hs.ellipticOk = supportedCurve &amp;&amp; supportedPointFormat

        foundCompression := false
        // We only support null compression, so check that the client offered it.
        for _, compression := range hs.clientHello.compressionMethods </span><span class="cov6" title="40">{
                if compression == compressionNone </span><span class="cov6" title="39">{
                        foundCompression = true
                        break</span>
                }
        }

        <span class="cov6" title="40">if !foundCompression </span><span class="cov1" title="1">{
                c.sendAlert(alertHandshakeFailure)
                stateInc(ERR_CLIENT_NOT_SUPPORT_UNCOMPRESS_CONN, 1)
                return false, errors.New("tls: client does not support uncompressed connections")
        }</span>

        <span class="cov6" title="39">hs.hello.vers = c.vers
        hs.hello.random = make([]byte, 32)
        _, err = io.ReadFull(config.rand(), hs.hello.random)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                stateInc(ERR_SERVER_INTERNAL, 1)
                return false, err
        }</span>
        <span class="cov6" title="39">hs.hello.secureRenegotiation = hs.clientHello.secureRenegotiation
        hs.hello.compressionMethod = compressionNone
        if len(hs.clientHello.serverName) &gt; 0 </span><span class="cov2" title="2">{
                c.serverName = hs.clientHello.serverName
        }</span>

    <span class="cov6" title="39">nextProtos := c.config.getNextProtos(c)
        if len(hs.clientHello.alpnProtocols) &gt; 0 </span><span class="cov2" title="2">{
                if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, nextProtos); !fallback </span><span class="cov1" title="1">{
                        hs.hello.alpnProtocol = selectedProto
                        c.clientProtocol = selectedProto
                }</span>
        // stat application protocol supported by client
        <span class="cov2" title="2">for _, proto := range(hs.clientHello.alpnProtocols) </span><span class="cov3" title="4">{
            stateInc(alpnProtoText(proto), 1)
        }</span>
        <span class="cov2" title="2">stateInc(TLS_ALPN_EXT_COUNT, 1)</span>
        } <span class="cov6" title="37">else {
                // Although sending an empty NPN extension is reasonable, Firefox has
                // had a bug around this. Best to send nothing at all if
                // config.NextProtos is empty. See
                // https://code.google.com/p/go/issues/detail?id=5445.
                if hs.clientHello.nextProtoNeg &amp;&amp; len(nextProtos) &gt; 0 </span><span class="cov0" title="0">{
                        hs.hello.nextProtoNeg = true
                        hs.hello.nextProtos = nextProtos
                }</span>
        }

    // check which cert type is supported for this connection
    <span class="cov6" title="39">c.certType = hs.getServerCertType()

    // Select certificate for current connection
        if len(config.Certificates) == 0 </span><span class="cov0" title="0">{
                c.sendAlert(alertInternalError)
                stateInc(ERR_NO_CERT_CONFIGURED, 1)
                return false, errors.New("tls: no certificates configured")
        }</span>
        <span class="cov6" title="39">hs.cert = &amp;config.Certificates[0]
        if len(hs.clientHello.serverName) &gt; 0 </span><span class="cov2" title="2">{
                hs.cert = config.getCertificateForName(hs.clientHello.serverName)
        }</span>
    <span class="cov6" title="39">if config.MultiCert != nil </span><span class="cov0" title="0">{
        if cert := config.MultiCert.Get(c); cert != nil </span><span class="cov0" title="0">{
            hs.cert = cert
        }</span>
    }

        <span class="cov6" title="39">_, hs.ecdsaOk = hs.cert.PrivateKey.(*ecdsa.PrivateKey)

        if hs.checkForResumption() </span><span class="cov3" title="4">{
                return true, nil
        }</span>

        <span class="cov6" title="35">var preferenceList, supportedList []uint16
        if c.config.PreferServerCipherSuites </span><span class="cov2" title="3">{
                preferenceList = c.config.cipherSuites()
                supportedList = hs.clientHello.cipherSuites
        }</span> <span class="cov6" title="32">else {
                preferenceList = hs.clientHello.cipherSuites
                supportedList = c.config.cipherSuites()
        }</span>

        <span class="cov6" title="35">if antiTlsDosEngine != nil </span><span class="cov0" title="0">{
                value := antiTlsDosEngine.TryCipherSuite(preferenceList, supportedList, hs)
                if suite, ok := value.(*cipherSuite); ok </span><span class="cov0" title="0">{
                        hs.suite = suite
                }</span>
    } <span class="cov6" title="35">else {
        for _, id := range preferenceList </span><span class="cov6" title="48">{
            if hs.suite = c.tryCipherSuite(id, supportedList, c.vers, hs.ellipticOk, hs.ecdsaOk); hs.suite != nil </span><span class="cov6" title="34">{
                break</span>
            }
        }
    }

    // no cipher suite supported by both client and server.
        <span class="cov6" title="35">if hs.suite == nil </span><span class="cov1" title="1">{
        // If client proposes ECDHE without ECC extensions, just try ECDHE cipher suite
        // and choose CurveP256 and Uncompressed point format for client.
        //
        // Note: A client that proposes ECC cipher suites may choose not to include 
        // elliptic curves extension or elliptic point format extension. In this case, 
        // the server is free to choose any one of the elliptic curves or point formats.
        //
        // For more information, see RFC 4492 Section 4
        ellipticMayOk := hs.checkEllipticMayOk(supportedCurve, supportedPointFormat)
        if ellipticMayOk </span><span class="cov1" title="1">{
            for _, id := range preferenceList </span><span class="cov1" title="1">{
                if !CheckSuiteECDHE(id) </span><span class="cov1" title="1">{
                    continue</span>
                }
                <span class="cov0" title="0">if hs.suite = c.tryCipherSuite(id, supportedList, c.vers, true, hs.ecdsaOk); hs.suite != nil </span><span class="cov0" title="0">{
                    break</span>
                }
            }

            <span class="cov1" title="1">if hs.suite != nil </span><span class="cov0" title="0">{
                stateInc(HANDSHAKE_ACCEPT_ECDHE_WITHOUT_EXT, 1)
                    hs.clientHello.supportedCurves = append(hs.clientHello.supportedCurves, CurveP256)
                    hs.clientHello.supportedPoints = append(hs.clientHello.supportedPoints, pointFormatUncompressed)
            }</span>
        }
    }

        <span class="cov6" title="35">if hs.suite == nil </span><span class="cov1" title="1">{
                c.sendAlert(alertHandshakeFailure)
                stateInc(ERR_NO_SHARED_CIPHER_SUITE, 1)
                return false, errors.New("tls: no cipher suite supported by both client and server")
        }</span>

        // See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00.
        <span class="cov6" title="34">for _, id := range hs.clientHello.cipherSuites </span><span class="cov9" title="387">{
                if id == TLS_FALLBACK_SCSV </span><span class="cov1" title="1">{
                        // The client is doing a fallback connection.
                        if hs.clientHello.vers &lt; c.config.MaxVersion </span><span class="cov1" title="1">{
                                c.sendAlert(alertInappropriateFallback)
                        stateInc(ERR_TLS_FALLBACK_SCSV, 1)
                                return false, errors.New("tls: client using inppropriate protocol fallback")
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov6" title="33">return false, nil</span>
}

func (hs *serverHandshakeState) checkEllipticMayOk(supportedCurve, supportedPointFormat bool) bool <span class="cov1" title="1">{
    if hs.c.vers &lt;= VersionSSL30 </span><span class="cov0" title="0">{
        return false
    }</span>
    <span class="cov1" title="1">if supportedCurve &amp;&amp; len(hs.clientHello.supportedPoints) == 0 </span><span class="cov0" title="0">{
        return true
    }</span>
    <span class="cov1" title="1">if supportedPointFormat &amp;&amp; len(hs.clientHello.supportedCurves) == 0 </span><span class="cov0" title="0">{
        return true
    }</span>
    <span class="cov1" title="1">if len(hs.clientHello.supportedCurves) == 0 &amp;&amp; len(hs.clientHello.supportedPoints) == 0 </span><span class="cov1" title="1">{
        return true
    }</span>
    <span class="cov0" title="0">return false</span>
}

// checkForResumption returns true if we should perform resumption on this connection.
func (hs *serverHandshakeState) checkForResumption() bool <span class="cov6" title="39">{
        c := hs.c

        var useSessionTicket bool
        var ok bool
        // check session ticket
        if !c.config.SessionTicketsDisabled &amp;&amp; hs.clientHello.ticketSupported &amp;&amp; len(hs.clientHello.sessionTicket) != 0 </span><span class="cov3" title="5">{
                stateInc(HANDSHAKE_CHECK_RESUME_SESSION_TICKET, 1)
                useSessionTicket = true
                if hs.sessionState, ok = c.decryptTicket(hs.clientHello.sessionTicket); !ok </span><span class="cov1" title="1">{
                        return false
                }</span>
        } <span class="cov6" title="34">else {
                // check session cache
                if len(hs.clientHello.sessionId) == 0 </span><span class="cov6" title="33">{
                        return false
                }</span>
                <span class="cov1" title="1">stateInc(HANDSHAKE_CHECK_RESUME_SESSION_CACHE, 1)
                useSessionTicket = false
                hs.sessionState = nil
                if !c.config.SessionCacheDisabled &amp;&amp; c.config.ServerSessionCache != nil </span><span class="cov0" title="0">{
                        sessionCache := c.config.ServerSessionCache
                        sessionParam, ok := sessionCache.Get(fmt.Sprintf("%x", hs.clientHello.sessionId))
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">candidateSession := new(sessionState)
                        if ok := candidateSession.unmarshal(sessionParam); !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">hs.sessionState = candidateSession</span>
                }
        }

        <span class="cov3" title="5">if hs.sessionState == nil || hs.sessionState.vers &gt; hs.clientHello.vers </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov3" title="4">if vers, ok := c.config.mutualVersion(hs.sessionState.vers); !ok || vers != hs.sessionState.vers </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="4">cipherSuiteOk := false
        // Check that the client is still offering the ciphersuite in the session.
        for _, id := range hs.clientHello.cipherSuites </span><span class="cov3" title="4">{
                if id == hs.sessionState.cipherSuite </span><span class="cov3" title="4">{
                        cipherSuiteOk = true
                        break</span>
                }
        }
        <span class="cov3" title="4">if !cipherSuiteOk </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that we also support the ciphersuite from the session.
        <span class="cov3" title="4">hs.suite = c.tryCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.sessionState.vers, hs.ellipticOk, hs.ecdsaOk)
        if hs.suite == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="4">sessionHasClientCerts := len(hs.sessionState.certificates) != 0
        needClientCerts := c.config.ClientAuth == RequireAnyClientCert || c.config.ClientAuth == RequireAndVerifyClientCert
        if needClientCerts &amp;&amp; !sessionHasClientCerts </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="4">if sessionHasClientCerts &amp;&amp; c.config.ClientAuth == NoClientCert </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov3" title="4">if useSessionTicket </span><span class="cov3" title="4">{
                stateInc(HANDSHAKE_SHOULD_RESUME_SESSION_TICKET, 1)
        }</span> <span class="cov0" title="0">else {
                stateInc(HANDSHAKE_SHOULD_RESUME_SESSION_CACHE, 1)
        }</span>

        <span class="cov3" title="4">return true</span>
}

func (hs *serverHandshakeState) doResumeHandshake() error <span class="cov3" title="4">{
        c := hs.c

        hs.hello.cipherSuite = hs.suite.id
        // We echo the client's session ID in the ServerHello to let it know
        // that we're doing a resumption.
        hs.hello.sessionId = hs.clientHello.sessionId
        hs.finishedHash.Write(hs.hello.marshal())
    hsStateInc(SERV_SEND_SERVER_HELLO, true, 1)
        c.writeRecord(recordTypeHandshake, hs.hello.marshal())

        if len(hs.sessionState.certificates) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="4">hs.masterSecret = hs.sessionState.masterSecret

        return nil</span>
}

func (hs *serverHandshakeState) doFullHandshake() error <span class="cov6" title="33">{
        config := hs.c.config
        c := hs.c

        if hs.clientHello.ocspStapling &amp;&amp; len(hs.cert.OCSPStaple) &gt; 0 </span><span class="cov0" title="0">{
                hs.hello.ocspStapling = true
        }</span>

        <span class="cov6" title="33">hs.hello.ticketSupported = hs.clientHello.ticketSupported &amp;&amp; !config.SessionTicketsDisabled
        if !hs.hello.ticketSupported &amp;&amp; !c.config.SessionCacheDisabled </span><span class="cov3" title="4">{
                // create new session id
                hs.hello.sessionId = make([]byte, 32)
                if _, err := io.ReadFull(c.config.rand(), hs.hello.sessionId); err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertInternalError)
                        stateInc(ERR_SERVER_INTERNAL, 1)
                        return err
                }</span>
        }

        <span class="cov6" title="33">hs.hello.cipherSuite = hs.suite.id
        hs.finishedHash.Write(hs.hello.marshal())
    hsStateInc(SERV_SEND_SERVER_HELLO, false, 1)
        c.writeRecord(recordTypeHandshake, hs.hello.marshal())

        certMsg := new(certificateMsg)
        certMsg.certificates = hs.cert.Certificate
        hs.finishedHash.Write(certMsg.marshal())
    hsStateInc(SERV_SEND_CERTIFICATE, false, 1)
        c.writeRecord(recordTypeHandshake, certMsg.marshal())

        if hs.hello.ocspStapling </span><span class="cov0" title="0">{
                certStatus := new(certificateStatusMsg)
                certStatus.statusType = statusTypeOCSP
                certStatus.response = hs.cert.OCSPStaple
                hs.finishedHash.Write(certStatus.marshal())
        hsStateInc(SERV_SEND_CERTIFICATE_STATUS, false, 1)
                c.writeRecord(recordTypeHandshake, certStatus.marshal())
        }</span>

        <span class="cov6" title="33">keyAgreement := hs.suite.ka(c.vers)
        skx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                stateInc(ERR_ALERT_HANDSHAKE_FAILURE, 1)
                return err
        }</span>
        <span class="cov6" title="33">if skx != nil </span><span class="cov4" title="11">{
                hs.finishedHash.Write(skx.marshal())
        hsStateInc(SERV_SEND_SERVER_KEY_EXCHANGE, false, 1)
                c.writeRecord(recordTypeHandshake, skx.marshal())
        }</span>

        <span class="cov6" title="33">if config.ClientAuth &gt;= RequestClientCert </span><span class="cov2" title="3">{
                // Request a client certificate
                certReq := new(certificateRequestMsg)
                certReq.certificateTypes = []byte{
                        byte(certTypeRSASign),
                        byte(certTypeECDSASign),
                }
                if c.vers &gt;= VersionTLS12 </span><span class="cov2" title="3">{
                        certReq.hasSignatureAndHash = true
                        certReq.signatureAndHashes = supportedClientCertSignatureAlgorithms
                }</span>

                // An empty list of certificateAuthorities signals to
                // the client that it may send any certificate in response
                // to our request. When we know the CAs we trust, then
                // we can send them down, so that the client can choose
                // an appropriate certificate to give to us.
                <span class="cov2" title="3">if config.ClientCAs != nil </span><span class="cov0" title="0">{
                        certReq.certificateAuthorities = config.ClientCAs.Subjects()
                }</span>
                <span class="cov2" title="3">hs.finishedHash.Write(certReq.marshal())
        hsStateInc(SERV_SEND_CERTIFICATE_REQUEST, false, 1)
                c.writeRecord(recordTypeHandshake, certReq.marshal())</span>
        }

        <span class="cov6" title="33">helloDone := new(serverHelloDoneMsg)
        hs.finishedHash.Write(helloDone.marshal())
    hsStateInc(SERV_SEND_SERVER_HELLO_DONE, false, 1)
        c.writeRecord(recordTypeHandshake, helloDone.marshal())

        var pub crypto.PublicKey // public key for client auth, if any

        msg, err := c.readHandshake()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="32">var ok bool
        // If we requested a client certificate, then the client must send a
        // certificate message, even if it's empty.
        if config.ClientAuth &gt;= RequestClientCert </span><span class="cov2" title="3">{
        hsStateInc(SERV_READ_CERTIFICATE, false, 1)
                if certMsg, ok = msg.(*certificateMsg); !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(certMsg, msg)
                }</span>
                <span class="cov2" title="3">hs.finishedHash.Write(certMsg.marshal())

                if len(certMsg.certificates) == 0 </span><span class="cov1" title="1">{
                        // The client didn't actually send a certificate
                        switch config.ClientAuth </span>{
                        <span class="cov0" title="0">case RequireAnyClientCert, RequireAndVerifyClientCert:
                                c.sendAlert(alertBadCertificate)
                                stateInc(alertBadCertificate.String(), 1)
                                stateInc(ERR_CLIENT_CERT_NOT_PROVIDE, 1)
                                return errors.New("tls: client didn't provide a certificate")</span>
                        }
                }

                <span class="cov2" title="3">pub, err = hs.processCertsFromClient(certMsg.certificates)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov2" title="3">msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get client key exchange
    <span class="cov6" title="32">hsStateInc(SERV_READ_CLIENT_KEY_EXCHANGE, false, 1)
        ckx, ok := msg.(*clientKeyExchangeMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(ckx, msg)
        }</span>
        <span class="cov6" title="32">hs.finishedHash.Write(ckx.marshal())

        // If we received a client cert in response to our certificate request message,
        // the client will send us a certificateVerifyMsg immediately after the
        // clientKeyExchangeMsg.  This message is a digest of all preceding
        // handshake-layer messages that is signed using the private key corresponding
        // to the client's certificate. This allows us to verify that the client is in
        // possession of the private key of the certificate.
        if len(c.peerCertificates) &gt; 0 </span><span class="cov2" title="2">{
        hsStateInc(SERV_READ_CERTIFICATE_VERIFY, false, 1)
                msg, err = c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">certVerify, ok := msg.(*certificateVerifyMsg)
                if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(certVerify, msg)
                }</span>

                <span class="cov2" title="2">switch key := pub.(type) </span>{
                <span class="cov1" title="1">case *ecdsa.PublicKey:
                        ecdsaSig := new(ecdsaSignature)
                        if _, err = asn1.Unmarshal(certVerify.signature, ecdsaSig); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov1" title="1">if ecdsaSig.R.Sign() &lt;= 0 || ecdsaSig.S.Sign() &lt;= 0 </span><span class="cov0" title="0">{
                                stateInc(ERR_WRONG_ECDSA_SIGNATURE, 1)
                                err = errors.New("ECDSA signature contained zero or negative values")
                                break</span>
                        }
                        <span class="cov1" title="1">digest, _, _ := hs.finishedHash.hashForClientCertificate(signatureECDSA)
                        if !ecdsa.Verify(key, digest, ecdsaSig.R, ecdsaSig.S) </span><span class="cov0" title="0">{
                                stateInc(ERR_ECDSA_VERIFY_FAILURE, 1)
                                err = errors.New("ECDSA verification failure")
                                break</span>
                        }
                <span class="cov1" title="1">case *rsa.PublicKey:
                        digest, hashFunc, _ := hs.finishedHash.hashForClientCertificate(signatureRSA)
                        err = rsa.VerifyPKCS1v15(key, hashFunc, digest, certVerify.signature)</span>
                }
                <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        stateInc(ERR_BAD_CERT, 1)
                        return errors.New("could not validate signature of connection nonces: " + err.Error())
                }</span>

                <span class="cov2" title="2">hs.finishedHash.Write(certVerify.marshal())</span>
        }

        <span class="cov6" title="32">preMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)
        if err != nil </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                stateInc(ERR_ALERT_HANDSHAKE_FAILURE, 1)
                return err
        }</span>
        <span class="cov6" title="32">hs.masterSecret = masterFromPreMasterSecret(c.vers, preMasterSecret, hs.clientHello.random, hs.hello.random)

        return nil</span>
}

func (hs *serverHandshakeState) establishKeys() error <span class="cov6" title="36">{
        c := hs.c

        clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
                keysFromMasterSecret(c.vers, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)

        var clientCipher, serverCipher interface{}
        var clientHash, serverHash macFunction

        if hs.suite.aead == nil </span><span class="cov6" title="34">{
                clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)
                clientHash = hs.suite.mac(c.vers, clientMAC)
                serverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)
                serverHash = hs.suite.mac(c.vers, serverMAC)
        }</span> <span class="cov2" title="2">else {
                clientCipher = hs.suite.aead(clientKey, clientIV)
                serverCipher = hs.suite.aead(serverKey, serverIV)
        }</span>

        <span class="cov6" title="36">c.in.prepareCipherSpec(c.vers, clientCipher, clientHash)
        c.out.prepareCipherSpec(c.vers, serverCipher, serverHash)

        return nil</span>
}

func (hs *serverHandshakeState) readFinished(isResume bool) error <span class="cov6" title="36">{
        c := hs.c

    hsStateInc(SERV_READ_CHANGE_CIPHER_SPEC, isResume, 1)
        c.readRecord(recordTypeChangeCipherSpec)
        if err := c.in.error(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="36">if hs.hello.nextProtoNeg </span><span class="cov0" title="0">{
        hsStateInc(SERV_READ_NEXT_PROTO, isResume, 1)
                msg, err := c.readHandshake()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">nextProto, ok := msg.(*nextProtoMsg)
                if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertUnexpectedMessage)
                        return unexpectedMessageError(nextProto, msg)
                }</span>
                <span class="cov0" title="0">hs.finishedHash.Write(nextProto.marshal())
                c.clientProtocol = nextProto.proto</span>
        }

    <span class="cov6" title="36">hsStateInc(SERV_READ_FINISHED, isResume, 1)
        msg, err := c.readHandshake()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="36">clientFinished, ok := msg.(*finishedMsg)
        if !ok </span><span class="cov0" title="0">{
                c.sendAlert(alertUnexpectedMessage)
                return unexpectedMessageError(clientFinished, msg)
        }</span>

        <span class="cov6" title="36">verify := hs.finishedHash.clientSum(hs.masterSecret)
        if len(verify) != len(clientFinished.verifyData) ||
                subtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 </span><span class="cov0" title="0">{
                c.sendAlert(alertHandshakeFailure)
                stateInc(ERR_WRONG_CLIENT_FINISH_MSG, 1)
                return errors.New("tls: client's Finished message is incorrect")
        }</span>

        <span class="cov6" title="36">hs.finishedHash.Write(clientFinished.marshal())
        return nil</span>
}

func (hs *serverHandshakeState) sendSessionTicket(isResume bool) error <span class="cov6" title="32">{
        if !hs.hello.ticketSupported </span><span class="cov5" title="25">{
                return nil
        }</span>

        <span class="cov3" title="7">c := hs.c
        m := new(newSessionTicketMsg)

        var err error
        state := sessionState{
                vers:         c.vers,
                cipherSuite:  hs.suite.id,
                masterSecret: hs.masterSecret,
                certificates: hs.certsFromClient,
        }
        m.ticket, err = c.encryptTicket(&amp;state)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="7">hs.finishedHash.Write(m.marshal())
    hsStateInc(SERV_SEND_SESSION_TICKET, isResume, 1)
        c.writeRecord(recordTypeHandshake, m.marshal())

        return nil</span>
}

func (hs *serverHandshakeState) sendFinished(isResume bool) error <span class="cov6" title="36">{
        c := hs.c

    hsStateInc(SERV_SEND_CHANGE_CIPHER_SPEC, isResume, 1)
        c.writeRecord(recordTypeChangeCipherSpec, []byte{1})

        finished := new(finishedMsg)
        finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)
        hs.finishedHash.Write(finished.marshal())

    hsStateInc(SERV_SEND_FINISHED, isResume, 1)
        c.writeRecord(recordTypeHandshake, finished.marshal())

        c.cipherSuite = hs.suite.id

        return nil
}</span>

// processCertsFromClient takes a chain of client certificates either from a
// Certificates message or from a sessionState and verifies them. It returns
// the public key of the leaf certificate.
func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (crypto.PublicKey, error) <span class="cov2" title="3">{
        c := hs.c

        hs.certsFromClient = certificates
        certs := make([]*x509.Certificate, len(certificates))
        var err error
        for i, asn1Data := range certificates </span><span class="cov2" title="2">{
                if certs[i], err = x509.ParseCertificate(asn1Data); err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        stateInc(ERR_PARSE_CLIENT_CERT, 1)
                        return nil, errors.New("tls: failed to parse client certificate: " + err.Error())
                }</span>
        }

        <span class="cov2" title="3">if c.config.ClientAuth &gt;= VerifyClientCertIfGiven &amp;&amp; len(certs) &gt; 0 </span><span class="cov0" title="0">{
                opts := x509.VerifyOptions{
                        Roots:         c.config.ClientCAs,
                        CurrentTime:   c.config.time(),
                        Intermediates: x509.NewCertPool(),
                        KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
                }

                for _, cert := range certs[1:] </span><span class="cov0" title="0">{
                        opts.Intermediates.AddCert(cert)
                }</span>

                <span class="cov0" title="0">chains, err := certs[0].Verify(opts)
                if err != nil </span><span class="cov0" title="0">{
                        c.sendAlert(alertBadCertificate)
                        stateInc(ERR_VERIFY_CLIENT_CERT, 1)
                        return nil, errors.New("tls: failed to verify client's certificate: " + err.Error())
                }</span>

                <span class="cov0" title="0">ok := false
                for _, ku := range certs[0].ExtKeyUsage </span><span class="cov0" title="0">{
                        if ku == x509.ExtKeyUsageClientAuth </span><span class="cov0" title="0">{
                                ok = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        c.sendAlert(alertHandshakeFailure)
                        stateInc(ERR_CLIENT_CERT_NOT_FOR_AUTH, 1)
                        return nil, errors.New("tls: client's certificate's extended key usage doesn't permit it to be used for client authentication")
                }</span>

                <span class="cov0" title="0">c.verifiedChains = chains</span>
        }

        <span class="cov2" title="3">if len(certs) &gt; 0 </span><span class="cov2" title="2">{
                var pub crypto.PublicKey
                switch key := certs[0].PublicKey.(type) </span>{
                <span class="cov2" title="2">case *ecdsa.PublicKey, *rsa.PublicKey:
                        pub = key</span>
                <span class="cov0" title="0">default:
                        c.sendAlert(alertUnsupportedCertificate)
                        stateInc(ERR_CLIENT_CERT_NOT_SUPPORT, 1)
                        return nil, fmt.Errorf("tls: client's certificate contains an unsupported public key of type %T", certs[0].PublicKey)</span>
                }
                <span class="cov2" title="2">c.peerCertificates = certs
                return pub, nil</span>
        }

        <span class="cov1" title="1">return nil, nil</span>
}

func (hs *serverHandshakeState) postHandshake() <span class="cov6" title="49">{
        if antiTlsDosEngine != nil </span><span class="cov0" title="0">{
                antiTlsDosEngine.LogHandshakeInfo(NewHandshakeInfo(hs))
        }</span>
}

// tryCipherSuite returns a cipherSuite with the given id if that cipher suite
// is acceptable to use.
func (c *Conn) tryCipherSuite(id uint16, supportedCipherSuites []uint16, version uint16, ellipticOk, ecdsaOk bool) *cipherSuite <span class="cov6" title="54">{
        for _, supported := range supportedCipherSuites </span><span class="cov10" title="448">{
                if id == supported </span><span class="cov6" title="45">{
                        var candidate *cipherSuite

                        for _, s := range cipherSuites </span><span class="cov9" title="341">{
                                if s.id == id </span><span class="cov6" title="45">{
                                        candidate = s
                                        break</span>
                                }
                        }
                        <span class="cov6" title="45">if candidate == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Don't select a ciphersuite which we can't
                        // support for this client.
                        <span class="cov6" title="45">if (candidate.flags&amp;suiteECDHE != 0) &amp;&amp; !ellipticOk </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov6" title="45">if (candidate.flags&amp;suiteECDSA != 0) != ecdsaOk </span><span class="cov2" title="3">{
                                continue</span>
                        }
                        <span class="cov6" title="42">if version &lt; VersionTLS12 &amp;&amp; candidate.flags&amp;suiteTLS12 != 0 </span><span class="cov2" title="2">{
                                continue</span>
                        }
                        <span class="cov6" title="40">stateInc(CipherSuiteText(id), 1)
                        return candidate</span>
                }
        }

        <span class="cov4" title="14">return nil</span>
}

//wrapper of tryCipherSuite for easy use out of this package
func TryCipherSuiteWrapper(id uint16, supportedList []uint16, handshakeState interface{}) interface{} <span class="cov1" title="1">{
        if hs, ok := handshakeState.(*serverHandshakeState); ok </span><span class="cov1" title="1">{
                c := hs.c
                if suite := c.tryCipherSuite(id, supportedList, c.vers, hs.ellipticOk, hs.ecdsaOk); suite != nil </span><span class="cov1" title="1">{
                        return suite
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func IsEcdheCipherSuite(suite interface{}) bool <span class="cov2" title="2">{
        if s, ok := suite.(*cipherSuite); ok </span><span class="cov2" title="2">{
                return (s.flags&amp;suiteECDHE) != 0
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file233" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/md5"
        "crypto/rsa"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/x509"
        "encoding/asn1"
        "errors"
        "io"
        "math/big"
)

var errClientKeyExchange = errors.New("tls: invalid ClientKeyExchange message")
var errServerKeyExchange = errors.New("tls: invalid ServerKeyExchange message")

// rsaKeyAgreement implements the standard TLS key agreement where the client
// encrypts the pre-master secret to the server's public key.
type rsaKeyAgreement struct{}

func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) <span class="cov7" title="22">{
        return nil, nil
}</span>

func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) <span class="cov7" title="21">{
        preMasterSecret := make([]byte, 48)
        _, err := io.ReadFull(config.rand(), preMasterSecret[2:])
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_SERVER_INTERNAL, 1)
                return nil, err
        }</span>

        <span class="cov7" title="21">if len(ckx.ciphertext) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>

        <span class="cov7" title="21">ciphertext := ckx.ciphertext
        if version != VersionSSL30 </span><span class="cov6" title="18">{
                ciphertextLen := int(ckx.ciphertext[0])&lt;&lt;8 | int(ckx.ciphertext[1])
                if ciphertextLen != len(ckx.ciphertext)-2 </span><span class="cov0" title="0">{
                        return nil, errClientKeyExchange
                }</span>
                <span class="cov6" title="18">ciphertext = ckx.ciphertext[2:]</span>
        }

        <span class="cov7" title="21">err = rsa.DecryptPKCS1v15SessionKey(config.rand(), cert.PrivateKey.(*rsa.PrivateKey), ciphertext, preMasterSecret)
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_DECRYPT_SESSION_KEY, 1)
                return nil, err
        }</span>
        // We don't check the version number in the premaster secret.  For one,
        // by checking it, we would leak information about the validity of the
        // encrypted pre-master secret. Secondly, it provides only a small
        // benefit against a downgrade attack and some implementations send the
        // wrong version anyway. See the discussion at the end of section
        // 7.4.7.1 of RFC 4346.
        <span class="cov7" title="21">return preMasterSecret, nil</span>
}

func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error <span class="cov0" title="0">{
        return errors.New("tls: unexpected ServerKeyExchange")
}</span>

func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) <span class="cov5" title="11">{
        preMasterSecret := make([]byte, 48)
        preMasterSecret[0] = byte(clientHello.vers &gt;&gt; 8)
        preMasterSecret[1] = byte(clientHello.vers)
        _, err := io.ReadFull(config.rand(), preMasterSecret[2:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="11">encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov5" title="11">ckx := new(clientKeyExchangeMsg)
        ckx.ciphertext = make([]byte, len(encrypted)+2)
        ckx.ciphertext[0] = byte(len(encrypted) &gt;&gt; 8)
        ckx.ciphertext[1] = byte(len(encrypted))
        copy(ckx.ciphertext[2:], encrypted)
        return preMasterSecret, ckx, nil</span>
}

// sha1Hash calculates a SHA1 hash over the given byte slices.
func sha1Hash(slices [][]byte) []byte <span class="cov5" title="9">{
        hsha1 := sha1.New()
        for _, slice := range slices </span><span class="cov7" title="27">{
                hsha1.Write(slice)
        }</span>
        <span class="cov5" title="9">return hsha1.Sum(nil)</span>
}

// md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the
// concatenation of an MD5 and SHA1 hash.
func md5SHA1Hash(slices [][]byte) []byte <span class="cov3" title="4">{
        md5sha1 := make([]byte, md5.Size+sha1.Size)
        hmd5 := md5.New()
        for _, slice := range slices </span><span class="cov6" title="12">{
                hmd5.Write(slice)
        }</span>
        <span class="cov3" title="4">copy(md5sha1, hmd5.Sum(nil))
        copy(md5sha1[md5.Size:], sha1Hash(slices))
        return md5sha1</span>
}

// sha256Hash implements TLS 1.2's hash function.
func sha256Hash(slices [][]byte) []byte <span class="cov6" title="17">{
        h := sha256.New()
        for _, slice := range slices </span><span class="cov9" title="51">{
                h.Write(slice)
        }</span>
        <span class="cov6" title="17">return h.Sum(nil)</span>
}

// hashForServerKeyExchange hashes the given slices and returns their digest
// and the identifier of the hash function used. The hashFunc argument is only
// used for &gt;= TLS 1.2 and precisely identifies the hash function to use.
func hashForServerKeyExchange(sigType, hashFunc uint8, version uint16, slices ...[]byte) ([]byte, crypto.Hash, error) <span class="cov7" title="26">{
        if version &gt;= VersionTLS12 </span><span class="cov6" title="17">{
                switch hashFunc </span>{
                <span class="cov6" title="17">case hashSHA256:
                        return sha256Hash(slices), crypto.SHA256, nil</span>
                <span class="cov0" title="0">case hashSHA1:
                        return sha1Hash(slices), crypto.SHA1, nil</span>
                <span class="cov0" title="0">default:
                        stateInc(ERR_UNKNOWN_HASH_FUNC, 1) 
                        return nil, crypto.Hash(0), errors.New("tls: unknown hash function used by peer")</span>
                }
        }
        <span class="cov5" title="9">if sigType == signatureECDSA </span><span class="cov4" title="5">{
                return sha1Hash(slices), crypto.SHA1, nil
        }</span>
        <span class="cov3" title="4">return md5SHA1Hash(slices), crypto.MD5SHA1, nil</span>
}

// pickTLS12HashForSignature returns a TLS 1.2 hash identifier for signing a
// ServerKeyExchange given the signature type being used and the client's
// advertised list of supported signature and hash combinations.
func pickTLS12HashForSignature(sigType uint8, clientSignatureAndHashes []signatureAndHash) (uint8, error) <span class="cov5" title="9">{
        if len(clientSignatureAndHashes) == 0 </span><span class="cov0" title="0">{
                // If the client didn't specify any signature_algorithms
                // extension then we can assume that it supports SHA1. See
                // http://tools.ietf.org/html/rfc5246#section-7.4.1.4.1
                return hashSHA1, nil
        }</span>

        <span class="cov5" title="9">for _, sigAndHash := range clientSignatureAndHashes </span><span class="cov8" title="49">{
                if sigAndHash.signature != sigType </span><span class="cov7" title="28">{
                        continue</span>
                }
                <span class="cov7" title="21">switch sigAndHash.hash </span>{
                <span class="cov5" title="9">case hashSHA1, hashSHA256:
                        return sigAndHash.hash, nil</span>
                }
        }

        <span class="cov0" title="0">stateInc(ERR_CLIENT_NOT_SUPPORT_COMMON_HASH_FUNC, 1) 
        return 0, errors.New("tls: client doesn't support any common hash functions")</span>
}

func curveForCurveID(id CurveID) (elliptic.Curve, bool) <span class="cov7" title="26">{
        switch id </span>{
        <span class="cov7" title="26">case CurveP256:
                return elliptic.P256(), true</span>
        <span class="cov0" title="0">case CurveP384:
                return elliptic.P384(), true</span>
        <span class="cov0" title="0">case CurveP521:
                return elliptic.P521(), true</span>
        <span class="cov0" title="0">default:
                return nil, false</span>
        }

}

// for call from outside
func CurveForCurveID(id CurveID) (elliptic.Curve, bool) <span class="cov0" title="0">{
   return curveForCurveID(id)
}</span>

// ecdheRSAKeyAgreement implements a TLS key agreement where the server
// generates a ephemeral EC public/private key pair and signs it. The
// pre-master secret is then calculated using ECDH. The signature may
// either be ECDSA or RSA.
type ecdheKeyAgreement struct {
        version    uint16
        sigType    uint8
        privateKey []byte
        curve      elliptic.Curve
        x, y       *big.Int
}

func (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) <span class="cov5" title="11">{
        var curveid CurveID
        preferredCurves := config.curvePreferences()

NextCandidate:
        for _, candidate := range preferredCurves </span><span class="cov5" title="11">{
                for _, c := range clientHello.supportedCurves </span><span class="cov10" title="80">{
                        if candidate == c </span><span class="cov5" title="11">{
                                curveid = c
                                break NextCandidate</span>
                        }
                }
        }

        <span class="cov5" title="11">if curveid == 0 </span><span class="cov0" title="0">{
                stateInc(ERR_OFFERED_CURVES_NOT_SUPPORT, 1)
                return nil, errors.New("tls: no supported elliptic curves offered")
        }</span>

        <span class="cov5" title="11">var ok bool
        if ka.curve, ok = curveForCurveID(curveid); !ok </span><span class="cov0" title="0">{
                stateInc(ERR_PREFERRED_CURVE_NOT_SUPPORT, 1)
                return nil, errors.New("tls: preferredCurves includes unsupported curve")
        }</span>

        <span class="cov5" title="11">var x, y *big.Int
        var err error
        ka.privateKey, x, y, err = elliptic.GenerateKey(ka.curve, config.rand())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="11">ecdhePublic := elliptic.Marshal(ka.curve, x, y)

        // http://tools.ietf.org/html/rfc4492#section-5.4
        serverECDHParams := make([]byte, 1+2+1+len(ecdhePublic))
        serverECDHParams[0] = 3 // named curve
        serverECDHParams[1] = byte(curveid &gt;&gt; 8)
        serverECDHParams[2] = byte(curveid)
        serverECDHParams[3] = byte(len(ecdhePublic))
        copy(serverECDHParams[4:], ecdhePublic)

        var tls12HashId uint8
        if ka.version &gt;= VersionTLS12 </span><span class="cov5" title="9">{
                if tls12HashId, err = pickTLS12HashForSignature(ka.sigType, clientHello.signatureAndHashes); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov5" title="11">digest, hashFunc, err := hashForServerKeyExchange(ka.sigType, tls12HashId, ka.version, clientHello.random, hello.random, serverECDHParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="11">var sig []byte
        switch ka.sigType </span>{
        <span class="cov3" title="3">case signatureECDSA:
                privKey, ok := cert.PrivateKey.(*ecdsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        stateInc(ERR_SERVER_WRONG_ECDSA_PRI_KEY, 1)
                        return nil, errors.New("ECDHE ECDSA requires an ECDSA server private key")
                }</span>
                <span class="cov3" title="3">r, s, err := ecdsa.Sign(config.rand(), privKey, digest)
                if err != nil </span><span class="cov0" title="0">{
                        stateInc(ERR_SIGN_ECDHE_PARAMS, 1)
                        return nil, errors.New("failed to sign ECDHE parameters: " + err.Error())
                }</span>
                <span class="cov3" title="3">sig, err = asn1.Marshal(ecdsaSignature{r, s})</span>
        <span class="cov5" title="8">case signatureRSA:
                privKey, ok := cert.PrivateKey.(*rsa.PrivateKey)
                if !ok </span><span class="cov0" title="0">{
                        stateInc(ERR_SERVER_WRONG_RSA_PRI_KEY, 1)
                        return nil, errors.New("ECDHE RSA requires a RSA server private key")
                }</span>
                <span class="cov5" title="8">sig, err = rsa.SignPKCS1v15(config.rand(), privKey, hashFunc, digest)
                if err != nil </span><span class="cov0" title="0">{
                        stateInc(ERR_SIGN_ECDHE_PARAMS, 1)
                        return nil, errors.New("failed to sign ECDHE parameters: " + err.Error())
                }</span>
        <span class="cov0" title="0">default:
                stateInc(ERR_UNKNOWN_ECDHE_SIGN_ALGOR, 1)
                return nil, errors.New("unknown ECDHE signature algorithm")</span>
        }

        <span class="cov5" title="11">skx := new(serverKeyExchangeMsg)
        sigAndHashLen := 0
        if ka.version &gt;= VersionTLS12 </span><span class="cov5" title="9">{
                sigAndHashLen = 2
        }</span>
        <span class="cov5" title="11">skx.key = make([]byte, len(serverECDHParams)+sigAndHashLen+2+len(sig))
        copy(skx.key, serverECDHParams)
        k := skx.key[len(serverECDHParams):]
        if ka.version &gt;= VersionTLS12 </span><span class="cov5" title="9">{
                k[0] = tls12HashId
                k[1] = ka.sigType
                k = k[2:]
        }</span>
        <span class="cov5" title="11">k[0] = byte(len(sig) &gt;&gt; 8)
        k[1] = byte(len(sig))
        copy(k[2:], sig)

        return skx, nil</span>
}

func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) <span class="cov5" title="11">{
        if len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>
        <span class="cov5" title="11">x, y := elliptic.Unmarshal(ka.curve, ckx.ciphertext[1:])
        if x == nil </span><span class="cov0" title="0">{
                return nil, errClientKeyExchange
        }</span>
        <span class="cov5" title="11">x, _ = ka.curve.ScalarMult(x, y, ka.privateKey)
        preMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)&gt;&gt;3)
        xBytes := x.Bytes()
        copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)

        return preMasterSecret, nil</span>
}

func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error <span class="cov6" title="15">{
        if len(skx.key) &lt; 4 </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov6" title="15">if skx.key[0] != 3 </span><span class="cov0" title="0">{ // named curve
                return errors.New("tls: server selected unsupported curve")
        }</span>
        <span class="cov6" title="15">curveid := CurveID(skx.key[1])&lt;&lt;8 | CurveID(skx.key[2])

        var ok bool
        if ka.curve, ok = curveForCurveID(curveid); !ok </span><span class="cov0" title="0">{
                return errors.New("tls: server selected unsupported curve")
        }</span>

        <span class="cov6" title="15">publicLen := int(skx.key[3])
        if publicLen+4 &gt; len(skx.key) </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov6" title="15">ka.x, ka.y = elliptic.Unmarshal(ka.curve, skx.key[4:4+publicLen])
        if ka.x == nil </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov6" title="15">serverECDHParams := skx.key[:4+publicLen]

        sig := skx.key[4+publicLen:]
        if len(sig) &lt; 2 </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>

        <span class="cov6" title="15">var tls12HashId uint8
        if ka.version &gt;= VersionTLS12 </span><span class="cov5" title="8">{
                // handle SignatureAndHashAlgorithm
                var sigAndHash []uint8
                sigAndHash, sig = sig[:2], sig[2:]
                if sigAndHash[1] != ka.sigType </span><span class="cov0" title="0">{
                        return errServerKeyExchange
                }</span>
                <span class="cov5" title="8">tls12HashId = sigAndHash[0]
                if len(sig) &lt; 2 </span><span class="cov0" title="0">{
                        return errServerKeyExchange
                }</span>
        }
        <span class="cov6" title="15">sigLen := int(sig[0])&lt;&lt;8 | int(sig[1])
        if sigLen+2 != len(sig) </span><span class="cov0" title="0">{
                return errServerKeyExchange
        }</span>
        <span class="cov6" title="15">sig = sig[2:]

        digest, hashFunc, err := hashForServerKeyExchange(ka.sigType, tls12HashId, ka.version, clientHello.random, serverHello.random, serverECDHParams)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="15">switch ka.sigType </span>{
        <span class="cov5" title="8">case signatureECDSA:
                pubKey, ok := cert.PublicKey.(*ecdsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("ECDHE ECDSA requires a ECDSA server public key")
                }</span>
                <span class="cov5" title="8">ecdsaSig := new(ecdsaSignature)
                if _, err := asn1.Unmarshal(sig, ecdsaSig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="8">if ecdsaSig.R.Sign() &lt;= 0 || ecdsaSig.S.Sign() &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("ECDSA signature contained zero or negative values")
                }</span>
                <span class="cov5" title="8">if !ecdsa.Verify(pubKey, digest, ecdsaSig.R, ecdsaSig.S) </span><span class="cov0" title="0">{
                        return errors.New("ECDSA verification failure")
                }</span>
        <span class="cov4" title="7">case signatureRSA:
                pubKey, ok := cert.PublicKey.(*rsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("ECDHE RSA requires a RSA server public key")
                }</span>
                <span class="cov4" title="7">if err := rsa.VerifyPKCS1v15(pubKey, hashFunc, digest, sig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        <span class="cov0" title="0">default:
                return errors.New("unknown ECDHE signature algorithm")</span>
        }

        <span class="cov6" title="15">return nil</span>
}

func (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) <span class="cov6" title="15">{
        if ka.curve == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("missing ServerKeyExchange message")
        }</span>
        <span class="cov6" title="15">priv, mx, my, err := elliptic.GenerateKey(ka.curve, config.rand())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="15">x, _ := ka.curve.ScalarMult(ka.x, ka.y, priv)
        preMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)&gt;&gt;3)
        xBytes := x.Bytes()
        copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)

        serialized := elliptic.Marshal(ka.curve, mx, my)

        ckx := new(clientKeyExchangeMsg)
        ckx.ciphertext = make([]byte, 1+len(serialized))
        ckx.ciphertext[0] = byte(len(serialized))
        copy(ckx.ciphertext[1:], serialized)

        return preMasterSecret, ckx, nil</span>
}
</pre>
		
		<pre class="file" id="file234" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "crypto"
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "hash"
)

// Split a premaster secret in two as specified in RFC 4346, section 5.
func splitPreMasterSecret(secret []byte) (s1, s2 []byte) <span class="cov5" title="95">{
        s1 = secret[0 : (len(secret)+1)/2]
        s2 = secret[len(secret)/2:]
        return
}</span>

// pHash implements the P_hash function, as defined in RFC 4346, section 5.
func pHash(result, secret, seed []byte, hash func() hash.Hash) <span class="cov7" title="337">{
        h := hmac.New(hash, secret)
        h.Write(seed)
        a := h.Sum(nil)

        j := 0
        for j &lt; len(result) </span><span class="cov8" title="777">{
                h.Reset()
                h.Write(a)
                h.Write(seed)
                b := h.Sum(nil)
                todo := len(b)
                if j+todo &gt; len(result) </span><span class="cov7" title="313">{
                        todo = len(result) - j
                }</span>
                <span class="cov8" title="777">copy(result[j:j+todo], b)
                j += todo

                h.Reset()
                h.Write(a)
                a = h.Sum(nil)</span>
        }
}

// prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, section 5.
func prf10(result, secret, label, seed []byte) <span class="cov5" title="90">{
        hashSHA1 := sha1.New
        hashMD5 := md5.New

        labelAndSeed := make([]byte, len(label)+len(seed))
        copy(labelAndSeed, label)
        copy(labelAndSeed[len(label):], seed)

        s1, s2 := splitPreMasterSecret(secret)
        pHash(result, s1, labelAndSeed, hashMD5)
        result2 := make([]byte, len(result))
        pHash(result2, s2, labelAndSeed, hashSHA1)

        for i, b := range result2 </span><span class="cov10" title="3768">{
                result[i] ^= b
        }</span>
}

// prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, section 5.
func prf12(result, secret, label, seed []byte) <span class="cov6" title="157">{
        labelAndSeed := make([]byte, len(label)+len(seed))
        copy(labelAndSeed, label)
        copy(labelAndSeed[len(label):], seed)

        pHash(result, secret, labelAndSeed, sha256.New)
}</span>

// prf30 implements the SSL 3.0 pseudo-random function, as defined in
// www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 6.
func prf30(result, secret, label, seed []byte) <span class="cov3" title="8">{
        hashSHA1 := sha1.New()
        hashMD5 := md5.New()

        done := 0
        i := 0
        // RFC5246 section 6.3 says that the largest PRF output needed is 128
        // bytes. Since no more ciphersuites will be added to SSLv3, this will
        // remain true. Each iteration gives us 16 bytes so 10 iterations will
        // be sufficient.
        var b [11]byte
        for done &lt; len(result) </span><span class="cov4" title="36">{
                for j := 0; j &lt;= i; j++ </span><span class="cov6" title="110">{
                        b[j] = 'A' + byte(i)
                }</span>

                <span class="cov4" title="36">hashSHA1.Reset()
                hashSHA1.Write(b[:i+1])
                hashSHA1.Write(secret)
                hashSHA1.Write(seed)
                digest := hashSHA1.Sum(nil)

                hashMD5.Reset()
                hashMD5.Write(secret)
                hashMD5.Write(digest)

                done += copy(result[done:], hashMD5.Sum(nil))
                i++</span>
        }
}

const (
        tlsRandomLength      = 32 // Length of a random nonce in TLS 1.1.
        masterSecretLength   = 48 // Length of a master secret in TLS 1.1.
        finishedVerifyLength = 12 // Length of verify_data in a Finished message.
)

var masterSecretLabel = []byte("master secret")
var keyExpansionLabel = []byte("key expansion")
var clientFinishedLabel = []byte("client finished")
var serverFinishedLabel = []byte("server finished")

func prfForVersion(version uint16) func(result, secret, label, seed []byte) <span class="cov6" title="131">{
        switch version </span>{
        <span class="cov3" title="8">case VersionSSL30:
                return prf30</span>
        <span class="cov5" title="48">case VersionTLS10, VersionTLS11:
                return prf10</span>
        <span class="cov5" title="75">case VersionTLS12:
                return prf12</span>
        <span class="cov0" title="0">default:
                panic("unknown version")</span>
        }
}

// masterFromPreMasterSecret generates the master secret from the pre-master
// secret. See http://tools.ietf.org/html/rfc5246#section-8.1
func masterFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serverRandom []byte) []byte <span class="cov5" title="62">{
        var seed [tlsRandomLength * 2]byte
        copy(seed[0:len(clientRandom)], clientRandom)
        copy(seed[len(clientRandom):], serverRandom)
        masterSecret := make([]byte, masterSecretLength)
        prfForVersion(version)(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])
        return masterSecret
}</span>

// keysFromMasterSecret generates the connection keys from the master
// secret, given the lengths of the MAC key, cipher key and IV, as defined in
// RFC 2246, section 6.3.
func keysFromMasterSecret(version uint16, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) <span class="cov5" title="69">{
        var seed [tlsRandomLength * 2]byte
        copy(seed[0:len(clientRandom)], serverRandom)
        copy(seed[len(serverRandom):], clientRandom)

        n := 2*macLen + 2*keyLen + 2*ivLen
        keyMaterial := make([]byte, n)
        prfForVersion(version)(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])
        clientMAC = keyMaterial[:macLen]
        keyMaterial = keyMaterial[macLen:]
        serverMAC = keyMaterial[:macLen]
        keyMaterial = keyMaterial[macLen:]
        clientKey = keyMaterial[:keyLen]
        keyMaterial = keyMaterial[keyLen:]
        serverKey = keyMaterial[:keyLen]
        keyMaterial = keyMaterial[keyLen:]
        clientIV = keyMaterial[:ivLen]
        keyMaterial = keyMaterial[ivLen:]
        serverIV = keyMaterial[:ivLen]
        return
}</span>

func newFinishedHash(version uint16) finishedHash <span class="cov5" title="69">{
        if version &gt;= VersionTLS12 </span><span class="cov5" title="41">{
                return finishedHash{sha256.New(), sha256.New(), nil, nil, version}
        }</span>
        <span class="cov4" title="28">return finishedHash{sha1.New(), sha1.New(), md5.New(), md5.New(), version}</span>
}

// A finishedHash calculates the hash of a set of handshake messages suitable
// for including in a Finished message.
type finishedHash struct {
        client hash.Hash
        server hash.Hash

        // Prior to TLS 1.2, an additional MD5 hash is required.
        clientMD5 hash.Hash
        serverMD5 hash.Hash

        version uint16
}

func (h finishedHash) Write(msg []byte) (n int, err error) <span class="cov7" title="509">{
        h.client.Write(msg)
        h.server.Write(msg)

        if h.version &lt; VersionTLS12 </span><span class="cov6" title="196">{
                h.clientMD5.Write(msg)
                h.serverMD5.Write(msg)
        }</span>
        <span class="cov7" title="509">return len(msg), nil</span>
}

// finishedSum30 calculates the contents of the verify_data member of a SSLv3
// Finished message given the MD5 and SHA1 hashes of a set of handshake
// messages.
func finishedSum30(md5, sha1 hash.Hash, masterSecret []byte, magic [4]byte) []byte <span class="cov2" title="6">{
        md5.Write(magic[:])
        md5.Write(masterSecret)
        md5.Write(ssl30Pad1[:])
        md5Digest := md5.Sum(nil)

        md5.Reset()
        md5.Write(masterSecret)
        md5.Write(ssl30Pad2[:])
        md5.Write(md5Digest)
        md5Digest = md5.Sum(nil)

        sha1.Write(magic[:])
        sha1.Write(masterSecret)
        sha1.Write(ssl30Pad1[:40])
        sha1Digest := sha1.Sum(nil)

        sha1.Reset()
        sha1.Write(masterSecret)
        sha1.Write(ssl30Pad2[:40])
        sha1.Write(sha1Digest)
        sha1Digest = sha1.Sum(nil)

        ret := make([]byte, len(md5Digest)+len(sha1Digest))
        copy(ret, md5Digest)
        copy(ret[len(md5Digest):], sha1Digest)
        return ret
}</span>

var ssl3ClientFinishedMagic = [4]byte{0x43, 0x4c, 0x4e, 0x54}
var ssl3ServerFinishedMagic = [4]byte{0x53, 0x52, 0x56, 0x52}

// clientSum returns the contents of the verify_data member of a client's
// Finished message.
func (h finishedHash) clientSum(masterSecret []byte) []byte <span class="cov5" title="65">{
        if h.version == VersionSSL30 </span><span class="cov2" title="3">{
                return finishedSum30(h.clientMD5, h.client, masterSecret, ssl3ClientFinishedMagic)
        }</span>

        <span class="cov5" title="62">out := make([]byte, finishedVerifyLength)
        if h.version &gt;= VersionTLS12 </span><span class="cov5" title="41">{
                seed := h.client.Sum(nil)
                prf12(out, masterSecret, clientFinishedLabel, seed)
        }</span> <span class="cov4" title="21">else {
                seed := make([]byte, 0, md5.Size+sha1.Size)
                seed = h.clientMD5.Sum(seed)
                seed = h.client.Sum(seed)
                prf10(out, masterSecret, clientFinishedLabel, seed)
        }</span>
        <span class="cov5" title="62">return out</span>
}

// serverSum returns the contents of the verify_data member of a server's
// Finished message.
func (h finishedHash) serverSum(masterSecret []byte) []byte <span class="cov5" title="65">{
        if h.version == VersionSSL30 </span><span class="cov2" title="3">{
                return finishedSum30(h.serverMD5, h.server, masterSecret, ssl3ServerFinishedMagic)
        }</span>

        <span class="cov5" title="62">out := make([]byte, finishedVerifyLength)
        if h.version &gt;= VersionTLS12 </span><span class="cov5" title="41">{
                seed := h.server.Sum(nil)
                prf12(out, masterSecret, serverFinishedLabel, seed)
        }</span> <span class="cov4" title="21">else {
                seed := make([]byte, 0, md5.Size+sha1.Size)
                seed = h.serverMD5.Sum(seed)
                seed = h.server.Sum(seed)
                prf10(out, masterSecret, serverFinishedLabel, seed)
        }</span>
        <span class="cov5" title="62">return out</span>
}

// hashForClientCertificate returns a digest, hash function, and TLS 1.2 hash
// id suitable for signing by a TLS client certificate.
func (h finishedHash) hashForClientCertificate(sigType uint8) ([]byte, crypto.Hash, uint8) <span class="cov3" title="10">{
        if h.version &gt;= VersionTLS12 </span><span class="cov2" title="6">{
                digest := h.server.Sum(nil)
                return digest, crypto.SHA256, hashSHA256
        }</span>
        <span class="cov2" title="4">if sigType == signatureECDSA </span><span class="cov1" title="2">{
                digest := h.server.Sum(nil)
                return digest, crypto.SHA1, hashSHA1
        }</span>

        <span class="cov1" title="2">digest := make([]byte, 0, 36)
        digest = h.serverMD5.Sum(digest)
        digest = h.server.Sum(digest)
        return digest, crypto.MD5SHA1, 0</span> /* not specified in TLS 1.2. */
}
</pre>
		
		<pre class="file" id="file235" style="display: none">/* sslkey_decrypt.go - get ssl key from decrypted file */
/*
modification history
--------------------
2015/7/10, by Weiwei Zhang, create
*/
/*
*/
package bfe_tls 

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/hmac"
    "crypto/rc4"
    "crypto/sha256"
    "crypto/sha512"
    "errors"
    "io/ioutil"
)

const (
    PASSWD_BOOK_SIZE        = 65536 //64k
)

// length of keys
const (
    AES_CBC_KEY_LEN     = 32
    AES_CBC_IV_LEN      = 16
    RC4_KEY_LEN         = 16
    AES_GCM_KEY_LEN     = 32
    AES_GCM_IV_LEN      = 12
    AES_GCM_AAD_LEN     = 16
    AES_GCM_TAG_LEN     = 16
)

//special strings used by encryption and decryption
const (
    MAX_STRING_NUM = 18
)

// strings for generating hash value
var hashStrings = [MAX_STRING_NUM]string {
    "What's in a name? That which we call a rose by any other name would smell as sweet.",
    "If they throw stones at you, do not throw back,",
    "use them to build your own foundation instead.",
    "\x34\x73\xde\x72\x8a\xf1\x2e\xab\xd7\xb1\x10\x21\x41\x01\x2a",
    "There is but one step from the sublime to the ridiculous.",
    "Important principles may and must be flexible.",
    "That is the essence of science: ask an impertinent question,",
    "and you are on the way to the pertinent answer.",
    "The Golden Rule is that there are no golden rules.",
    "Even the weariest river winds somewhere safe to sea.",
    "Sometimes the most urgent and vital thing you can possibly do is take a complete rest.",
    "There is no royal road to learning",
    "There is but one step from the sublime to the ridiculous.",
    "The danger of the past was that men became slaves.",
    "The danger of the future is that men may become robots.",
    "To be or not to be: that is a question",
    "It is our choices that show what we truly are, far more than our abilities.",
    "Give everything a shot. You never know what (or who) is going to change your life.",
}

// pkcs5 unpadding function
func pkcs5UnPadding(src []byte) []byte <span class="cov1" title="1">{
    length := len(src)
    unpadding := int(src[length-1])
    return src[:(length - unpadding)]
}</span>

// RC4 decryption function
func decryptRc4(src, key []byte) ([]byte, error) <span class="cov1" title="1">{
    rc4Cipher, err := rc4.NewCipher(key)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">dst := make([]byte, len(src))
    rc4Cipher.XORKeyStream(dst, src)
    return dst, nil</span>
}

// AES CBC mode decryption function
// Make sure that src data must be padded,
// and the src length is integral multiple of AES block size
func decryptAesCbc(src, key, iv []byte) ([]byte, error) <span class="cov1" title="1">{
    aesBlockDecrypter, err := aes.NewCipher([]byte(key))
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">dst := make([]byte, len(src))
    aesDecrypter := cipher.NewCBCDecrypter(aesBlockDecrypter, iv)
    aesDecrypter.CryptBlocks(dst, src)
    return dst, nil</span>
}

// AES CBC mode decryption function
func decryptAesGcm(src, key, iv, aad []byte) ([]byte, error) <span class="cov1" title="1">{
    aesBlockDecrypter, err := aes.NewCipher(key)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">decryptAead, err := cipher.NewGCM(aesBlockDecrypter)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">dst := make([]byte, len(src))
    dst, err = decryptAead.Open(nil, iv, src, aad)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov1" title="1">return dst, nil</span>
}

// get AES CBC key from password book
func getAesCbcKey(passwdBook, strHash1, strHash2, cbcKey []byte) <span class="cov1" title="1">{
    var i = int(0)
    var j = int(0)
    var index = int(0)
    var tmp_ptr = strHash1

    for j = 0; i &lt; AES_CBC_KEY_LEN &amp;&amp; j &lt; sha256.Size; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        cbcKey[i] = passwdBook[index]
        j += 2
    }</span>
    <span class="cov1" title="1">tmp_ptr = strHash2
    for j = 0; i &lt; AES_CBC_KEY_LEN &amp;&amp; j &lt; sha256.Size; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        cbcKey[i] = passwdBook[index]
        j += 2
    }</span>
}

// get AES CBC IV from password book
func getAesCbcIV(passwdBook, strHash, cbcIV []byte) <span class="cov1" title="1">{
    var i = int(0)
    var j = int(0)
    var index = int(0)
    var tmp_ptr = strHash

    for j = 0; i &lt; AES_CBC_IV_LEN &amp;&amp; j &lt; sha256.Size; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        cbcIV[i] = passwdBook[index]
        j += 2
    }</span>
}

// get RC4 key from password book
func getRc4Key(passwdBook, strHash, rc4Key []byte) <span class="cov1" title="1">{
    var i = int(0)
    var j = int(0)
    var index = int(0)
    var tmp_ptr = strHash

    for j = 0; i &lt; RC4_KEY_LEN &amp;&amp; j &lt; sha256.Size; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        rc4Key[i] = passwdBook[index]
        j += 2
    }</span>
}

// get AES GCM key from password book
func getAesGcmKey(passwdBook, strHash, hmacHash, gcmKey []byte) <span class="cov1" title="1">{
    var i = int(0)
    var j = int(0)
    var index = int(0)
    var tmp_ptr = strHash

    for j = 0; i &lt; AES_GCM_KEY_LEN &amp;&amp; j &lt; sha256.Size; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        gcmKey[i] = passwdBook[index]
        j += 2
    }</span>
    <span class="cov1" title="1">tmp_ptr = hmacHash
    for j = 0; i &lt; AES_GCM_KEY_LEN &amp;&amp; j &lt; sha512.Size; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        gcmKey[i] = passwdBook[index]
        j += 2
    }</span>
}

// get AES GCM IV from password book
func getAesGcmIV(passwdBook, hmacHash, gcmIV []byte) <span class="cov1" title="1">{
    var i = int(0)
    var j = int(0)
    var index = int(0)
    var tmp_ptr = hmacHash

    for j = 0; i &lt; AES_GCM_IV_LEN; i++ </span><span class="cov9" title="12">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        gcmIV[i] = passwdBook[index]
        j += 2
    }</span>
}

// get AES GCM AAD from password book
func getAesGcmAad(passwdBook, hmacHash, gcmAad []byte) <span class="cov1" title="1">{
    var i = int(0)
    var j = int(0)
    var index = int(0)
    var tmp_ptr = hmacHash

    for j = 0; i &lt; AES_GCM_AAD_LEN &amp;&amp; j &lt; sha512.Size / 2; i++ </span><span class="cov10" title="16">{
        index = int(tmp_ptr[j]) * 256 + int(tmp_ptr[j+1])
        gcmAad[i] = passwdBook[index]
        j += 2
    }</span>
}

// get all encryption/decryption keys from password book
func getKeysFromPasswdBook(passwdBook, cbcKey, cbcIV, rc4Key, gcmKey, gcmIV, gcmAad []byte) error <span class="cov1" title="1">{
    var string_hash [MAX_STRING_NUM][128]byte
    var hmac1Hash, hmac2Hash [64]byte

    for i := 0; i &lt; 15; i++ </span><span class="cov9" title="15">{
        sha256Hash := sha256.New()
        sha256Hash.Write([]byte(hashStrings[i]))
        copy(string_hash[i][:], sha256Hash.Sum(nil))
    }</span>

    <span class="cov1" title="1">hmac1 := hmac.New(sha512.New, string_hash[0][:])
    hmac1.Write([]byte(hashStrings[16]))
    copy(hmac1Hash[:], hmac1.Sum(nil))

    hmac2 := hmac.New(sha512.New, hmac1Hash[:])
    hmac2.Write([]byte(hashStrings[17]))
    copy(hmac2Hash[:], hmac2.Sum(nil))

    getAesCbcKey(passwdBook, string_hash[2][:], string_hash[3][:], cbcKey)
    getAesCbcIV(passwdBook, string_hash[5][:], cbcIV)
    getRc4Key(passwdBook, string_hash[8][:], rc4Key)
    getAesGcmKey(passwdBook, string_hash[13][:], hmac1Hash[:], gcmKey)
    getAesGcmIV(passwdBook, hmac2Hash[:32], gcmIV)
    getAesGcmAad(passwdBook, hmac2Hash[32:], gcmAad)

    return nil</span>
}

func decryptSslKey(verStr string, cipherText []byte) ([]byte, error) <span class="cov1" title="1">{
    gcmIV := make([]byte, AES_GCM_IV_LEN)
    cbcIV := make([]byte, AES_CBC_IV_LEN)
    gcmAad := make([]byte, AES_GCM_AAD_LEN)
    rc4Key := make([]byte, RC4_KEY_LEN)
    gcmKey := make([]byte, AES_GCM_KEY_LEN)
    cbcKey := make([]byte, AES_CBC_KEY_LEN)

    switch verStr </span>{
    <span class="cov1" title="1">default:
        var cipherLen = int(cipherText[0]) * 256 + int(cipherText[1])
        if len(cipherText) != 2 + cipherLen + PASSWD_BOOK_SIZE </span><span class="cov0" title="0">{
            return nil, errors.New("tls.decryptSslKey: cipher text not correct")
        }</span>

        <span class="cov1" title="1">err := getKeysFromPasswdBook(cipherText[2+cipherLen:], cbcKey, cbcIV, rc4Key, gcmKey, gcmIV, gcmAad)
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>

        // Decrypt and return the key 
        <span class="cov1" title="1">decAesGcm, err := decryptAesGcm(cipherText[2:2+cipherLen], []byte(gcmKey), gcmIV, gcmAad)
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
        <span class="cov1" title="1">decRc4, err := decryptRc4(decAesGcm, []byte(rc4Key))
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
        <span class="cov1" title="1">decAesCbc, err := decryptAesCbc(decRc4, []byte(cbcKey), cbcIV)
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
        <span class="cov1" title="1">decAesCbc = pkcs5UnPadding(decAesCbc)
        return decAesCbc, nil</span>
    }
}

/* DecryptSslKeyFile - decrypt the encrypted ssl key file and return key contents
 *
 * Params:
 *     - cipherFile: ssl key cipher file
 *
 * Return:
 *     - ssl key contents
 *     - error
 */
func DecryptSslKeyFile(cipherFile string) ([]byte, error) <span class="cov1" title="1">{
    // cipher file contains:
    // (1) version length (1 byte)
    // (2) version string 
    // (3) cipher length (2 byte)
    // (4) cipher text
    // (5) password book (the last 64k)
    cipherText, err := ioutil.ReadFile(cipherFile)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // check length of cipher text
    // must not less than (1+2+PASSWD_BOOK_SIZE)
    <span class="cov1" title="1">if len(cipherText) &lt; 3 + PASSWD_BOOK_SIZE </span><span class="cov0" title="0">{
        return nil, errors.New("tls.DecryptSslKeyFile: cipher file not complete")
    }</span>

    <span class="cov1" title="1">var verLen = int(cipherText[0])
    return decryptSslKey(string(cipherText[1:1+verLen]), cipherText[1+verLen:])</span>
}
</pre>
		
		<pre class="file" id="file236" style="display: none">/* state.go - for monitor internal state of tls */
/*
modification history
--------------------
2015/4/24, by Sijie Yang, create
*/
/*
DESCRIPTION
*/
package bfe_tls

import (
    "fmt"
)

// tls errors
const (
        // tls
        ERR_WRONG_LISTENER_TYPE           = "TLS_ERR_WRONG_LISTENER_TYPE"
        ERR_MODIFY_CONFIG_IN_USE          = "TLS_ERR_MODIFY_CONFIG_IN_USE"
        ERR_NO_CERT_IN_CONFIG             = "TLS_ERR_NO_CERT_IN_CONFIG"
        ERR_DECODE_CERT_IN_PEM            = "TLS_ERR_DECODE_CERT_IN_PEM"
        ERR_DECODE_KEY_IN_PEM             = "TLS_ERR_DECODE_KEY_IN_PEM"
        ERR_PARSE_CERT                    = "TLS_ERR_PARSE_CERT"
        ERR_PARSE_PRI_KEY                 = "TLS_ERR_PARSE_PRI_KEY"
        ERR_KEY_TYPE_NOT_MATCH            = "TLS_ERR_KEY_TYPE_NOT_MATCH"
        ERR_KEY_NOT_MATCH                 = "TLS_ERR_KEY_NOT_MATCH"
        ERR_UNKNOWN_PUB_KEY_ALGOR         = "TLS_ERR_UNKNOWN_PUB_KEY_ALGOR"
        ERR_UNKNOWN_PRI_KEY_TYPE_IN_PKCS8 = "TLS_ERR_UNKNOWN_PRI_KEY_TYPE_IN_PKCS8"
        ERR_ALERT_HANDSHAKE_FAILURE       = "TLS_ERR_ALERT_HANDSHAKE_FAILURE"
    ERR_TLS_FALLBACK_SCSV             = "TLS_FALLBACK_SCSV_ALERT"
    ERR_KEY_DECRYPT_FAIL              = "TLS_ERR_KEY_DECRYPT_FAIL"

        // conn
        ERR_UNKNOWN_RECORD_TYPE                  = "TLS_ERR_UNKNOWN_RECORD_TYPE"
        ERR_WRONG_RECORD_TYPE_AFTER_HS_COMPLETE  = "TLS_ERR_WRONG_RECORD_TYPE_AFTER_HS_COMPLETE"
        ERR_WRONG_RECORD_TYPE_BEFORE_HS_COMPLETE = "TLS_ERR_WRONG_RECORD_TYPE_BEFORE_HS_COMPLETE"
        ERR_SSLV2_NOT_SUPPORT                    = "TLS_ERR_SSLV2_NOT_SUPPORT"
        ERR_VERSION_NOT_EXPECTED                 = "TLS_ERR_VERSION_NOT_EXPECTED"
        ERR_RECORD_OVERFLOW                      = "TLS_ERR_RECORD_OVERFLOW"
        ERR_UNEXPECTED_MESSAGE                   = "TLS_ERR_UNEXPECTED_MESSAGE"
        ERR_UNEXPECTED_EOF                       = "TLS_ERR_UNEXPECTED_EOF"
        ERR_SERVER_SHOULD_NOT_VERIFY_HOSTNAME    = "TLS_ERR_SERVER_SHOULD_NOT_VERIFY_HOSTNAME"
        ERR_CLIENT_HANDSHAKE_NOT_PERFORMED       = "TLS_ERR_CLIENT_HANDSHAKE_NOT_PERFORMED"

        ERR_ALERT_RECORD_OVERFLOW    = "TLS_ERR_ALERT_RECORD_OVERFLOW"
        ERR_ALERT_UNEXPECTED_MESSAGE = "TLS_ERR_ALERT_UNEXPECTED_MESSAGE"
        ERR_ALERT_NO_RENEGOTIATION   = "TLS_ERR_ALERT_NO_RENEGOTIATION"
        ERR_ALERT_CLOSE_NOTIFY       = "TLS_ERR_ALERT_CLOSE_NOTIFY"
        ERR_ALERT_INTERNAL_ERROR     = "TLS_ERR_ALERT_INTERNAL_ERROR"

        // key_agreement
        ERR_CLIENT_KEY_EXCHANGE                 = "TLS_ERR_CLIENT_KEY_EXCHANGE"
        ERR_SERVER_KEY_EXCHANGE                 = "TLS_ERR_SERVER_KEY_EXCHANGE"
        ERR_SERVER_INTERNAL                     = "TLS_ERR_SERVER_INTERNAL"
        ERR_DECRYPT_SESSION_KEY                 = "TLS_ERR_DECRYPT_SESSION_KEY"
        ERR_UNKNOWN_HASH_FUNC                   = "TLS_ERR_UNKNOWN_HASH_FUNC"
        ERR_CLIENT_NOT_SUPPORT_COMMON_HASH_FUNC = "TLS_ERR_CLIENT_NOT_SUPPORT_COMMON_HASH_FUNC"
        ERR_OFFERED_CURVES_NOT_SUPPORT          = "TLS_ERR_OFFERED_CURVES_NOT_SUPPORT"
        ERR_PREFERRED_CURVE_NOT_SUPPORT         = "TLS_ERR_PREFERRED_CURVE_NOT_SUPPORT"
        ERR_SERVER_WRONG_ECDSA_PRI_KEY          = "TLS_ERR_SERVER_WRONG_ECDSA_PRI_KEY"
        ERR_SIGN_ECDHE_PARAMS                   = "TLS_ERR_SIGN_ECDHE_PARAMS"
        ERR_SERVER_WRONG_RSA_PRI_KEY            = "TLS_ERR_SERVER_WRONG_RSA_PRI_KEY"
        ERR_UNKNOWN_ECDHE_SIGN_ALGOR            = "TLS_ERR_UNKNOWN_ECDHE_SIGN_ALGOR"

        // handshake_server
        ERR_CLIENT_VERSION_NOT_SUPPORT         = "TLS_ERR_CLIENT_VERSION_NOT_SUPPORT"
        ERR_CLIENT_NOT_SUPPORT_UNCOMPRESS_CONN = "TLS_ERR_CLIENT_NOT_SUPPORT_UNCOMPRESS_CONN"
        ERR_NO_CERT_CONFIGURED                 = "TLS_ERR_NO_CERT_CONFIGURED"
        ERR_NO_SHARED_CIPHER_SUITE             = "TLS_ERR_NO_SHARED_CIPHER_SUITE"
        ERR_CLIENT_CERT_NOT_PROVIDE            = "TLS_ERR_CLIENT_CERT_NOT_PROVIDE"
        ERR_WRONG_ECDSA_SIGNATURE              = "TLS_ERR_WRONG_ECDSA_SIGNATURE"
        ERR_ECDSA_VERIFY_FAILURE               = "TLS_ERR_ECDSA_VERIFY_FAILURE"
        ERR_BAD_CERT                           = "TLS_ERR_BAD_CERT"
        ERR_WRONG_CLIENT_FINISH_MSG            = "TLS_ERR_WRONG_CLIENT_FINISH_MSG"
        ERR_PARSE_CLIENT_CERT                  = "TLS_ERR_PARSE_CLIENT_CERT"
        ERR_VERIFY_CLIENT_CERT                 = "TLS_ERR_VERIFY_CLIENT_CERT"
        ERR_CLIENT_CERT_NOT_FOR_AUTH           = "TLS_ERR_CLIENT_CERT_NOT_FOR_AUTH"
        ERR_CLIENT_CERT_NOT_SUPPORT            = "TLS_ERR_CLIENT_CERT_NOT_SUPPORT"
        ERR_REJECT_CONN_CLIENTHELLO_RANDOM     = "TLS_ERR_REJECT_CONN_CLIENTHELLO_RANDOM"

        // ticket
    ERR_ENC_TICKET_WHEN_INIT_IV            = "TLS_ERR_ENC_TICKET_WHEN_INIT_IV"
    ERR_ENC_TICKET_WHEN_CREATE_CIPHER      = "TLS_ERR_ENC_TICKET_WHEN_CREATE_CIPHER"
    ERR_DEC_TICKET_WRONG_SIZE              = "TLS_ERR_DEC_TICKET_WRONG_SIZE"
    ERR_DEC_TICKET_WRONG_MAC               = "TLS_ERR_DEC_TICKET_WRONG_MAC"
    ERR_DEC_TICKET_WHEN_NEW_CIPHER         = "TLS_ERR_DEC_TICKET_WHEN_NEW_CIPHER"
    ERR_DEC_TICKET_WRONG_CIPHER_SIZE       = "TLS_ERR_DEC_TICKET_WRONG_CIPHER_SIZE"
    ERR_SESSION_STATE_TOO_SMALL            = "TLS_ERR_SESSION_STATE_TOO_SMALL"
    ERR_SESSION_STATE_TOO_LARGE            = "TLS_ERR_SESSION_STATE_TOO_LARGE"
    ERR_SESSION_STATE_WRONG_CERT           = "TLS_ERR_SESSION_STATE_WRONG_CERT"
    ERR_SESSION_STATE_WRONG_CERT_NUM       = "TLS_ERR_SESSION_STATE_WRONG_CERT_NUM"
    ERR_SESSION_STATE_WRONG_MASTER_SECRET  = "TLS_ERR_SESSION_STATE_WRONG_MASTER_SECRET"
    ERR_SESSION_STATE_MARSHAL_ERR          = "TLS_ERR_SESSION_STATE_MARSHAL_ERR"
    ERR_SESSION_STATE_UNMARSHAL_ERR        = "TLS_ERR_SESSION_STATE_UNMARSHAL_ERR"
)

// tls counters
const (
    // handshake
        HANDSHAKE_READ_CLIENTHELLO_ERR         = "TLS_HANDSHAKE_READ_CLIENTHELLO_ERR"
        HANDSHAKE_FULL_ALL                     = "TLS_HANDSHAKE_FULL_ALL"
        HANDSHAKE_FULL_SUCC                    = "TLS_HANDSHAKE_FULL_SUCC"
        HANDSHAKE_RESUME_ALL                   = "TLS_HANDSHAKE_RESUME_ALL"
        HANDSHAKE_RESUME_SUCC                  = "TLS_HANDSHAKE_RESUME_SUCC"
        HANDSHAKE_CHECK_RESUME_SESSION_TICKET  = "TLS_HANDSHAKE_CHECK_RESUME_SESSION_TICKET"
        HANDSHAKE_SHOULD_RESUME_SESSION_TICKET = "TLS_HANDSHAKE_SHOULD_RESUME_SESSION_TICKET"
        HANDSHAKE_CHECK_RESUME_SESSION_CACHE   = "TLS_HANDSHAKE_CHECK_RESUME_SESSION_CACHE"
        HANDSHAKE_SHOULD_RESUME_SESSION_CACHE  = "TLS_HANDSHAKE_SHOULD_RESUME_SESSION_CACHE"
    HANDSHAKE_FIND_SHA1_PATTERN            = "TLS_HANDSHAKE_SHA1_PATTERN_FOUND"
    HANDSHAKE_FIND_SHA256_PATTERN          = "TLS_HANDSHAKE_SHA256_PATTERN_FOUND"
    HANDSHAKE_FIND_NO_PATTERN              = "TLS_HANDSHAKE_NO_PATTERN_FOUND"
    HANDSHAKE_ACCEPT_SSLV2_CLIENT_HEELO    = "TLS_HANDSHAKE_ACCEPT_SSLV2_CLIENT_HELLO"
    HANDSHAKE_ACCEPT_ECDHE_WITHOUT_EXT     = "TLS_HANDSHAKE_ACCEPT_ECDHE_WITHOUT_EXT"

    // extension
    TLS_ALPN_EXT_COUNT                     = "TLS_ALPN_EXT_COUNT"
)

// handshake actions at server side
const (
    /* Note: message flow for a full handshake:
     * 
     *  CLIENT                       SERVER
     *
     *  ClientHello    ------&gt;         
     *                               ServerHello
     *                               Certificate*
     *                               ServerKeyExchange*
     *                               CertificateRequest*
     *                 &lt;------       ServerHelloDone
     *  
     *  Certificate*
     *  ClientKeyExchange
     *  CertificateVerify*
     *  [ChangeCipherSpec]
     *  Finished       ------&gt; 
     *                               [ChangeCipherSpec]
     *                 &lt;------       Finished
     *
     *  AppData        &lt;-----&gt;       AppData
     */
    SERV_SEND_SERVER_HELLO_FULL        = "TLS_SERV_SEND_SERVER_HELLO.FULL"
    SERV_SEND_CERTIFICATE_FULL         = "TLS_SERV_SEND_CERTIFICATE.FULL"
    SERV_SEND_CERTIFICATE_STATUS_FULL  = "TLS_SERV_SEND_CERTIFICATE_STATUS.FULL"
    SERV_SEND_SERVER_KEY_EXCHANGE_FULL = "TLS_SERV_SEND_SERVER_KEY_EXCHANGE.FULL"
    SERV_SEND_CERTIFICATE_REQUEST_FULL = "TLS_SERV_SEND_CERTIFICATE_REQUEST.FULL"
    SERV_SEND_SERVER_HELLO_DONE_FULL   = "TLS_SERV_SEND_SERVER_HELLO_DONE.FULL"
    SERV_READ_CERTIFICATE_FULL         = "TLS_SERV_READ_CERTIFICATE.FULL"
    SERV_READ_CLIENT_KEY_EXCHANGE_FULL = "TLS_SERV_READ_CLIENT_KEY_EXCHANGE.FULL"
    SERV_READ_CERTIFICATE_VERIFY_FULL  = "TLS_SERV_READ_CERTIFICATE_VERIFY.FULL"
    SERV_READ_CHANGE_CIPHER_SPEC_FULL  = "TLS_SERV_READ_CHANGE_CIPHER_SPEC.FULL"
    SERV_READ_NEXT_PROTO_FULL          = "TLS_SERV_READ_NEXT_PROTO.FULL"
    SERV_READ_FINISHED_FULL            = "TLS_SERV_READ_FINISHED.FULL"
    SERV_SEND_SESSION_TICKET_FULL      = "TLS_SERV_SEND_SESSION_TICKET.FULL"
    SERV_SEND_CHANGE_CIPHER_SPEC_FULL  = "TLS_SERV_SEND_CHANGE_CIPHER_SPEC.FULL"
    SERV_SEND_FINISHED_FULL            = "TLS_SERV_SEND_FINISHED.FULL"

    /* Note: message flow for an abbreviated handshake
     *
     *  CLIENT                       SERVER
     *
     *  ClientHello    ------&gt;         
     *                               ServerHello
     *                               [ChangeCipherSpec]
     *                 &lt;------       Finished
     *  [ChangeCipherSpec]
     *  Finished       ------&gt; 
     *
     *  AppData        &lt;-----&gt;       AppData
     */
    SERV_SEND_SERVER_HELLO_RESUME        = "TLS_SERV_SEND_SERVER_HELLO.RESUME"
    SERV_SEND_SESSION_TICKET_RESUME      = "TLS_SERV_SEND_SESSION_TICKET.RESUME"
    SERV_SEND_CHANGE_CIPHER_SPEC_RESUME  = "TLS_SERV_SEND_CHANGE_CIPHER_SPEC.RESUME"
    SERV_SEND_FINISHED_RESUME            = "TLS_SERV_SEND_FINISHED.RESUME"
    SERV_READ_CHANGE_CIPHER_SPEC_RESUME  = "TLS_SERV_READ_CHANGE_CIPHER_SPEC.RESUME"
    SERV_READ_NEXT_PROTO_RESUME          = "TLS_SERV_READ_NEXT_PROTO.RESUME"
    SERV_READ_FINISHED_RESUME            = "TLS_SERV_READ_FINISHED.RESUME"

    /* all actions at server side */
    SERV_READ_CLIENT_HELLO        = "TLS_SERV_READ_CLIENT_HELLO"
    SERV_SEND_SERVER_HELLO        = "TLS_SERV_SEND_SERVER_HELLO"
    SERV_SEND_CERTIFICATE         = "TLS_SERV_SEND_CERTIFICATE"                  
    SERV_SEND_CERTIFICATE_STATUS  = "TLS_SERV_SEND_CERTIFICATE_STATUS"                  
    SERV_SEND_SERVER_KEY_EXCHANGE = "TLS_SERV_SEND_SERVER_KEY_EXCHANGE"
    SERV_SEND_CERTIFICATE_REQUEST = "TLS_SERV_SEND_CERTIFICATE_REQUEST"
    SERV_SEND_SERVER_HELLO_DONE   = "TLS_SERV_SEND_SERVER_HELLO_DONE"
    SERV_READ_CERTIFICATE         = "TLS_SERV_READ_CERTIFICATE"
    SERV_READ_CLIENT_KEY_EXCHANGE = "TLS_SERV_READ_CLIENT_KEY_EXCHANGE"
    SERV_READ_CERTIFICATE_VERIFY  = "TLS_SERV_READ_CERTIFICATE_VERIFY"
    SERV_READ_CHANGE_CIPHER_SPEC  = "TLS_SERV_READ_CHANGE_CIPHER_SPEC"
    SERV_READ_NEXT_PROTO          = "TLS_SERV_READ_NEXT_PROTO"
    SERV_READ_FINISHED            = "TLS_SERV_READ_FINISHED"
    SERV_SEND_SESSION_TICKET      = "TLS_SERV_SEND_SESSION_TICKET"
    SERV_SEND_CHANGE_CIPHER_SPEC  = "TLS_SERV_SEND_CHANGE_CIPHER_SPEC"
    SERV_SEND_FINISHED            = "TLS_SERV_SEND_FINISHED"
)

var allCounters = []string{
        ERR_WRONG_LISTENER_TYPE,
        ERR_MODIFY_CONFIG_IN_USE,
        ERR_NO_CERT_IN_CONFIG,
        ERR_DECODE_CERT_IN_PEM,
        ERR_DECODE_KEY_IN_PEM,
        ERR_PARSE_CERT,
        ERR_PARSE_PRI_KEY,
        ERR_KEY_TYPE_NOT_MATCH,
        ERR_KEY_NOT_MATCH,
        ERR_UNKNOWN_PUB_KEY_ALGOR,
        ERR_UNKNOWN_PRI_KEY_TYPE_IN_PKCS8,
        ERR_ALERT_HANDSHAKE_FAILURE,
    ERR_TLS_FALLBACK_SCSV,
    ERR_KEY_DECRYPT_FAIL,

        ERR_UNKNOWN_RECORD_TYPE,
        ERR_WRONG_RECORD_TYPE_AFTER_HS_COMPLETE,
        ERR_WRONG_RECORD_TYPE_BEFORE_HS_COMPLETE,
        ERR_SSLV2_NOT_SUPPORT,
        ERR_VERSION_NOT_EXPECTED,
        ERR_RECORD_OVERFLOW,
        ERR_UNEXPECTED_MESSAGE,
        ERR_UNEXPECTED_EOF,
        ERR_SERVER_SHOULD_NOT_VERIFY_HOSTNAME,
        ERR_CLIENT_HANDSHAKE_NOT_PERFORMED,
        ERR_ALERT_RECORD_OVERFLOW,
        ERR_ALERT_UNEXPECTED_MESSAGE,
        ERR_ALERT_NO_RENEGOTIATION,
        ERR_ALERT_CLOSE_NOTIFY,
        ERR_ALERT_INTERNAL_ERROR,

        ERR_CLIENT_KEY_EXCHANGE,
        ERR_SERVER_KEY_EXCHANGE,
        ERR_SERVER_INTERNAL,
        ERR_DECRYPT_SESSION_KEY,
        ERR_UNKNOWN_HASH_FUNC,
        ERR_CLIENT_NOT_SUPPORT_COMMON_HASH_FUNC,
        ERR_OFFERED_CURVES_NOT_SUPPORT,
        ERR_PREFERRED_CURVE_NOT_SUPPORT,
        ERR_SERVER_WRONG_ECDSA_PRI_KEY,
        ERR_SIGN_ECDHE_PARAMS,
        ERR_SERVER_WRONG_RSA_PRI_KEY,
        ERR_UNKNOWN_ECDHE_SIGN_ALGOR,

        ERR_CLIENT_VERSION_NOT_SUPPORT,
        ERR_CLIENT_NOT_SUPPORT_UNCOMPRESS_CONN,
        ERR_NO_CERT_CONFIGURED,
        ERR_NO_SHARED_CIPHER_SUITE,
        ERR_CLIENT_CERT_NOT_PROVIDE,
        ERR_WRONG_ECDSA_SIGNATURE,
        ERR_ECDSA_VERIFY_FAILURE,
        ERR_BAD_CERT,
        ERR_WRONG_CLIENT_FINISH_MSG,
        ERR_PARSE_CLIENT_CERT,
        ERR_VERIFY_CLIENT_CERT,
        ERR_CLIENT_CERT_NOT_FOR_AUTH,
        ERR_CLIENT_CERT_NOT_SUPPORT,
        ERR_REJECT_CONN_CLIENTHELLO_RANDOM,

    ERR_ENC_TICKET_WHEN_INIT_IV,
    ERR_ENC_TICKET_WHEN_CREATE_CIPHER,
    ERR_DEC_TICKET_WRONG_SIZE,
    ERR_DEC_TICKET_WRONG_MAC,
    ERR_DEC_TICKET_WHEN_NEW_CIPHER,
    ERR_DEC_TICKET_WRONG_CIPHER_SIZE,
    ERR_SESSION_STATE_TOO_SMALL,
    ERR_SESSION_STATE_TOO_LARGE,
    ERR_SESSION_STATE_WRONG_CERT,
    ERR_SESSION_STATE_WRONG_CERT_NUM,
    ERR_SESSION_STATE_WRONG_MASTER_SECRET,
    ERR_SESSION_STATE_MARSHAL_ERR,
    ERR_SESSION_STATE_UNMARSHAL_ERR,

        HANDSHAKE_READ_CLIENTHELLO_ERR,
        HANDSHAKE_FULL_ALL,
        HANDSHAKE_FULL_SUCC,
        HANDSHAKE_RESUME_ALL,
        HANDSHAKE_RESUME_SUCC,
        HANDSHAKE_CHECK_RESUME_SESSION_TICKET,
        HANDSHAKE_SHOULD_RESUME_SESSION_TICKET,
        HANDSHAKE_CHECK_RESUME_SESSION_CACHE,
        HANDSHAKE_SHOULD_RESUME_SESSION_CACHE,
    HANDSHAKE_FIND_SHA1_PATTERN,
    HANDSHAKE_FIND_SHA256_PATTERN,
    HANDSHAKE_FIND_NO_PATTERN,
    HANDSHAKE_ACCEPT_SSLV2_CLIENT_HEELO,
    HANDSHAKE_ACCEPT_ECDHE_WITHOUT_EXT,

    TLS_ALPN_EXT_COUNT,

    SERV_READ_CLIENT_HELLO,

    SERV_SEND_SERVER_HELLO_FULL,
    SERV_SEND_CERTIFICATE_FULL,
    SERV_SEND_CERTIFICATE_STATUS_FULL,
    SERV_SEND_SERVER_KEY_EXCHANGE_FULL,
    SERV_SEND_CERTIFICATE_REQUEST_FULL,
    SERV_SEND_SERVER_HELLO_DONE_FULL,
    SERV_READ_CERTIFICATE_FULL,
    SERV_READ_CLIENT_KEY_EXCHANGE_FULL,
    SERV_READ_CERTIFICATE_VERIFY_FULL,
    SERV_READ_CHANGE_CIPHER_SPEC_FULL,
    SERV_READ_NEXT_PROTO_FULL,
    SERV_READ_FINISHED_FULL,
    SERV_SEND_SESSION_TICKET_FULL,
    SERV_SEND_CHANGE_CIPHER_SPEC_FULL,
    SERV_SEND_FINISHED_FULL,

    SERV_SEND_SERVER_HELLO_RESUME,
    SERV_SEND_SESSION_TICKET_RESUME,
    SERV_SEND_CHANGE_CIPHER_SPEC_RESUME,
    SERV_SEND_FINISHED_RESUME,
    SERV_READ_CHANGE_CIPHER_SPEC_RESUME,
    SERV_READ_NEXT_PROTO_RESUME,
    SERV_READ_FINISHED_RESUME,
}

func AllCounters() []string <span class="cov0" title="0">{
        return allCounters
}</span>

// for monitor state of tls
type TlsState interface {
        // increase counter for key
        Inc(key string, value int)
}

var tlsState TlsState

func SetTlsState(state TlsState) <span class="cov0" title="0">{
        tlsState = state
}</span>

func stateInc(key string, value int) <span class="cov10" title="16645">{
        if tlsState != nil </span><span class="cov0" title="0">{
                tlsState.Inc(key, value)
        }</span>
}

func hsStateInc(key string, isResume bool, value int) <span class="cov6" title="305">{
    if !isResume </span><span class="cov6" title="285">{
        key = fmt.Sprintf("%s.FULL", key)
    }</span> <span class="cov3" title="20">else {
        key = fmt.Sprintf("%s.RESUME", key)
    }</span>
    <span class="cov6" title="305">stateInc(key, value)</span>
}
</pre>
		
		<pre class="file" id="file237" style="display: none">/* ticket.go - tls session state */
/*
modification history
--------------------
2015/5/28, by Sijie Yang, modify
        - Support ticket in OpenSSL format for interoperability with Nginx
*/
/*
DESCRIPTION
Warn: 
   - If nginx is updated with a new version of OpenSSL, you should check 
         whether the format of SessionState in OpenSSL is changed or not. 
   - For more details, see &lt;openssl-1.0.2&gt;/ssl/{ssl_asn1.c,T1_lib.c}
*/

// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bfe_tls

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/hmac"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/asn1"
        "encoding/binary"
        "errors"
        "io"
        "time"
)

const (
        FORMAT_RAW  = 0
        FORMAT_ASN1 = 1
)

var ticketFormat = FORMAT_RAW

/* SetTicketFormat - set ticket format
 * 
 * Params:
 *         - format: ticket format (FORMAT_RAW, FORMAT_ASN1)
 * 
 * Note: 
 *         - In online environment, we should use FORMAT_ASN1 to be compatible with OpenSSL
 *         - In unit test environment, we just use FORMAT_RAW to avoid from modifing
 *           official unit test data in binary form
 */
func SetTicketFormat(format int) <span class="cov0" title="0">{
        if format == FORMAT_RAW </span><span class="cov0" title="0">{
                ticketFormat = FORMAT_RAW
        }</span> <span class="cov0" title="0">else {
                ticketFormat = FORMAT_ASN1
        }</span>
}

var sessionIdCtx = []byte("HTTP")

// sessionState contains the information that is serialized into a session
// ticket in order to later resume a connection.
type sessionState struct {
        vers                 uint16
        cipherSuite  uint16
        masterSecret []byte
        certificates [][]byte

        // Note: SessionId will not be serialized if ticket format is FORMAT_RAW
        sessionId        []byte // session id
}

// sessionState in OpenSSL
type sessionStateAsn1 struct {
        StructVer        int16   // struct version; OpenSSL doesn't care about StructVer now 
        Vers                 int16  // tls version
        CipherSuite  []byte // cipher id
        SessionId        []byte  // session id
        MasterSecret []byte // master secret

        /* following are optional fields */
        Time                 int64  `asn1:"optional,explicit,tag:1"` // unix epoch time (seconds)
        Timeout          int64  `asn1:"optional,explicit,tag:2"`    // timeout for this session state (seconds)
        SessionIdCtx []byte `asn1:"optional,explicit,tag:4"` // used to ensure sessions are only 
                                                                                                                 // reused in the appropriate context
}

// convert sessionState to sessionStateAsn1
func (s *sessionState) convertTo() *sessionStateAsn1 <span class="cov0" title="0">{
        s1 := new(sessionStateAsn1)

        s1.StructVer = 1
        s1.Vers = int16(s.vers)
        s1.CipherSuite = make([]byte, 2)
        binary.BigEndian.PutUint16(s1.CipherSuite, s.cipherSuite)
        s1.SessionId = s.sessionId
        s1.MasterSecret = s.masterSecret

        // for optional field
        s1.Time = time.Now().Unix() // current timestamp
        s1.Timeout = 100800                 // 28 Hour
        s1.SessionIdCtx = sessionIdCtx  

        return s1
}</span>

// convert sessionState from sessionStateAsn1
func (s *sessionState) convertFrom(s1 *sessionStateAsn1) <span class="cov0" title="0">{
        s.vers = uint16(s1.Vers)
        s.cipherSuite = binary.BigEndian.Uint16(s1.CipherSuite)  
        s.sessionId = s1.SessionId
        s.masterSecret = s1.MasterSecret
}</span>

func (s *sessionState) equal(i interface{}) bool <span class="cov4" title="100">{
        s1, ok := i.(*sessionState)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">if s.vers != s1.vers ||
                s.cipherSuite != s1.cipherSuite ||
                !bytes.Equal(s.masterSecret, s1.masterSecret) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">if len(s.certificates) != len(s1.certificates) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov4" title="100">for i := range s.certificates </span><span class="cov6" title="947">{
                if !bytes.Equal(s.certificates[i], s1.certificates[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov4" title="100">return true</span>
}

func (s *sessionState) marshal() []byte <span class="cov5" title="207">{
        if ticketFormat == FORMAT_ASN1 </span><span class="cov0" title="0">{
                return s.marshalAsn1() 
        }</span> <span class="cov5" title="207">else {
                return s.marshalRaw()
        }</span>
}

func (s *sessionState) unmarshal(data []byte) bool <span class="cov8" title="16116">{
        if ticketFormat == FORMAT_ASN1 </span><span class="cov0" title="0">{
                return s.unmarshalAsn1(data) 
        }</span> <span class="cov8" title="16116">else {
                return s.unmarshalRaw(data)
        }</span>
}

func (s *sessionState) marshalRaw() []byte <span class="cov5" title="207">{
        length := 2 + 2 + 2 + len(s.masterSecret) + 2
        for _, cert := range s.certificates </span><span class="cov7" title="1894">{
                length += 4 + len(cert)
        }</span>

        <span class="cov5" title="207">ret := make([]byte, length)
        x := ret
        x[0] = byte(s.vers &gt;&gt; 8)
        x[1] = byte(s.vers)
        x[2] = byte(s.cipherSuite &gt;&gt; 8)
        x[3] = byte(s.cipherSuite)
        x[4] = byte(len(s.masterSecret) &gt;&gt; 8)
        x[5] = byte(len(s.masterSecret))
        x = x[6:]
        copy(x, s.masterSecret)
        x = x[len(s.masterSecret):]

        x[0] = byte(len(s.certificates) &gt;&gt; 8)
        x[1] = byte(len(s.certificates))
        x = x[2:]

        for _, cert := range s.certificates </span><span class="cov7" title="1894">{
                x[0] = byte(len(cert) &gt;&gt; 24)
                x[1] = byte(len(cert) &gt;&gt; 16)
                x[2] = byte(len(cert) &gt;&gt; 8)
                x[3] = byte(len(cert))
                copy(x[4:], cert)
                x = x[4+len(cert):]
        }</span>

        <span class="cov5" title="207">return ret</span>
}

func (s *sessionState) unmarshalRaw(data []byte) bool <span class="cov8" title="16116">{
        if len(data) &lt; 8 </span><span class="cov6" title="893">{
                stateInc(ERR_SESSION_STATE_TOO_SMALL, 1)
                return false
        }</span>

        <span class="cov8" title="15223">s.vers = uint16(data[0])&lt;&lt;8 | uint16(data[1])
        s.cipherSuite = uint16(data[2])&lt;&lt;8 | uint16(data[3])
        masterSecretLen := int(data[4])&lt;&lt;8 | int(data[5])
        data = data[6:]
        if len(data) &lt; masterSecretLen </span><span class="cov8" title="5926">{
                stateInc(ERR_SESSION_STATE_WRONG_MASTER_SECRET, 1)
                return false
        }</span>

        <span class="cov8" title="9297">s.masterSecret = data[:masterSecretLen]
        data = data[masterSecretLen:]

        if len(data) &lt; 2 </span><span class="cov5" title="200">{
                stateInc(ERR_SESSION_STATE_WRONG_CERT_NUM, 1)
                return false
        }</span>

        <span class="cov8" title="9097">numCerts := int(data[0])&lt;&lt;8 | int(data[1])
        data = data[2:]

        s.certificates = make([][]byte, numCerts)
        for i := range s.certificates </span><span class="cov10" title="64285">{
                if len(data) &lt; 4 </span><span class="cov7" title="3788">{
                        stateInc(ERR_SESSION_STATE_WRONG_CERT, 1)
                        return false
                }</span>
                <span class="cov9" title="60497">certLen := int(data[0])&lt;&lt;24 | int(data[1])&lt;&lt;16 | int(data[2])&lt;&lt;8 | int(data[3])
                data = data[4:]
                if certLen &lt; 0 </span><span class="cov0" title="0">{
                        stateInc(ERR_SESSION_STATE_WRONG_CERT, 1)
                        return false
                }</span>
                <span class="cov9" title="60497">if len(data) &lt; certLen </span><span class="cov7" title="5205">{
                        stateInc(ERR_SESSION_STATE_WRONG_CERT, 1)
                        return false
                }</span>
                <span class="cov9" title="55292">s.certificates[i] = data[:certLen]
                data = data[certLen:]</span>
        }

        <span class="cov4" title="104">if len(data) &gt; 0 </span><span class="cov0" title="0">{
                stateInc(ERR_SESSION_STATE_TOO_LARGE, 1)
                return false
        }</span>

        <span class="cov4" title="104">return true</span>
}

// marshal for compatible with OpenSSL
func (s *sessionState) marshalAsn1() []byte <span class="cov0" title="0">{
        s1 := s.convertTo()
        ret, err := asn1.Marshal(*s1) 
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_SESSION_STATE_MARSHAL_ERR, 1)
        }</span>
        <span class="cov0" title="0">return ret</span>
}

// unmarshal for compatible with OpenSSL
func (s *sessionState) unmarshalAsn1(data []byte) bool <span class="cov0" title="0">{
        s1 := new(sessionStateAsn1)
        _, err := asn1.Unmarshal(data, s1)        
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_SESSION_STATE_UNMARSHAL_ERR, 1)
                return false
        }</span>

        <span class="cov0" title="0">s.convertFrom(s1)
        return true</span>
}

func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) <span class="cov2" title="7">{
        if ticketFormat == FORMAT_ASN1 </span><span class="cov0" title="0">{
                return c.encryptTicketAsn1(state)
        }</span> <span class="cov2" title="7">else {
                return c.encryptTicketRaw(state)
        }</span>
}

func (c *Conn) decryptTicket(encrypted []byte) (*sessionState, bool) <span class="cov2" title="5">{
        if ticketFormat == FORMAT_ASN1 </span><span class="cov0" title="0">{
                return c.decryptTicketAsn1(encrypted)
        }</span> <span class="cov2" title="5">else {
                return c.decryptTicketRaw(encrypted)
        }</span>
}

func (c *Conn) encryptTicketRaw(state *sessionState) ([]byte, error) <span class="cov2" title="7">{
        serialized := state.marshal()
        encrypted := make([]byte, aes.BlockSize+len(serialized)+sha256.Size)
        iv := encrypted[:aes.BlockSize]
        macBytes := encrypted[len(encrypted)-sha256.Size:]

        if _, err := io.ReadFull(c.config.rand(), iv); err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_ENC_TICKET_WHEN_INIT_IV, 1)
                return nil, err
        }</span>
        <span class="cov2" title="7">block, err := aes.NewCipher(c.config.SessionTicketKey[:16])
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_ENC_TICKET_WHEN_CREATE_CIPHER, 1)
                return nil, errors.New("tls: failed to create cipher while encrypting ticket: " + err.Error()) 
        }</span>
        <span class="cov2" title="7">cipher.NewCTR(block, iv).XORKeyStream(encrypted[aes.BlockSize:], serialized)

        mac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])
        mac.Write(encrypted[:len(encrypted)-sha256.Size])
        mac.Sum(macBytes[:0])

        return encrypted, nil</span>
}

func (c *Conn) decryptTicketRaw(encrypted []byte) (*sessionState, bool) <span class="cov2" title="5">{
        if len(encrypted) &lt; aes.BlockSize+sha256.Size </span><span class="cov0" title="0">{
                stateInc(ERR_DEC_TICKET_WRONG_SIZE, 1)
                return nil, false
        }</span>

        <span class="cov2" title="5">iv := encrypted[:aes.BlockSize]
        macBytes := encrypted[len(encrypted)-sha256.Size:]

        mac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])
        mac.Write(encrypted[:len(encrypted)-sha256.Size])
        expected := mac.Sum(nil)

        if subtle.ConstantTimeCompare(macBytes, expected) != 1 </span><span class="cov1" title="1">{
                stateInc(ERR_DEC_TICKET_WRONG_MAC, 1)
                return nil, false
        }</span>

        <span class="cov2" title="4">block, err := aes.NewCipher(c.config.SessionTicketKey[:16])
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_DEC_TICKET_WHEN_NEW_CIPHER, 1)
                return nil, false
        }</span>

        <span class="cov2" title="4">ciphertext := encrypted[aes.BlockSize : len(encrypted)-sha256.Size]
        plaintext := ciphertext
        cipher.NewCTR(block, iv).XORKeyStream(plaintext, ciphertext)

        state := new(sessionState)
        ok := state.unmarshal(plaintext)
        return state, ok</span>
}

/* encryptTicketAsn1 - encrypt a ticket in the format compatible with OpenSSL
 *
 * Params:
 *         - state : tls session state
 * 
 * Return:
 *         - data  : data of ticket generated
 *         - error : errors if fail 
 *
 * Note: 
 *         - Ticket Format in OpenSSL:
 * +---------------------------------+
 * |   Session Ticket Key Name       | (16 bytes)
 * +---------------------------------+
 * |               IV                | (16 bytes)
 * +---------------------------------+
 * |        Encrypted Data           | (16*N bytes) 
 * | (sessionSteate encrypted by     |
 * .        'AES_128_CBC')           .
 * .                                 .
 * |                                 |
 * +---------------------------------+
 * |       HMAC(F1, F2 ,F3)          | (32 bytes)
 * +                                 +
 * |        (using 'SHA256')         | 
 * +---------------------------------+
 */
func (c *Conn) encryptTicketAsn1(state *sessionState) ([]byte, error) <span class="cov0" title="0">{
        // 1. marshal session state
        serialized := state.marshal()

        // 2. padding session state
        serialized = PKCS5Padding(serialized, aes.BlockSize)

        // 3. prepare room for ticket
        encrypted := make([]byte, ticketKeyNameLen+aes.BlockSize+len(serialized)+sha256.Size)
        keyName   := encrypted[:ticketKeyNameLen]
        iv                := encrypted[ticketKeyNameLen : ticketKeyNameLen+aes.BlockSize]
        macBytes  := encrypted[len(encrypted)-sha256.Size:]

        // 4. set session ticket key name
        copy(keyName, c.config.SessionTicketKeyName[:])

        // 5. set IV
        if _, err := io.ReadFull(c.config.rand(), iv); err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_ENC_TICKET_WHEN_INIT_IV, 1)
                return nil, err
        }</span>

        // 6. encrypt session state
        <span class="cov0" title="0">block, err := aes.NewCipher(c.config.SessionTicketKey[:16])
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_ENC_TICKET_WHEN_CREATE_CIPHER, 1)
                return nil, errors.New("tls: failed to create cipher while encrypting ticket: " + err.Error()) 
        }</span>
        <span class="cov0" title="0">cipher.NewCBCEncrypter(block, iv).CryptBlocks(encrypted[ticketKeyNameLen+aes.BlockSize:], serialized)

        // 7. set mac
        mac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])
        mac.Write(encrypted[:len(encrypted)-sha256.Size])
        mac.Sum(macBytes[:0])

        return encrypted, nil</span>
}

func PKCS5Padding(ciphertext []byte, blockSize int) []byte <span class="cov0" title="0">{
        padding := blockSize - len(ciphertext)%blockSize
        padtext := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(ciphertext, padtext...)
}</span>

/* decryptTicketAsn1 - decrypt a OpenSSL ticket
 *
 * Params:
 *         - encrypted : ticket data
 *
 * Return:
 *         - state : session state decrypt from ticket
 *         - ok        : true if success, false if not
 */
func (c *Conn) decryptTicketAsn1(encrypted []byte) (*sessionState, bool) <span class="cov0" title="0">{
        // 1. check ticket size
        if len(encrypted) &lt; ticketKeyNameLen + aes.BlockSize+sha256.Size </span><span class="cov0" title="0">{
                stateInc(ERR_DEC_TICKET_WRONG_SIZE, 1)
                return nil, false
        }</span>

        // 2. check ciphertext size
        <span class="cov0" title="0">ciphertext := encrypted[ticketKeyNameLen+aes.BlockSize : len(encrypted)-sha256.Size]
        if len(ciphertext) % aes.BlockSize != 0 </span><span class="cov0" title="0">{
                stateInc(ERR_DEC_TICKET_WRONG_CIPHER_SIZE, 1)
                return nil, false
        }</span>

        // 3. check mac
        <span class="cov0" title="0">macBytes := encrypted[len(encrypted)-sha256.Size:]
        mac := hmac.New(sha256.New, c.config.SessionTicketKey[16:32])
        mac.Write(encrypted[:len(encrypted)-sha256.Size])
        expected := mac.Sum(nil)

        if subtle.ConstantTimeCompare(macBytes, expected) != 1 </span><span class="cov0" title="0">{
                stateInc(ERR_DEC_TICKET_WRONG_MAC, 1)
                return nil, false
        }</span>

        // 4. decrypt ticket
        <span class="cov0" title="0">iv := encrypted[ticketKeyNameLen : ticketKeyNameLen+aes.BlockSize]
        block, err := aes.NewCipher(c.config.SessionTicketKey[:16])
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_DEC_TICKET_WHEN_NEW_CIPHER, 1)
                return nil, false
        }</span>

        <span class="cov0" title="0">plaintext := ciphertext
        cipher.NewCBCDecrypter(block, iv).CryptBlocks(plaintext, ciphertext)

        // 5. unmarshal session state
        state := new(sessionState)
        ok := state.unmarshal(plaintext)
        return state, ok</span>
}

</pre>
		
		<pre class="file" id="file238" style="display: none">/* tls.go - high-level api for tls */
/*
modification history
--------------------
2015/4/16, by Sijie Yang, modify
    - support update config for tls.listener
*/
/*
DESCRIPTION
*/

// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package tls partially implements TLS 1.2, as specified in RFC 5246.
package bfe_tls

import (
        "crypto"
        "crypto/ecdsa"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "io/ioutil"
        "net"
        "strings"
        "sync"
        "time"
)

// Server returns a new TLS server side connection
// using conn as the underlying transport.
// The configuration config must be non-nil and must have
// at least one certificate.
func Server(conn net.Conn, config *Config) *Conn <span class="cov10" title="49">{
        return &amp;Conn{conn: conn, config: config}
}</span>

// Client returns a new TLS client side connection
// using conn as the underlying transport.
// The config cannot be nil: users must set either ServerName or
// InsecureSkipVerify in the config.
func Client(conn net.Conn, config *Config) *Conn <span class="cov9" title="41">{
        return &amp;Conn{conn: conn, config: config, isClient: true}
}</span>

// A listener implements a network listener (net.Listener) for TLS connections.
type listener struct {
        net.Listener
        config *Config
        lock   sync.RWMutex // lock for config
}

// Accept waits for and returns the next incoming TLS connection.
// The returned connection c is a *tls.Conn.
func (l *listener) Accept() (c net.Conn, err error) <span class="cov0" title="0">{
        c, err = l.Listener.Accept()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.lock.RLock()
        c = Server(c, l.config)
        l.lock.RUnlock()
        return</span>
}

// NewListener creates a Listener which accepts connections from an inner
// Listener and wraps each connection with Server.
// The configuration config must be non-nil and must have
// at least one certificate.
func NewListener(inner net.Listener, config *Config) net.Listener <span class="cov0" title="0">{
        l := new(listener)
        l.Listener = inner
        l.config = config
        return l
}</span>

/* UpdateListener - update config for tls listener
 *
 * Params:
 *     - ln  : a tls listener
 *     - conf: a tls config
 *
 * Return:
 *     - error
 *
 * Note:
 *     1. tls.listener will not modify tls.Config and just pass it
 * to accepted Connection.
 *     2. tls.Conn will just read tls.Config during handshake and
 * data transfer phase
 *     3. MUST specified a new tls.config when called
 */
func UpdateListener(ln net.Listener, conf *Config) error <span class="cov0" title="0">{
        l, ok := ln.(*listener)
        if !ok </span><span class="cov0" title="0">{
                stateInc(ERR_WRONG_LISTENER_TYPE, 1)
                return errors.New("tls.UpdateListener: type not tls.listner")
        }</span>

        <span class="cov0" title="0">l.lock.Lock()
        defer l.lock.Unlock()

        if l.config == conf </span><span class="cov0" title="0">{
                stateInc(ERR_MODIFY_CONFIG_IN_USE, 1)
                return errors.New("tls.UpdateListener: not safe to modify config in use")
        }</span>

        <span class="cov0" title="0">l.config = conf
        return nil</span>
}

// Listen creates a TLS listener accepting connections on the
// given network address using net.Listen.
// The configuration config must be non-nil and must have
// at least one certificate.
func Listen(network, laddr string, config *Config) (net.Listener, error) <span class="cov0" title="0">{
        if config == nil || len(config.Certificates) == 0 </span><span class="cov0" title="0">{
                stateInc(ERR_NO_CERT_IN_CONFIG, 1)
                return nil, errors.New("tls.Listen: no certificates in configuration")
        }</span>
        <span class="cov0" title="0">l, err := net.Listen(network, laddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewListener(l, config), nil</span>
}

type timeoutError struct{}

func (timeoutError) Error() string   <span class="cov1" title="1">{ return "tls: DialWithDialer timed out" }</span>
func (timeoutError) Timeout() bool   <span class="cov0" title="0">{ return true }</span>
func (timeoutError) Temporary() bool <span class="cov0" title="0">{ return true }</span>

// DialWithDialer connects to the given network address using dialer.Dial and
// then initiates a TLS handshake, returning the resulting TLS connection. Any
// timeout or deadline given in the dialer apply to connection and TLS
// handshake as a whole.
//
// DialWithDialer interprets a nil configuration as equivalent to the zero
// configuration; see the documentation of Config for the defaults.
func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error) <span class="cov2" title="2">{
        // We want the Timeout and Deadline values from dialer to cover the
        // whole process: TCP connection and TLS handshake. This means that we
        // also need to start our own timers now.
        timeout := dialer.Timeout

        if !dialer.Deadline.IsZero() </span><span class="cov0" title="0">{
                deadlineTimeout := dialer.Deadline.Sub(time.Now())
                if timeout == 0 || deadlineTimeout &lt; timeout </span><span class="cov0" title="0">{
                        timeout = deadlineTimeout
                }</span>
        }

        <span class="cov2" title="2">var errChannel chan error

        if timeout != 0 </span><span class="cov1" title="1">{
                errChannel = make(chan error, 2)
                time.AfterFunc(timeout, func() </span><span class="cov1" title="1">{
                        errChannel &lt;- timeoutError{}
                }</span>)
        }

        <span class="cov2" title="2">rawConn, err := dialer.Dial(network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">colonPos := strings.LastIndex(addr, ":")
        if colonPos == -1 </span><span class="cov0" title="0">{
                colonPos = len(addr)
        }</span>
        <span class="cov2" title="2">hostname := addr[:colonPos]

        if config == nil </span><span class="cov1" title="1">{
                config = defaultConfig()
        }</span>
        // If no ServerName is set, infer the ServerName
        // from the hostname we're connecting to.
        <span class="cov2" title="2">if config.ServerName == "" </span><span class="cov2" title="2">{
                // Make a copy to avoid polluting argument or default.
                c := *config
                c.ServerName = hostname
                config = &amp;c
        }</span>

        <span class="cov2" title="2">conn := Client(rawConn, config)

        if timeout == 0 </span><span class="cov1" title="1">{
                err = conn.Handshake()
        }</span> <span class="cov1" title="1">else {
                go func() </span><span class="cov1" title="1">{
                        errChannel &lt;- conn.Handshake()
                }</span>()

                <span class="cov1" title="1">err = &lt;-errChannel</span>
        }

        <span class="cov2" title="2">if err != nil </span><span class="cov1" title="1">{
                rawConn.Close()
                return nil, err
        }</span>

        <span class="cov1" title="1">return conn, nil</span>
}

// Dial connects to the given network address using net.Dial
// and then initiates a TLS handshake, returning the resulting
// TLS connection.
// Dial interprets a nil configuration as equivalent to
// the zero configuration; see the documentation of Config
// for the defaults.
func Dial(network, addr string, config *Config) (*Conn, error) <span class="cov1" title="1">{
        return DialWithDialer(new(net.Dialer), network, addr, config)
}</span>

// LoadX509KeyPair reads and parses a public/private key pair from a pair of
// files. The files must contain PEM encoded data.
func LoadX509KeyPair(certFile, keyFile string) (cert Certificate, err error) <span class="cov0" title="0">{
        certPEMBlock, err := ioutil.ReadFile(certFile)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">keyPEMBlock, err := ioutil.ReadFile(keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return X509KeyPair(certPEMBlock, keyPEMBlock)</span>
}

// X509KeyPair parses a public/private key pair from a pair of
// PEM encoded data.
func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error) <span class="cov6" title="10">{
        var certDERBlock *pem.Block
        for </span><span class="cov8" title="28">{
                certDERBlock, certPEMBlock = pem.Decode(certPEMBlock)
                if certDERBlock == nil </span><span class="cov6" title="10">{
                        break</span>
                }
                <span class="cov7" title="18">if certDERBlock.Type == "CERTIFICATE" </span><span class="cov6" title="10">{
                        cert.Certificate = append(cert.Certificate, certDERBlock.Bytes)
                }</span>
        }

        <span class="cov6" title="10">if len(cert.Certificate) == 0 </span><span class="cov0" title="0">{
                stateInc(ERR_DECODE_CERT_IN_PEM, 1)
                err = errors.New("crypto/tls: failed to parse certificate PEM data")
                return
        }</span>

        <span class="cov6" title="10">var keyDERBlock *pem.Block
        for </span><span class="cov7" title="17">{
                keyDERBlock, keyPEMBlock = pem.Decode(keyPEMBlock)
                if keyDERBlock == nil </span><span class="cov0" title="0">{
                        stateInc(ERR_DECODE_KEY_IN_PEM, 1)
                        err = errors.New("crypto/tls: failed to parse key PEM data")
                        return
                }</span>
                <span class="cov7" title="17">if keyDERBlock.Type == "PRIVATE KEY" || strings.HasSuffix(keyDERBlock.Type, " PRIVATE KEY") </span><span class="cov6" title="10">{
                        break</span>
                }
        }

        <span class="cov6" title="10">cert.PrivateKey, err = parsePrivateKey(keyDERBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // We don't need to parse the public key for TLS, but we so do anyway
        // to check that it looks sane and matches the private key.
        <span class="cov6" title="10">x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
        if err != nil </span><span class="cov0" title="0">{
                stateInc(ERR_PARSE_CERT, 1)
                return
        }</span>

        <span class="cov6" title="10">switch pub := x509Cert.PublicKey.(type) </span>{
        <span class="cov5" title="6">case *rsa.PublicKey:
                priv, ok := cert.PrivateKey.(*rsa.PrivateKey)
                if !ok </span><span class="cov1" title="1">{
                        stateInc(ERR_KEY_TYPE_NOT_MATCH, 1)
                        err = errors.New("crypto/tls: private key type does not match public key type")
                        return
                }</span>
                <span class="cov4" title="5">if pub.N.Cmp(priv.N) != 0 </span><span class="cov0" title="0">{
                        stateInc(ERR_KEY_NOT_MATCH, 1)
                        err = errors.New("crypto/tls: private key does not match public key")
                        return
                }</span>
        <span class="cov4" title="4">case *ecdsa.PublicKey:
                priv, ok := cert.PrivateKey.(*ecdsa.PrivateKey)
                if !ok </span><span class="cov1" title="1">{
                        stateInc(ERR_KEY_TYPE_NOT_MATCH, 1)
                        err = errors.New("crypto/tls: private key type does not match public key type")
                        return
                }</span>
                <span class="cov3" title="3">if pub.X.Cmp(priv.X) != 0 || pub.Y.Cmp(priv.Y) != 0 </span><span class="cov0" title="0">{
                        stateInc(ERR_KEY_NOT_MATCH, 1)
                        err = errors.New("crypto/tls: private key does not match public key")
                        return
                }</span>
        <span class="cov0" title="0">default:
                stateInc(ERR_UNKNOWN_PUB_KEY_ALGOR, 1)
                err = errors.New("crypto/tls: unknown public key algorithm")
                return</span>
        }

        <span class="cov5" title="8">return</span>
}

// Attempt to parse the given private key DER block. OpenSSL 0.9.8 generates
// PKCS#1 private keys by default, while OpenSSL 1.0.0 generates PKCS#8 keys.
// OpenSSL ecparam generates SEC1 EC private keys for ECDSA. We try all three.
func parsePrivateKey(der []byte) (crypto.PrivateKey, error) <span class="cov6" title="10">{
        if key, err := x509.ParsePKCS1PrivateKey(der); err == nil </span><span class="cov5" title="6">{
                return key, nil
        }</span>
        <span class="cov4" title="4">if key, err := x509.ParsePKCS8PrivateKey(der); err == nil </span><span class="cov0" title="0">{
                switch key := key.(type) </span>{
                <span class="cov0" title="0">case *rsa.PrivateKey, *ecdsa.PrivateKey:
                        return key, nil</span>
                <span class="cov0" title="0">default:
                        stateInc(ERR_UNKNOWN_PRI_KEY_TYPE_IN_PKCS8, 1)
                        return nil, errors.New("crypto/tls: found unknown private key type in PKCS#8 wrapping")</span>
                }
        }
        <span class="cov4" title="4">if key, err := x509.ParseECPrivateKey(der); err == nil </span><span class="cov4" title="4">{
                return key, nil
        }</span>

        <span class="cov0" title="0">stateInc(ERR_PARSE_PRI_KEY, 1)
        return nil, errors.New("crypto/tls: failed to parse private key")</span>
}

// LoadX509KeyPairSafe reads and parses a public/private key pair from a pair of
// files. The key file contains ssl key cipher text.
func LoadX509KeyPairSafe(certFile, keyFile string) (cert Certificate, err error) <span class="cov0" title="0">{
        certPEMBlock, err := ioutil.ReadFile(certFile)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

    // get SSL key from decrypted file
        <span class="cov0" title="0">keyPEMBlock, err := DecryptSslKeyFile(keyFile)
        if err != nil </span><span class="cov0" title="0">{
        stateInc(ERR_KEY_DECRYPT_FAIL, 1)
        // if failed in decrypting key file, try to use it directly
            keyPEMBlock, err = ioutil.ReadFile(keyFile)
            if err != nil </span><span class="cov0" title="0">{
                return
            }</span>
    }
        <span class="cov0" title="0">return X509KeyPair(certPEMBlock, keyPEMBlock)</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">/* exit.go - provide AbnormalExit function  */
/*
modification history
--------------------
2014/8/26, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
    "os"
)

import (
    "www.baidu.com/golang-lib/log"
)

func AbnormalExit() <span class="cov0" title="0">{
        // waiting for logger finish jobs
        log.Logger.Close()
    // exit
        os.Exit(1)
}</pre>
		
		<pre class="file" id="file240" style="display: none">/* file.go - file copy implementation */
/*
modification history
--------------------
2014/9/15, by Weiwei02, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
    "fmt"
    "io"
    "os"
    "path"
)

// regular file copy from src to dst
// return file length, error
func CopyFile(src, dst string) (int64, error) <span class="cov0" title="0">{
    srcFile, err := os.Open(src)
    if err != nil </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("open src error %s", err)
    }</span>
    <span class="cov0" title="0">defer srcFile.Close()

    srcFileStat, err := srcFile.Stat()
    if err != nil </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("stat src error %s", err)
    }</span>

    <span class="cov0" title="0">if !srcFileStat.Mode().IsRegular() </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("%s is not a regular file", src)
    }</span>

    // mkdir all dir
    <span class="cov0" title="0">dirPath := path.Dir(dst)
    if err = os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("MkdirALl err %s", err.Error())
    }</span>

    // create file
    <span class="cov0" title="0">dstFile, err := os.Create(dst)
    if err != nil </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("create dst error %s", dst)
    }</span>
    <span class="cov0" title="0">defer dstFile.Close()

    return io.Copy(dstFile, srcFile)</span>
}

// backup file, atomic rename
func BackupFile(path string, bakPath string) error <span class="cov0" title="0">{
    copyPath := fmt.Sprintf("%s.%d.bak", path, os.Getpid())
    if _, err := CopyFile(path, copyPath); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov0" title="0">if err := os.Rename(copyPath, bakPath); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file241" style="display: none">/* fixed_pool.go - fixed size memory pool */
/*
modification history
--------------------
2015/5/6, by Sijie Yang, Create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
        "sync"
)

type FixedPool struct {
        pool sync.Pool // memory block pool
        size int       // memory block size
}

func NewFixedPool(size int) *FixedPool <span class="cov1" title="1">{
        p := new(FixedPool)
        p.size = size
        return p
}</span>

// Get a byte slice from pool
func (p *FixedPool) GetBlock() []byte <span class="cov10" title="2">{
        if v := p.pool.Get(); v != nil </span><span class="cov1" title="1">{
                return v.([]byte)
        }</span>
        <span class="cov1" title="1">return make([]byte, p.size)</span>
}

// Release a byte slice to pool
func (p *FixedPool) PutBlock(block []byte) <span class="cov10" title="2">{
        // just ingore block with mismatched size
        if len(block) != p.size </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov1" title="1">p.pool.Put(block)</span>
}
</pre>
		
		<pre class="file" id="file242" style="display: none">/* gc_switch.go - open and close gc  */
/*
modification history
--------------------
2014/8/26, by Taochunhua, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
    "runtime/debug"
)

import (
    "bfe_config/bfe_conf"
)

/* OpenGc - Open GC flag
 *          After this function call, golang gc will enabled.
 */
func OpenGc() <span class="cov0" title="0">{
    if bfe_conf.AUTO_GC </span><span class="cov0" title="0">{
        // using golang auto gc
        return
    }</span> <span class="cov0" title="0">else {
        debug.SetGCPercent(10)
    }</span>
}

/* CloseGc - Close GC flag
 *          After this function call, golang gc will disabled.
 */
func CloseGc() <span class="cov0" title="0">{
    if bfe_conf.AUTO_GC </span><span class="cov0" title="0">{
        // using golang auto gc
        return
    }</span> <span class="cov0" title="0">else {
        debug.SetGCPercent(-10)
    }</span>
}
</pre>
		
		<pre class="file" id="file243" style="display: none">/* get_net_info.go - get net info of net connection */
/*
modification history
--------------------
2015/9/1, by niexiaohui, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
        "encoding/binary"
        "fmt"
        "net"
        "reflect"
        "syscall"
    "unsafe"
)

import (
    "bfe_basic"
        "bfe_tls"
)

const (
    TCP_CWND_INIT = 18  // initial cwnd option
    TCP_INFO_LEN  = 103 // tcp_info struct len
    TCP_WISE_INFO = 19  // tcp wise info option
    TEST_CWND = 20      // test set cwnd
)

// get net fd from tcp conn
func GetConnFd(conn net.Conn) (int, error) <span class="cov0" title="0">{
        // the fd is tcpConn.fd.sysfd
        fd := 0
        switch conn.(type) </span>{
        <span class="cov0" title="0">case *bfe_tls.Conn:
                c := conn.(*bfe_tls.Conn).GetNetConn()
                fd = net.GetTcpSocketFd(c.(*net.TCPConn))</span>
        <span class="cov0" title="0">case *net.TCPConn:
                fd = net.GetTcpSocketFd(conn.(*net.TCPConn))</span>
        <span class="cov0" title="0">default:
                return fd, fmt.Errorf("GetConnFd(): conn type not support %s", reflect.TypeOf(conn))</span>
        }
        <span class="cov0" title="0">return fd, nil</span>
}

// get kernel initial cwnd
func GetKernelCwnd() (uint32, error) <span class="cov0" title="0">{
        var icw uint32
    // port is 0, using available port  
    addr, err := net.ResolveTCPAddr("tcp4", "127.1:0")
    if err != nil </span><span class="cov0" title="0">{
        return icw, err
    }</span>
        // listen 
        <span class="cov0" title="0">l, err := net.ListenTCP("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return icw, err
        }</span>
        <span class="cov0" title="0">defer l.Close()
        // connection
        conn, err := net.Dial("tcp", l.Addr().String())
        if err != nil </span><span class="cov0" title="0">{
                return icw, err
        }</span>
    <span class="cov0" title="0">defer conn.Close()
        // get fd
        fd, err := GetConnFd(conn)
        if err != nil </span><span class="cov0" title="0">{
                return icw, err
        }</span>
    // get icw
    <span class="cov0" title="0">icw, err = GetFdCwnd(fd)
    if err != nil </span><span class="cov0" title="0">{
        return icw, err
    }</span>
    <span class="cov0" title="0">return icw, nil</span>
}

// get net_fd cwnd
func GetFdCwnd(fd int) (uint32, error) <span class="cov0" title="0">{
        var icw uint32
    data, err := syscall.GetsockoptMutiByte(fd, syscall.SOL_TCP, syscall.TCP_INFO, TCP_INFO_LEN)
    if err != nil </span><span class="cov0" title="0">{
            return icw, err
    }</span>
    <span class="cov0" title="0">if IsBigEndian() </span><span class="cov0" title="0">{
        icw = binary.BigEndian.Uint32(data[80:84])
    }</span> <span class="cov0" title="0">else {
        icw = binary.LittleEndian.Uint32(data[80:84])
    }</span>
    <span class="cov0" title="0">return icw, nil</span>
}
// set net_fd cwnd 
func SetFdCwnd(fd int, icw int) error <span class="cov0" title="0">{
    // tell kernel initial icw
    err := syscall.SetsockoptInt(fd, syscall.IPPROTO_TCP, TCP_CWND_INIT, icw)
    return err
}</span>

// get tcp wise info 
func GetTcpWiseInfo(fd int, length int) (value []byte, err error)<span class="cov0" title="0">{
    data, err := syscall.GetsockoptMutiByte(fd, syscall.IPPROTO_TCP, TCP_WISE_INFO, length)
    return data, err
}</span>

// check kernel, return nil means support
func SupportTcpWise() (bool, error) <span class="cov0" title="0">{
    // port is 0, using available port  
    addr, err := net.ResolveTCPAddr("tcp4", "127.1:0")
    if err != nil </span><span class="cov0" title="0">{
        return false, err
    }</span>
    // listen 
    <span class="cov0" title="0">l, err := net.ListenTCP("tcp", addr)
    if err != nil </span><span class="cov0" title="0">{
        return false, err
    }</span>
    <span class="cov0" title="0">defer l.Close()
    // connection
    conn, err := net.Dial("tcp", l.Addr().String())
    if err != nil </span><span class="cov0" title="0">{
        return false, err
    }</span>
    <span class="cov0" title="0">defer conn.Close()
    // get fd
    fd, err := GetConnFd(conn)
    if err != nil </span><span class="cov0" title="0">{
        return false, err
    }</span>
    // check change initial cwnd function
    <span class="cov0" title="0">err = SetFdCwnd(fd, TEST_CWND)
    if err != nil </span><span class="cov0" title="0">{
        return false, nil
    }</span>
    // check get tcp wise info function
    <span class="cov0" title="0">tcpWiseInfo := new(bfe_basic.TcpWiseInfo)
    tcpWiseInfoLen := int(unsafe.Sizeof(*tcpWiseInfo))
    _, err = GetTcpWiseInfo(fd, tcpWiseInfoLen)
    if err != nil </span><span class="cov0" title="0">{
        return false, nil
    }</span>
    <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file244" style="display: none">/* getvip_linux.go - get vip from newttm module */
/*
modification history
--------------------
2014/7/22, by Taochunhua, Create
*/
/*
DESCRIPTION
*/

package bfe_util

import (
        "net"
        "syscall"
    "reflect"
)

import (
    "www.baidu.com/golang-lib/log"
)

import (
    "bfe_tls"
)

// get vip from tcp conn
func GetVip(conn net.Conn) net.IP <span class="cov0" title="0">{
//func GetVip(tcpConn *net.TCPConn) net.IP {
    // the fd is tcpConn.fd.sysfd
    fd := 0
    switch conn.(type) </span>{
    <span class="cov0" title="0">case *bfe_tls.Conn:
        c := conn.(*bfe_tls.Conn).GetNetConn()
        fd = net.GetTcpSocketFd(c.(*net.TCPConn))</span>
    <span class="cov0" title="0">case *net.TCPConn:
        fd = net.GetTcpSocketFd(conn.(*net.TCPConn))</span>
    <span class="cov0" title="0">default:
        log.Logger.Debug("GetVip(): conn type not supoort %s", reflect.TypeOf(conn))
        return nil</span>
    }

    // get vip from file handler
    <span class="cov0" title="0">TCP_GET_VIP := 254
    // get 8 bytes raw bytes from socketopt
    rawInfo, err := syscall.GetsockoptMutiByte(fd, syscall.IPPROTO_TCP, TCP_GET_VIP, 8)
    if err != nil </span><span class="cov0" title="0">{
        // no vip or no new ttm module
        log.Logger.Debug("GetVip():GetsockoptInt failed: %s", err.Error())
        return nil
    }</span>

    <span class="cov0" title="0">ipv4 := net.IPv4(rawInfo[4], rawInfo[5], rawInfo[6], rawInfo[7])
    log.Logger.Debug("GetVip(): VIP raw : %v", rawInfo)

    return ipv4.To4()</span>
}
</pre>
		
		<pre class="file" id="file245" style="display: none">/* json_util.go - load json from file, check nil  */
/*
modification history
--------------------
2014/8/1, by Weiwei, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
    "os"
    "path"
        "reflect"
)

// load json content from file, unmarshal to jsonObject
// check if all field is set if checkNilPointer is true
// check if any field is not pointer type if allowNoPointerField is false
func LoadJsonFile(path string, jsonObject interface{}) error <span class="cov0" title="0">{
        buf, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(buf, jsonObject); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// dump json file
func DumpJson(jsonObject interface{}, filePath string, perm os.FileMode) error <span class="cov0" title="0">{
    buf, err := json.MarshalIndent(jsonObject, "", "    ")
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("marshal err %s", err)
    }</span>
    
    // mkdirall dir
    <span class="cov0" title="0">dirPath := path.Dir(filePath)
    if err = os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("MkdirALl err %s", err.Error())
    }</span>
    <span class="cov0" title="0">return ioutil.WriteFile(filePath, buf, perm)</span>
}

// check if a struct has a nil field
// if allowNoPointerField is false, it also check if fields are all pointers
// if param object is not a struct , return nil
func CheckNilField(object interface{}, allowNoPointerField bool) error <span class="cov0" title="0">{
        v := reflect.ValueOf(object)
        if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fmt.Errorf("input is not struct")
        }</span>
        
        <span class="cov0" title="0">typeOfV := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                f := v.Field(i)
                if f.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                        if !allowNoPointerField </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s field %s is not a pointer", typeOfV, typeOfV.Field(i).Name)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if f.IsNil() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s field %s is not set", typeOfV, typeOfV.Field(i).Name)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file246" style="display: none">/* limit_rate.go - a rate limiter using leaky bucket algorithm */
/*
modification history
--------------------
2015/5/20, by Sijie Yang, Create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
    "sync"
    "time"
)

type RateLimiter struct {
    rate     int64       // units dripped per second 
    capacity int64       // capacity of bucket
    amount   int64       // current amount of units in bucket
    last     int64       // timestamp of last check
    lock     sync.Mutex
}

/* NewRateLimiter - create a rate limiter
 *
 * Params:
 *     - qps  : maximum request per second
 *     - burst: maximum burst number of request. If the requests rate exceed 'qps', 
 *              their processing is delayed such that requests are processed at a defined rate;
 *              After the number of excessive requests exceeds 'burst', new incoming 
                requests will be dropped.
 * Return:
 *     - rate limter
 */
func NewRateLimiter(qps int64, burst int64) *RateLimiter <span class="cov2" title="3">{
    l := new(RateLimiter)
    if qps &lt;= 0 </span><span class="cov0" title="0">{
         qps = 1000   // default maximum request per second
    }</span>
    <span class="cov2" title="3">if burst &lt;= 0 </span><span class="cov0" title="0">{
         burst = 1000 // default maximum burst number of request
    }</span>

    // Note: each request will add 1000 units to bucket
    <span class="cov2" title="3">l.rate = qps * 1000
    l.capacity = burst * 1000
    l.last = time.Now().UnixNano()/int64(time.Millisecond)
    return l</span>
}

/* Try - check whether request is allowable or should be dropped 
 * 
 * Return:
 *     - ret: true if allowalbe, false if not
 */
func (l *RateLimiter) Try() bool <span class="cov9" title="151">{
    delay, allowable := l.check()
    // should drop request 
    if !allowable </span><span class="cov0" title="0">{
        return false
    }</span>

    // delay if nessary such that requests are processed at a defined rate
    <span class="cov9" title="151">time.Sleep(delay)
    return true</span>
}

// check bucket and return status for new request
func (l *RateLimiter) check() (time.Duration, bool) <span class="cov10" title="171">{
    l.lock.Lock()
    defer l.lock.Unlock()

    now := time.Now().UnixNano()/int64(time.Millisecond)

    // number of units dripped since last check
    leak := l.rate * (now - l.last) / 1000

    // update current number of units in bucket
    l.amount = l.amount - leak
    if l.amount &lt; 0 </span><span class="cov0" title="0">{
        l.amount = 0
    }</span>
    <span class="cov10" title="171">l.last = now

    // time to wait for incoming operation
    delay := time.Duration(l.amount*1000/l.rate)*time.Millisecond

    // each operation add 1000 units to leaky bucket
    l.amount = l.amount + 1000
    if l.amount &gt; l.capacity </span><span class="cov5" title="10">{
        l.amount = l.capacity
        return 0, false
    }</span>

    <span class="cov9" title="161">return delay, true</span>
}

</pre>
		
		<pre class="file" id="file247" style="display: none">/* multi_process_utils.go - utils for multi-process  */
/*
modification history
--------------------
2014/10/20, by Taochunhua, create
2015/05/06, by Sijie Yang, modify
    - change name and prototype of ListenFdGet() to get 
      mulitply fds inherited from parent process
*/
/*
DESCRIPTION
*/
package bfe_util

import (
    "errors"
    "os"
    "syscall"
)

// Desc:
//     wrapper for system call fcntl.
// Parameters:
//     fd  - file description index
//     cmd - operatin command
//     arg - arguments of fcntl
// Returns:
//     val - return value of fcntl
//     errno - errno code
func fcntl(fd int, cmd int, arg int) (val int, errno int) <span class="cov0" title="0">{
    r0, _, e1 := syscall.Syscall(syscall.SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
    val = int(r0)
    errno = int(e1)
    return
}</span>

// Desc:
//     parent process will put listen socket fd in file table.
//     And call start-process(fork and exec). The fd will not close(no close-on-exec tag).
//     The handlers in file table is : stdin, stdout, stderr, fd1, fd2
//     This function get fd from its file table.
//
// Returns:
//     os.File pointer created from fd
func FdGet(fd int) (*os.File, error) <span class="cov0" title="0">{
    // call fcntl, get flags
    flags, errno := fcntl(fd, syscall.F_GETFD, 0)
    if errno != 0 </span><span class="cov0" title="0">{
        return nil, errors.New("F_GETFD failed")
    }</span>
    
    // invalid fd
    <span class="cov0" title="0">if flags &amp; syscall.FD_CLOEXEC != 0 </span><span class="cov0" title="0">{
        return nil, errors.New("fd has FD_CLOEXEC")
    }</span>
    
    // set fd non-blocking
    // Parent bfe process use net.TCPListener.File() to create fd.
    // And this fd will be set to blocking mode.
    <span class="cov0" title="0">_, errno = fcntl(fd, syscall.F_SETFL, flags | syscall.O_NONBLOCK)
    if errno != 0 </span><span class="cov0" title="0">{
        return nil, errors.New("F_SETFL failed")
    }</span>
    
    // set close-on-exec tag
    <span class="cov0" title="0">syscall.CloseOnExec(fd)
    
    // create os.File for golang
    return os.NewFile(uintptr(fd), ""), nil</span>
}
</pre>
		
		<pre class="file" id="file248" style="display: none">/* prob_generator.go - generate probability event */
/*
modification history
--------------------
2015/6/4, by Xiong Zongtao, create

*/
/*
DESCRIPTION
Usage:
        base  := 1000
        ratio := 5
        p := NewProbGenerator(base, ratio)
        
        if p.IsHit() {
                // probability hit, do something
                // about 5 times every 1000 calls
        } else {
                //probability miss, do something else
        }
*/

package bfe_util

import (
        "time"
        "math/rand"
)

type ProbGenerator struct {
        base  int
        ratio int
}

func NewProbGenerator(base int, ratio int) *ProbGenerator <span class="cov1" title="1">{
        p := new(ProbGenerator)
        p.base  = base
        p.ratio = ratio
        rand.Seed(time.Now().Unix())

        return p
}</span>

//is hit at ratio ratio/base
func (p *ProbGenerator) IsHit() bool <span class="cov10" title="1000">{
        return rand.Intn(p.base) &lt; p.ratio
}</span>
</pre>
		
		<pre class="file" id="file249" style="display: none">/* register_signal_linux.go - setup signal table under linux */
/*
modification history
--------------------
2014/7/23, by Taochunhua, Create
*/
/*
DESCRIPTION
*/

package bfe_util

import (
    "syscall"
)

import (
    "www.baidu.com/golang-lib/signal_table"
)

// register signal handlers under linux
func RegisterSignalHandlers(signalTable *signal_table.SignalTable) <span class="cov0" title="0">{
    // ignore
    signalTable.Register(syscall.SIGHUP, signal_table.IgnoreHandler)
    signalTable.Register(syscall.SIGQUIT, signal_table.IgnoreHandler)
    signalTable.Register(syscall.SIGILL, signal_table.IgnoreHandler)
    signalTable.Register(syscall.SIGTRAP, signal_table.IgnoreHandler)
    signalTable.Register(syscall.SIGABRT, signal_table.IgnoreHandler)
    signalTable.Register(syscall.SIGSTKFLT, signal_table.IgnoreHandler)
    
    // terminate
    signalTable.Register(syscall.SIGTERM, signal_table.TermHandler)
}</span>


</pre>
		
		<pre class="file" id="file250" style="display: none">/* rolling_counter.go - event counter for latest some seconds */
/*
modification history
--------------------
2015/06/05, by Zongtao Xiong, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
        "sync"
    "time"
)

type RollingCounter struct {
    slot    []int64      // slot used to store counter every second
    count     int64      // total count of all slots
    lastTime  int64      // timestamp last increment
    slotNum   int64      // slot number
    lock      sync.Mutex // lock for access contention
}

func NewRollingCounter(slots int64) *RollingCounter <span class="cov2" title="3">{
    counter := new(RollingCounter)

    counter.slot     = make([]int64, slots)
    counter.slotNum  = slots
    counter.count    = 0
    counter.lastTime = time.Now().Unix()

    return counter
}</span>

func (c *RollingCounter) progress(s int64) <span class="cov10" title="364">{
    if s &gt; c.lastTime </span><span class="cov2" title="2">{

        // all slots is expired
        if c.lastTime + c.slotNum &lt;= s </span><span class="cov1" title="1">{

            //reset all slots
            for i := int64(0); i &lt; c.slotNum; i++ </span><span class="cov2" title="2">{
                c.slot[i] = 0
            }</span>

            //reset total count
            <span class="cov1" title="1">c.count = 0</span>
        } <span class="cov1" title="1">else {
                        //reset first (s - lastTime) slots, sub them from total count
            for i := c.lastTime + 1; i &lt;= s; i++ </span><span class="cov1" title="1">{
                c.count = c.count - c.slot[i % c.slotNum]
                c.slot[i % c.slotNum] = 0
            }</span>
        }
    }
}

func (c *RollingCounter) Inc() <span class="cov6" title="40">{
    c.lock.Lock()
    defer c.lock.Unlock()

    s := time.Now().Unix()

        //remove expired counts
        c.progress(s)

    c.slot[s % c.slotNum]++
    c.count++

    c.lastTime = s
}</span>

// for access/visit counter
func (c *RollingCounter) IncAndCheck(thresh int64) bool <span class="cov0" title="0">{
    c.lock.Lock()
    defer c.lock.Unlock()

    s := time.Now().Unix()

        //remove expired counts
        c.progress(s)

    c.slot[s % c.slotNum]++
    c.count++
    c.lastTime = s

        if c.count &gt; thresh </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// for resource consuming counter
func (c *RollingCounter) CheckAndInc(thresh int64) bool <span class="cov9" title="320">{
    c.lock.Lock()
    defer c.lock.Unlock()

    s := time.Now().Unix()

        //remove expired counts
        c.progress(s)
    c.lastTime = s

        if c.count &gt;= thresh </span><span class="cov9" title="220">{
                return false
        }</span>

    <span class="cov8" title="100">c.slot[s % c.slotNum]++
    c.count++
        
        return true</span>
}

// get total count
func (c *RollingCounter) Get() int64 <span class="cov3" title="4">{
    c.lock.Lock()
    defer c.lock.Unlock()

    s := time.Now().Unix()

        //remove expired counts
        c.progress(s)

        c.lastTime = s

    return c.count
}</span>
</pre>
		
		<pre class="file" id="file251" style="display: none">/* tcp_wise_util.go - get cwnd table info and check whether the machine is bigendian */
/*
modification history
--------------------
2015/10/9, by niexiaohui, create
*/
/*
DESCRIPTION
*/
package bfe_util

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "strings"
)

type MetaInfo struct {
        Version string
}

func GetVersion(path string) (string, error) <span class="cov0" title="0">{
        // open file
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // read the first line
        reader := bufio.NewReader(file)
        line, _, err := reader.ReadLine()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // get meta data
        <span class="cov0" title="0">firstLine := strings.Trim(string(line), " \t\r\n")
        if !strings.HasPrefix(firstLine, "#") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("firstLine don't contail version info")
        }</span>

        // decode the json string
        <span class="cov0" title="0">metaInfo := &amp;MetaInfo{}
        metaString := strings.Trim(firstLine, "#")
        decoder := json.NewDecoder(strings.NewReader(metaString))
        err = decoder.Decode(metaInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // check metaInfo
        <span class="cov0" title="0">err = checkVersion(*metaInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return metaInfo.Version, nil</span>
}

/* check meta info */
func checkVersion(Info MetaInfo) error <span class="cov0" title="0">{
        if Info.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("metaInfo:Version is empty string")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

/* check machine is big endian or not*/
func IsBigEndian() bool <span class="cov0" title="0">{
        var i int32 = 0x12345678
        var b byte = byte(i)
        return b == 0x12
}</span>


</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
